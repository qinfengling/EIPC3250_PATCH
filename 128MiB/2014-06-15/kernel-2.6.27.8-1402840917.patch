diff --exclude CVS --exclude .git -uNr linux-2.6.27.8/Makefile.common linux-2.6.27.8.modified/Makefile.common
--- linux-2.6.27.8/Makefile.common	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.27.8.modified/Makefile.common	2013-05-30 03:44:13.000000000 -0400
@@ -0,0 +1,18 @@
+ifneq ($(KBUILD_EXTMOD),)
+
+EXTRA_CFLAGS += \
+	-I$(TOPDIR)/include \
+	-I$(TOPDIR)/drivers/net/can/hal \
+	\
+	-DETH_P_CAN=0x000C \
+	-DARPHRD_CAN=280
+
+ifneq ($(CONFIG_CAN_CALC_BITTIMING),n)
+EXTRA_CFLAGS += -DCONFIG_CAN_CALC_BITTIMING
+endif
+
+ifeq ($(CONFIG_CAN_DEBUG_DEVICES),y)
+EXTRA_CFLAGS += -DCONFIG_CAN_DEBUG_DEVICES
+endif
+
+endif
Binary files linux-2.6.27.8/arch/arm/boot/Image and linux-2.6.27.8.modified/arch/arm/boot/Image differ
Binary files linux-2.6.27.8/arch/arm/boot/compressed/piggy.gz and linux-2.6.27.8.modified/arch/arm/boot/compressed/piggy.gz differ
Binary files linux-2.6.27.8/arch/arm/boot/compressed/vmlinux and linux-2.6.27.8.modified/arch/arm/boot/compressed/vmlinux differ
Binary files linux-2.6.27.8/arch/arm/boot/uImage and linux-2.6.27.8.modified/arch/arm/boot/uImage differ
Binary files linux-2.6.27.8/arch/arm/boot/zImage and linux-2.6.27.8.modified/arch/arm/boot/zImage differ
diff --exclude CVS --exclude .git -uNr linux-2.6.27.8/arch/arm/kernel/vmlinux.lds linux-2.6.27.8.modified/arch/arm/kernel/vmlinux.lds
--- linux-2.6.27.8/arch/arm/kernel/vmlinux.lds	2014-06-15 10:04:08.000000000 -0400
+++ linux-2.6.27.8.modified/arch/arm/kernel/vmlinux.lds	2013-05-14 22:43:30.000000000 -0400
@@ -3,7 +3,7 @@
 /*
  * Automatically generated C config: don't edit
  * Linux kernel version: 2.6.27.8
- * Thu Oct 21 14:50:15 2010
+ * Tue May 14 22:42:40 2013
  */
 /* ld script to make ARM Linux kernel
  * taken from the i386 version by Russell King
diff --exclude CVS --exclude .git -uNr linux-2.6.27.8/arch/arm/mach-lpc32xx/board-phy3250.c linux-2.6.27.8.modified/arch/arm/mach-lpc32xx/board-phy3250.c
--- linux-2.6.27.8/arch/arm/mach-lpc32xx/board-phy3250.c	2014-06-15 10:04:08.000000000 -0400
+++ linux-2.6.27.8.modified/arch/arm/mach-lpc32xx/board-phy3250.c	2014-06-15 09:19:12.000000000 -0400
@@ -150,7 +150,7 @@
 
 	return 1;
 }
-#define BLK_SIZE (512 * 32)
+#define BLK_SIZE (2048 * 64)
 static struct mtd_partition __initdata phy3250_nand_partition[] = {
 	{
 		.name	= "phy3250-boot",
@@ -437,20 +437,48 @@
 {
 	.get_mac_addr	= &return_mac_address,
 	.phy_irq	= -1,
-	.phy_mask	= 0xFFFFFFF0,
+	.phy_mask	= 0x7FFFFFFF,
 
 };
 #endif
 
+/**
+ *@brief: 		phy3250_spi_cs_setup
+ *@details:		spi片选初始化设置
+ *@param[in]		int cs  0--SPI E2P, 1或者非0--SPI CAN MCP2515
+ *@param[out]	无
+ *@retval:		无
+ */
 static void phy3250_spi_cs_setup(int cs)
 {
-	/* Setup SPI CS0 as an output on GPIO5 */
-	__raw_writel((1 << 5), GPIO_P2_MUX_CLR(GPIO_IOBASE));
+	if( 0 == cs )
+	{
+		/* Setup SPI CS0 as an output on GPIO5 */
+		__raw_writel((1 << 5), GPIO_P2_MUX_CLR(GPIO_IOBASE));
+
+		/* Set chip select high */
+		__raw_writel(OUTP_STATE_GPIO(5),
+			GPIO_P3_OUTP_SET(GPIO_IOBASE));
+	}
+	else
+	{
+		/* Setup SPI CS0 as an output on GPIO0 */
+		__raw_writel(1, GPIO_P2_MUX_CLR(GPIO_IOBASE));
 
-	/* Set chip select high */
-	__raw_writel(OUTP_STATE_GPIO(5),
-		GPIO_P3_OUTP_SET(GPIO_IOBASE));
+		/* Set chip select high */
+		__raw_writel(OUTP_STATE_GPIO(0),
+			GPIO_P3_OUTP_SET(GPIO_IOBASE));
+	}
 }
+
+/**
+ *@brief: 		phy3250_spi_cs_set
+ *@details:		spi使能控制
+ *@param[in]		int cs  0--SPI E2P, 1--SPI CAN MCP2515
+ 				int state  0--输出低电平,1或者非0--输出高电平
+ *@param[out]	
+ *@retval:		无
+ */
 static int phy3250_spi_cs_set(int cs, int state)
 {
 	if (cs == 0)
@@ -470,8 +498,18 @@
 	}
 	else
 	{
-		/* Invalid chip select */
-		return -ENODEV;
+		if (state != 0)
+		{
+			/* Set chip select high */
+			__raw_writel(OUTP_STATE_GPIO(0),
+				GPIO_P3_OUTP_SET(GPIO_IOBASE));
+		}
+		else
+		{
+			/* Set chip select low */
+			__raw_writel(OUTP_STATE_GPIO(0),
+				GPIO_P3_OUTP_CLR(GPIO_IOBASE));
+		}
 	}
 
 	return 0;
diff --exclude CVS --exclude .git -uNr linux-2.6.27.8/drivers/net/can/Kconfig linux-2.6.27.8.modified/drivers/net/can/Kconfig
--- linux-2.6.27.8/drivers/net/can/Kconfig	2008-12-05 15:03:02.000000000 -0500
+++ linux-2.6.27.8.modified/drivers/net/can/Kconfig	2013-05-30 03:44:17.000000000 -0400
@@ -12,6 +12,125 @@
 	  This driver can also be built as a module.  If so, the module
 	  will be called vcan.
 
+config CAN_SLCAN
+	tristate "Serial / USB serial CAN Adaptors (slcan)"
+	depends on CAN
+	default N
+	---help---
+	  CAN driver for several 'low cost' CAN interfaces that are attached
+	  via serial lines or via USB-to-serial adapters using the LAWICEL
+	  ASCII protocol. The driver implements the tty linediscipline N_SLCAN.
+
+	  As only the sending and receiving of CAN frames is implemented, this
+	  driver should work with the (serial/USB) CAN hardware from:
+	  www.canusb.com / www.can232.com / www.mictronics.de / www.canhack.de
+
+	  Userspace tools to attach the SLCAN line discipline (slcan_attach,
+	  slcand) can be found in the can-utils at the SocketCAN SVN, see
+	  http://developer.berlios.de/projects/socketcan for details.
+
+	  The slcan driver supports up to 10 CAN netdevices by default which
+	  can be changed by the 'maxdev=xx' module option. This driver can
+	  also be built as a module. If so, the module will be called slcan.
+
+config CAN_OLD_DRIVERS
+	tristate "Prompt for old CAN drivers (e.g. no sysfs support)"
+	depends on CAN
+	default N
+	---help---
+	  The old drivers do not support sysfs nor proper platform device
+	  support. Some of the old drivers might only be configured by
+	  module commandline options.
+
+if CAN_OLD_DRIVERS
+source "drivers/net/can/old/Kconfig"
+endif
+
+config CAN_DEV
+	tristate "Platform CAN drivers with Netlink support"
+	depends on CAN
+	default y
+	---help---
+	  Enables the common framework for platform CAN drivers with Netlink
+	  support. This is the standard library for CAN drivers.
+	  If unsure, say Y.
+
+config CAN_DEV_SYSFS
+	bool "Support for sysfs interface (deprecated)"
+	depends on CAN_DEV && SYSFS
+	default N
+	---help---
+	  Adds support for the legacy sysfs interface to configure CAN
+	  devices. If possible, please use the new netlink interface
+	  instead.
+	  If unsure, say N.
+
+config CAN_CALC_BITTIMING
+	bool "CAN bit-timing calculation"
+	depends on CAN_DEV
+	default y
+	---help---
+	  If enabled, CAN bit-timing parameters will be calculated for the
+	  bit-rate specified via Netlink argument "bitrate" when the device
+	  get started. This works fine for the most common CAN controllers
+	  with standard bit-rates but may fail for exotic bit-rates or CAN
+	  source clock frequencies. Disabling saves some space, but then the
+	  bit-timing parameters must be specified directly using the Netlink
+	  arguments "tq", "prop_seg", "phase_seg1", "phase_seg2" and "sjw".
+	  If unsure, say Y.
+
+config CAN_ESD_PCI331
+	tristate "ESD CAN 331 Cards"
+	depends on PCI && CAN_DEV
+	---help---
+	  This driver supports the PCI/331, CPCI/331 and PMC/331 CAN cards
+	  from the esd system design gmbh (http://www.esd.eu).
+
+config CAN_SOFTING
+	tristate "Softing Gmbh CAN generic support"
+	depends on CAN_DEV
+	---help---
+	  generic softing CAN cards
+	  Sofing CAN cards come with 1 or 2 physical busses.
+	  The API of the card does not allow fine control per bus, but
+	  controls the 2 busses on the card together.
+	  As such, some actions (start/stop/busoff recovery) on 1 bus
+	  must bring down the other bus too temporarily.
+	  You have been warned.
+	  This driver is written on safe on 64bit, but not on big endian.
+
+config CAN_SOFTING_CS
+	tristate "Softing CAN pcmcia cards"
+	depends on CAN_SOFTING && PCMCIA
+	---help---
+	  Support for PCMCIA cards from Softing Gmbh & some cards
+	  from Vector Gmbh.
+	  You need firmware for these, which you can get at
+	  http://developer.berlios.de/projects/socketcan/
+	  This version of the driver is written against
+	  firmware version 4.6
+
+config CAN_AT91
+	tristate "Atmel AT91 onchip CAN controller"
+	depends on CAN_DEV && ARCH_AT91SAM9263
+	default N
+	---help---
+	  This is a driver for the SoC CAN controller in Atmel's AT91SAM9263.
+
+config CAN_MCP251X
+	tristate "Microchip MCP251x SPI CAN controllers"
+	depends on CAN_DEV && SPI
+	---help---
+	  Driver for the Microchip MCP251x SPI CAN controllers.
+
+source "drivers/net/can/cc770/Kconfig"
+
+source "drivers/net/can/mscan/Kconfig"
+
+source "drivers/net/can/sja1000/Kconfig"
+
+source "drivers/net/can/usb/Kconfig"
+
 config CAN_DEBUG_DEVICES
 	bool "CAN devices debugging messages"
 	depends on CAN
diff --exclude CVS --exclude .git -uNr linux-2.6.27.8/drivers/net/can/Kconfig.kernel linux-2.6.27.8.modified/drivers/net/can/Kconfig.kernel
--- linux-2.6.27.8/drivers/net/can/Kconfig.kernel	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.27.8.modified/drivers/net/can/Kconfig.kernel	2013-05-30 03:44:17.000000000 -0400
@@ -0,0 +1,88 @@
+menu "CAN Device Drivers"
+	depends on CAN
+
+config CAN_VCAN
+	tristate "Virtual Local CAN Interface (vcan)"
+	depends on CAN
+	default N
+	---help---
+	  Similar to the network loopback devices, vcan offers a
+	  virtual local CAN interface.
+
+	  This driver can also be built as a module.  If so, the module
+	  will be called vcan.
+
+config CAN_DEV
+	tristate "Platform CAN drivers with Netlink support"
+	depends on CAN
+	default Y
+	---help---
+	  Enables the common framework for platform CAN drivers with Netlink
+	  support. This is the standard library for CAN drivers.
+	  If unsure, say Y.
+
+config CAN_CALC_BITTIMING
+	bool "CAN bit-timing calculation"
+	depends on CAN_DEV
+	default Y
+	---help---
+	  If enabled, CAN bit-timing parameters will be calculated for the
+	  bit-rate specified via Netlink argument "bitrate" when the device
+	  get started. This works fine for the most common CAN controllers
+	  with standard bit-rates but may fail for exotic bit-rates or CAN
+	  source clock frequencies. Disabling saves some space, but then the
+	  bit-timing parameters must be specified directly using the Netlink
+	  arguments "tq", "prop_seg", "phase_seg1", "phase_seg2" and "sjw".
+	  If unsure, say Y.
+
+config CAN_SJA1000
+	depends on CAN_DEV && HAS_IOMEM
+	tristate "Philips SJA1000"
+	---help---
+	  Driver for the SJA1000 CAN controllers from Philips or NXP
+
+config CAN_SJA1000_PLATFORM
+	depends on CAN_SJA1000
+	tristate "Generic Platform Bus based SJA1000 driver"
+	---help---
+	  This driver adds support for the SJA1000 chips connected to
+	  the "platform bus" (Linux abstraction for directly to the
+	  processor attached devices).  Which can be found on various
+	  boards from Phytec (http://www.phytec.de) like the PCM027,
+	  PCM038.
+
+config CAN_SJA1000_OF_PLATFORM
+	depends on CAN_SJA1000 && PPC_OF
+	tristate "Generic OF Platform Bus based SJA1000 driver"
+	---help---
+	  This driver adds support for the SJA1000 chips connected to
+	  the OpenFirmware "platform bus" found on embedded systems with
+	  OpenFirmware bindings, e.g. if you have a PowerPC based system
+	  you may want to enable this option.
+
+config CAN_EMS_PCI
+	tristate "EMS CPC-PCI, CPC-PCIe and CPC-104P Card"
+	depends on PCI && CAN_SJA1000
+	---help---
+	  This driver is for the one, two or four channel CPC-PCI,
+	  CPC-PCIe and CPC-104P cards from EMS Dr. Thomas Wuensche
+	  (http://www.ems-wuensche.de).
+
+config CAN_KVASER_PCI
+	tristate "Kvaser PCIcanx and Kvaser PCIcan PCI Cards"
+	depends on PCI && CAN_SJA1000
+	---help---
+	  This driver is for the the PCIcanx and PCIcan cards (1, 2 or
+	  4 channel) from Kvaser (http://www.kvaser.com).
+
+config CAN_DEBUG_DEVICES
+	bool "CAN devices debugging messages"
+	depends on CAN
+	default N
+	---help---
+	  Say Y here if you want the CAN device drivers to produce a bunch of
+	  debug messages to the system log.  Select this if you are having
+	  a problem with CAN support and want to see more of what is going
+	  on.
+
+endmenu
diff --exclude CVS --exclude .git -uNr linux-2.6.27.8/drivers/net/can/Makefile linux-2.6.27.8.modified/drivers/net/can/Makefile
--- linux-2.6.27.8/drivers/net/can/Makefile	2008-12-05 15:03:02.000000000 -0500
+++ linux-2.6.27.8.modified/drivers/net/can/Makefile	2013-05-30 03:44:18.000000000 -0400
@@ -1,5 +1,78 @@
 #
-#  Makefile for the Linux Controller Area Network drivers.
+#  $Id: Makefile 1226 2010-12-12 18:26:05Z hartkopp $
 #
 
+
+ifeq ($(KERNELRELEASE),)
+
+KERNELDIR := /lib/modules/$(shell uname -r)/build
+PWD       := $(shell pwd)
+TOPDIR    := $(PWD)/../../..
+
+export CONFIG_CAN_VCAN=m
+export CONFIG_CAN_SLCAN=m
+export CONFIG_CAN_DEV=m
+export CONFIG_CAN_CALC_BITTIMING=y
+#export CONFIG_CAN_DEV_SYSFS=y
+#export CONFIG_CAN_SJA1000_OLD=m
+#export CONFIG_CAN_I82527_OLD=m
+export CONFIG_CAN_CC770=m
+export CONFIG_CAN_CC770_ISA=m
+#export CONFIG_CAN_CC770_OF_PLATFORM=m
+export CONFIG_CAN_SJA1000=m
+export CONFIG_CAN_SJA1000_PLATFORM=m
+#export CONFIG_CAN_SJA1000_OF_PLATFORM=m
+export CONFIG_CAN_IXXAT_PCI=m
+export CONFIG_CAN_PLX_PCI=m
+export CONFIG_CAN_PEAK_PCI=m
+export CONFIG_CAN_KVASER_PCI=m
+export CONFIG_CAN_EMS_PCI=m
+#export CONFIG_CAN_EMS_USB=m
+#export CONFIG_CAN_EMS_PCMCIA=m
+export CONFIG_CAN_EMS_104M=m
+export CONFIG_CAN_ESD_PCI=m
+export CONFIG_CAN_ESD_PCI331=m
+#export CONFIG_CAN_ESD_USB2=m
+export CONFIG_CAN_PIPCAN=m
+#export CONFIG_CAN_SOFTING=m
+#export CONFIG_CAN_SOFTING_CS=m
+export CONFIG_CAN_MCP251X=m
+
+modules modules_install clean:
+	$(MAKE) -C $(KERNELDIR) M=$(PWD) $@ TOPDIR=$(TOPDIR)
+
+else
+
+-include $(TOPDIR)/Makefile.common
+
 obj-$(CONFIG_CAN_VCAN)		+= vcan.o
+obj-$(CONFIG_CAN_SLCAN)		+= slcan.o
+
+obj-$(CONFIG_CAN_DEV)		+= can-dev.o
+can-dev-y			:= dev.o
+can-dev-$(CONFIG_CAN_DEV_SYSFS) += sysfs.o
+
+obj-$(CONFIG_CAN_CC770)		+= cc770/
+obj-$(CONFIG_CAN_SJA1000)	+= sja1000/
+obj-$(CONFIG_CAN_SOFTING)	+= softing/
+obj-$(CONFIG_CAN_MSCAN)		+= mscan/
+obj-$(CONFIG_USB)		+= usb/
+obj-$(CONFIG_CAN_AT91)		+= at91_can.o
+obj-$(CONFIG_CAN_ESD_PCI331)	+= esd_pci331.o
+obj-$(CONFIG_CAN_SJA1000_OLD)	+= old/sja1000/
+obj-$(CONFIG_CAN_I82527_OLD)	+= old/i82527/
+obj-$(CONFIG_CAN_MSCAN_OLD)	+= old/mscan/
+obj-$(CONFIG_CAN_CCAN_OLD)	+= old/ccan/
+obj-$(CONFIG_CAN_MCP251X)	+= mcp251x.o
+
+ifeq ($(CONFIG_CAN_DEBUG_DEVICES),y)
+	EXTRA_CFLAGS += -DDEBUG
+endif
+ifeq ($(CONFIG_CAN_DEV_SYSFS),y)
+	EXTRA_CFLAGS += -DCONFIG_CAN_DEV_SYSFS
+endif
+ifneq ($(CONFIG_CAN_CALC_BITTIMING),n)
+	EXTRA_CFLAGS += -DCONFIG_CAN_CALC_BITTIMING
+endif
+
+endif
diff --exclude CVS --exclude .git -uNr linux-2.6.27.8/drivers/net/can/Makefile.kernel linux-2.6.27.8.modified/drivers/net/can/Makefile.kernel
--- linux-2.6.27.8/drivers/net/can/Makefile.kernel	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.27.8.modified/drivers/net/can/Makefile.kernel	2013-05-30 03:44:17.000000000 -0400
@@ -0,0 +1,5 @@
+#
+#  Makefile for the Linux Controller Area Network drivers.
+#
+
+obj-$(CONFIG_CAN_VCAN)		+= vcan.o
diff --exclude CVS --exclude .git -uNr linux-2.6.27.8/drivers/net/can/at91_can.c linux-2.6.27.8.modified/drivers/net/can/at91_can.c
--- linux-2.6.27.8/drivers/net/can/at91_can.c	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.27.8.modified/drivers/net/can/at91_can.c	2013-05-30 03:44:17.000000000 -0400
@@ -0,0 +1,1180 @@
+/*
+ * at91_can.c - CAN network driver for AT91 SoC CAN controller
+ *
+ * (C) 2007 by Hans J. Koch <hjk@linutronix.de>
+ * (C) 2008, 2009 by Marc Kleine-Budde <kernel@pengutronix.de>
+ *
+ * This software may be distributed under the terms of the GNU General
+ * Public License ("GPL") version 2 as distributed in the 'COPYING'
+ * file from the main directory of the linux kernel source.
+ *
+ * Send feedback to <socketcan-users@lists.berlios.de>
+ *
+ *
+ * Your platform definition file should specify something like:
+ *
+ * static struct at91_can_data ek_can_data = {
+ *	transceiver_switch = sam9263ek_transceiver_switch,
+ * };
+ *
+ * at91_add_device_can(&ek_can_data);
+ *
+ */
+
+#include <linux/clk.h>
+#include <linux/errno.h>
+#include <linux/if_arp.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/netdevice.h>
+#include <linux/platform_device.h>
+#include <linux/skbuff.h>
+#include <linux/spinlock.h>
+#include <linux/string.h>
+#include <linux/types.h>
+
+#include <socketcan/can.h>
+#include <socketcan/can/dev.h>
+#include <socketcan/can/error.h>
+
+#include <mach/board.h>
+
+#define DRV_NAME		"at91_can"
+#define AT91_NAPI_WEIGHT	12
+
+/*
+ * RX/TX Mailbox split
+ * don't dare to touch
+ */
+#define AT91_MB_RX_NUM		12
+#define AT91_MB_TX_SHIFT	2
+
+#define AT91_MB_RX_FIRST	0
+#define AT91_MB_RX_LAST		(AT91_MB_RX_FIRST + AT91_MB_RX_NUM - 1)
+
+#define AT91_MB_RX_MASK(i)	((1 << (i)) - 1)
+#define AT91_MB_RX_SPLIT	8
+#define AT91_MB_RX_LOW_LAST	(AT91_MB_RX_SPLIT - 1)
+#define AT91_MB_RX_LOW_MASK	(AT91_MB_RX_MASK(AT91_MB_RX_SPLIT))
+
+#define AT91_MB_TX_NUM		(1 << AT91_MB_TX_SHIFT)
+#define AT91_MB_TX_FIRST	(AT91_MB_RX_LAST + 1)
+#define AT91_MB_TX_LAST		(AT91_MB_TX_FIRST + AT91_MB_TX_NUM - 1)
+
+#define AT91_NEXT_PRIO_SHIFT	(AT91_MB_TX_SHIFT)
+#define AT91_NEXT_PRIO_MASK	(0xf << AT91_MB_TX_SHIFT)
+#define AT91_NEXT_MB_MASK	(AT91_MB_TX_NUM - 1)
+#define AT91_NEXT_MASK		((AT91_MB_TX_NUM - 1) | AT91_NEXT_PRIO_MASK)
+
+/* Common registers */
+enum at91_reg {
+	AT91_MR		= 0x000,
+	AT91_IER	= 0x004,
+	AT91_IDR	= 0x008,
+	AT91_IMR	= 0x00C,
+	AT91_SR		= 0x010,
+	AT91_BR		= 0x014,
+	AT91_TIM	= 0x018,
+	AT91_TIMESTP	= 0x01C,
+	AT91_ECR	= 0x020,
+	AT91_TCR	= 0x024,
+	AT91_ACR	= 0x028,
+};
+
+/* Mailbox registers (0 <= i <= 15) */
+#define AT91_MMR(i)		(enum at91_reg)(0x200 + ((i) * 0x20))
+#define AT91_MAM(i)		(enum at91_reg)(0x204 + ((i) * 0x20))
+#define AT91_MID(i)		(enum at91_reg)(0x208 + ((i) * 0x20))
+#define AT91_MFID(i)		(enum at91_reg)(0x20C + ((i) * 0x20))
+#define AT91_MSR(i)		(enum at91_reg)(0x210 + ((i) * 0x20))
+#define AT91_MDL(i)		(enum at91_reg)(0x214 + ((i) * 0x20))
+#define AT91_MDH(i)		(enum at91_reg)(0x218 + ((i) * 0x20))
+#define AT91_MCR(i)		(enum at91_reg)(0x21C + ((i) * 0x20))
+
+/* Register bits */
+#define AT91_MR_CANEN		BIT(0)
+#define AT91_MR_LPM		BIT(1)
+#define AT91_MR_ABM		BIT(2)
+#define AT91_MR_OVL		BIT(3)
+#define AT91_MR_TEOF		BIT(4)
+#define AT91_MR_TTM		BIT(5)
+#define AT91_MR_TIMFRZ		BIT(6)
+#define AT91_MR_DRPT		BIT(7)
+
+#define AT91_SR_RBSY		BIT(29)
+
+#define AT91_MMR_PRIO_SHIFT	(16)
+
+#define AT91_MID_MIDE		BIT(29)
+
+#define AT91_MSR_MRTR		BIT(20)
+#define AT91_MSR_MABT		BIT(22)
+#define AT91_MSR_MRDY		BIT(23)
+#define AT91_MSR_MMI		BIT(24)
+
+#define AT91_MCR_MRTR		BIT(20)
+#define AT91_MCR_MTCR		BIT(23)
+
+/* Mailbox Modes */
+enum at91_mb_mode {
+	AT91_MB_MODE_DISABLED	= 0,
+	AT91_MB_MODE_RX		= 1,
+	AT91_MB_MODE_RX_OVRWR	= 2,
+	AT91_MB_MODE_TX		= 3,
+	AT91_MB_MODE_CONSUMER	= 4,
+	AT91_MB_MODE_PRODUCER	= 5,
+};
+
+/* Interrupt mask bits */
+#define AT91_IRQ_MB_RX		((1 << (AT91_MB_RX_LAST + 1)) \
+				 - (1 << AT91_MB_RX_FIRST))
+#define AT91_IRQ_MB_TX		((1 << (AT91_MB_TX_LAST + 1)) \
+				 - (1 << AT91_MB_TX_FIRST))
+#define AT91_IRQ_MB_ALL		(AT91_IRQ_MB_RX | AT91_IRQ_MB_TX)
+
+#define AT91_IRQ_ERRA		(1 << 16)
+#define AT91_IRQ_WARN		(1 << 17)
+#define AT91_IRQ_ERRP		(1 << 18)
+#define AT91_IRQ_BOFF		(1 << 19)
+#define AT91_IRQ_SLEEP		(1 << 20)
+#define AT91_IRQ_WAKEUP		(1 << 21)
+#define AT91_IRQ_TOVF		(1 << 22)
+#define AT91_IRQ_TSTP		(1 << 23)
+#define AT91_IRQ_CERR		(1 << 24)
+#define AT91_IRQ_SERR		(1 << 25)
+#define AT91_IRQ_AERR		(1 << 26)
+#define AT91_IRQ_FERR		(1 << 27)
+#define AT91_IRQ_BERR		(1 << 28)
+
+#define AT91_IRQ_ERR_ALL	(0x1fff0000)
+#define AT91_IRQ_ERR_FRAME	(AT91_IRQ_CERR | AT91_IRQ_SERR | \
+				 AT91_IRQ_AERR | AT91_IRQ_FERR | AT91_IRQ_BERR)
+#define AT91_IRQ_ERR_LINE	(AT91_IRQ_ERRA | AT91_IRQ_WARN | \
+				 AT91_IRQ_ERRP | AT91_IRQ_BOFF)
+
+#define AT91_IRQ_ALL		(0x1fffffff)
+
+struct at91_priv {
+	struct can_priv		can;	   /* must be the first member! */
+	struct net_device	*dev;
+	struct napi_struct	napi;
+
+	void __iomem		*reg_base;
+
+	u32			reg_sr;
+	unsigned int		tx_next;
+	unsigned int		tx_echo;
+	unsigned int		rx_next;
+
+	struct clk		*clk;
+	struct at91_can_data	*pdata;
+};
+
+static struct can_bittiming_const at91_bittiming_const = {
+	.tseg1_min	= 4,
+	.tseg1_max	= 16,
+	.tseg2_min	= 2,
+	.tseg2_max	= 8,
+	.sjw_max	= 4,
+	.brp_min 	= 2,
+	.brp_max	= 128,
+	.brp_inc	= 1,
+};
+
+static inline int get_tx_next_mb(const struct at91_priv *priv)
+{
+	return (priv->tx_next & AT91_NEXT_MB_MASK) + AT91_MB_TX_FIRST;
+}
+
+static inline int get_tx_next_prio(const struct at91_priv *priv)
+{
+	return (priv->tx_next >> AT91_NEXT_PRIO_SHIFT) & 0xf;
+}
+
+static inline int get_tx_echo_mb(const struct at91_priv *priv)
+{
+	return (priv->tx_echo & AT91_NEXT_MB_MASK) + AT91_MB_TX_FIRST;
+}
+
+static inline u32 at91_read(const struct at91_priv *priv, enum at91_reg reg)
+{
+	return readl(priv->reg_base + reg);
+}
+
+static inline void at91_write(const struct at91_priv *priv, enum at91_reg reg,
+		u32 value)
+{
+	writel(value, priv->reg_base + reg);
+}
+
+static inline void set_mb_mode_prio(const struct at91_priv *priv,
+		unsigned int mb, enum at91_mb_mode mode, int prio)
+{
+	at91_write(priv, AT91_MMR(mb), (mode << 24) | (prio << 16));
+}
+
+static inline void set_mb_mode(const struct at91_priv *priv, unsigned int mb,
+		enum at91_mb_mode mode)
+{
+	set_mb_mode_prio(priv, mb, mode, 0);
+}
+
+/*
+ * Swtich transceiver on or off
+ */
+static void at91_transceiver_switch(const struct at91_priv *priv, int on)
+{
+	if (priv->pdata && priv->pdata->transceiver_switch)
+		priv->pdata->transceiver_switch(on);
+}
+
+static void at91_setup_mailboxes(struct net_device *dev)
+{
+	struct at91_priv *priv = netdev_priv(dev);
+	unsigned int i;
+
+	/*
+	 * The first 12 mailboxes are used as a reception FIFO. The
+	 * last mailbox is configured with overwrite option. The
+	 * overwrite flag indicates a FIFO overflow.
+	 */
+	for (i = AT91_MB_RX_FIRST; i < AT91_MB_RX_LAST; i++)
+		set_mb_mode(priv, i, AT91_MB_MODE_RX);
+	set_mb_mode(priv, AT91_MB_RX_LAST, AT91_MB_MODE_RX_OVRWR);
+
+	/* The last 4 mailboxes are used for transmitting. */
+	for (i = AT91_MB_TX_FIRST; i <= AT91_MB_TX_LAST; i++)
+		set_mb_mode_prio(priv, i, AT91_MB_MODE_TX, 0);
+
+	/* Reset tx and rx helper pointers */
+	priv->tx_next = priv->tx_echo = priv->rx_next = 0;
+}
+
+static int at91_set_bittiming(struct net_device *dev)
+{
+	const struct at91_priv *priv = netdev_priv(dev);
+	const struct can_bittiming *bt = &priv->can.bittiming;
+	u32 reg_br;
+
+	reg_br = ((priv->can.ctrlmode & CAN_CTRLMODE_3_SAMPLES) << 24) |
+		((bt->brp - 1) << 16) |	((bt->sjw - 1) << 12) |
+		((bt->prop_seg - 1) << 8) | ((bt->phase_seg1 - 1) << 4) |
+		((bt->phase_seg2 - 1) << 0);
+
+	dev_info(ND2D(dev), "writing AT91_BR: 0x%08x\n", reg_br);
+
+	at91_write(priv, AT91_BR, reg_br);
+
+	return 0;
+}
+
+static void at91_chip_start(struct net_device *dev)
+{
+	struct at91_priv *priv = netdev_priv(dev);
+	u32 reg_mr, reg_ier;
+
+	/* disable interrupts */
+	at91_write(priv, AT91_IDR, AT91_IRQ_ALL);
+
+	/* disable chip */
+	reg_mr = at91_read(priv, AT91_MR);
+	at91_write(priv, AT91_MR, reg_mr & ~AT91_MR_CANEN);
+
+	at91_setup_mailboxes(dev);
+	at91_transceiver_switch(priv, 1);
+
+	/* enable chip */
+	at91_write(priv, AT91_MR, AT91_MR_CANEN);
+
+	priv->can.state = CAN_STATE_ERROR_ACTIVE;
+
+	/* Enable interrupts */
+	reg_ier = AT91_IRQ_MB_RX | AT91_IRQ_ERRP | AT91_IRQ_ERR_FRAME;
+	at91_write(priv, AT91_IDR, AT91_IRQ_ALL);
+	at91_write(priv, AT91_IER, reg_ier);
+}
+
+static void at91_chip_stop(struct net_device *dev, enum can_state state)
+{
+	struct at91_priv *priv = netdev_priv(dev);
+	u32 reg_mr;
+
+	/* disable interrupts */
+	at91_write(priv, AT91_IDR, AT91_IRQ_ALL);
+
+	reg_mr = at91_read(priv, AT91_MR);
+	at91_write(priv, AT91_MR, reg_mr & ~AT91_MR_CANEN);
+
+	at91_transceiver_switch(priv, 0);
+	priv->can.state = state;
+}
+
+/*
+ * theory of operation:
+ *
+ * According to the datasheet priority 0 is the highest priority, 15
+ * is the lowest. If two mailboxes have the same priority level the
+ * message of the mailbox with the lowest number is sent first.
+ *
+ * We use the first TX mailbox (AT91_MB_TX_FIRST) with prio 0, then
+ * the next mailbox with prio 0, and so on, until all mailboxes are
+ * used. Then we start from the beginning with mailbox
+ * AT91_MB_TX_FIRST, but with prio 1, mailbox AT91_MB_TX_FIRST + 1
+ * prio 1. When we reach the last mailbox with prio 15, we have to
+ * stop sending, waiting for all messages to be delivered, then start
+ * again with mailbox AT91_MB_TX_FIRST prio 0.
+ *
+ * We use the priv->tx_next as counter for the next transmission
+ * mailbox, but without the offset AT91_MB_TX_FIRST. The lower bits
+ * encode the mailbox number, the upper 4 bits the mailbox priority:
+ *
+ * priv->tx_next = (prio << AT91_NEXT_PRIO_SHIFT) ||
+ *                 (mb - AT91_MB_TX_FIRST);
+ *
+ */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,32)
+static int at91_start_xmit(struct sk_buff *skb, struct net_device *dev)
+#else
+static netdev_tx_t at91_start_xmit(struct sk_buff *skb, struct net_device *dev)
+#endif
+{
+	struct at91_priv *priv = netdev_priv(dev);
+	struct net_device_stats *stats = &dev->stats;
+	struct can_frame *cf = (struct can_frame *)skb->data;
+	unsigned int mb, prio;
+	u32 reg_mid, reg_mcr;
+
+	if (can_dropped_invalid_skb(dev, skb))
+		return NETDEV_TX_OK;
+
+	mb = get_tx_next_mb(priv);
+	prio = get_tx_next_prio(priv);
+
+	if (unlikely(!(at91_read(priv, AT91_MSR(mb)) & AT91_MSR_MRDY))) {
+		netif_stop_queue(dev);
+
+		dev_err(ND2D(dev),
+			"BUG! TX buffer full when queue awake!\n");
+		return NETDEV_TX_BUSY;
+	}
+
+	if (cf->can_id & CAN_EFF_FLAG)
+		reg_mid = (cf->can_id & CAN_EFF_MASK) | AT91_MID_MIDE;
+	else
+		reg_mid = (cf->can_id & CAN_SFF_MASK) << 18;
+
+	reg_mcr = ((cf->can_id & CAN_RTR_FLAG) ? AT91_MCR_MRTR : 0) |
+		(cf->can_dlc << 16) | AT91_MCR_MTCR;
+
+	/* disable MB while writing ID (see datasheet) */
+	set_mb_mode(priv, mb, AT91_MB_MODE_DISABLED);
+	at91_write(priv, AT91_MID(mb), reg_mid);
+	set_mb_mode_prio(priv, mb, AT91_MB_MODE_TX, prio);
+
+	at91_write(priv, AT91_MDL(mb), *(u32 *)(cf->data + 0));
+	at91_write(priv, AT91_MDH(mb), *(u32 *)(cf->data + 4));
+
+	/* This triggers transmission */
+	at91_write(priv, AT91_MCR(mb), reg_mcr);
+
+	stats->tx_bytes += cf->can_dlc;
+	dev->trans_start = jiffies;
+
+	/* _NOTE_: substract AT91_MB_TX_FIRST offset from mb! */
+	can_put_echo_skb(skb, dev, mb - AT91_MB_TX_FIRST);
+
+	/*
+	 * we have to stop the queue and deliver all messages in case
+	 * of a prio+mb counter wrap around. This is the case if
+	 * tx_next buffer prio and mailbox equals 0.
+	 *
+	 * also stop the queue if next buffer is still in use
+	 * (== not ready)
+	 */
+	priv->tx_next++;
+	if (!(at91_read(priv, AT91_MSR(get_tx_next_mb(priv))) &
+	      AT91_MSR_MRDY) ||
+	    (priv->tx_next & AT91_NEXT_MASK) == 0)
+		netif_stop_queue(dev);
+
+	/* Enable interrupt for this mailbox */
+	at91_write(priv, AT91_IER, 1 << mb);
+
+	return NETDEV_TX_OK;
+}
+
+/**
+ * at91_activate_rx_low - activate lower rx mailboxes
+ * @priv: a91 context
+ *
+ * Reenables the lower mailboxes for reception of new CAN messages
+ */
+static inline void at91_activate_rx_low(const struct at91_priv *priv)
+{
+	u32 mask = AT91_MB_RX_LOW_MASK;
+	at91_write(priv, AT91_TCR, mask);
+}
+
+/**
+ * at91_activate_rx_mb - reactive single rx mailbox
+ * @priv: a91 context
+ * @mb: mailbox to reactivate
+ *
+ * Reenables given mailbox for reception of new CAN messages
+ */
+static inline void at91_activate_rx_mb(const struct at91_priv *priv,
+		unsigned int mb)
+{
+	u32 mask = 1 << mb;
+	at91_write(priv, AT91_TCR, mask);
+}
+
+/**
+ * at91_rx_overflow_err - send error frame due to rx overflow
+ * @dev: net device
+ */
+static void at91_rx_overflow_err(struct net_device *dev)
+{
+	struct net_device_stats *stats = &dev->stats;
+	struct sk_buff *skb;
+	struct can_frame *cf;
+
+	dev_dbg(ND2D(dev), "RX buffer overflow\n");
+	stats->rx_over_errors++;
+	stats->rx_errors++;
+
+	skb = alloc_can_err_skb(dev, &cf);
+	if (unlikely(!skb))
+		return;
+
+	cf->can_id |= CAN_ERR_CRTL;
+	cf->data[1] = CAN_ERR_CRTL_RX_OVERFLOW;
+	netif_receive_skb(skb);
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,32)
+	dev->last_rx = jiffies;
+#endif
+	stats->rx_packets++;
+	stats->rx_bytes += cf->can_dlc;
+}
+
+/**
+ * at91_read_mb - read CAN msg from mailbox (lowlevel impl)
+ * @dev: net device
+ * @mb: mailbox number to read from
+ * @cf: can frame where to store message
+ *
+ * Reads a CAN message from the given mailbox and stores data into
+ * given can frame. "mb" and "cf" must be valid.
+ */
+static void at91_read_mb(struct net_device *dev, unsigned int mb,
+		struct can_frame *cf)
+{
+	const struct at91_priv *priv = netdev_priv(dev);
+	u32 reg_msr, reg_mid;
+
+	reg_mid = at91_read(priv, AT91_MID(mb));
+	if (reg_mid & AT91_MID_MIDE)
+		cf->can_id = ((reg_mid >> 0) & CAN_EFF_MASK) | CAN_EFF_FLAG;
+	else
+		cf->can_id = (reg_mid >> 18) & CAN_SFF_MASK;
+
+	reg_msr = at91_read(priv, AT91_MSR(mb));
+	if (reg_msr & AT91_MSR_MRTR)
+		cf->can_id |= CAN_RTR_FLAG;
+	cf->can_dlc = get_can_dlc((reg_msr >> 16) & 0xf);
+
+	*(u32 *)(cf->data + 0) = at91_read(priv, AT91_MDL(mb));
+	*(u32 *)(cf->data + 4) = at91_read(priv, AT91_MDH(mb));
+
+	if (unlikely(mb == AT91_MB_RX_LAST && reg_msr & AT91_MSR_MMI))
+		at91_rx_overflow_err(dev);
+}
+
+/**
+ * at91_read_msg - read CAN message from mailbox
+ * @dev: net device
+ * @mb: mail box to read from
+ *
+ * Reads a CAN message from given mailbox, and put into linux network
+ * RX queue, does all housekeeping chores (stats, ...)
+ */
+static void at91_read_msg(struct net_device *dev, unsigned int mb)
+{
+	struct net_device_stats *stats = &dev->stats;
+	struct can_frame *cf;
+	struct sk_buff *skb;
+
+	skb = alloc_can_skb(dev, &cf);
+	if (unlikely(!skb)) {
+		stats->rx_dropped++;
+		return;
+	}
+
+	at91_read_mb(dev, mb, cf);
+	netif_receive_skb(skb);
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,32)
+	dev->last_rx = jiffies;
+#endif
+	stats->rx_packets++;
+	stats->rx_bytes += cf->can_dlc;
+}
+
+/**
+ * at91_poll_rx - read multiple CAN messages from mailboxes
+ * @dev: net device
+ * @quota: max number of pkgs we're allowed to receive
+ *
+ * Theory of Operation:
+ *
+ * 12 of the 16 mailboxes on the chip are reserved for RX. we split
+ * them into 2 groups. The lower group holds 8 and upper 4 mailboxes.
+ *
+ * Like it or not, but the chip always saves a received CAN message
+ * into the first free mailbox it finds (starting with the
+ * lowest). This makes it very difficult to read the messages in the
+ * right order from the chip. This is how we work around that problem:
+ *
+ * The first message goes into mb nr. 0 and issues an interrupt. All
+ * rx ints are disabled in the interrupt handler and a napi poll is
+ * scheduled. We read the mailbox, but do _not_ reenable the mb (to
+ * receive another message).
+ *
+ *    lower mbxs      upper
+ *   ______^______    __^__
+ *  /             \  /     \
+ * +-+-+-+-+-+-+-+-++-+-+-+-+
+ * |x|x|x|x|x|x|x|x|| | | | |
+ * +-+-+-+-+-+-+-+-++-+-+-+-+
+ *  0 0 0 0 0 0  0 0 0 0 1 1  \ mail
+ *  0 1 2 3 4 5  6 7 8 9 0 1  / box
+ *
+ * The variable priv->rx_next points to the next mailbox to read a
+ * message from. As long we're in the lower mailboxes we just read the
+ * mailbox but not reenable it.
+ *
+ * With completion of the last of the lower mailboxes, we reenable the
+ * whole first group, but continue to look for filled mailboxes in the
+ * upper mailboxes. Imagine the second group like overflow mailboxes,
+ * which takes CAN messages if the lower goup is full. While in the
+ * upper group we reenable the mailbox right after reading it. Giving
+ * the chip more room to store messages.
+ *
+ * After finishing we look again in the lower group if we've still
+ * quota.
+ *
+ */
+static int at91_poll_rx(struct net_device *dev, int quota)
+{
+	struct at91_priv *priv = netdev_priv(dev);
+	u32 reg_sr = at91_read(priv, AT91_SR);
+	const unsigned long *addr = (unsigned long *)&reg_sr;
+	unsigned int mb;
+	int received = 0;
+
+	if (priv->rx_next > AT91_MB_RX_LOW_LAST &&
+	    reg_sr & AT91_MB_RX_LOW_MASK)
+		dev_info(ND2D(dev),
+			 "order of incoming frames cannot be guaranteed\n");
+
+ again:
+	for (mb = find_next_bit(addr, AT91_MB_RX_NUM, priv->rx_next);
+	     mb < AT91_MB_RX_NUM && quota > 0;
+	     reg_sr = at91_read(priv, AT91_SR),
+	     mb = find_next_bit(addr, AT91_MB_RX_NUM, ++priv->rx_next)) {
+		at91_read_msg(dev, mb);
+
+		/* reactivate mailboxes */
+		if (mb == AT91_MB_RX_LOW_LAST)
+			/* all lower mailboxed, if just finished it */
+			at91_activate_rx_low(priv);
+		else if (mb > AT91_MB_RX_LOW_LAST)
+			/* only the mailbox we read */
+			at91_activate_rx_mb(priv, mb);
+
+		received++;
+		quota--;
+	}
+
+	/* upper group completed, look again in lower */
+	if (priv->rx_next > AT91_MB_RX_LOW_LAST &&
+	    quota > 0 && mb >= AT91_MB_RX_NUM) {
+		priv->rx_next = 0;
+		goto again;
+	}
+
+	return received;
+}
+
+static void at91_poll_err_frame(struct net_device *dev,
+		struct can_frame *cf, u32 reg_sr)
+{
+	struct at91_priv *priv = netdev_priv(dev);
+
+	/* CRC error */
+	if (reg_sr & AT91_IRQ_CERR) {
+		dev_dbg(ND2D(dev), "CERR irq\n");
+		dev->stats.rx_errors++;
+		priv->can.can_stats.bus_error++;
+		cf->can_id |= CAN_ERR_PROT | CAN_ERR_BUSERROR;
+	}
+
+	/* Stuffing Error */
+	if (reg_sr & AT91_IRQ_SERR) {
+		dev_dbg(ND2D(dev), "SERR irq\n");
+		dev->stats.rx_errors++;
+		priv->can.can_stats.bus_error++;
+		cf->can_id |= CAN_ERR_PROT | CAN_ERR_BUSERROR;
+		cf->data[2] |= CAN_ERR_PROT_STUFF;
+	}
+
+	/* Acknowledgement Error */
+	if (reg_sr & AT91_IRQ_AERR) {
+		dev_dbg(ND2D(dev), "AERR irq\n");
+		dev->stats.tx_errors++;
+		cf->can_id |= CAN_ERR_ACK;
+	}
+
+	/* Form error */
+	if (reg_sr & AT91_IRQ_FERR) {
+		dev_dbg(ND2D(dev), "FERR irq\n");
+		dev->stats.rx_errors++;
+		priv->can.can_stats.bus_error++;
+		cf->can_id |= CAN_ERR_PROT | CAN_ERR_BUSERROR;
+		cf->data[2] |= CAN_ERR_PROT_FORM;
+	}
+
+	/* Bit Error */
+	if (reg_sr & AT91_IRQ_BERR) {
+		dev_dbg(ND2D(dev), "BERR irq\n");
+		dev->stats.tx_errors++;
+		priv->can.can_stats.bus_error++;
+		cf->can_id |= CAN_ERR_PROT | CAN_ERR_BUSERROR;
+		cf->data[2] |= CAN_ERR_PROT_BIT;
+	}
+}
+
+static int at91_poll_err(struct net_device *dev, int quota, u32 reg_sr)
+{
+	struct sk_buff *skb;
+	struct can_frame *cf;
+
+	if (quota == 0)
+		return 0;
+
+	skb = alloc_can_err_skb(dev, &cf);
+	if (unlikely(!skb))
+		return 0;
+
+	at91_poll_err_frame(dev, cf, reg_sr);
+	netif_receive_skb(skb);
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,32)
+	dev->last_rx = jiffies;
+#endif
+	dev->stats.rx_packets++;
+	dev->stats.rx_bytes += cf->can_dlc;
+
+	return 1;
+}
+
+static int at91_poll(struct napi_struct *napi, int quota)
+{
+	struct net_device *dev = napi->dev;
+	const struct at91_priv *priv = netdev_priv(dev);
+	u32 reg_sr = at91_read(priv, AT91_SR);
+	int work_done = 0;
+
+	if (reg_sr & AT91_IRQ_MB_RX)
+		work_done += at91_poll_rx(dev, quota - work_done);
+
+	/*
+	 * The error bits are clear on read,
+	 * so use saved value from irq handler.
+	 */
+	reg_sr |= priv->reg_sr;
+	if (reg_sr & AT91_IRQ_ERR_FRAME)
+		work_done += at91_poll_err(dev, quota - work_done, reg_sr);
+
+	if (work_done < quota) {
+		/* enable IRQs for frame errors and all mailboxes >= rx_next */
+		u32 reg_ier = AT91_IRQ_ERR_FRAME;
+		reg_ier |= AT91_IRQ_MB_RX & ~AT91_MB_RX_MASK(priv->rx_next);
+
+		napi_complete(napi);
+		at91_write(priv, AT91_IER, reg_ier);
+	}
+
+	return work_done;
+}
+
+/*
+ * theory of operation:
+ *
+ * priv->tx_echo holds the number of the oldest can_frame put for
+ * transmission into the hardware, but not yet ACKed by the CAN tx
+ * complete IRQ.
+ *
+ * We iterate from priv->tx_echo to priv->tx_next and check if the
+ * packet has been transmitted, echo it back to the CAN framework. If
+ * we discover a not yet transmitted package, stop looking for more.
+ *
+ */
+static void at91_irq_tx(struct net_device *dev, u32 reg_sr)
+{
+	struct at91_priv *priv = netdev_priv(dev);
+	u32 reg_msr;
+	unsigned int mb;
+
+	/* masking of reg_sr not needed, already done by at91_irq */
+
+	for (/* nix */; (priv->tx_next - priv->tx_echo) > 0; priv->tx_echo++) {
+		mb = get_tx_echo_mb(priv);
+
+		/* no event in mailbox? */
+		if (!(reg_sr & (1 << mb)))
+			break;
+
+		/* Disable irq for this TX mailbox */
+		at91_write(priv, AT91_IDR, 1 << mb);
+
+		/*
+		 * only echo if mailbox signals us a transfer
+		 * complete (MSR_MRDY). Otherwise it's a tansfer
+		 * abort. "can_bus_off()" takes care about the skbs
+		 * parked in the echo queue.
+		 */
+		reg_msr = at91_read(priv, AT91_MSR(mb));
+		if (likely(reg_msr & AT91_MSR_MRDY &&
+			   ~reg_msr & AT91_MSR_MABT)) {
+			/* _NOTE_: substract AT91_MB_TX_FIRST offset from mb! */
+			can_get_echo_skb(dev, mb - AT91_MB_TX_FIRST);
+			dev->stats.tx_packets++;
+		}
+	}
+
+	/*
+	 * restart queue if we don't have a wrap around but restart if
+	 * we get a TX int for the last can frame directly before a
+	 * wrap around.
+	 */
+	if ((priv->tx_next & AT91_NEXT_MASK) != 0 ||
+	    (priv->tx_echo & AT91_NEXT_MASK) == 0)
+		netif_wake_queue(dev);
+}
+
+static void at91_irq_err_state(struct net_device *dev,
+		struct can_frame *cf, enum can_state new_state)
+{
+	struct at91_priv *priv = netdev_priv(dev);
+	u32 reg_idr, reg_ier, reg_ecr;
+	u8 tec, rec;
+
+	reg_ecr = at91_read(priv, AT91_ECR);
+	rec = reg_ecr & 0xff;
+	tec = reg_ecr >> 16;
+
+	switch (priv->can.state) {
+	case CAN_STATE_ERROR_ACTIVE:
+		/*
+		 * from: ERROR_ACTIVE
+		 * to  : ERROR_WARNING, ERROR_PASSIVE, BUS_OFF
+		 * =>  : there was a warning int
+		 */
+		if (new_state >= CAN_STATE_ERROR_WARNING &&
+		    new_state <= CAN_STATE_BUS_OFF) {
+			dev_dbg(ND2D(dev), "Error Warning IRQ\n");
+			priv->can.can_stats.error_warning++;
+
+			cf->can_id |= CAN_ERR_CRTL;
+			cf->data[1] = (tec > rec) ?
+				CAN_ERR_CRTL_TX_WARNING :
+				CAN_ERR_CRTL_RX_WARNING;
+		}
+	case CAN_STATE_ERROR_WARNING:	/* fallthrough */
+		/*
+		 * from: ERROR_ACTIVE, ERROR_WARNING
+		 * to  : ERROR_PASSIVE, BUS_OFF
+		 * =>  : error passive int
+		 */
+		if (new_state >= CAN_STATE_ERROR_PASSIVE &&
+		    new_state <= CAN_STATE_BUS_OFF) {
+			dev_dbg(ND2D(dev), "Error Passive IRQ\n");
+			priv->can.can_stats.error_passive++;
+
+			cf->can_id |= CAN_ERR_CRTL;
+			cf->data[1] = (tec > rec) ?
+				CAN_ERR_CRTL_TX_PASSIVE :
+				CAN_ERR_CRTL_RX_PASSIVE;
+		}
+		break;
+	case CAN_STATE_BUS_OFF:
+		/*
+		 * from: BUS_OFF
+		 * to  : ERROR_ACTIVE, ERROR_WARNING, ERROR_PASSIVE
+		 */
+		if (new_state <= CAN_STATE_ERROR_PASSIVE) {
+			cf->can_id |= CAN_ERR_RESTARTED;
+
+			dev_dbg(dev->dev.parent, "restarted\n");
+			priv->can.can_stats.restarts++;
+
+			netif_carrier_on(dev);
+			netif_wake_queue(dev);
+		}
+		break;
+	default:
+		break;
+	}
+
+
+	/* process state changes depending on the new state */
+	switch (new_state) {
+	case CAN_STATE_ERROR_ACTIVE:
+		/*
+		 * actually we want to enable AT91_IRQ_WARN here, but
+		 * it screws up the system under certain
+		 * circumstances. so just enable AT91_IRQ_ERRP, thus
+		 * the "fallthrough"
+		 */
+		dev_dbg(ND2D(dev), "Error Active\n");
+		cf->can_id |= CAN_ERR_PROT;
+		cf->data[2] = CAN_ERR_PROT_ACTIVE;
+	case CAN_STATE_ERROR_WARNING:	/* fallthrough */
+		reg_idr = AT91_IRQ_ERRA | AT91_IRQ_WARN | AT91_IRQ_BOFF;
+		reg_ier = AT91_IRQ_ERRP;
+		break;
+	case CAN_STATE_ERROR_PASSIVE:
+		reg_idr = AT91_IRQ_ERRA | AT91_IRQ_WARN | AT91_IRQ_ERRP;
+		reg_ier = AT91_IRQ_BOFF;
+		break;
+	case CAN_STATE_BUS_OFF:
+		reg_idr = AT91_IRQ_ERRA | AT91_IRQ_ERRP |
+			AT91_IRQ_WARN | AT91_IRQ_BOFF;
+		reg_ier = 0;
+
+		cf->can_id |= CAN_ERR_BUSOFF;
+
+		dev_dbg(ND2D(dev), "bus-off\n");
+		netif_carrier_off(dev);
+		priv->can.can_stats.bus_off++;
+
+		/* turn off chip, if restart is disabled */
+		if (!priv->can.restart_ms) {
+			at91_chip_stop(dev, CAN_STATE_BUS_OFF);
+			return;
+		}
+		break;
+	default:
+		break;
+	}
+
+	at91_write(priv, AT91_IDR, reg_idr);
+	at91_write(priv, AT91_IER, reg_ier);
+}
+
+static void at91_irq_err(struct net_device *dev)
+{
+	struct at91_priv *priv = netdev_priv(dev);
+	struct sk_buff *skb;
+	struct can_frame *cf;
+	enum can_state new_state;
+	u32 reg_sr;
+
+	reg_sr = at91_read(priv, AT91_SR);
+
+	/* we need to look at the unmasked reg_sr */
+	if (unlikely(reg_sr & AT91_IRQ_BOFF))
+		new_state = CAN_STATE_BUS_OFF;
+	else if (unlikely(reg_sr & AT91_IRQ_ERRP))
+		new_state = CAN_STATE_ERROR_PASSIVE;
+	else if (unlikely(reg_sr & AT91_IRQ_WARN))
+		new_state = CAN_STATE_ERROR_WARNING;
+	else if (likely(reg_sr & AT91_IRQ_ERRA))
+		new_state = CAN_STATE_ERROR_ACTIVE;
+	else {
+		dev_err(ND2D(dev), "BUG! hardware in undefined state\n");
+		return;
+	}
+
+	/* state hasn't changed */
+	if (likely(new_state == priv->can.state))
+		return;
+
+	skb = alloc_can_err_skb(dev, &cf);
+	if (unlikely(!skb))
+		return;
+
+	at91_irq_err_state(dev, cf, new_state);
+	netif_rx(skb);
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,32)
+	dev->last_rx = jiffies;
+#endif
+	dev->stats.rx_packets++;
+	dev->stats.rx_bytes += cf->can_dlc;
+
+	priv->can.state = new_state;
+}
+
+/*
+ * interrupt handler
+ */
+static irqreturn_t at91_irq(int irq, void *dev_id)
+{
+	struct net_device *dev = dev_id;
+	struct at91_priv *priv = netdev_priv(dev);
+	irqreturn_t handled = IRQ_NONE;
+	u32 reg_sr, reg_imr;
+
+	reg_sr = at91_read(priv, AT91_SR);
+	reg_imr = at91_read(priv, AT91_IMR);
+
+	/* Ignore masked interrupts */
+	reg_sr &= reg_imr;
+	if (!reg_sr)
+		goto exit;
+
+	handled = IRQ_HANDLED;
+
+	/* Receive or error interrupt? -> napi */
+	if (reg_sr & (AT91_IRQ_MB_RX | AT91_IRQ_ERR_FRAME)) {
+		/*
+		 * The error bits are clear on read,
+		 * save for later use.
+		 */
+		priv->reg_sr = reg_sr;
+		at91_write(priv, AT91_IDR,
+			   AT91_IRQ_MB_RX | AT91_IRQ_ERR_FRAME);
+		napi_schedule(&priv->napi);
+	}
+
+	/* Transmission complete interrupt */
+	if (reg_sr & AT91_IRQ_MB_TX)
+		at91_irq_tx(dev, reg_sr);
+
+	at91_irq_err(dev);
+
+ exit:
+	return handled;
+}
+
+static int at91_open(struct net_device *dev)
+{
+	struct at91_priv *priv = netdev_priv(dev);
+	int err;
+
+	clk_enable(priv->clk);
+
+	/* check or determine and set bittime */
+	err = open_candev(dev);
+	if (err)
+		goto out;
+
+	/* register interrupt handler */
+	if (request_irq(dev->irq, at91_irq, IRQF_SHARED,
+			dev->name, dev)) {
+		err = -EAGAIN;
+		goto out_close;
+	}
+
+	/* start chip and queuing */
+	at91_chip_start(dev);
+	napi_enable(&priv->napi);
+	netif_start_queue(dev);
+
+	return 0;
+
+ out_close:
+	close_candev(dev);
+ out:
+	clk_disable(priv->clk);
+
+	return err;
+}
+
+/*
+ * stop CAN bus activity
+ */
+static int at91_close(struct net_device *dev)
+{
+	struct at91_priv *priv = netdev_priv(dev);
+
+	netif_stop_queue(dev);
+	napi_disable(&priv->napi);
+	at91_chip_stop(dev, CAN_STATE_STOPPED);
+
+	free_irq(dev->irq, dev);
+	clk_disable(priv->clk);
+
+	close_candev(dev);
+
+	return 0;
+}
+
+static int at91_set_mode(struct net_device *dev, enum can_mode mode)
+{
+	switch (mode) {
+	case CAN_MODE_START:
+		at91_chip_start(dev);
+		netif_wake_queue(dev);
+		break;
+
+	default:
+		return -EOPNOTSUPP;
+	}
+
+	return 0;
+}
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,28)
+static const struct net_device_ops at91_netdev_ops = {
+	.ndo_open	= at91_open,
+	.ndo_stop	= at91_close,
+	.ndo_start_xmit	= at91_start_xmit,
+};
+#endif
+
+static int __init at91_can_probe(struct platform_device *pdev)
+{
+	struct net_device *dev;
+	struct at91_priv *priv;
+	struct resource *res;
+	struct clk *clk;
+	void __iomem *addr;
+	int err, irq;
+
+	clk = clk_get(&pdev->dev, "can_clk");
+	if (IS_ERR(clk)) {
+		dev_err(&pdev->dev, "no clock defined\n");
+		err = -ENODEV;
+		goto exit;
+	}
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	irq = platform_get_irq(pdev, 0);
+	if (!res || irq <= 0) {
+		err = -ENODEV;
+		goto exit_put;
+	}
+
+	if (!request_mem_region(res->start,
+				resource_size(res),
+				pdev->name)) {
+		err = -EBUSY;
+		goto exit_put;
+	}
+
+	addr = ioremap_nocache(res->start, resource_size(res));
+	if (!addr) {
+		err = -ENOMEM;
+		goto exit_release;
+	}
+
+	dev = alloc_candev(sizeof(struct at91_priv), AT91_MB_TX_NUM);
+	if (!dev) {
+		err = -ENOMEM;
+		goto exit_iounmap;
+	}
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,28)
+	dev->netdev_ops	= &at91_netdev_ops;
+#else
+	dev->open = at91_open;
+	dev->stop = at91_close;
+	dev->hard_start_xmit = at91_start_xmit;
+#endif
+	dev->irq = irq;
+	dev->flags |= IFF_ECHO;
+
+	priv = netdev_priv(dev);
+	priv->can.clock.freq = clk_get_rate(clk);
+	priv->can.bittiming_const = &at91_bittiming_const;
+	priv->can.do_set_bittiming = at91_set_bittiming;
+	priv->can.do_set_mode = at91_set_mode;
+	priv->can.ctrlmode_supported = CAN_CTRLMODE_3_SAMPLES;
+	priv->reg_base = addr;
+	priv->dev = dev;
+	priv->clk = clk;
+	priv->pdata = pdev->dev.platform_data;
+
+	netif_napi_add(dev, &priv->napi, at91_poll, AT91_NAPI_WEIGHT);
+
+	dev_set_drvdata(&pdev->dev, dev);
+	SET_NETDEV_DEV(dev, &pdev->dev);
+
+	err = register_candev(dev);
+	if (err) {
+		dev_err(&pdev->dev, "registering netdev failed\n");
+		goto exit_free;
+	}
+
+	dev_info(&pdev->dev, "device registered (reg_base=%p, irq=%d)\n",
+		 priv->reg_base, dev->irq);
+
+	return 0;
+
+ exit_free:
+	free_netdev(dev);
+ exit_iounmap:
+	iounmap(addr);
+ exit_release:
+	release_mem_region(res->start, resource_size(res));
+ exit_put:
+	clk_put(clk);
+ exit:
+	return err;
+}
+
+static int __devexit at91_can_remove(struct platform_device *pdev)
+{
+	struct net_device *dev = platform_get_drvdata(pdev);
+	struct at91_priv *priv = netdev_priv(dev);
+	struct resource *res;
+
+	unregister_netdev(dev);
+
+	platform_set_drvdata(pdev, NULL);
+
+	free_netdev(dev);
+
+	iounmap(priv->reg_base);
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	release_mem_region(res->start, resource_size(res));
+
+	clk_put(priv->clk);
+
+	return 0;
+}
+
+static struct platform_driver at91_can_driver = {
+	.probe		= at91_can_probe,
+	.remove		= __devexit_p(at91_can_remove),
+	.driver		= {
+		.name	= DRV_NAME,
+		.owner	= THIS_MODULE,
+	},
+};
+
+static int __init at91_can_module_init(void)
+{
+	printk(KERN_INFO "%s netdevice driver\n", DRV_NAME);
+	return platform_driver_register(&at91_can_driver);
+}
+
+static void __exit at91_can_module_exit(void)
+{
+	platform_driver_unregister(&at91_can_driver);
+	printk(KERN_INFO "%s: driver removed\n", DRV_NAME);
+}
+
+module_init(at91_can_module_init);
+module_exit(at91_can_module_exit);
+
+MODULE_AUTHOR("Marc Kleine-Budde <mkl@pengutronix.de>");
+MODULE_LICENSE("GPL v2");
+MODULE_DESCRIPTION(DRV_NAME " CAN netdevice driver");
diff --exclude CVS --exclude .git -uNr linux-2.6.27.8/drivers/net/can/cc770/Kconfig linux-2.6.27.8.modified/drivers/net/can/cc770/Kconfig
--- linux-2.6.27.8/drivers/net/can/cc770/Kconfig	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.27.8.modified/drivers/net/can/cc770/Kconfig	2013-05-30 03:44:17.000000000 -0400
@@ -0,0 +1,25 @@
+menuconfig CAN_CC770
+	tristate "Bosch CC770 and Intel AN82527 devices"
+	depends on CAN_DEV && HAS_IOMEM
+
+if CAN_CC770
+
+config CAN_CC770_ISA
+	depends on ISA
+	tristate "ISA Bus based legacy CC770 driver"
+	---help---
+	  This driver adds legacy support for CC770 and AN82527 chips
+	  connected to the ISA bus using I/O port, memory mapped or
+	  indirect access.
+
+config CAN_CC770_OF_PLATFORM
+	depends on PPC_OF
+	tristate "Generic OF Platform Bus based CC770 driver"
+	---help---
+	  This driver adds support for the CC770 and other AN82527
+	  compatible chips connected to the OpenFirmware "platform bus"
+	  found on embedded systems with OpenFirmware bindings, e.g. if
+	  you have a PowerPC based system you may want to enable this
+	  option.
+
+endif
diff --exclude CVS --exclude .git -uNr linux-2.6.27.8/drivers/net/can/cc770/Makefile linux-2.6.27.8.modified/drivers/net/can/cc770/Makefile
--- linux-2.6.27.8/drivers/net/can/cc770/Makefile	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.27.8.modified/drivers/net/can/cc770/Makefile	2013-05-30 03:44:17.000000000 -0400
@@ -0,0 +1,26 @@
+#
+#  $Id: Makefile 443 2007-07-25 11:41:27Z hartkopp $
+#
+
+ifeq ($(KERNELRELEASE),)
+
+KERNELDIR := /lib/modules/$(shell uname -r)/build
+PWD       := $(shell pwd)
+TOPDIR    := $(PWD)/../../../..
+
+modules modules_install clean:
+	$(MAKE) -C $(KERNELDIR) M=$(PWD) $@ TOPDIR=$(TOPDIR)
+
+else
+
+-include $(TOPDIR)/Makefile.common
+
+obj-$(CONFIG_CAN_CC770) += cc770.o
+obj-$(CONFIG_CAN_CC770_ISA) += cc770_isa.o
+obj-$(CONFIG_CAN_CC770_OF_PLATFORM) += cc770_of_platform.o
+
+ifeq ($(CONFIG_CAN_DEBUG_DEVICES),y)
+	EXTRA_CFLAGS += -DDEBUG
+endif
+
+endif
diff --exclude CVS --exclude .git -uNr linux-2.6.27.8/drivers/net/can/cc770/cc770.c linux-2.6.27.8.modified/drivers/net/can/cc770/cc770.c
--- linux-2.6.27.8/drivers/net/can/cc770/cc770.c	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.27.8.modified/drivers/net/can/cc770/cc770.c	2013-05-30 03:44:17.000000000 -0400
@@ -0,0 +1,949 @@
+/*
+ * $Id:  $
+ *
+ * cc770.c - Bosch CC770 and Intel AN82527 network device driver
+ *
+ * Copyright (C) 2009 Wolfgang Grandegger <wg@grandegger.com>
+ *
+ * Derived from the old Socket-CAN i82527 driver:
+ *
+ * Copyright (c) 2002-2007 Volkswagen Group Electronic Research
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of Volkswagen nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * Alternatively, provided that this notice is retained in full, this
+ * software may be distributed under the terms of the GNU General
+ * Public License ("GPL") version 2, in which case the provisions of the
+ * GPL apply INSTEAD OF those given above.
+ *
+ * The provided data structures and external interfaces from this code
+ * are not restricted to be used by modules with a GPL compatible license.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * Send feedback to <socketcan-users@lists.berlios.de>
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/version.h>
+#include <linux/sched.h>
+#include <linux/types.h>
+#include <linux/fcntl.h>
+#include <linux/interrupt.h>
+#include <linux/ptrace.h>
+#include <linux/string.h>
+#include <linux/errno.h>
+#include <linux/netdevice.h>
+#include <linux/if_arp.h>
+#include <linux/if_ether.h>
+#include <linux/skbuff.h>
+#include <linux/delay.h>
+
+#include <socketcan/can.h>
+#include <socketcan/can/dev.h>
+#include <socketcan/can/error.h>
+#include <socketcan/can/dev.h>
+
+#include "cc770.h"
+
+#include <socketcan/can/version.h>	/* for RCSID. Removed by mkpatch script */
+#define DRV_NAME  "cc770"
+
+MODULE_AUTHOR("Wolfgang Grandegger <wg@grandegger.com>");
+MODULE_LICENSE("GPL v2");
+MODULE_DESCRIPTION(DRV_NAME "CAN netdevice driver");
+
+/*
+ * The CC770 is a CAN controller from Bosch, which is 100% compatible
+ * with the AN82527 from Intel, but with "bugs" being fixed and some
+ * additional functionality, mainly:
+ *
+ * 1. RX and TX error counters are readable.
+ * 2. Support of silent (listen-only) mode.
+ * 3. Message object 15 can receive all types of frames, also RTR and EFF.
+ *
+ * Details are available from Bosch's "CC770_Product_Info_2007-01.pdf",
+ * which explains in detail the compatibility between the CC770 and the
+ * 82527. This driver use the additional functionality 3. on real CC770
+ * devices. Unfortunately, the CC770 does still not store the message
+ * identifier of received remote transmission request frames and
+ * therefore it's set to 0.
+ *
+ * The message objects 1..14 can be used for TX and RX while the message
+ * objects 15 is optimized for RX. It has a shadow register for reliable
+ * data receiption under heavy bus load. Therefore it makes sense to use
+ * this message object for the needed use case. The frame type (EFF/SFF)
+ * for the message object 15 can be defined via kernel module parameter
+ * "msgobj15_eff". If not equal 0, it will receive 29-bit EFF frames,
+ * otherwise 11 bit SFF messages.
+ */
+static int msgobj15_eff;
+module_param(msgobj15_eff, int, S_IRUGO);
+MODULE_PARM_DESC(msgobj15_eff, "Extended 29-bit frames for message object 15 "
+		 "(default: 11-bit standard frames)");
+
+static int i82527_compat;
+module_param(i82527_compat, int, S_IRUGO);
+MODULE_PARM_DESC(i82527_compat, "Strict Intel 82527 comptibility mode "
+		 "without using additional functions");
+
+/*
+ * This driver uses the last 5 message objects 11..15. The definitions
+ * and structure below allows to configure and assign them to the real
+ * message object.
+ */
+static unsigned char cc770_obj_flags[CC770_OBJ_MAX] = {
+	[CC770_OBJ_RX0]     = CC770_OBJ_FLAG_RX,
+	[CC770_OBJ_RX1]     = CC770_OBJ_FLAG_RX | CC770_OBJ_FLAG_EFF,
+	[CC770_OBJ_RX_RTR0] = CC770_OBJ_FLAG_RX | CC770_OBJ_FLAG_RTR,
+	[CC770_OBJ_RX_RTR1] = CC770_OBJ_FLAG_RX | CC770_OBJ_FLAG_RTR |
+			      CC770_OBJ_FLAG_EFF,
+	[CC770_OBJ_TX]      = 0,
+};
+
+static struct can_bittiming_const cc770_bittiming_const = {
+	.name = DRV_NAME,
+	.tseg1_min = 1,
+	.tseg1_max = 16,
+	.tseg2_min = 1,
+	.tseg2_max = 8,
+	.sjw_max = 4,
+	.brp_min = 1,
+	.brp_max = 64,
+	.brp_inc = 1,
+};
+
+static inline int intid2obj(unsigned int intid)
+{
+	if (intid == 2)
+		return 0;
+	else
+		return MSGOBJ_LAST + 2 - intid;
+}
+
+static void enable_all_objs(const struct net_device *dev)
+{
+	struct cc770_priv *priv = netdev_priv(dev);
+	u8 msgcfg;
+	unsigned char obj_flags;
+	unsigned int o, mo;
+
+	for (o = 0; o <  CC770_OBJ_MAX; o++) {
+		obj_flags = priv->obj_flags[o];
+		mo = obj2msgobj(o);
+
+		if (obj_flags & CC770_OBJ_FLAG_RX) {
+			/*
+			 * We don't need extra objects for RTR and EFF if
+			 * the additional CC770 functions are enabled.
+			 */
+			if (priv->control_normal_mode & CTRL_EAF) {
+				if (o > 0)
+					continue;
+				dev_dbg(ND2D(dev), "Message object %d for "
+					"RX data, RTR, SFF and EFF\n", mo);
+			} else {
+				dev_dbg(ND2D(dev),
+					"Message object %d for RX %s %s\n", mo,
+					obj_flags & CC770_OBJ_FLAG_RTR ?
+					"RTR" : "data",
+					obj_flags & CC770_OBJ_FLAG_EFF ?
+					  "EFF" : "SFF");
+			}
+
+			if (obj_flags & CC770_OBJ_FLAG_EFF)
+				msgcfg = MSGCFG_XTD;
+			else
+				msgcfg = 0;
+			if (obj_flags & CC770_OBJ_FLAG_RTR)
+				msgcfg |= MSGCFG_DIR;
+
+			cc770_write_reg(priv, msgobj[mo].config, msgcfg);
+			cc770_write_reg(priv, msgobj[mo].ctrl0,
+					MSGVAL_SET | TXIE_RES |
+					RXIE_SET | INTPND_RES);
+
+			if (obj_flags & CC770_OBJ_FLAG_RTR)
+				cc770_write_reg(priv, msgobj[mo].ctrl1,
+						NEWDAT_RES | CPUUPD_SET |
+						TXRQST_RES | RMTPND_RES);
+			else
+				cc770_write_reg(priv, msgobj[mo].ctrl1,
+						NEWDAT_RES | MSGLST_RES |
+						TXRQST_RES | RMTPND_RES);
+		} else {
+			dev_dbg(ND2D(dev), "Message object %d for "
+				"TX data, RTR, SFF and EFF\n", mo);
+
+			cc770_write_reg(priv, msgobj[mo].ctrl1,
+					RMTPND_RES | TXRQST_RES |
+					CPUUPD_RES | NEWDAT_RES);
+			cc770_write_reg(priv, msgobj[mo].ctrl0,
+					MSGVAL_RES | TXIE_RES |
+					RXIE_RES | INTPND_RES);
+		}
+	}
+}
+
+static void disable_all_objs(const struct cc770_priv *priv)
+{
+	int o, mo;
+
+	for (o = 0; o <  CC770_OBJ_MAX; o++) {
+		mo = obj2msgobj(o);
+
+		if (priv->obj_flags[o] & CC770_OBJ_FLAG_RX) {
+			if (o > 0 &&
+			    priv->control_normal_mode & CTRL_EAF)
+				continue;
+
+			cc770_write_reg(priv, msgobj[mo].ctrl1,
+					NEWDAT_RES | MSGLST_RES |
+					TXRQST_RES | RMTPND_RES);
+			cc770_write_reg(priv, msgobj[mo].ctrl0,
+					MSGVAL_RES | TXIE_RES |
+					RXIE_RES | INTPND_RES);
+		} else {
+			/* Clear message object for send */
+			cc770_write_reg(priv, msgobj[mo].ctrl1,
+					RMTPND_RES | TXRQST_RES |
+					CPUUPD_RES | NEWDAT_RES);
+			cc770_write_reg(priv, msgobj[mo].ctrl0,
+					MSGVAL_RES | TXIE_RES |
+					RXIE_RES | INTPND_RES);
+		}
+	}
+}
+
+static void set_reset_mode(struct net_device *dev)
+{
+	struct cc770_priv *priv = netdev_priv(dev);
+
+	/* Enable configuration and puts chip in bus-off, disable interrupts */
+	cc770_write_reg(priv, control, CTRL_CCE | CTRL_INI);
+
+	priv->can.state = CAN_STATE_STOPPED;
+
+	/* Clear interrupts */
+	cc770_read_reg(priv, interrupt);
+
+	/* Clear status register */
+	cc770_write_reg(priv, status, 0);
+
+	/* Disable all used message objects */
+	disable_all_objs(priv);
+}
+
+static void set_normal_mode(struct net_device *dev)
+{
+	struct cc770_priv *priv = netdev_priv(dev);
+
+	/* Clear interrupts */
+	cc770_read_reg(priv, interrupt);
+
+	/* Clear status register and pre-set last error code */
+	cc770_write_reg(priv, status, STAT_LEC_MASK);
+
+	/* Enable all used message objects*/
+	enable_all_objs(dev);
+
+	/*
+	 * Clear bus-off, interrupts only for errors,
+	 * not for status change
+	 */
+	cc770_write_reg(priv, control, priv->control_normal_mode);
+
+	priv->can.state = CAN_STATE_ERROR_ACTIVE;
+}
+
+static void chipset_init(struct cc770_priv *priv)
+{
+	int mo, id, data;
+
+	/* Enable configuration and put chip in bus-off, disable interrupts */
+	cc770_write_reg(priv, control, (CTRL_CCE | CTRL_INI));
+
+	/* Set CLKOUT divider and slew rates */
+	cc770_write_reg(priv, clkout, priv->clkout);
+
+	/* Configure CPU interface / CLKOUT enable */
+	cc770_write_reg(priv, cpu_interface, priv->cpu_interface | CPUIF_CEN);
+
+	/* Set bus configuration  */
+	cc770_write_reg(priv, bus_config, priv->bus_config);
+
+	/* Clear interrupts */
+	cc770_read_reg(priv, interrupt);
+
+	/* Clear status register */
+	cc770_write_reg(priv, status, 0);
+
+	/* Clear and invalidate message objects */
+	for (mo = MSGOBJ_FIRST; mo <= MSGOBJ_LAST; mo++) {
+		cc770_write_reg(priv, msgobj[mo].ctrl0,
+				INTPND_UNC | RXIE_RES |
+				TXIE_RES | MSGVAL_RES);
+		cc770_write_reg(priv, msgobj[mo].ctrl0,
+				INTPND_RES | RXIE_RES |
+				TXIE_RES | MSGVAL_RES);
+		cc770_write_reg(priv, msgobj[mo].ctrl1,
+				NEWDAT_RES | MSGLST_RES |
+				TXRQST_RES | RMTPND_RES);
+		for (data = 0; data < 8; data++)
+			cc770_write_reg(priv, msgobj[mo].data[data], 0);
+		for (id = 0; id < 4; id++)
+			cc770_write_reg(priv, msgobj[mo].id[id], 0);
+		cc770_write_reg(priv, msgobj[mo].config, 0);
+	}
+
+	/* Set all global ID masks to "don't care" */
+	cc770_write_reg(priv, global_mask_std[0], 0);
+	cc770_write_reg(priv, global_mask_std[1], 0);
+	cc770_write_reg(priv, global_mask_ext[0], 0);
+	cc770_write_reg(priv, global_mask_ext[1], 0);
+	cc770_write_reg(priv, global_mask_ext[2], 0);
+	cc770_write_reg(priv, global_mask_ext[3], 0);
+
+}
+
+static int cc770_probe_chip(struct net_device *dev)
+{
+	struct cc770_priv *priv = netdev_priv(dev);
+
+	/* Enable configuration, put chip in bus-off, disable ints */
+	cc770_write_reg(priv, control, CTRL_CCE | CTRL_EAF | CTRL_INI);
+	/* Configure cpu interface / CLKOUT disable */
+	cc770_write_reg(priv, cpu_interface, priv->cpu_interface);
+
+	/*
+	 * Check if hardware reset is still inactive or maybe there
+	 * is no chip in this address space
+	 */
+	if (cc770_read_reg(priv, cpu_interface) & CPUIF_RST) {
+		dev_info(ND2D(dev), "probing @0x%p failed (reset)\n",
+			 priv->reg_base);
+		return 0;
+	}
+
+	/* Write and read back test pattern */
+	cc770_write_reg(priv, msgobj[1].data[1], 0x25);
+	cc770_write_reg(priv, msgobj[2].data[3], 0x52);
+	cc770_write_reg(priv, msgobj[10].data[6], 0xc3);
+	if ((cc770_read_reg(priv, msgobj[1].data[1]) != 0x25) ||
+	    (cc770_read_reg(priv, msgobj[2].data[3]) != 0x52) ||
+	    (cc770_read_reg(priv, msgobj[10].data[6]) != 0xc3)) {
+		dev_info(ND2D(dev), "probing @0x%p failed (pattern)\n",
+			 priv->reg_base);
+		return 0;
+	}
+
+	/* Check if this chip is a CC770 supporting additional functions */
+	if (cc770_read_reg(priv, control) & CTRL_EAF)
+		priv->control_normal_mode |= CTRL_EAF;
+
+	return 1;
+}
+
+static void cc770_start(struct net_device *dev)
+{
+	struct cc770_priv *priv = netdev_priv(dev);
+
+	/* leave reset mode */
+	if (priv->can.state != CAN_STATE_STOPPED)
+		set_reset_mode(dev);
+
+	/* leave reset mode */
+	set_normal_mode(dev);
+}
+
+static int cc770_set_mode(struct net_device *dev, enum can_mode mode)
+{
+	struct cc770_priv *priv = netdev_priv(dev);
+
+	if (!priv->open_time)
+		return -EINVAL;
+
+	switch (mode) {
+	case CAN_MODE_START:
+		cc770_start(dev);
+		if (netif_queue_stopped(dev))
+			netif_wake_queue(dev);
+		break;
+
+	default:
+		return -EOPNOTSUPP;
+	}
+
+	return 0;
+}
+
+static int cc770_set_bittiming(struct net_device *dev)
+{
+	struct cc770_priv *priv = netdev_priv(dev);
+	struct can_bittiming *bt = &priv->can.bittiming;
+	u8 btr0, btr1;
+
+	btr0 = ((bt->brp - 1) & 0x3f) | (((bt->sjw - 1) & 0x3) << 6);
+	btr1 = ((bt->prop_seg + bt->phase_seg1 - 1) & 0xf) |
+		(((bt->phase_seg2 - 1) & 0x7) << 4);
+	if (priv->can.ctrlmode & CAN_CTRLMODE_3_SAMPLES)
+		btr1 |= 0x80;
+
+	dev_info(ND2D(dev),
+		 "setting BTR0=0x%02x BTR1=0x%02x\n", btr0, btr1);
+
+	cc770_write_reg(priv, bit_timing_0, btr0);
+	cc770_write_reg(priv, bit_timing_1, btr1);
+
+	return 0;
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,32)
+static int cc770_start_xmit(struct sk_buff *skb, struct net_device *dev)
+#else
+static netdev_tx_t cc770_start_xmit(struct sk_buff *skb, struct net_device *dev)
+#endif
+{
+	struct cc770_priv *priv = netdev_priv(dev);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,23)
+	struct net_device_stats *stats = can_get_stats(dev);
+#else
+	struct net_device_stats *stats = &dev->stats;
+#endif
+	struct can_frame *cf = (struct can_frame *)skb->data;
+	unsigned int mo = obj2msgobj(CC770_OBJ_TX);
+	u8 dlc, rtr;
+	u32 id;
+	int i;
+
+	if (can_dropped_invalid_skb(dev, skb))
+		return NETDEV_TX_OK;
+
+	if ((cc770_read_reg(priv,
+			    msgobj[mo].ctrl1) & TXRQST_UNC) == TXRQST_SET) {
+		dev_err(ND2D(dev), "TX register is still occupied!\n");
+		return NETDEV_TX_BUSY;
+	}
+
+	netif_stop_queue(dev);
+
+	dlc = cf->can_dlc;
+	id = cf->can_id;
+	if (cf->can_id & CAN_RTR_FLAG)
+		rtr = 0;
+	else
+		rtr = MSGCFG_DIR;
+	cc770_write_reg(priv, msgobj[mo].ctrl1,
+			RMTPND_RES | TXRQST_RES | CPUUPD_SET | NEWDAT_RES);
+	cc770_write_reg(priv, msgobj[mo].ctrl0,
+			MSGVAL_SET | TXIE_SET | RXIE_RES | INTPND_RES);
+	if (id & CAN_EFF_FLAG) {
+		id &= CAN_EFF_MASK;
+		cc770_write_reg(priv, msgobj[mo].config,
+				(dlc << 4) + rtr + MSGCFG_XTD);
+		cc770_write_reg(priv, msgobj[mo].id[3],
+				(id << 3) & 0xFFU);
+		cc770_write_reg(priv, msgobj[mo].id[2],
+				(id >> 5) & 0xFFU);
+		cc770_write_reg(priv, msgobj[mo].id[1],
+				(id >> 13) & 0xFFU);
+		cc770_write_reg(priv, msgobj[mo].id[0],
+				(id >> 21) & 0xFFU);
+	} else {
+		id &= CAN_SFF_MASK;
+		cc770_write_reg(priv, msgobj[mo].config,
+				(dlc << 4) + rtr);
+		cc770_write_reg(priv, msgobj[mo].id[0],
+				(id >> 3) & 0xFFU);
+		cc770_write_reg(priv, msgobj[mo].id[1],
+				(id << 5) & 0xFFU);
+	}
+
+	dlc &= 0x0f;		/* restore length only */
+	for (i = 0; i < dlc; i++)
+		cc770_write_reg(priv, msgobj[mo].data[i], cf->data[i]);
+
+	cc770_write_reg(priv, msgobj[mo].ctrl1,
+			RMTPND_RES | TXRQST_SET | CPUUPD_RES | NEWDAT_UNC);
+
+	stats->tx_bytes += dlc;
+	dev->trans_start = jiffies;
+
+	can_put_echo_skb(skb, dev, 0);
+
+	/*
+	 * HM: We had some cases of repeated IRQs so make sure the
+	 * INT is acknowledged I know it's already further up, but
+	 * doing again fixed the issue
+	 */
+	cc770_write_reg(priv, msgobj[mo].ctrl0,
+			MSGVAL_UNC | TXIE_UNC | RXIE_UNC | INTPND_RES);
+
+	return NETDEV_TX_OK;
+}
+
+static void cc770_rx(struct net_device *dev, unsigned int mo, u8 ctrl1)
+{
+	struct cc770_priv *priv = netdev_priv(dev);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,23)
+	struct net_device_stats *stats = can_get_stats(dev);
+#else
+	struct net_device_stats *stats = &dev->stats;
+#endif
+	struct can_frame *cf;
+	struct sk_buff *skb;
+	u8 config;
+	u32 id;
+	int i;
+
+	skb = alloc_can_skb(dev, &cf);
+	if (skb == NULL)
+		return;
+
+	config = cc770_read_reg(priv, msgobj[mo].config);
+
+	if (ctrl1 & RMTPND_SET) {
+		/*
+		 * Unfortunately, the chip does not store the real message
+		 * identifier of the received remote transmission request
+		 * frame. Therefore we set it to 0.
+		 */
+		cf->can_id = CAN_RTR_FLAG;
+		if (config & MSGCFG_XTD)
+			cf->can_id |= CAN_EFF_FLAG;
+		cf->can_dlc = 0;
+	} else {
+		if (config & MSGCFG_XTD) {
+			id = cc770_read_reg(priv, msgobj[mo].id[3]);
+			id |= cc770_read_reg(priv, msgobj[mo].id[2]) << 8;
+			id |= cc770_read_reg(priv, msgobj[mo].id[1]) << 16;
+			id |= cc770_read_reg(priv, msgobj[mo].id[0]) << 24;
+			id >>= 3;
+			id |= CAN_EFF_FLAG;
+		} else {
+			id = cc770_read_reg(priv, msgobj[mo].id[1]);
+			id |= cc770_read_reg(priv, msgobj[mo].id[0]) << 8;
+			id >>= 5;
+		}
+
+		cf->can_id = id;
+		cf->can_dlc = get_can_dlc((config & 0xf0) >> 4);
+		for (i = 0; i < cf->can_dlc; i++)
+			cf->data[i] = cc770_read_reg(priv, msgobj[mo].data[i]);
+	}
+	netif_rx(skb);
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,32)
+	dev->last_rx = jiffies;
+#endif
+	stats->rx_packets++;
+	stats->rx_bytes += cf->can_dlc;
+}
+
+static int cc770_err(struct net_device *dev, u8 status)
+{
+	struct cc770_priv *priv = netdev_priv(dev);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,23)
+	struct net_device_stats *stats = can_get_stats(dev);
+#else
+	struct net_device_stats *stats = &dev->stats;
+#endif
+	struct can_frame *cf;
+	struct sk_buff *skb;
+	u8 lec;
+
+	dev_dbg(ND2D(dev), "status interrupt (%#x)\n", status);
+
+	skb = alloc_can_err_skb(dev, &cf);
+	if (skb == NULL)
+		return -ENOMEM;
+
+	if (status & STAT_BOFF) {
+		/* Disable interrupts */
+		cc770_write_reg(priv, control, CTRL_INI);
+		cf->can_id |= CAN_ERR_BUSOFF;
+		priv->can.state = CAN_STATE_BUS_OFF;
+		can_bus_off(dev);
+	} else if (status & STAT_WARN) {
+		cf->can_id |= CAN_ERR_CRTL;
+		cf->data[1] = CAN_ERR_CRTL_RX_WARNING | CAN_ERR_CRTL_TX_WARNING;
+		priv->can.state = CAN_STATE_ERROR_WARNING;
+		priv->can.can_stats.error_warning++;
+	}
+
+	lec = status & STAT_LEC_MASK;
+	if (lec < 7 && lec > 0) {
+		if (lec == STAT_LEC_ACK) {
+			cf->can_id |= CAN_ERR_ACK;
+		} else {
+			cf->can_id |= CAN_ERR_PROT;
+			switch (lec) {
+			case STAT_LEC_STUFF:
+				cf->data[2] |= CAN_ERR_PROT_STUFF;
+				break;
+			case STAT_LEC_FORM:
+				cf->data[2] |= CAN_ERR_PROT_FORM;
+				break;
+			case STAT_LEC_BIT1:
+				cf->data[2] |= CAN_ERR_PROT_BIT1;
+				break;
+			case STAT_LEC_BIT0:
+				cf->data[2] |= CAN_ERR_PROT_BIT0;
+				break;
+			case STAT_LEC_CRC:
+				cf->data[3] |= CAN_ERR_PROT_LOC_CRC_SEQ;
+				break;
+			}
+		}
+	}
+
+	netif_rx(skb);
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,32)
+	dev->last_rx = jiffies;
+#endif
+	stats->rx_packets++;
+	stats->rx_bytes += cf->can_dlc;
+
+	return 0;
+}
+
+static int cc770_status_interrupt(struct net_device *dev)
+{
+	struct cc770_priv *priv = netdev_priv(dev);
+	u8 status;
+
+	status = cc770_read_reg(priv, status);
+	/* Reset the status register including RXOK and TXOK */
+	cc770_write_reg(priv, status, STAT_LEC_MASK);
+
+	if (status & (STAT_WARN | STAT_BOFF) ||
+	    (status & STAT_LEC_MASK) != STAT_LEC_MASK) {
+		cc770_err(dev, status);
+		return status & STAT_BOFF;
+	}
+
+	return 0;
+}
+
+static void cc770_rx_interrupt(struct net_device *dev, unsigned int o)
+{
+	struct cc770_priv *priv = netdev_priv(dev);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,23)
+	struct net_device_stats *stats = can_get_stats(dev);
+#else
+	struct net_device_stats *stats = &dev->stats;
+#endif
+	unsigned int mo = obj2msgobj(o);
+	u8 ctrl1;
+
+	while (1) {
+		ctrl1 = cc770_read_reg(priv, msgobj[mo].ctrl1);
+
+		if (!(ctrl1 & NEWDAT_SET))  {
+			/* Check for RTR if additional functions are enabled */
+			if (priv->control_normal_mode & CTRL_EAF) {
+				if (!(cc770_read_reg(priv, msgobj[mo].ctrl0) &
+				      INTPND_SET))
+					break;
+			} else {
+				break;
+			}
+		}
+
+		if (ctrl1 & MSGLST_SET) {
+			stats->rx_over_errors++;
+			stats->rx_errors++;
+		}
+		if (mo < MSGOBJ_LAST)
+			cc770_write_reg(priv, msgobj[mo].ctrl1,
+					NEWDAT_RES | MSGLST_RES |
+					TXRQST_UNC | RMTPND_UNC);
+		cc770_rx(dev, mo, ctrl1);
+
+		cc770_write_reg(priv, msgobj[mo].ctrl0,
+				MSGVAL_SET | TXIE_RES |
+				RXIE_SET | INTPND_RES);
+		cc770_write_reg(priv, msgobj[mo].ctrl1,
+				NEWDAT_RES | MSGLST_RES |
+				TXRQST_RES | RMTPND_RES);
+	}
+}
+
+static void cc770_rtr_interrupt(struct net_device *dev, unsigned int o)
+{
+	struct cc770_priv *priv = netdev_priv(dev);
+	unsigned int mo = obj2msgobj(o);
+	u8 ctrl0, ctrl1;
+
+	while (1) {
+		ctrl0 = cc770_read_reg(priv, msgobj[mo].ctrl0);
+		if (!(ctrl0 & INTPND_SET))
+			break;
+
+		ctrl1 = cc770_read_reg(priv, msgobj[mo].ctrl1);
+		cc770_rx(dev, mo, ctrl1);
+
+		cc770_write_reg(priv, msgobj[mo].ctrl0,
+				MSGVAL_SET | TXIE_RES |
+				RXIE_SET | INTPND_RES);
+		cc770_write_reg(priv, msgobj[mo].ctrl1,
+				NEWDAT_RES | CPUUPD_SET |
+				TXRQST_RES | RMTPND_RES);
+	}
+}
+
+static void cc770_tx_interrupt(struct net_device *dev, unsigned int o)
+{
+	struct cc770_priv *priv = netdev_priv(dev);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,23)
+	struct net_device_stats *stats = can_get_stats(dev);
+#else
+	struct net_device_stats *stats = &dev->stats;
+#endif
+	unsigned int mo = obj2msgobj(o);
+
+	/* Nothing more to send, switch off interrupts */
+	cc770_write_reg(priv, msgobj[mo].ctrl0,
+			MSGVAL_RES | TXIE_RES | RXIE_RES | INTPND_RES);
+	/*
+	 * We had some cases of repeated IRQ so make sure the
+	 * INT is acknowledged
+	 */
+	cc770_write_reg(priv, msgobj[mo].ctrl0,
+			MSGVAL_UNC | TXIE_UNC | RXIE_UNC | INTPND_RES);
+
+	stats->tx_packets++;
+	can_get_echo_skb(dev, 0);
+	netif_wake_queue(dev);
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,19)
+irqreturn_t cc770_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+#else
+irqreturn_t cc770_interrupt(int irq, void *dev_id)
+#endif
+{
+	struct net_device *dev = (struct net_device *)dev_id;
+	struct cc770_priv *priv = netdev_priv(dev);
+	u8 intid;
+	int o, n = 0;
+
+	/* Shared interrupts and IRQ off? */
+	if (priv->can.state == CAN_STATE_STOPPED)
+		return IRQ_NONE;
+
+	if (priv->pre_irq)
+		priv->pre_irq(priv);
+
+	while (n < CC770_MAX_IRQ) {
+		/* Read the highest pending interrupt request */
+		intid = cc770_read_reg(priv, interrupt);
+		if (!intid)
+			break;
+		n++;
+
+		if (intid == 1) {
+			/* Exit in case of bus-off */
+			if (cc770_status_interrupt(dev))
+				break;
+		} else {
+			o = intid2obj(intid);
+
+			if (o >= CC770_OBJ_MAX) {
+				dev_err(ND2D(dev),
+					"Unexpected interrupt id %d\n", intid);
+				continue;
+			}
+
+			if (priv->obj_flags[o] & CC770_OBJ_FLAG_RTR)
+				cc770_rtr_interrupt(dev, o);
+			else if (priv->obj_flags[o] & CC770_OBJ_FLAG_RX)
+				cc770_rx_interrupt(dev, o);
+			else
+				cc770_tx_interrupt(dev, o);
+		}
+	}
+
+	if (priv->post_irq)
+		priv->post_irq(priv);
+
+	if (n >= CC770_MAX_IRQ)
+		dev_dbg(ND2D(dev), "%d messages handled in ISR", n);
+
+	return (n) ? IRQ_HANDLED : IRQ_NONE;
+}
+
+static int cc770_open(struct net_device *dev)
+{
+	struct cc770_priv *priv = netdev_priv(dev);
+	int err;
+
+	/* set chip into reset mode */
+	set_reset_mode(dev);
+
+	/* common open */
+	err = open_candev(dev);
+	if (err)
+		return err;
+
+	err = request_irq(dev->irq, &cc770_interrupt, priv->irq_flags,
+			  dev->name, (void *)dev);
+	if (err) {
+		close_candev(dev);
+		return -EAGAIN;
+	}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,23)
+	/* clear statistics */
+	memset(&priv->can.net_stats, 0, sizeof(priv->can.net_stats));
+#endif
+
+	/* init and start chip */
+	cc770_start(dev);
+	priv->open_time = jiffies;
+
+	netif_start_queue(dev);
+
+	return 0;
+}
+
+static int cc770_close(struct net_device *dev)
+{
+	struct cc770_priv *priv = netdev_priv(dev);
+
+	netif_stop_queue(dev);
+	set_reset_mode(dev);
+
+	free_irq(dev->irq, (void *)dev);
+	close_candev(dev);
+
+	priv->open_time = 0;
+
+	return 0;
+}
+
+struct net_device *alloc_cc770dev(int sizeof_priv)
+{
+	struct net_device *dev;
+	struct cc770_priv *priv;
+
+	dev = alloc_candev(sizeof(struct cc770_priv) + sizeof_priv,
+			   CC770_ECHO_SKB_MAX);
+	if (!dev)
+		return NULL;
+
+	priv = netdev_priv(dev);
+
+	priv->dev = dev;
+	priv->can.bittiming_const = &cc770_bittiming_const;
+	priv->can.do_set_bittiming = cc770_set_bittiming;
+	priv->can.do_set_mode = cc770_set_mode;
+	priv->can.ctrlmode_supported = CAN_CTRLMODE_3_SAMPLES;
+
+	memcpy(priv->obj_flags, cc770_obj_flags, sizeof(cc770_obj_flags));
+
+	if (sizeof_priv)
+		priv->priv = (void *)priv + sizeof(struct cc770_priv);
+
+	return dev;
+}
+EXPORT_SYMBOL_GPL(alloc_cc770dev);
+
+void free_cc770dev(struct net_device *dev)
+{
+	free_candev(dev);
+}
+EXPORT_SYMBOL_GPL(free_cc770dev);
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,28)
+static const struct net_device_ops cc770_netdev_ops = {
+	.ndo_open               = cc770_open,
+	.ndo_stop               = cc770_close,
+	.ndo_start_xmit         = cc770_start_xmit,
+};
+#endif
+
+int register_cc770dev(struct net_device *dev)
+{
+	struct cc770_priv *priv = netdev_priv(dev);
+
+	if (!cc770_probe_chip(dev))
+		return -ENODEV;
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,28)
+	dev->netdev_ops = &cc770_netdev_ops;
+#else
+	dev->open = cc770_open;
+	dev->stop = cc770_close;
+	dev->hard_start_xmit = cc770_start_xmit;
+#endif
+
+	dev->flags |= IFF_ECHO;	/* we support local echo */
+
+	/* Should we use additional functions? */
+	if (!i82527_compat && priv->control_normal_mode & CTRL_EAF) {
+		priv->control_normal_mode = CTRL_IE | CTRL_EAF | CTRL_EIE;
+		dev_dbg(ND2D(dev), "i82527 mode with additional functions\n");
+	} else {
+		priv->control_normal_mode = CTRL_IE | CTRL_EIE;
+		dev_dbg(ND2D(dev), "strict i82527 compatibility mode\n");
+	}
+
+	chipset_init(priv);
+	set_reset_mode(dev);
+
+	return register_candev(dev);
+}
+EXPORT_SYMBOL_GPL(register_cc770dev);
+
+void unregister_cc770dev(struct net_device *dev)
+{
+	set_reset_mode(dev);
+	unregister_candev(dev);
+}
+EXPORT_SYMBOL_GPL(unregister_cc770dev);
+
+static __init int cc770_init(void)
+{
+	if (msgobj15_eff) {
+		cc770_obj_flags[CC770_OBJ_RX0] |= CC770_OBJ_FLAG_EFF;
+		cc770_obj_flags[CC770_OBJ_RX1] &= ~CC770_OBJ_FLAG_EFF;
+	}
+
+	printk(KERN_INFO "%s CAN netdevice driver\n", DRV_NAME);
+
+	return 0;
+}
+
+module_init(cc770_init);
+
+static __exit void cc770_exit(void)
+{
+	printk(KERN_INFO "%s: driver removed\n", DRV_NAME);
+}
+module_exit(cc770_exit);
diff --exclude CVS --exclude .git -uNr linux-2.6.27.8/drivers/net/can/cc770/cc770.h linux-2.6.27.8.modified/drivers/net/can/cc770/cc770.h
--- linux-2.6.27.8/drivers/net/can/cc770/cc770.h	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.27.8.modified/drivers/net/can/cc770/cc770.h	2013-05-30 03:44:17.000000000 -0400
@@ -0,0 +1,249 @@
+/*
+ * $Id:  $
+ *
+ * cc770.h - Bosch CC770 and Intel AN82527 network device driver
+ *
+ * Copyright (C) 2009 Wolfgang Grandegger <wg@grandegger.com>
+ *
+ * Derived from the old Socket-CAN i82527 driver:
+ *
+ * Copyright (c) 2002-2007 Volkswagen Group Electronic Research
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of Volkswagen nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * Alternatively, provided that this notice is retained in full, this
+ * software may be distributed under the terms of the GNU General
+ * Public License ("GPL") version 2, in which case the provisions of the
+ * GPL apply INSTEAD OF those given above.
+ *
+ * The provided data structures and external interfaces from this code
+ * are not restricted to be used by modules with a GPL compatible license.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * Send feedback to <socketcan-users@lists.berlios.de>
+ */
+
+#ifndef CC770_DEV_H
+#define CC770_DEV_H
+
+#include <socketcan/can/dev.h>
+
+struct cc770_msgobj {
+	u8 ctrl0;
+	u8 ctrl1;
+	u8 id[4];
+	u8 config;
+	u8 data[8];
+	u8 dontuse;		/* padding */
+} __attribute__ ((packed));
+
+struct cc770_regs {
+	union {
+		struct cc770_msgobj msgobj[16]; /* Message object 1..15 */
+		struct {
+			u8 control;		/* Control Register */
+			u8 status;		/* Status Register */
+			u8 cpu_interface;	/* CPU Interface Register */
+			u8 dontuse1;
+			u8 high_speed_read[2];	/* High Speed Read */
+			u8 global_mask_std[2];	/* Standard Global Mask */
+			u8 global_mask_ext[4];	/* Extended Global Mask */
+			u8 msg15_mask[4];	/* Message 15 Mask */
+			u8 dontuse2[15];
+			u8 clkout;		/* Clock Out Register */
+			u8 dontuse3[15];
+			u8 bus_config;		/* Bus Configuration Register */
+			u8 dontuse4[15];
+			u8 bit_timing_0;	/* Bit Timing Register byte 0 */
+			u8 dontuse5[15];
+			u8 bit_timing_1;	/* Bit Timing Register byte 1 */
+			u8 dontuse6[15];
+			u8 interrupt;		/* Interrupt Register */
+			u8 dontuse7[15];
+			u8 rx_error_counter;	/* Receive Error Counter */
+			u8 dontuse8[15];
+			u8 tx_error_counter;	/* Transmit Error Counter */
+			u8 dontuse9[31];
+			u8 p1_conf;
+			u8 dontuse10[15];
+			u8 p2_conf;
+			u8 dontuse11[15];
+			u8 p1_in;
+			u8 dontuse12[15];
+			u8 p2_in;
+			u8 dontuse13[15];
+			u8 p1_out;
+			u8 dontuse14[15];
+			u8 p2_out;
+			u8 dontuse15[15];
+			u8 serial_reset_addr;
+		};
+	};
+} __attribute__ ((packed));
+
+/* Control Register (0x00) */
+#define CTRL_INI	0x01	/* Initialization */
+#define CTRL_IE		0x02	/* Interrupt Enable */
+#define CTRL_SIE	0x04	/* Status Interrupt Enable */
+#define CTRL_EIE	0x08	/* Error Interrupt Enable */
+#define CTRL_EAF	0x20	/* Enable additional functions */
+#define CTRL_CCE	0x40	/* Change Configuration Enable */
+
+/* Status Register (0x01) */
+#define STAT_LEC_STUFF	0x01	/* Stuff error */
+#define STAT_LEC_FORM	0x02	/* Form error */
+#define STAT_LEC_ACK	0x03	/* Acknowledgement error */
+#define STAT_LEC_BIT1	0x04	/* Bit1 error */
+#define STAT_LEC_BIT0	0x05	/* Bit0 error */
+#define STAT_LEC_CRC	0x06	/* CRC error */
+#define STAT_LEC_MASK	0x07	/* Last Error Code mask */
+#define STAT_TXOK	0x08	/* Transmit Message Successfully */
+#define STAT_RXOK	0x10	/* Receive Message Successfully */
+#define STAT_WAKE	0x20	/* Wake Up Status */
+#define STAT_WARN	0x40	/* Warning Status */
+#define STAT_BOFF	0x80	/* Bus Off Status */
+
+/* CPU Interface Register (0x02) */
+#define CPUIF_CEN	0x01	/* Clock Out Enable */
+#define CPUIF_MUX	0x04	/* Multiplex */
+#define CPUIF_SLP	0x08	/* Sleep */
+#define CPUIF_PWD	0x10	/* Power Down Mode */
+#define CPUIF_DMC	0x20	/* Divide Memory Clock */
+#define CPUIF_DSC	0x40	/* Divide System Clock */
+#define CPUIF_RST	0x80	/* Hardware Reset Status */
+
+/* Clock Out Register (0x1f) */
+#define CLKOUT_CD_MASK  0x0f	/* Clock Divider mask */
+#define CLKOUT_SL_MASK	0x30	/* Slew Rate mask */
+#define CLKOUT_SL_SHIFT	4
+
+/* Bus Configuration Register (0x2f) */
+#define BUSCFG_DR0	0x01	/* Disconnect RX0 Input / Select RX input */
+#define BUSCFG_DR1	0x02	/* Disconnect RX1 Input / Silent mode */
+#define BUSCFG_DT1	0x08	/* Disconnect TX1 Output */
+#define BUSCFG_POL	0x20	/* Polarity dominant or recessive */
+#define BUSCFG_CBY	0x40	/* Input Comparator Bypass */
+
+/* Message Control Register 0 (Base Address + 0x0) */
+#define INTPND_RES	0x01	/* No Interrupt pending */
+#define INTPND_SET	0x02	/* Interrupt pending */
+#define INTPND_UNC	0x03
+#define RXIE_RES	0x04	/* Receive Interrupt Disable */
+#define RXIE_SET	0x08	/* Receive Interrupt Enable */
+#define RXIE_UNC	0x0c
+#define TXIE_RES	0x10	/* Transmit Interrupt Disable */
+#define TXIE_SET	0x20	/* Transmit Interrupt Enable */
+#define TXIE_UNC	0x30
+#define MSGVAL_RES	0x40	/* Message Invalid */
+#define MSGVAL_SET	0x80	/* Message Valid */
+#define MSGVAL_UNC	0xc0
+
+/* Message Control Register 1 (Base Address + 0x01) */
+#define NEWDAT_RES	0x01	/* No New Data */
+#define NEWDAT_SET	0x02	/* New Data */
+#define NEWDAT_UNC	0x03
+#define MSGLST_RES	0x04	/* No Message Lost */
+#define MSGLST_SET	0x08	/* Message Lost */
+#define MSGLST_UNC	0x0c
+#define CPUUPD_RES	0x04	/* No CPU Updating */
+#define CPUUPD_SET	0x08	/* CPU Updating */
+#define CPUUPD_UNC	0x0c
+#define TXRQST_RES	0x10	/* No Transmission Request */
+#define TXRQST_SET	0x20	/* Transmission Request */
+#define TXRQST_UNC	0x30
+#define RMTPND_RES	0x40	/* No Remote Request Pending */
+#define RMTPND_SET	0x80	/* Remote Request Pending */
+#define RMTPND_UNC	0xc0
+
+/* Message Configuration Register (Base Address + 0x06) */
+#define MSGCFG_XTD	0x04	/* Extended Identifier */
+#define MSGCFG_DIR	0x08	/* Direction is Transmit */
+
+#define MSGOBJ_FIRST	1
+#define MSGOBJ_LAST	15
+
+#define CC770_IO_SIZE	0x100
+#define CC770_MAX_IRQ	20	/* max. number of interrupts handled in ISR */
+
+#define CC770_ECHO_SKB_MAX	1
+
+#define cc770_read_reg(priv, member)					\
+	priv->read_reg(priv, offsetof(struct cc770_regs, member))
+
+#define cc770_write_reg(priv, member, value)				\
+	priv->write_reg(priv, offsetof(struct cc770_regs, member), value)
+
+/*
+ * Message objects and flags used by this driver
+ */
+#define CC770_OBJ_FLAG_RX 	0x01
+#define CC770_OBJ_FLAG_RTR	0x02
+#define CC770_OBJ_FLAG_EFF	0x04
+
+enum {
+	CC770_OBJ_RX0 = 0,	/* for receiving normal messages */
+	CC770_OBJ_RX1,		/* for receiving normal messages */
+	CC770_OBJ_RX_RTR0,	/* for receiving remote transmission requests */
+	CC770_OBJ_RX_RTR1,	/* for receiving remote transmission requests */
+	CC770_OBJ_TX,		/* for sending messages */
+	CC770_OBJ_MAX
+};
+
+#define obj2msgobj(o)	(MSGOBJ_LAST - (o)) /* message object 11..15 */
+
+/*
+ * CC770 private data structure
+ */
+struct cc770_priv {
+	struct can_priv can;	/* must be the first member */
+	int open_time;
+	struct sk_buff *echo_skb;
+
+	/* the lower-layer is responsible for appropriate locking */
+	u8 (*read_reg)(const struct cc770_priv *priv, int reg);
+	void (*write_reg)(const struct cc770_priv *priv, int reg, u8 val);
+	void (*pre_irq)(const struct cc770_priv *priv);
+	void (*post_irq)(const struct cc770_priv *priv);
+
+	void *priv;		/* for board-specific data */
+	struct net_device *dev;
+
+	void __iomem *reg_base;	/* ioremap'ed address to registers */
+	unsigned long irq_flags;	/* for request_irq() */
+
+	unsigned char obj_flags[CC770_OBJ_MAX];
+	u8 control_normal_mode;	/* Control register for normal mode */
+	u8 cpu_interface;	/* CPU interface register */
+	u8 clkout;		/* Clock out register */
+	u8 bus_config;		/* Bus conffiguration register */
+};
+
+struct net_device *alloc_cc770dev(int sizeof_priv);
+void free_cc770dev(struct net_device *dev);
+int register_cc770dev(struct net_device *dev);
+void unregister_cc770dev(struct net_device *dev);
+
+#endif /* CC770_DEV_H */
diff --exclude CVS --exclude .git -uNr linux-2.6.27.8/drivers/net/can/cc770/cc770_isa.c linux-2.6.27.8.modified/drivers/net/can/cc770/cc770_isa.c
--- linux-2.6.27.8/drivers/net/can/cc770/cc770_isa.c	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.27.8.modified/drivers/net/can/cc770/cc770_isa.c	2013-05-30 03:44:17.000000000 -0400
@@ -0,0 +1,315 @@
+/*
+ * Copyright (C) 2009 Wolfgang Grandegger <wg@grandegger.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the version 2 of the GNU General Public License
+ * as published by the Free Software Foundation
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/kernel.h>
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/isa.h>
+#include <linux/interrupt.h>
+#include <linux/netdevice.h>
+#include <linux/delay.h>
+#include <linux/irq.h>
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,16)
+#include <linux/io.h>
+#else
+#include <asm/io.h>
+#endif
+#include <socketcan/can.h>
+#include <socketcan/can/dev.h>
+
+#include "cc770.h"
+
+#define DRV_NAME "cc770_isa"
+
+#define MAXDEV 8
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,16)
+#error This driver does not support Kernel versions < 2.6.16
+#endif
+
+MODULE_AUTHOR("Wolfgang Grandegger <wg@grandegger.com>");
+MODULE_DESCRIPTION("Socket-CAN driver for CC770 on the ISA bus");
+MODULE_LICENSE("GPL v2");
+
+#define CLK_DEFAULT	16000000	/* 16 MHz */
+#define BCR_DEFAULT	0x00
+#define COR_DEFAULT	0x00
+
+static unsigned long port[MAXDEV];
+static unsigned long mem[MAXDEV];
+static int __devinitdata irq[MAXDEV];
+static int __devinitdata clk[MAXDEV];
+static char __devinitdata cir[MAXDEV] = {[0 ... (MAXDEV - 1)] = -1};
+static char __devinitdata bcr[MAXDEV] = {[0 ... (MAXDEV - 1)] = -1};
+static char __devinitdata cor[MAXDEV] = {[0 ... (MAXDEV - 1)] = -1};
+static char __devinitdata indirect[MAXDEV] = {[0 ... (MAXDEV - 1)] = -1};
+
+module_param_array(port, ulong, NULL, S_IRUGO);
+MODULE_PARM_DESC(port, "I/O port number");
+
+module_param_array(mem, ulong, NULL, S_IRUGO);
+MODULE_PARM_DESC(mem, "I/O memory address");
+
+module_param_array(indirect, byte, NULL, S_IRUGO);
+MODULE_PARM_DESC(indirect, "Indirect access via address and data port");
+
+module_param_array(irq, int, NULL, S_IRUGO);
+MODULE_PARM_DESC(irq, "IRQ number");
+
+module_param_array(clk, int, NULL, S_IRUGO);
+MODULE_PARM_DESC(clk, "External oscillator clock frequency "
+		 "(default=16000000 [16 MHz])");
+
+module_param_array(cir, byte, NULL, S_IRUGO);
+MODULE_PARM_DESC(cdr, "CPU interface register (default=0x40 [CPU_DSC])");
+
+module_param_array(bcr, byte, NULL, S_IRUGO);
+MODULE_PARM_DESC(ocr, "Bus configuration register (default=0x00)");
+
+module_param_array(cor, byte, NULL, S_IRUGO);
+MODULE_PARM_DESC(cor, "Clockout register (default=0x00)");
+
+#define CC770_IOSIZE          0x20
+#define CC770_IOSIZE_INDIRECT 0x02
+
+static u8 cc770_isa_mem_read_reg(const struct cc770_priv *priv, int reg)
+{
+	return readb(priv->reg_base + reg);
+}
+
+static void cc770_isa_mem_write_reg(const struct cc770_priv *priv,
+				      int reg, u8 val)
+{
+	writeb(val, priv->reg_base + reg);
+}
+
+static u8 cc770_isa_port_read_reg(const struct cc770_priv *priv, int reg)
+{
+	return inb((unsigned long)priv->reg_base + reg);
+}
+
+static void cc770_isa_port_write_reg(const struct cc770_priv *priv,
+				       int reg, u8 val)
+{
+	outb(val, (unsigned long)priv->reg_base + reg);
+}
+
+static u8 cc770_isa_port_read_reg_indirect(const struct cc770_priv *priv,
+					     int reg)
+{
+	unsigned long base = (unsigned long)priv->reg_base;
+
+	outb(reg, base);
+	return inb(base + 1);
+}
+
+static void cc770_isa_port_write_reg_indirect(const struct cc770_priv *priv,
+						int reg, u8 val)
+{
+	unsigned long base = (unsigned long)priv->reg_base;
+
+	outb(reg, base);
+	outb(val, base + 1);
+}
+
+static int __devinit cc770_isa_match(struct device *pdev, unsigned int idx)
+{
+	if (port[idx] || mem[idx]) {
+		if (irq[idx])
+			return 1;
+	} else if (idx)
+		return 0;
+
+	dev_err(pdev, "insufficient parameters supplied\n");
+	return 0;
+}
+
+static int __devinit cc770_isa_probe(struct device *pdev, unsigned int idx)
+{
+	struct net_device *dev;
+	struct cc770_priv *priv;
+	void __iomem *base = NULL;
+	int iosize = CC770_IOSIZE;
+	int err;
+	u32 clktmp;
+
+	if (mem[idx]) {
+		if (!request_mem_region(mem[idx], iosize, DRV_NAME)) {
+			err = -EBUSY;
+			goto exit;
+		}
+		base = ioremap_nocache(mem[idx], iosize);
+		if (!base) {
+			err = -ENOMEM;
+			goto exit_release;
+		}
+	} else {
+		if (indirect[idx] > 0 ||
+		    (indirect[idx] == -1 && indirect[0] > 0))
+			iosize = CC770_IOSIZE_INDIRECT;
+		if (!request_region(port[idx], iosize, DRV_NAME)) {
+			err = -EBUSY;
+			goto exit;
+		}
+	}
+
+	dev = alloc_cc770dev(0);
+	if (!dev) {
+		err = -ENOMEM;
+		goto exit_unmap;
+	}
+	priv = netdev_priv(dev);
+
+	dev->irq = irq[idx];
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,18)
+	priv->irq_flags = SA_SHIRQ;
+#else
+	priv->irq_flags = IRQF_SHARED;
+#endif
+	if (mem[idx]) {
+		priv->reg_base = base;
+		dev->base_addr = mem[idx];
+		priv->read_reg = cc770_isa_mem_read_reg;
+		priv->write_reg = cc770_isa_mem_write_reg;
+	} else {
+		priv->reg_base = (void __iomem *)port[idx];
+		dev->base_addr = port[idx];
+
+		if (iosize == CC770_IOSIZE_INDIRECT) {
+			priv->read_reg = cc770_isa_port_read_reg_indirect;
+			priv->write_reg = cc770_isa_port_write_reg_indirect;
+		} else {
+			priv->read_reg = cc770_isa_port_read_reg;
+			priv->write_reg = cc770_isa_port_write_reg;
+		}
+	}
+
+	if (clk[idx])
+		clktmp = clk[idx];
+	else if (clk[0])
+		clktmp = clk[0];
+	else
+		clktmp = CLK_DEFAULT;
+	priv->can.clock.freq = clktmp;
+
+	if (cir[idx] != -1) {
+		priv->cpu_interface = cir[idx] & 0xff;
+	} else if (cir[0] != -1) {
+		priv->cpu_interface = cir[0] & 0xff;
+	} else {
+		/* The system clock may not exceed 10 MHz */
+		if (clktmp > 10000000) {
+			priv->cpu_interface |= CPUIF_DSC;
+			clktmp /= 2;
+		}
+		/* The memory clock may not exceed 8 MHz */
+		if (clktmp > 8000000)
+			priv->cpu_interface |= CPUIF_DMC;
+	}
+
+	if (priv->cpu_interface & CPUIF_DSC)
+		priv->can.clock.freq /= 2;
+
+	if (bcr[idx] != -1)
+		priv->bus_config = bcr[idx] & 0xff;
+	else if (bcr[0] != -1)
+		priv->bus_config = bcr[0] & 0xff;
+	else
+		priv->bus_config = BCR_DEFAULT;
+
+	if (cor[idx] != -1)
+		priv->clkout = cor[idx] & 0xff;
+	else if (cor[0] != -1)
+		priv->clkout = cor[0] & 0xff;
+	else
+		priv->clkout = COR_DEFAULT;
+
+	dev_set_drvdata(pdev, dev);
+	SET_NETDEV_DEV(dev, pdev);
+
+	err = register_cc770dev(dev);
+	if (err) {
+		dev_err(pdev, "registering %s failed (err=%d)\n",
+			DRV_NAME, err);
+		goto exit_unmap;
+	}
+
+	dev_info(pdev, "%s device registered (reg_base=0x%p, irq=%d)\n",
+		 DRV_NAME, priv->reg_base, dev->irq);
+	return 0;
+
+ exit_unmap:
+	if (mem[idx])
+		iounmap(base);
+ exit_release:
+	if (mem[idx])
+		release_mem_region(mem[idx], iosize);
+	else
+		release_region(port[idx], iosize);
+ exit:
+	return err;
+}
+
+static int __devexit cc770_isa_remove(struct device *pdev, unsigned int idx)
+{
+	struct net_device *dev = dev_get_drvdata(pdev);
+	struct cc770_priv *priv = netdev_priv(dev);
+
+	unregister_cc770dev(dev);
+	dev_set_drvdata(pdev, NULL);
+
+	if (mem[idx]) {
+		iounmap(priv->reg_base);
+		release_mem_region(mem[idx], CC770_IOSIZE);
+	} else {
+		if (priv->read_reg == cc770_isa_port_read_reg_indirect)
+			release_region(port[idx], CC770_IOSIZE_INDIRECT);
+		else
+			release_region(port[idx], CC770_IOSIZE);
+	}
+	free_cc770dev(dev);
+
+	return 0;
+}
+
+static struct isa_driver cc770_isa_driver = {
+	.match = cc770_isa_match,
+	.probe = cc770_isa_probe,
+	.remove = __devexit_p(cc770_isa_remove),
+	.driver = {
+		.name = DRV_NAME,
+	},
+};
+
+static int __init cc770_isa_init(void)
+{
+	int err = isa_register_driver(&cc770_isa_driver, MAXDEV);
+
+	if (!err)
+		printk(KERN_INFO
+		       "Legacy %s driver for max. %d devices registered\n",
+		       DRV_NAME, MAXDEV);
+	return err;
+}
+
+static void __exit cc770_isa_exit(void)
+{
+	isa_unregister_driver(&cc770_isa_driver);
+}
+
+module_init(cc770_isa_init);
+module_exit(cc770_isa_exit);
diff --exclude CVS --exclude .git -uNr linux-2.6.27.8/drivers/net/can/cc770/cc770_of_platform.c linux-2.6.27.8.modified/drivers/net/can/cc770/cc770_of_platform.c
--- linux-2.6.27.8/drivers/net/can/cc770/cc770_of_platform.c	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.27.8.modified/drivers/net/can/cc770/cc770_of_platform.c	2013-05-30 03:44:17.000000000 -0400
@@ -0,0 +1,266 @@
+/*
+ * Driver for CC770 CAN controllers on the OpenFirmware platform bus
+ *
+ * Copyright (C) 2009 Wolfgang Grandegger <wg@grandegger.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the version 2 of the GNU General Public License
+ * as published by the Free Software Foundation
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+/* This is a generic driver for CC770 chips on the OpenFirmware platform
+ * bus found on embedded PowerPC systems. You need a CC770 CAN node
+ * definition in your flattened device tree source (DTS) file similar to:
+ *
+ *   can@3,100 {
+ *           compatible = "bosch,cc770";
+ *           reg = <3 0x100 0x80>;
+ *           interrupts = <2 0>;
+ *           interrupt-parent = <&mpic>;
+ *           bosch,external-clock-frequency = <16000000>;
+ *   };
+ *
+ * See "Documentation/powerpc/dts-bindings/can/cc770.txt" for further
+ * information.
+ */
+
+#include <linux/kernel.h>
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/interrupt.h>
+#include <linux/netdevice.h>
+#include <linux/delay.h>
+#include <socketcan/can.h>
+#include <socketcan/can/dev.h>
+
+#include <linux/of_platform.h>
+#include <asm/prom.h>
+
+#include "cc770.h"
+
+#define DRV_NAME "cc770_of_platform"
+
+MODULE_AUTHOR("Wolfgang Grandegger <wg@grandegger.com>");
+MODULE_DESCRIPTION("Socket-CAN driver for CC770 on the OF platform bus");
+MODULE_LICENSE("GPL v2");
+
+#define CC770_OFP_CAN_CLOCK  16000000
+
+static u8 cc770_ofp_read_reg(const struct cc770_priv *priv, int reg)
+{
+	return in_8(priv->reg_base + reg);
+}
+
+static void cc770_ofp_write_reg(const struct cc770_priv *priv, int reg, u8 val)
+{
+	out_8(priv->reg_base + reg, val);
+}
+
+static int __devexit cc770_ofp_remove(struct of_device *ofdev)
+{
+	struct net_device *dev = dev_get_drvdata(&ofdev->dev);
+	struct cc770_priv *priv = netdev_priv(dev);
+	struct resource res;
+
+	dev_set_drvdata(&ofdev->dev, NULL);
+
+	unregister_cc770dev(dev);
+	iounmap(priv->reg_base);
+	/* irq_dispose_mapping(dev->irq);*/ /* will not work for shared IRQs */
+	free_cc770dev(dev);
+
+	of_address_to_resource(ofdev->node, 0, &res);
+	release_mem_region(res.start, resource_size(&res));
+
+	return 0;
+}
+
+static int __devinit cc770_ofp_probe(struct of_device *ofdev,
+				     const struct of_device_id *id)
+{
+	struct device_node *np = ofdev->node;
+	struct net_device *dev;
+	struct cc770_priv *priv;
+	struct resource res;
+	const u32 *prop;
+	u32 clkext;
+	int err, irq, res_size, prop_size;
+	void __iomem *base;
+
+	err = of_address_to_resource(np, 0, &res);
+	if (err) {
+		dev_err(&ofdev->dev, "invalid address\n");
+		return err;
+	}
+
+	res_size = resource_size(&res);
+
+	if (!request_mem_region(res.start, res_size, DRV_NAME)) {
+		dev_err(&ofdev->dev, "couldn't request %#llx..%#llx\n",
+			(unsigned long long)res.start,
+			(unsigned long long)res.end);
+		return -EBUSY;
+	}
+
+	base = ioremap_nocache(res.start, res_size);
+	if (!base) {
+		dev_err(&ofdev->dev, "couldn't ioremap %#llx..%#llx\n",
+			(unsigned long long)res.start,
+			(unsigned long long)res.end);
+		err = -ENOMEM;
+		goto exit_release_mem;
+	}
+
+	irq = irq_of_parse_and_map(np, 0);
+	if (irq == NO_IRQ) {
+		dev_err(&ofdev->dev, "no irq found\n");
+		err = -ENODEV;
+		goto exit_unmap_mem;
+	}
+
+	dev = alloc_cc770dev(0);
+	if (!dev) {
+		err = -ENOMEM;
+		goto exit_dispose_irq;
+	}
+
+	priv = netdev_priv(dev);
+
+	priv->read_reg = cc770_ofp_read_reg;
+	priv->write_reg = cc770_ofp_write_reg;
+
+	prop = of_get_property(np, "bosch,external-clock-frequency",
+			       &prop_size);
+	if (prop && (prop_size ==  sizeof(u32)))
+		clkext = *prop;
+	else
+		clkext = CC770_OFP_CAN_CLOCK; /* default */
+	priv->can.clock.freq = clkext;
+
+	/* The system clock may not exceed 10 MHz */
+	if (priv->can.clock.freq > 10000000) {
+		priv->cpu_interface |= CPUIF_DSC;
+		priv->can.clock.freq /= 2;
+	}
+
+	/* The memory clock may not exceed 8 MHz */
+	if (priv->can.clock.freq > 8000000)
+		priv->cpu_interface |= CPUIF_DMC;
+
+	if (of_get_property(np, "bosch,divide-memory-clock", NULL))
+		priv->cpu_interface |= CPUIF_DMC;
+	if (of_get_property(np, "bosch,iso-low-speed-mux", NULL))
+		priv->cpu_interface |= CPUIF_MUX;
+
+	if (of_get_property(np, "bosch,comperator-bypass", NULL))
+		priv->bus_config |= BUSCFG_CBY;
+	if (of_get_property(np, "bosch,disconnect-rx0-input", NULL))
+		priv->bus_config |= BUSCFG_DR0;
+	if (of_get_property(np, "bosch,disconnect-rx1-input", NULL))
+		priv->bus_config |= BUSCFG_DR1;
+	if (of_get_property(np, "bosch,disconnect-tx1-output", NULL))
+		priv->bus_config |= BUSCFG_DT1;
+	if (of_get_property(np, "bosch,polarity-dominant", NULL))
+		priv->bus_config |= BUSCFG_POL;
+
+	prop = of_get_property(np, "bosch,clock-out-frequency", &prop_size);
+	if (prop && (prop_size == sizeof(u32)) && *prop > 0) {
+		u32 cdv = clkext / *prop;
+		int slew;
+
+		if (cdv > 0 && cdv < 16) {
+			priv->cpu_interface |= CPUIF_CEN;
+			priv->clkout |= (cdv - 1) & CLKOUT_CD_MASK;
+
+			prop = of_get_property(np, "bosch,slew-rate",
+					       &prop_size);
+			if (prop && (prop_size == sizeof(u32))) {
+				slew = *prop;
+			} else {
+				/* Determine default slew rate */
+				slew = (CLKOUT_SL_MASK >> CLKOUT_SL_SHIFT) -
+					((cdv * clkext - 1) / 8000000);
+				if (slew < 0)
+					slew = 0;
+			}
+			priv->clkout |= (slew << CLKOUT_SL_SHIFT) &
+				CLKOUT_SL_MASK;
+		} else {
+			dev_dbg(ND2D(dev), "invalid clock-out-frequency\n");
+		}
+
+	}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,18)
+	priv->irq_flags = SA_SHIRQ;
+#else
+	priv->irq_flags = IRQF_SHARED;
+#endif
+	priv->reg_base = base;
+
+	dev->irq = irq;
+
+	dev_info(&ofdev->dev,
+		 "reg_base=0x%p irq=%d clock=%d cpu_interface=0x%02x "
+		 "bus_config=0x%02x clkout=0x%02x\n",
+		 priv->reg_base, dev->irq, priv->can.clock.freq,
+		 priv->cpu_interface, priv->bus_config, priv->clkout);
+
+	dev_set_drvdata(&ofdev->dev, dev);
+	SET_NETDEV_DEV(dev, &ofdev->dev);
+
+	err = register_cc770dev(dev);
+	if (err) {
+		dev_err(&ofdev->dev, "registering %s failed (err=%d)\n",
+			DRV_NAME, err);
+		goto exit_free_cc770;
+	}
+
+	return 0;
+
+exit_free_cc770:
+	free_cc770dev(dev);
+exit_dispose_irq:
+	/* irq_dispose_mapping(dev->irq);*/ /* will not work for shared IRQs */
+exit_unmap_mem:
+	iounmap(base);
+exit_release_mem:
+	release_mem_region(res.start, res_size);
+
+	return err;
+}
+
+static struct of_device_id __devinitdata cc770_ofp_table[] = {
+	{.compatible = "bosch,cc770"}, /* CC770 from Bosch */
+	{.compatible = "intc,82527"},  /* AN82527 from Intel CP */
+	{},
+};
+
+static struct of_platform_driver cc770_ofp_driver = {
+	.owner = THIS_MODULE,
+	.name = DRV_NAME,
+	.probe = cc770_ofp_probe,
+	.remove = __devexit_p(cc770_ofp_remove),
+	.match_table = cc770_ofp_table,
+};
+
+static int __init cc770_ofp_init(void)
+{
+	return of_register_platform_driver(&cc770_ofp_driver);
+}
+module_init(cc770_ofp_init);
+
+static void __exit cc770_ofp_exit(void)
+{
+	return of_unregister_platform_driver(&cc770_ofp_driver);
+};
+module_exit(cc770_ofp_exit);
diff --exclude CVS --exclude .git -uNr linux-2.6.27.8/drivers/net/can/dev.c linux-2.6.27.8.modified/drivers/net/can/dev.c
--- linux-2.6.27.8/drivers/net/can/dev.c	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.27.8.modified/drivers/net/can/dev.c	2013-05-30 03:44:17.000000000 -0400
@@ -0,0 +1,867 @@
+/*
+ * $Id: dev.c 1153 2010-03-05 09:11:52Z wolf $
+ *
+ * Copyright (C) 2005 Marc Kleine-Budde, Pengutronix
+ * Copyright (C) 2006 Andrey Volkov, Varma Electronics
+ * Copyright (C) 2008-2009 Wolfgang Grandegger <wg@grandegger.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the version 2 of the GNU General Public License
+ * as published by the Free Software Foundation
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/module.h>
+#include <linux/version.h>
+#include <linux/kernel.h>
+#include <linux/netdevice.h>
+#include <linux/if_arp.h>
+#include <socketcan/can.h>
+#include <socketcan/can/dev.h>
+#ifndef CONFIG_CAN_DEV_SYSFS
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,24)
+#error "CAN netlink interface not support by this kernel version"
+#endif
+#include <socketcan/can/netlink.h>
+#include <net/rtnetlink.h>
+#else
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,21)
+#error "CAN sysfs interface not support by this kernel version"
+#endif
+#include "sysfs.h"
+#endif
+
+#define MOD_DESC "CAN device driver interface"
+
+MODULE_DESCRIPTION(MOD_DESC);
+MODULE_LICENSE("GPL v2");
+MODULE_AUTHOR("Wolfgang Grandegger <wg@grandegger.com>");
+
+#ifdef CONFIG_CAN_CALC_BITTIMING
+#define CAN_CALC_MAX_ERROR 50 /* in one-tenth of a percent */
+
+/*
+ * Bit-timing calculation derived from:
+ *
+ * Code based on LinCAN sources and H8S2638 project
+ * Copyright 2004-2006 Pavel Pisa - DCE FELK CVUT cz
+ * Copyright 2005      Stanislav Marek
+ * email: pisa@cmp.felk.cvut.cz
+ *
+ * Calculates proper bit-timing parameters for a specified bit-rate
+ * and sample-point, which can then be used to set the bit-timing
+ * registers of the CAN controller. You can find more information
+ * in the header file socketcan/can/netlink.h.
+ */
+static int can_update_spt(const struct can_bittiming_const *btc,
+			  int sampl_pt, int tseg, int *tseg1, int *tseg2)
+{
+	*tseg2 = tseg + 1 - (sampl_pt * (tseg + 1)) / 1000;
+	if (*tseg2 < btc->tseg2_min)
+		*tseg2 = btc->tseg2_min;
+	if (*tseg2 > btc->tseg2_max)
+		*tseg2 = btc->tseg2_max;
+	*tseg1 = tseg - *tseg2;
+	if (*tseg1 > btc->tseg1_max) {
+		*tseg1 = btc->tseg1_max;
+		*tseg2 = tseg - *tseg1;
+	}
+	return 1000 * (tseg + 1 - *tseg2) / (tseg + 1);
+}
+
+static int can_calc_bittiming(struct net_device *dev, struct can_bittiming *bt)
+{
+	struct can_priv *priv = netdev_priv(dev);
+	const struct can_bittiming_const *btc = priv->bittiming_const;
+	long rate, best_rate = 0;
+	long best_error = 1000000000, error = 0;
+	int best_tseg = 0, best_brp = 0, brp = 0;
+	int tsegall, tseg = 0, tseg1 = 0, tseg2 = 0;
+	int spt_error = 1000, spt = 0, sampl_pt;
+	u64 v64;
+
+	if (!priv->bittiming_const)
+		return -ENOTSUPP;
+
+	/* Use CIA recommended sample points */
+	if (bt->sample_point) {
+		sampl_pt = bt->sample_point;
+	} else {
+		if (bt->bitrate > 800000)
+			sampl_pt = 750;
+		else if (bt->bitrate > 500000)
+			sampl_pt = 800;
+		else
+			sampl_pt = 875;
+	}
+
+	/* tseg even = round down, odd = round up */
+	for (tseg = (btc->tseg1_max + btc->tseg2_max) * 2 + 1;
+	     tseg >= (btc->tseg1_min + btc->tseg2_min) * 2; tseg--) {
+		tsegall = 1 + tseg / 2;
+		/* Compute all possible tseg choices (tseg=tseg1+tseg2) */
+		brp = priv->clock.freq / (tsegall * bt->bitrate) + tseg % 2;
+		/* chose brp step which is possible in system */
+		brp = (brp / btc->brp_inc) * btc->brp_inc;
+		if ((brp < btc->brp_min) || (brp > btc->brp_max))
+			continue;
+		rate = priv->clock.freq / (brp * tsegall);
+		error = bt->bitrate - rate;
+		/* tseg brp biterror */
+		if (error < 0)
+			error = -error;
+		if (error > best_error)
+			continue;
+		best_error = error;
+		if (error == 0) {
+			spt = can_update_spt(btc, sampl_pt, tseg / 2,
+					     &tseg1, &tseg2);
+			error = sampl_pt - spt;
+			if (error < 0)
+				error = -error;
+			if (error > spt_error)
+				continue;
+			spt_error = error;
+		}
+		best_tseg = tseg / 2;
+		best_brp = brp;
+		best_rate = rate;
+		if (error == 0)
+			break;
+	}
+
+	if (best_error) {
+		/* Error in one-tenth of a percent */
+		error = (best_error * 1000) / bt->bitrate;
+		if (error > CAN_CALC_MAX_ERROR) {
+			dev_err(ND2D(dev),
+				"bitrate error %ld.%ld%% too high\n",
+				error / 10, error % 10);
+			return -EDOM;
+		} else {
+			dev_warn(ND2D(dev), "bitrate error %ld.%ld%%\n",
+				 error / 10, error % 10);
+		}
+	}
+
+	spt = can_update_spt(btc, sampl_pt, best_tseg, &tseg1, &tseg2);
+
+	v64 = (u64)best_brp * 1000000000UL;
+	do_div(v64, priv->clock.freq);
+	bt->tq = (u32)v64;
+	bt->prop_seg = tseg1 / 2;
+	bt->phase_seg1 = tseg1 - bt->prop_seg;
+	bt->phase_seg2 = tseg2;
+	bt->sjw = 1;
+	bt->brp = best_brp;
+#ifndef CONFIG_CAN_DEV_SYSFS
+	/* real bit-rate */
+	bt->bitrate = priv->clock.freq / (bt->brp * (tseg1 + tseg2 + 1));
+	/* real sample point */
+	bt->sample_point = spt;
+#endif
+	return 0;
+}
+#else /* !CONFIG_CAN_CALC_BITTIMING */
+static int can_calc_bittiming(struct net_device *dev, struct can_bittiming *bt)
+{
+	dev_err(ND2D(dev), "bit-timing calculation not available\n");
+	return -EINVAL;
+}
+#endif /* CONFIG_CAN_CALC_BITTIMING */
+
+
+#ifdef CONFIG_CAN_DEV_SYSFS
+int can_sample_point(struct can_bittiming *bt)
+{
+	return ((bt->prop_seg + bt->phase_seg1 + 1) * 1000) /
+		(bt->prop_seg + bt->phase_seg1 + bt->phase_seg2 + 1);
+}
+#endif
+
+/*
+ * Checks the validity of the specified bit-timing parameters prop_seg,
+ * phase_seg1, phase_seg2 and sjw and tries to determine the bitrate
+ * prescaler value brp. You can find more information in the header
+ * file socketcan/can/netlink.h.
+ */
+static int can_fixup_bittiming(struct net_device *dev, struct can_bittiming *bt)
+{
+	struct can_priv *priv = netdev_priv(dev);
+	const struct can_bittiming_const *btc = priv->bittiming_const;
+	int tseg1, alltseg;
+	u64 brp64;
+
+	if (!priv->bittiming_const)
+		return -ENOTSUPP;
+
+	tseg1 = bt->prop_seg + bt->phase_seg1;
+	if (!bt->sjw)
+		bt->sjw = 1;
+	if (bt->sjw > btc->sjw_max ||
+	    tseg1 < btc->tseg1_min || tseg1 > btc->tseg1_max ||
+	    bt->phase_seg2 < btc->tseg2_min || bt->phase_seg2 > btc->tseg2_max)
+		return -ERANGE;
+
+	brp64 = (u64)priv->clock.freq * (u64)bt->tq;
+	if (btc->brp_inc > 1)
+		do_div(brp64, btc->brp_inc);
+	brp64 += 500000000UL - 1;
+	do_div(brp64, 1000000000UL); /* the practicable BRP */
+	if (btc->brp_inc > 1)
+		brp64 *= btc->brp_inc;
+	bt->brp = (u32)brp64;
+
+	if (bt->brp < btc->brp_min || bt->brp > btc->brp_max)
+		return -EINVAL;
+
+	alltseg = bt->prop_seg + bt->phase_seg1 + bt->phase_seg2 + 1;
+	bt->bitrate = priv->clock.freq / (bt->brp * alltseg);
+	bt->sample_point = ((tseg1 + 1) * 1000) / alltseg;
+
+	return 0;
+}
+
+int can_get_bittiming(struct net_device *dev, struct can_bittiming *bt)
+{
+	struct can_priv *priv = netdev_priv(dev);
+	int err;
+
+	/* Check if the CAN device has bit-timing parameters */
+	if (priv->bittiming_const) {
+
+		/* Non-expert mode? Check if the bitrate has been pre-defined */
+		if (!bt->tq)
+			/* Determine bit-timing parameters */
+			err = can_calc_bittiming(dev, bt);
+		else
+			/* Check bit-timing params and calculate proper brp */
+			err = can_fixup_bittiming(dev, bt);
+		if (err)
+			return err;
+	}
+
+	return 0;
+}
+
+/*
+ * Local echo of CAN messages
+ *
+ * CAN network devices *should* support a local echo functionality
+ * (see Documentation/networking/can.txt). To test the handling of CAN
+ * interfaces that do not support the local echo both driver types are
+ * implemented. In the case that the driver does not support the echo
+ * the IFF_ECHO remains clear in dev->flags. This causes the PF_CAN core
+ * to perform the echo as a fallback solution.
+ */
+static void can_flush_echo_skb(struct net_device *dev)
+{
+	struct can_priv *priv = netdev_priv(dev);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,23)
+	struct net_device_stats *stats = can_get_stats(dev);
+#else
+	struct net_device_stats *stats = &dev->stats;
+#endif
+	int i;
+
+	for (i = 0; i < priv->echo_skb_max; i++) {
+		if (priv->echo_skb[i]) {
+			kfree_skb(priv->echo_skb[i]);
+			priv->echo_skb[i] = NULL;
+			stats->tx_dropped++;
+			stats->tx_aborted_errors++;
+		}
+	}
+}
+
+/*
+ * Put the skb on the stack to be looped backed locally lateron
+ *
+ * The function is typically called in the start_xmit function
+ * of the device driver. The driver must protect access to
+ * priv->echo_skb, if necessary.
+ */
+void can_put_echo_skb(struct sk_buff *skb, struct net_device *dev,
+		      unsigned int idx)
+{
+	struct can_priv *priv = netdev_priv(dev);
+
+	BUG_ON(idx >= priv->echo_skb_max);
+
+	/* check flag whether this packet has to be looped back */
+	if (!(dev->flags & IFF_ECHO) || skb->pkt_type != PACKET_LOOPBACK) {
+		kfree_skb(skb);
+		return;
+	}
+
+	if (!priv->echo_skb[idx]) {
+		struct sock *srcsk = skb->sk;
+
+		if (atomic_read(&skb->users) != 1) {
+			struct sk_buff *old_skb = skb;
+
+			skb = skb_clone(old_skb, GFP_ATOMIC);
+			kfree_skb(old_skb);
+			if (!skb)
+				return;
+		} else
+			skb_orphan(skb);
+
+		skb->sk = srcsk;
+
+		/* make settings for echo to reduce code in irq context */
+		skb->protocol = __constant_htons(ETH_P_CAN);
+		skb->pkt_type = PACKET_BROADCAST;
+		skb->ip_summed = CHECKSUM_UNNECESSARY;
+		skb->dev = dev;
+
+		/* save this skb for tx interrupt echo handling */
+		priv->echo_skb[idx] = skb;
+	} else {
+		/* locking problem with netif_stop_queue() ?? */
+		dev_err(ND2D(dev), "%s: BUG! echo_skb is occupied!\n",
+			__func__);
+		kfree_skb(skb);
+	}
+}
+EXPORT_SYMBOL_GPL(can_put_echo_skb);
+
+/*
+ * Get the skb from the stack and loop it back locally
+ *
+ * The function is typically called when the TX done interrupt
+ * is handled in the device driver. The driver must protect
+ * access to priv->echo_skb, if necessary.
+ */
+void can_get_echo_skb(struct net_device *dev, unsigned int idx)
+{
+	struct can_priv *priv = netdev_priv(dev);
+
+	BUG_ON(idx >= priv->echo_skb_max);
+
+	if (priv->echo_skb[idx]) {
+		netif_rx(priv->echo_skb[idx]);
+		priv->echo_skb[idx] = NULL;
+	}
+}
+EXPORT_SYMBOL_GPL(can_get_echo_skb);
+
+/*
+  * Remove the skb from the stack and free it.
+  *
+  * The function is typically called when TX failed.
+  */
+void can_free_echo_skb(struct net_device *dev, unsigned int idx)
+{
+	struct can_priv *priv = netdev_priv(dev);
+
+	BUG_ON(idx >= priv->echo_skb_max);
+
+	if (priv->echo_skb[idx]) {
+		kfree_skb(priv->echo_skb[idx]);
+		priv->echo_skb[idx] = NULL;
+	}
+}
+EXPORT_SYMBOL_GPL(can_free_echo_skb);
+
+/*
+ * CAN device restart for bus-off recovery
+ */
+void can_restart(unsigned long data)
+{
+	struct net_device *dev = (struct net_device *)data;
+	struct can_priv *priv = netdev_priv(dev);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,23)
+	struct net_device_stats *stats = can_get_stats(dev);
+#else
+	struct net_device_stats *stats = &dev->stats;
+#endif
+	struct sk_buff *skb;
+	struct can_frame *cf;
+	int err;
+
+	BUG_ON(netif_carrier_ok(dev));
+
+	/*
+	 * No synchronization needed because the device is bus-off and
+	 * no messages can come in or go out.
+	 */
+	can_flush_echo_skb(dev);
+
+	/* send restart message upstream */
+	skb = alloc_can_err_skb(dev, &cf);
+	if (skb == NULL) {
+		err = -ENOMEM;
+		goto restart;
+	}
+	cf->can_id |= CAN_ERR_RESTARTED;
+
+	netif_rx(skb);
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,32)
+	dev->last_rx = jiffies;
+#endif
+	stats->rx_packets++;
+	stats->rx_bytes += cf->can_dlc;
+
+restart:
+	dev_dbg(ND2D(dev), "restarted\n");
+	priv->can_stats.restarts++;
+
+	/* Now restart the device */
+	err = priv->do_set_mode(dev, CAN_MODE_START);
+
+	netif_carrier_on(dev);
+	if (err)
+		dev_err(ND2D(dev), "Error %d during restart", err);
+}
+
+int can_restart_now(struct net_device *dev)
+{
+	struct can_priv *priv = netdev_priv(dev);
+
+	/*
+	 * A manual restart is only permitted if automatic restart is
+	 * disabled and the device is in the bus-off state
+	 */
+	if (priv->restart_ms)
+		return -EINVAL;
+	if (priv->state != CAN_STATE_BUS_OFF)
+		return -EBUSY;
+
+	/* Runs as soon as possible in the timer context */
+	mod_timer(&priv->restart_timer, jiffies);
+
+	return 0;
+}
+
+/*
+ * CAN bus-off
+ *
+ * This functions should be called when the device goes bus-off to
+ * tell the netif layer that no more packets can be sent or received.
+ * If enabled, a timer is started to trigger bus-off recovery.
+ */
+void can_bus_off(struct net_device *dev)
+{
+	struct can_priv *priv = netdev_priv(dev);
+
+	dev_dbg(ND2D(dev), "bus-off\n");
+
+	netif_carrier_off(dev);
+	priv->can_stats.bus_off++;
+
+	if (priv->restart_ms)
+		mod_timer(&priv->restart_timer,
+			  jiffies + (priv->restart_ms * HZ) / 1000);
+}
+EXPORT_SYMBOL_GPL(can_bus_off);
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,23)
+struct net_device_stats *can_get_stats(struct net_device *dev)
+{
+	struct can_priv *priv = netdev_priv(dev);
+
+	return &priv->net_stats;
+}
+EXPORT_SYMBOL_GPL(can_get_stats);
+#endif
+
+static void can_setup(struct net_device *dev)
+{
+	dev->type = ARPHRD_CAN;
+	dev->mtu = sizeof(struct can_frame);
+	dev->hard_header_len = 0;
+	dev->addr_len = 0;
+	dev->tx_queue_len = 10;
+
+	/* New-style flags. */
+	dev->flags = IFF_NOARP;
+	dev->features = NETIF_F_NO_CSUM;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,23)
+	dev->get_stats = can_get_stats;
+#endif
+}
+
+struct sk_buff *alloc_can_skb(struct net_device *dev, struct can_frame **cf)
+{
+	struct sk_buff *skb;
+
+	skb = netdev_alloc_skb(dev, sizeof(struct can_frame));
+	if (unlikely(!skb))
+		return NULL;
+
+	skb->protocol = __constant_htons(ETH_P_CAN);
+	skb->pkt_type = PACKET_BROADCAST;
+	skb->ip_summed = CHECKSUM_UNNECESSARY;
+	*cf = (struct can_frame *)skb_put(skb, sizeof(struct can_frame));
+	memset(*cf, 0, sizeof(struct can_frame));
+
+	return skb;
+}
+EXPORT_SYMBOL_GPL(alloc_can_skb);
+
+struct sk_buff *alloc_can_err_skb(struct net_device *dev, struct can_frame **cf)
+{
+	struct sk_buff *skb;
+
+	skb = alloc_can_skb(dev, cf);
+	if (unlikely(!skb))
+		return NULL;
+
+	(*cf)->can_id = CAN_ERR_FLAG;
+	(*cf)->can_dlc = CAN_ERR_DLC;
+
+	return skb;
+}
+EXPORT_SYMBOL_GPL(alloc_can_err_skb);
+
+/*
+ * Allocate and setup space for the CAN network device
+ */
+struct net_device *alloc_candev(int sizeof_priv, unsigned int echo_skb_max)
+{
+	struct net_device *dev;
+	struct can_priv *priv;
+	int size;
+
+	if (echo_skb_max)
+		size = ALIGN(sizeof_priv, sizeof(struct sk_buff *)) +
+			echo_skb_max * sizeof(struct sk_buff *);
+	else
+		size = sizeof_priv;
+
+	dev = alloc_netdev(size, "can%d", can_setup);
+	if (!dev)
+		return NULL;
+
+	priv = netdev_priv(dev);
+
+	if (echo_skb_max) {
+		priv->echo_skb_max = echo_skb_max;
+		priv->echo_skb = (void *)priv +
+			ALIGN(sizeof_priv, sizeof(struct sk_buff *));
+	}
+
+	priv->state = CAN_STATE_STOPPED;
+
+	init_timer(&priv->restart_timer);
+
+	return dev;
+}
+EXPORT_SYMBOL_GPL(alloc_candev);
+
+/*
+ * Free space of the CAN network device
+ */
+void free_candev(struct net_device *dev)
+{
+	free_netdev(dev);
+}
+EXPORT_SYMBOL_GPL(free_candev);
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,15)
+static inline void setup_timer(struct timer_list * timer,
+				void (*function)(unsigned long),
+				unsigned long data)
+{
+	timer->function = function;
+	timer->data = data;
+	init_timer(timer);
+}
+#endif
+
+/*
+ * Common open function when the device gets opened.
+ *
+ * This function should be called in the open function of the device
+ * driver.
+ */
+int open_candev(struct net_device *dev)
+{
+	struct can_priv *priv = netdev_priv(dev);
+#ifdef CONFIG_CAN_DEV_SYSFS
+	int err;
+#endif
+
+	if (!priv->bittiming.tq && !priv->bittiming.bitrate) {
+		dev_err(ND2D(dev), "bit-timing not yet defined\n");
+		return -EINVAL;
+	}
+
+#ifdef CONFIG_CAN_DEV_SYSFS
+	err = can_get_bittiming(dev, &priv->bittiming);
+	if (err)
+		return err;
+
+ 	if (priv->do_set_bittiming) {
+		/* Finally, set the bit-timing registers */
+		err = priv->do_set_bittiming(dev);
+		if (err)
+			return err;
+	}
+#endif
+
+	/* Switch carrier on if device was stopped while in bus-off state */
+	if (!netif_carrier_ok(dev))
+		netif_carrier_on(dev);
+
+	setup_timer(&priv->restart_timer, can_restart, (unsigned long)dev);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(open_candev);
+
+/*
+ * Common close function for cleanup before the device gets closed.
+ *
+ * This function should be called in the close function of the device
+ * driver.
+ */
+void close_candev(struct net_device *dev)
+{
+	struct can_priv *priv = netdev_priv(dev);
+
+	if (del_timer_sync(&priv->restart_timer))
+		dev_put(dev);
+	can_flush_echo_skb(dev);
+}
+EXPORT_SYMBOL_GPL(close_candev);
+
+#ifndef CONFIG_CAN_DEV_SYSFS
+/*
+ * CAN netlink interface
+ */
+static const struct nla_policy can_policy[IFLA_CAN_MAX + 1] = {
+	[IFLA_CAN_STATE]	= { .type = NLA_U32 },
+	[IFLA_CAN_CTRLMODE]	= { .len = sizeof(struct can_ctrlmode) },
+	[IFLA_CAN_RESTART_MS]	= { .type = NLA_U32 },
+	[IFLA_CAN_RESTART]	= { .type = NLA_U32 },
+	[IFLA_CAN_BITTIMING]	= { .len = sizeof(struct can_bittiming) },
+	[IFLA_CAN_BITTIMING_CONST]
+				= { .len = sizeof(struct can_bittiming_const) },
+	[IFLA_CAN_CLOCK]	= { .len = sizeof(struct can_clock) },
+	[IFLA_CAN_BERR_COUNTER]	= { .len = sizeof(struct can_berr_counter) },
+};
+
+static int can_changelink(struct net_device *dev,
+			  struct nlattr *tb[], struct nlattr *data[])
+{
+	struct can_priv *priv = netdev_priv(dev);
+	int err;
+
+	/* We need synchronization with dev->stop() */
+	ASSERT_RTNL();
+
+	if (data[IFLA_CAN_CTRLMODE]) {
+		struct can_ctrlmode *cm;
+
+		/* Do not allow changing controller mode while running */
+		if (dev->flags & IFF_UP)
+			return -EBUSY;
+		cm = nla_data(data[IFLA_CAN_CTRLMODE]);
+		if (cm->flags & ~priv->ctrlmode_supported)
+			return -EOPNOTSUPP;
+		priv->ctrlmode &= ~cm->mask;
+		priv->ctrlmode |= cm->flags;
+	}
+
+	if (data[IFLA_CAN_BITTIMING]) {
+		struct can_bittiming bt;
+
+		/* Do not allow changing bittiming while running */
+		if (dev->flags & IFF_UP)
+			return -EBUSY;
+		memcpy(&bt, nla_data(data[IFLA_CAN_BITTIMING]), sizeof(bt));
+		if ((!bt.bitrate && !bt.tq) || (bt.bitrate && bt.tq))
+			return -EINVAL;
+		err = can_get_bittiming(dev, &bt);
+		if (err)
+			return err;
+		memcpy(&priv->bittiming, &bt, sizeof(bt));
+
+		if (priv->do_set_bittiming) {
+			/* Finally, set the bit-timing registers */
+			err = priv->do_set_bittiming(dev);
+			if (err)
+				return err;
+		}
+	}
+
+	if (data[IFLA_CAN_RESTART_MS]) {
+		/* Do not allow changing restart delay while running */
+		if (dev->flags & IFF_UP)
+			return -EBUSY;
+		priv->restart_ms = nla_get_u32(data[IFLA_CAN_RESTART_MS]);
+	}
+
+	if (data[IFLA_CAN_RESTART]) {
+		/* Do not allow a restart while not running */
+		if (!(dev->flags & IFF_UP))
+			return -EINVAL;
+		err = can_restart_now(dev);
+		if (err)
+			return err;
+	}
+
+	return 0;
+}
+
+static size_t can_get_size(const struct net_device *dev)
+{
+	struct can_priv *priv = netdev_priv(dev);
+	size_t size;
+
+	size = nla_total_size(sizeof(u32));   /* IFLA_CAN_STATE */
+	size += sizeof(struct can_ctrlmode);  /* IFLA_CAN_CTRLMODE */
+	size += nla_total_size(sizeof(u32));  /* IFLA_CAN_RESTART_MS */
+	size += sizeof(struct can_bittiming); /* IFLA_CAN_BITTIMING */
+	size += sizeof(struct can_clock);     /* IFLA_CAN_CLOCK */
+	if (priv->do_get_berr_counter)        /* IFLA_CAN_BERR_COUNTER */
+		size += sizeof(struct can_berr_counter);
+	if (priv->bittiming_const)	      /* IFLA_CAN_BITTIMING_CONST */
+		size += sizeof(struct can_bittiming_const);
+
+	return size;
+}
+
+static int can_fill_info(struct sk_buff *skb, const struct net_device *dev)
+{
+	struct can_priv *priv = netdev_priv(dev);
+	struct can_ctrlmode cm = {.flags = priv->ctrlmode};
+	struct can_berr_counter bec;
+	enum can_state state = priv->state;
+
+	if (priv->do_get_state)
+		priv->do_get_state(dev, &state);
+	NLA_PUT_U32(skb, IFLA_CAN_STATE, state);
+	NLA_PUT(skb, IFLA_CAN_CTRLMODE, sizeof(cm), &cm);
+	NLA_PUT_U32(skb, IFLA_CAN_RESTART_MS, priv->restart_ms);
+	NLA_PUT(skb, IFLA_CAN_BITTIMING,
+		sizeof(priv->bittiming), &priv->bittiming);
+	NLA_PUT(skb, IFLA_CAN_CLOCK, sizeof(cm), &priv->clock);
+	if (priv->do_get_berr_counter && !priv->do_get_berr_counter(dev, &bec))
+		NLA_PUT(skb, IFLA_CAN_BERR_COUNTER, sizeof(bec), &bec);
+	if (priv->bittiming_const)
+		NLA_PUT(skb, IFLA_CAN_BITTIMING_CONST,
+			sizeof(*priv->bittiming_const), priv->bittiming_const);
+
+	return 0;
+
+nla_put_failure:
+	return -EMSGSIZE;
+}
+
+static size_t can_get_xstats_size(const struct net_device *dev)
+{
+	return sizeof(struct can_device_stats);
+}
+
+static int can_fill_xstats(struct sk_buff *skb, const struct net_device *dev)
+{
+	struct can_priv *priv = netdev_priv(dev);
+
+	NLA_PUT(skb, IFLA_INFO_XSTATS,
+		sizeof(priv->can_stats), &priv->can_stats);
+
+	return 0;
+
+nla_put_failure:
+	return -EMSGSIZE;
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,33)
+static int can_newlink(struct net_device *dev,
+		       struct nlattr *tb[], struct nlattr *data[])
+#else
+static int can_newlink(struct net *src_net, struct net_device *dev,
+		       struct nlattr *tb[], struct nlattr *data[])
+#endif
+{
+	return -EOPNOTSUPP;
+}
+
+static struct rtnl_link_ops can_link_ops __read_mostly = {
+	.kind		= "can",
+	.maxtype	= IFLA_CAN_MAX,
+	.policy		= can_policy,
+	.setup		= can_setup,
+	.newlink	= can_newlink,
+	.changelink	= can_changelink,
+	.get_size	= can_get_size,
+	.fill_info	= can_fill_info,
+	.get_xstats_size = can_get_xstats_size,
+	.fill_xstats	= can_fill_xstats,
+};
+
+#endif /* !CONFIG_CAN_DEV_SYSFS */
+
+/*
+ * Register the CAN network device
+ */
+int register_candev(struct net_device *dev)
+{
+#ifdef CONFIG_CAN_DEV_SYSFS
+	int err;
+
+	err = register_netdev(dev);
+	if (!err)
+		can_create_sysfs(dev);
+
+	return err;
+#else
+	dev->rtnl_link_ops = &can_link_ops;
+	return register_netdev(dev);
+#endif
+}
+EXPORT_SYMBOL_GPL(register_candev);
+
+/*
+ * Unregister the CAN network device
+ */
+void unregister_candev(struct net_device *dev)
+{
+#ifdef CONFIG_CAN_DEV_SYSFS
+	can_remove_sysfs(dev);
+#endif
+	unregister_netdev(dev);
+}
+EXPORT_SYMBOL_GPL(unregister_candev);
+
+static __init int can_dev_init(void)
+{
+#ifndef CONFIG_CAN_DEV_SYSFS
+	int err;
+
+	err = rtnl_link_register(&can_link_ops);
+	if (!err)
+		printk(KERN_INFO MOD_DESC "\n");
+
+	return err;
+#else
+	printk(KERN_INFO MOD_DESC " using the deprecated SYSFS interface\n");
+
+	return 0;
+#endif
+}
+module_init(can_dev_init);
+
+static __exit void can_dev_exit(void)
+{
+#ifndef CONFIG_CAN_DEV_SYSFS
+	rtnl_link_unregister(&can_link_ops);
+#endif
+}
+module_exit(can_dev_exit);
+
+#ifndef CONFIG_CAN_DEV_SYSFS
+MODULE_ALIAS_RTNL_LINK("can");
+#endif
diff --exclude CVS --exclude .git -uNr linux-2.6.27.8/drivers/net/can/esd_pci331.c linux-2.6.27.8.modified/drivers/net/can/esd_pci331.c
--- linux-2.6.27.8/drivers/net/can/esd_pci331.c	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.27.8.modified/drivers/net/can/esd_pci331.c	2013-05-30 03:44:19.000000000 -0400
@@ -0,0 +1,955 @@
+/*
+ * Copyright (C) 2009 Thomas Koerper <thomas.koerper@esd.eu>, esd gmbh
+ * derived from kernel/2.6/drivers/net/can/sja1000/esd_pci.c,
+ * * Copyright (C) 2007 Wolfgang Grandegger <wg@grandegger.com>
+ * * Copyright (C) 2008 Sascha Hauer <s.hauer@pengutronix.de>, Pengutronix
+ * * Copyright (C) 2009 Matthias Fuchs <matthias.fuchs@esd.eu>, esd gmbh
+ * and kernel/2.6/drivers/net/can/at91_can.c,
+ * * Copyright (C) 2007 by Hans J. Koch <hjk@linutronix.de>
+ * * Copyright (C) 2008 by Marc Kleine-Budde <kernel@pengutronix.de
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the version 2 of the GNU General Public License
+ * as published by the Free Software Foundation
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include <linux/interrupt.h>
+#include <linux/netdevice.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/if_arp.h>
+#include <linux/skbuff.h>
+#include <linux/types.h>
+#include <linux/delay.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/io.h>
+#include <linux/byteorder/generic.h>
+#include <linux/pci.h>
+#include <linux/pci_ids.h>
+#include <socketcan/can.h>
+#include <socketcan/can/error.h>
+#include <socketcan/can/dev.h>
+
+#define DRV_NAME "esd_pci331"
+
+MODULE_AUTHOR("Thomas Koerper <thomas.koerper@esd.eu>");
+MODULE_LICENSE("GPL v2");
+MODULE_DESCRIPTION("Socket-CAN driver for the esd 331 CAN cards");
+MODULE_DEVICE_TABLE(pci, esd331_pci_tbl);
+MODULE_SUPPORTED_DEVICE("esd CAN-PCI/331, CAN-CPCI/331, CAN-PMC/331");
+
+#ifndef PCI_DEVICE_ID_PLX_9030
+# define PCI_DEVICE_ID_PLX_9030	0x9030
+#endif
+#ifndef PCI_DEVICE_ID_PLX_9050
+# define PCI_DEVICE_ID_PLX_9050	0x9050
+#endif
+#ifndef PCI_VENDOR_ID_ESDGMBH
+#define PCI_VENDOR_ID_ESDGMBH   0x12fe
+#endif
+
+#define ESD_PCI_SUB_SYS_ID_PCI331 0x0001
+#define ESD_PCI_SUB_SYS_ID_PMC331 0x000C
+
+/* Maximum number of interfaces supported per card */
+#define ESD331_MAX_CAN			2
+/* 331's fifo size. Don't change! */
+#define ESD331_DPRSIZE			1024
+/* Max. messages to handle per interrupt */
+#define ESD331_MAX_INTERRUPT_WORK	8
+#define ESD331_MAX_BOARD_MESSAGES	5
+#define ESD331_RTR_FLAG			0x10
+#define ESD331_ERR_OK			0x00
+#define ESD331_ERR_WARN			0x40
+#define ESD331_ERR_BUSOFF1		0x80
+#define ESD331_ERR_BUSOFF2		0xc0
+#define ESD331_CONF_OFFS_ICS		0x4c
+#define ESD331_CONF_OFFS_MISC_CTRL	0x50
+#define ESD331_OFFS_LINK_BASE		0x846
+#define ESD331_OFFS_IRQ_ACK		0xc0100
+#define ESD331_NETS_MASK		0x07
+#define ESD331_EVENT_MASK		0x7f
+#define ESD331_DLC_MASK			0x0f
+#define ESD331_EFF_SUPP_FLAG		0x80
+#define ESD331_IRQ_FLAG			0x00000004
+#define ESD331_ENABLE_IRQ_FLAG		0x00000041
+#define ESD331_STOP_OS			0x40000010
+#define ESD331_RESTART_OS		0x40000028
+
+#define ESD331_I20_BCAN			0
+#define ESD331_I20_ENABLE		1
+#define ESD331_I20_BAUD			4
+#define ESD331_I20_TXDONE		5
+#define ESD331_I20_TXTOUT		12
+#define ESD331_I20_ERROR		13
+#define ESD331_I20_BOARD		14
+#define ESD331_I20_EX_BCAN		15
+#define ESD331_I20_EX_TXDONE		16
+#define ESD331_I20_EX_TXTOUT		17
+#define ESD331_I20_BOARD2		20
+#define ESD331_I20_FAST			21
+
+#define ESD331_ECHO_SKB_MAX		1
+
+static struct pci_device_id esd331_pci_tbl[] = {
+	{PCI_VENDOR_ID_PLX, PCI_DEVICE_ID_PLX_9050,
+	PCI_VENDOR_ID_ESDGMBH, ESD_PCI_SUB_SYS_ID_PCI331},
+	{PCI_VENDOR_ID_PLX, PCI_DEVICE_ID_PLX_9030,
+	PCI_VENDOR_ID_ESDGMBH, ESD_PCI_SUB_SYS_ID_PMC331},
+	{0, }
+};
+
+struct esd331_can_msg {
+	u8 cmmd;
+	u8 net;
+	s16 id;
+	s16 len;
+	u8 data[8];
+	u16 x1;
+	u16 x2;
+	u16 x3;
+} __attribute__((packed));
+#define ESD331_CM_SSIZE (sizeof(struct esd331_can_msg) / sizeof(u16))
+
+struct esd331_idp {
+	u8 dummy[16];
+	u8 buffer[4];
+} __attribute__((packed));
+
+struct esd331_dpr {
+	char magic[16];
+	u16 rx_in;
+	u16 dummy1;
+	u16 rx_ou;
+	u16 dummy2;
+	struct esd331_can_msg rx_buff[ESD331_DPRSIZE];
+	u16 tx_in;
+	u16 dummy3;
+	u16 tx_ou;
+	u16 dummy4;
+	struct esd331_can_msg tx_buff[ESD331_DPRSIZE];
+} __attribute__((packed));
+
+struct esd331_pci {
+	struct pci_dev *pci_dev;
+	struct net_device *dev[ESD331_MAX_CAN];
+	void __iomem *conf_addr;
+	void __iomem *base_addr1;
+	void __iomem *base_addr2;
+	spinlock_t irq_lock; /* locks access to card's fifo */
+	struct esd331_dpr *dpr;
+	int eff_supp;
+	int net_count;
+};
+
+struct esd331_priv {
+	struct can_priv can; /* must be the first member! */
+	struct esd331_pci *board;
+	u8 boards_net;
+};
+
+struct esd331_baud_entry {
+	u32 rate;
+	u16 index;
+};
+
+static struct esd331_baud_entry esd331_baud_table[] = {
+	{1600000, 15},
+	{1000000, 0},
+	{800000, 14},
+	{666666, 1},
+	{500000, 2},
+	{333333, 3},
+	{250000, 4},
+	{166666, 5},
+	{125000, 6},
+	{100000, 7},
+	{83333, 16},
+	{66666, 8},
+	{50000, 9},
+	{33333, 10},
+	{20000, 11},
+	{12500, 12},
+	{10000, 13}
+};
+
+static void esd331_reset(void *pci331_confspace, int wait_for_restart)
+{
+	unsigned long data;
+	void __iomem *addr = pci331_confspace + ESD331_CONF_OFFS_MISC_CTRL;
+
+	data = readl(addr);
+	data |= ESD331_STOP_OS;
+	writel(data, addr);
+	msleep(10);
+
+	data = readl(addr);
+	data &= ~ESD331_RESTART_OS;
+	writel(data, addr);
+
+	if (wait_for_restart)
+		msleep_interruptible(3500);
+}
+
+static struct esd331_dpr *esd331_init_pointer(void __iomem *pci331_space2)
+{
+	unsigned long data;
+	struct esd331_idp *idp;
+	void __iomem *ptr = pci331_space2 + ESD331_OFFS_LINK_BASE;
+
+	data = readb(ptr++);
+	data = (data << 8) + readb(ptr++);
+	data = (data << 8) + readb(ptr++);
+	data = (data << 8) + readb(ptr++);
+
+	idp = (struct esd331_idp *)(pci331_space2 + data);
+	data = idp->buffer[0];
+	data = (data << 8) + idp->buffer[1];
+	data = (data << 8) + idp->buffer[2];
+	data = (data << 8) + idp->buffer[3];
+
+	return (struct esd331_dpr *)(pci331_space2 + data);
+}
+
+static void esd331_enable_irq(void *pci331_confspace)
+{
+	void __iomem *addr = pci331_confspace + ESD331_CONF_OFFS_ICS;
+	u32 data;
+
+	data = readl(addr);
+	data |= ESD331_ENABLE_IRQ_FLAG;
+	writel(data, addr);
+}
+
+static void esd331_disable_irq(void *pci331_confspace)
+{
+	void __iomem *addr = pci331_confspace + ESD331_CONF_OFFS_ICS;
+	u32 data;
+
+	data = readl(addr);
+	data &= ~ESD331_ENABLE_IRQ_FLAG;
+	writel(data, addr);
+}
+
+static int esd331_write(struct esd331_can_msg *mesg, struct esd331_pci *board)
+{
+	u16 in;
+	u16 in_new;
+	u16 out;
+	unsigned long irq_flags;
+	int err = -EAGAIN; /* = card's fifo full */
+	int i;
+
+	spin_lock_irqsave(&board->irq_lock, irq_flags);
+
+	out = be16_to_cpu(readw(&board->dpr->rx_ou));
+	in = be16_to_cpu(readw(&board->dpr->rx_in));
+
+	in_new = (in + 1) % ESD331_DPRSIZE;
+
+	if (in_new != out) {
+		u16 *ptr1;
+		u16 *ptr2;
+
+		ptr1 = (u16 *)mesg;
+		ptr2 = (u16 *)&board->dpr->rx_buff[in];
+		for (i = 0; i < ESD331_CM_SSIZE; i++)
+			writew(*ptr1++, ptr2++);
+
+		in_new = cpu_to_be16(in_new);
+		wmb();
+		writew(in_new, &board->dpr->rx_in);
+
+		err = 0;
+	}
+
+	spin_unlock_irqrestore(&board->irq_lock, irq_flags);
+	return err;
+}
+
+static int esd331_read(struct esd331_can_msg *mesg, struct esd331_pci *board)
+{
+	u16 in;
+	u16 out;
+	unsigned long irq_flags;
+	int err = -ENODATA;
+
+	spin_lock_irqsave(&board->irq_lock, irq_flags);
+
+	out = be16_to_cpu(readw(&board->dpr->tx_ou));
+	in = be16_to_cpu(readw(&board->dpr->tx_in));
+
+	if (in != out) {
+		u16 *ptr1;
+		u16 *ptr2;
+		int ll;
+
+		ptr1 = (u16 *)mesg;
+		ptr2 = (u16 *)&board->dpr->tx_buff[out];
+		for (ll = 0; ll < ESD331_CM_SSIZE; ll++)
+			*ptr1++ = readw(ptr2++);
+
+		out++;
+		out %= ESD331_DPRSIZE;
+
+		wmb();
+		writew(cpu_to_be16(out), &board->dpr->tx_ou);
+
+		mesg->id = be16_to_cpu(mesg->id);
+		mesg->len = be16_to_cpu(mesg->len);
+		mesg->x1 = be16_to_cpu(mesg->x1);
+		mesg->x2 = be16_to_cpu(mesg->x2);
+		mesg->x3 = be16_to_cpu(mesg->x3);
+
+		err = 0;
+	}
+
+	spin_unlock_irqrestore(&board->irq_lock, irq_flags);
+	return err;
+}
+
+static int esd331_write_allid(u8 net, struct esd331_pci *board)
+{
+	struct esd331_can_msg mesg;
+	u16 id;
+
+	memset(&mesg, 0, sizeof(mesg));
+
+	mesg.cmmd = ESD331_I20_ENABLE;
+	mesg.net = net;
+
+	for (id = 0; id < 2048; id++) {
+		int retryCount = 5;
+
+		mesg.id = cpu_to_be16(id);
+
+		while (esd331_write(&mesg, board) && (retryCount--))
+			msleep(1);
+
+		if (retryCount == 0)
+			return -EIO;
+	}
+
+	return 0;
+}
+
+static int esd331_write_fast(struct esd331_pci *board)
+{
+	struct esd331_can_msg mesg;
+
+	memset(&mesg, 0, sizeof(mesg));
+	mesg.cmmd = ESD331_I20_FAST;
+
+	return esd331_write(&mesg, board);
+}
+
+static int esd331_write_baud(u8 pci331net, int index, struct esd331_pci *board)
+{
+	struct esd331_can_msg mesg;
+
+	memset(&mesg, 0, sizeof(mesg));
+	mesg.cmmd = ESD331_I20_BAUD;
+	mesg.net = pci331net;
+	mesg.data[0] = (u8)(index >> 8);
+	mesg.data[1] = (u8)index;
+
+	return esd331_write(&mesg, board);
+}
+
+static int esd331_read_features(struct esd331_pci *board)
+{
+	struct esd331_can_msg msg;
+	int max_msg = ESD331_MAX_BOARD_MESSAGES;
+
+	board->net_count = 0;
+	board->eff_supp = 0;
+
+	while ((esd331_read(&msg, board) == 0) && (max_msg--)) {
+		if (msg.cmmd == ESD331_I20_BOARD) {
+			u8 magic = (msg.x1 >> 8);
+
+			if (magic == 0) {
+				u8 features = (u8)msg.x1;
+				u8 nets = (features & ESD331_NETS_MASK);
+
+				if (nets <= ESD331_MAX_CAN)
+					board->net_count = nets;
+
+				if (features & ESD331_EFF_SUPP_FLAG)
+					board->eff_supp = 1;
+			}
+		} else if (msg.cmmd == ESD331_I20_BOARD2) {
+			u8 features = msg.net;
+
+			if (features & ESD331_EFF_SUPP_FLAG)
+				board->eff_supp = 1;
+
+			if (board->net_count == 0) {
+				u8 nets = (features & ESD331_NETS_MASK);
+
+				if (nets <= ESD331_MAX_CAN)
+					board->net_count = nets;
+			}
+		}
+	}
+
+	return (board->net_count < 1) ? -EIO : 0;
+}
+
+static int esd331_create_err_frame(struct net_device *dev, canid_t idflags,
+					u8 d1)
+{
+	struct net_device_stats *stats;
+	struct can_frame *cf;
+	struct sk_buff *skb;
+
+	skb = alloc_can_err_skb(dev, &cf);
+	if (unlikely(skb == NULL))
+		return -ENOMEM;
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,23)
+	stats = can_get_stats(dev);
+#else
+	stats = &dev->stats;
+#endif
+
+	cf->can_id |= idflags;
+	cf->data[1] = d1;
+
+	netif_rx(skb);
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,32)
+	dev->last_rx = jiffies;
+#endif
+	stats->rx_packets++;
+	stats->rx_bytes += cf->can_dlc;
+
+	return 0;
+}
+
+static void esd331_irq_rx(struct net_device *dev, struct esd331_can_msg *msg,
+				int eff)
+{
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,23)
+	struct net_device_stats *stats = can_get_stats(dev);
+#else
+	struct net_device_stats *stats = &dev->stats;
+#endif
+	struct can_frame *cfrm;
+	struct sk_buff *skb;
+	int i;
+
+	skb = alloc_can_skb(dev, &cfrm);
+	if (unlikely(skb == NULL)) {
+		stats->rx_dropped++;
+		return;
+	}
+
+	if (eff) {
+		cfrm->can_id = (msg->id << 16);
+		cfrm->can_id |= (msg->x2);
+	} else {
+		cfrm->can_id = msg->id;
+	}
+	if (msg->len & ESD331_RTR_FLAG)
+		cfrm->can_id |= CAN_RTR_FLAG;
+
+	if (eff)
+		cfrm->can_id |= CAN_EFF_FLAG;
+
+	cfrm->can_dlc = get_can_dlc(msg->len & ESD331_DLC_MASK);
+
+	for (i = 0; i < cfrm->can_dlc; ++i)
+		cfrm->data[i] = msg->data[i];
+
+	netif_rx(skb);
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,32)
+	dev->last_rx = jiffies;
+#endif
+	stats->rx_packets++;
+	stats->rx_bytes += cfrm->can_dlc;
+}
+
+static void esd331_handle_errmsg(struct net_device *dev,
+					struct esd331_can_msg *msg)
+{
+	struct esd331_priv *priv = netdev_priv(dev);
+
+	if (msg->id & ESD331_EVENT_MASK)
+		return;
+
+	switch (msg->data[1]) {
+	case ESD331_ERR_OK:
+		if (priv->can.state != CAN_STATE_STOPPED)
+			priv->can.state = CAN_STATE_ERROR_ACTIVE;
+		break;
+
+	case ESD331_ERR_WARN:
+		if ((priv->can.state != CAN_STATE_ERROR_WARNING)
+				&& (priv->can.state != CAN_STATE_STOPPED)) {
+			priv->can.can_stats.error_warning++;
+			priv->can.state = CAN_STATE_ERROR_WARNING;
+
+			/* might be RX warning, too... */
+			esd331_create_err_frame(dev, CAN_ERR_CRTL,
+						CAN_ERR_CRTL_TX_WARNING);
+		}
+		break;
+
+	case ESD331_ERR_BUSOFF1:
+	case ESD331_ERR_BUSOFF2:
+		if ((priv->can.state != CAN_STATE_BUS_OFF)
+				&& (priv->can.state != CAN_STATE_STOPPED)) {
+			priv->can.state = CAN_STATE_BUS_OFF;
+			esd331_create_err_frame(dev, CAN_ERR_BUSOFF, 0);
+			can_bus_off(dev);
+		}
+		break;
+
+	default:
+		break;
+	}
+
+}
+
+static void esd331_handle_messages(struct esd331_pci *board)
+{
+	struct net_device *dev;
+	struct esd331_priv *priv;
+	struct net_device_stats *stats;
+	struct esd331_can_msg msg;
+	int msg_count = ESD331_MAX_INTERRUPT_WORK;
+
+	while ((esd331_read(&msg, board) == 0) && (msg_count--)) {
+		if (unlikely((msg.net >= ESD331_MAX_CAN)
+				|| (board->dev[msg.net] == NULL)))
+			continue;
+
+		dev = board->dev[msg.net];
+		priv = netdev_priv(dev);
+		if (priv->can.state == CAN_STATE_STOPPED)
+			continue;
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,23)
+		stats = can_get_stats(dev);
+#else
+		stats = &dev->stats;
+#endif
+		switch (msg.cmmd) {
+
+		case ESD331_I20_BCAN:
+		case ESD331_I20_EX_BCAN:
+			esd331_irq_rx(dev, &msg,
+					(msg.cmmd == ESD331_I20_EX_BCAN));
+			break;
+
+		case ESD331_I20_TXDONE:
+		case ESD331_I20_EX_TXDONE:
+			stats->tx_packets++;
+			stats->tx_bytes += msg.x1;
+			can_get_echo_skb(dev, 0);
+			netif_wake_queue(dev);
+			break;
+
+		case ESD331_I20_TXTOUT:
+		case ESD331_I20_EX_TXTOUT:
+			stats->tx_errors++;
+			stats->tx_dropped++;
+			can_free_echo_skb(dev, 0);
+			netif_wake_queue(dev);
+			break;
+
+		case ESD331_I20_ERROR:
+			esd331_handle_errmsg(dev, &msg);
+			break;
+
+		default:
+			break;
+		}
+	}
+}
+
+static int esd331_all_nets_stopped(struct esd331_pci *board)
+{
+	int i;
+
+	for (i = 0; i < ESD331_MAX_CAN; i++) {
+		if (board->dev[i] == NULL) {
+			break;
+		} else {
+			struct esd331_priv *priv = netdev_priv(board->dev[i]);
+
+			if (priv->can.state != CAN_STATE_STOPPED)
+				return 0;
+		}
+	}
+
+	return 1;
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,19)
+irqreturn_t esd331_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+#else
+irqreturn_t esd331_interrupt(int irq, void *dev_id)
+#endif
+{
+	struct esd331_pci *board = (struct esd331_pci *)dev_id;
+	void __iomem *ics = board->conf_addr + ESD331_CONF_OFFS_ICS;
+
+	if (!(readl(ics) & ESD331_IRQ_FLAG))
+		return IRQ_NONE;
+
+	writew(0xffff, board->base_addr2 + ESD331_OFFS_IRQ_ACK);
+	esd331_handle_messages(board);
+
+	return IRQ_HANDLED;
+}
+
+/* also enables interrupt when no other net on card is openened yet */
+static int esd331_open(struct net_device *dev)
+{
+	struct esd331_priv *priv = netdev_priv(dev);
+	int err;
+
+	err = open_candev(dev);
+	if (err)
+		return err;
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,23)
+	memset(&priv->can.net_stats, 0, sizeof(priv->can.net_stats));
+#endif
+
+	if (esd331_all_nets_stopped(priv->board))
+		esd331_enable_irq(priv->board->conf_addr);
+
+	priv->can.state = CAN_STATE_ERROR_ACTIVE;
+	netif_start_queue(dev);
+
+	return 0;
+}
+
+/* also disables interrupt when all other nets on card are closed already*/
+static int esd331_close(struct net_device *dev)
+{
+	struct esd331_priv *priv = netdev_priv(dev);
+
+	priv->can.state = CAN_STATE_STOPPED;
+	netif_stop_queue(dev);
+	close_candev(dev);
+
+	if (esd331_all_nets_stopped(priv->board))
+		esd331_disable_irq(priv->board->conf_addr);
+
+	return 0;
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,32)
+static int esd331_start_xmit(struct sk_buff *skb, struct net_device *dev)
+#else
+static netdev_tx_t esd331_start_xmit(struct sk_buff *skb,
+					struct net_device *dev)
+#endif
+{
+	struct esd331_priv *priv = netdev_priv(dev);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,23)
+	struct net_device_stats *stats = can_get_stats(dev);
+#else
+	struct net_device_stats *stats = &dev->stats;
+#endif
+	struct can_frame *cf = (struct can_frame *)skb->data;
+	struct esd331_can_msg msg;
+	int i;
+
+	if (can_dropped_invalid_skb(dev, skb))
+		return NETDEV_TX_OK;
+
+	if ((cf->can_id & CAN_EFF_FLAG) && (priv->board->eff_supp == 0)) {
+		stats->tx_dropped++;
+		kfree_skb(skb);
+		return NETDEV_TX_OK;
+	}
+
+	memset(&msg, 0, sizeof(msg));
+	if (cf->can_id & CAN_EFF_FLAG) {
+		msg.cmmd = ESD331_I20_EX_BCAN;
+		msg.id = cpu_to_be16((cf->can_id & CAN_EFF_MASK) >> 16);
+		msg.x2 = cpu_to_be16(cf->can_id & CAN_EFF_MASK);
+	} else {
+		msg.cmmd = ESD331_I20_BCAN;
+		msg.id = cpu_to_be16(cf->can_id & CAN_EFF_MASK);
+	}
+	msg.x1 = cpu_to_be16(cf->can_dlc);
+	msg.net = priv->boards_net;
+	msg.len = cpu_to_be16((cf->can_id & CAN_RTR_FLAG) ?
+				cf->can_dlc | ESD331_RTR_FLAG : cf->can_dlc);
+
+	for (i = 0; i < cf->can_dlc; i++)
+		msg.data[i] = cf->data[i];
+
+	can_put_echo_skb(skb, dev, 0);
+	if (unlikely(esd331_write(&msg, priv->board))) {
+		can_free_echo_skb(dev, 0);
+		dev_err(ND2D(dev), "Couldn't write frame to card's FIFO!\n");
+		stats->tx_dropped++;
+		return NETDEV_TX_OK;
+	}
+
+	netif_stop_queue(dev);
+	dev->trans_start = jiffies;
+
+	return NETDEV_TX_OK;
+}
+
+static int esd331_set_bittiming(struct net_device *dev)
+{
+	struct esd331_priv *priv = netdev_priv(dev);
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(esd331_baud_table); i++) {
+		if (priv->can.bittiming.bitrate == esd331_baud_table[i].rate) {
+			return esd331_write_baud(priv->boards_net,
+				esd331_baud_table[i].index, priv->board);
+		}
+	}
+
+	return -EINVAL;
+}
+
+static int esd331_set_mode(struct net_device *dev, enum can_mode mode)
+{
+	struct esd331_priv *priv = netdev_priv(dev);
+
+	switch (mode) {
+	case CAN_MODE_START:
+		priv->can.state = CAN_STATE_ERROR_ACTIVE;
+		if (netif_queue_stopped(dev))
+			netif_wake_queue(dev);
+
+		break;
+
+	default:
+		return -EOPNOTSUPP;
+	}
+
+	return 0;
+}
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,28)
+static const struct net_device_ops esd331_netdev_ops = {
+	.ndo_open = esd331_open,
+	.ndo_stop = esd331_close,
+	.ndo_start_xmit = esd331_start_xmit,
+};
+#endif
+
+static struct net_device *__devinit esd331_pci_add_chan(struct pci_dev *pdev,
+		struct esd331_pci *board, u8 boards_net)
+{
+	struct net_device *dev;
+	struct esd331_priv *priv;
+	int err;
+
+	dev = alloc_candev(sizeof(*priv), ESD331_ECHO_SKB_MAX);
+	if (dev == NULL)
+		return ERR_PTR(-ENOMEM);
+
+	priv = netdev_priv(dev);
+	priv->boards_net = boards_net;
+	priv->board = board;
+
+	SET_NETDEV_DEV(dev, &pdev->dev);
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,28)
+	dev->netdev_ops = &esd331_netdev_ops;
+#else
+	dev->open = esd331_open;
+	dev->stop = esd331_close;
+	dev->hard_start_xmit = esd331_start_xmit;
+#endif
+
+	dev->irq = pdev->irq;
+	/* Set and enable PCI interrupts */
+	dev->flags |= IFF_ECHO;
+
+	priv->can.do_set_bittiming = esd331_set_bittiming;
+	priv->can.do_set_mode = esd331_set_mode;
+	priv->can.ctrlmode_supported = CAN_CTRLMODE_3_SAMPLES;
+
+	err = register_candev(dev);
+	if (err) {
+		dev_err(&pdev->dev, "registering candev failed\n");
+		free_netdev(dev);
+		return ERR_PTR(err);
+	}
+
+	dev_info(&pdev->dev, "device %s registered\n", dev->name);
+
+	return dev;
+}
+
+static int __devinit esd331_pci_init_one(struct pci_dev *pdev,
+		const struct pci_device_id *ent)
+{
+	struct esd331_pci *board;
+	int err;
+	int i;
+	int read_features = 0;
+
+	dev_info(&pdev->dev,
+			"Initializing device %04x:%04x %04x:%04x\n",
+			pdev->vendor, pdev->device,
+			pdev->subsystem_vendor, pdev->subsystem_device);
+
+	board = kzalloc(sizeof(*board), GFP_KERNEL);
+	if (board == NULL)
+		return -ENOMEM;
+
+	err = pci_enable_device(pdev);
+	if (err)
+		goto failure;
+
+	err = pci_request_regions(pdev, DRV_NAME);
+	if (err)
+		goto failure;
+
+	board->conf_addr = pci_iomap(pdev, 0, 0);
+	if (board->conf_addr == NULL) {
+		err = -ENODEV;
+		goto failure_release_pci;
+	}
+	board->base_addr1 = pci_iomap(pdev, 2, 0);
+	if (board->base_addr1 == NULL) {
+		err = -ENODEV;
+		goto failure_iounmap_conf;
+	}
+	board->base_addr2 = pci_iomap(pdev, 3, 0);
+	if (board->base_addr2 == NULL) {
+		err = -ENODEV;
+		goto failure_iounmap_base1;
+	}
+
+	spin_lock_init(&board->irq_lock);
+
+retry_features:
+	board->dpr = esd331_init_pointer(board->base_addr1);
+	err = esd331_read_features(board);
+	if (err) {
+		/* esd331_read_features() works only after board reset */
+		/* So if failed: reset board and retry: */
+		if (!read_features) {
+			read_features++;
+			esd331_reset(board->conf_addr, 1);
+			goto retry_features;
+		}
+
+		goto failure_iounmap_base2;
+	}
+
+	for (i = 0; i < board->net_count; ++i) {
+		board->dev[i] = esd331_pci_add_chan(pdev, board, i);
+		if (IS_ERR(board->dev[i])) {
+			err = PTR_ERR(board->dev[i]);
+			goto failure_iounmap_base2;
+		}
+		if (esd331_write_allid(i, board)) {
+			dev_err(&pdev->dev, "device %s failed to enable all "
+						"IDs\n", board->dev[i]->name);
+		}
+	}
+
+	if (esd331_write_fast(board))
+		dev_err(&pdev->dev, "failed to enable fast mode\n");
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,18)
+	err = request_irq(pdev->irq, &esd331_interrupt, SA_SHIRQ, "pci331",
+			(void *)board);
+#else
+	err = request_irq(pdev->irq, &esd331_interrupt, IRQF_SHARED, "pci331",
+			(void *)board);
+#endif
+	if (err) {
+		err = -EAGAIN;
+		goto failure_iounmap_base2;
+	}
+	pci_set_drvdata(pdev, board);
+	return 0;
+
+failure_iounmap_base2:
+	pci_iounmap(pdev, board->base_addr2);
+
+failure_iounmap_base1:
+	pci_iounmap(pdev, board->base_addr1);
+
+failure_iounmap_conf:
+	pci_iounmap(pdev, board->conf_addr);
+
+failure_release_pci:
+	pci_release_regions(pdev);
+
+failure:
+	kfree(board);
+
+	return err;
+}
+
+static void __devexit esd331_pci_remove_one(struct pci_dev *pdev)
+{
+	struct esd331_pci *board = pci_get_drvdata(pdev);
+	int i;
+
+	esd331_disable_irq(board->conf_addr);
+	free_irq(pdev->irq, (void *)board);
+
+	for (i = 0; i < ESD331_MAX_CAN; i++) {
+		if (board->dev[i] == NULL)
+			break;
+
+		unregister_candev(board->dev[i]);
+		free_netdev(board->dev[i]);
+	}
+
+	esd331_reset(board->conf_addr, 0); /* 0 = No wait for restart here */
+	/* If module is reloaded too early, it will try a reset with waiting */
+
+	pci_iounmap(pdev, board->base_addr2);
+	pci_iounmap(pdev, board->base_addr1);
+	pci_iounmap(pdev, board->conf_addr);
+	pci_release_regions(pdev);
+
+	pci_disable_device(pdev);
+	pci_set_drvdata(pdev, NULL);
+
+	kfree(board);
+}
+
+static struct pci_driver esd331_pci_driver = {
+	.name = DRV_NAME,
+	.id_table = esd331_pci_tbl,
+	.probe = esd331_pci_init_one,
+	.remove = __devexit_p(esd331_pci_remove_one), };
+
+static int __init esd331_pci_init(void)
+{
+	printk(KERN_INFO "%s CAN netdevice driver\n", DRV_NAME);
+	return pci_register_driver(&esd331_pci_driver);
+}
+
+static void __exit esd331_pci_exit(void)
+{
+	pci_unregister_driver(&esd331_pci_driver);
+	printk(KERN_INFO "%s driver removed\n", DRV_NAME);
+}
+
+module_init(esd331_pci_init);
+module_exit(esd331_pci_exit);
diff --exclude CVS --exclude .git -uNr linux-2.6.27.8/drivers/net/can/mcp251x.c linux-2.6.27.8.modified/drivers/net/can/mcp251x.c
--- linux-2.6.27.8/drivers/net/can/mcp251x.c	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.27.8.modified/drivers/net/can/mcp251x.c	2013-05-30 03:44:17.000000000 -0400
@@ -0,0 +1,1158 @@
+/*
+ * CAN bus driver for Microchip 251x CAN Controller with SPI Interface
+ *
+ * MCP2510 support and bug fixes by Christian Pellegrin
+ * <chripell@evolware.org>
+ *
+ * Copyright 2009 Christian Pellegrin EVOL S.r.l.
+ *
+ * Copyright 2007 Raymarine UK, Ltd. All Rights Reserved.
+ * Written under contract by:
+ *   Chris Elston, Katalix Systems, Ltd.
+ *
+ * Based on Microchip MCP251x CAN controller driver written by
+ * David Vrabel, Copyright 2006 Arcom Control Systems Ltd.
+ *
+ * Based on CAN bus driver for the CCAN controller written by
+ * - Sascha Hauer, Marc Kleine-Budde, Pengutronix
+ * - Simon Kallweit, intefo AG
+ * Copyright 2007
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the version 2 of the GNU General Public License
+ * as published by the Free Software Foundation
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ *
+ *
+ * Your platform definition file should specify something like:
+ *
+ * static struct mcp251x_platform_data mcp251x_info = {
+ *         .oscillator_frequency = 8000000,
+ *         .board_specific_setup = &mcp251x_setup,
+ *         .model = CAN_MCP251X_MCP2510,
+ *         .power_enable = mcp251x_power_enable,
+ *         .transceiver_enable = NULL,
+ * };
+ *
+ * static struct spi_board_info spi_board_info[] = {
+ *         {
+ *                 .modalias = "mcp251x",
+ *                 .platform_data = &mcp251x_info,
+ *                 .irq = IRQ_EINT13,
+ *                 .max_speed_hz = 2*1000*1000,
+ *                 .chip_select = 2,
+ *         },
+ * };
+ *
+ * Please see mcp251x.h for a description of the fields in
+ * struct mcp251x_platform_data.
+ *
+ */
+
+#include <linux/completion.h>
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <linux/dma-mapping.h>
+#include <linux/freezer.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/netdevice.h>
+#include <linux/platform_device.h>
+#include <linux/spi/spi.h>
+#include <linux/uaccess.h>
+#include <socketcan/can.h>
+#include <socketcan/can/core.h>
+#include <socketcan/can/dev.h>
+#include <socketcan/can/platform/mcp251x.h>
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,22)
+#error This driver does not support Kernel versions < 2.6.22
+#endif
+
+/* SPI interface instruction set */
+#define INSTRUCTION_WRITE	0x02
+#define INSTRUCTION_READ	0x03
+#define INSTRUCTION_BIT_MODIFY	0x05
+#define INSTRUCTION_LOAD_TXB(n)	(0x40 + 2 * (n))
+#define INSTRUCTION_READ_RXB(n)	(((n) == 0) ? 0x90 : 0x94)
+#define INSTRUCTION_RESET	0xC0
+
+/* MPC251x registers */
+#define CANSTAT	      0x0e
+#define CANCTRL	      0x0f
+#  define CANCTRL_REQOP_MASK	    0xe0
+#  define CANCTRL_REQOP_CONF	    0x80
+#  define CANCTRL_REQOP_LISTEN_ONLY 0x60
+#  define CANCTRL_REQOP_LOOPBACK    0x40
+#  define CANCTRL_REQOP_SLEEP	    0x20
+#  define CANCTRL_REQOP_NORMAL	    0x00
+#  define CANCTRL_OSM		    0x08
+#  define CANCTRL_ABAT		    0x10
+#define TEC	      0x1c
+#define REC	      0x1d
+#define CNF1	      0x2a
+#  define CNF1_SJW_SHIFT   6
+#define CNF2	      0x29
+#  define CNF2_BTLMODE	   0x80
+#  define CNF2_SAM         0x40
+#  define CNF2_PS1_SHIFT   3
+#define CNF3	      0x28
+#  define CNF3_SOF	   0x08
+#  define CNF3_WAKFIL	   0x04
+#  define CNF3_PHSEG2_MASK 0x07
+#define CANINTE	      0x2b
+#  define CANINTE_MERRE 0x80
+#  define CANINTE_WAKIE 0x40
+#  define CANINTE_ERRIE 0x20
+#  define CANINTE_TX2IE 0x10
+#  define CANINTE_TX1IE 0x08
+#  define CANINTE_TX0IE 0x04
+#  define CANINTE_RX1IE 0x02
+#  define CANINTE_RX0IE 0x01
+#define CANINTF	      0x2c
+#  define CANINTF_MERRF 0x80
+#  define CANINTF_WAKIF 0x40
+#  define CANINTF_ERRIF 0x20
+#  define CANINTF_TX2IF 0x10
+#  define CANINTF_TX1IF 0x08
+#  define CANINTF_TX0IF 0x04
+#  define CANINTF_RX1IF 0x02
+#  define CANINTF_RX0IF 0x01
+#define EFLG	      0x2d
+#  define EFLG_EWARN	0x01
+#  define EFLG_RXWAR	0x02
+#  define EFLG_TXWAR	0x04
+#  define EFLG_RXEP	0x08
+#  define EFLG_TXEP	0x10
+#  define EFLG_TXBO	0x20
+#  define EFLG_RX0OVR	0x40
+#  define EFLG_RX1OVR	0x80
+#define TXBCTRL(n)  (((n) * 0x10) + 0x30 + TXBCTRL_OFF)
+#  define TXBCTRL_ABTF	0x40
+#  define TXBCTRL_MLOA	0x20
+#  define TXBCTRL_TXERR 0x10
+#  define TXBCTRL_TXREQ 0x08
+#define TXBSIDH(n)  (((n) * 0x10) + 0x30 + TXBSIDH_OFF)
+#  define SIDH_SHIFT    3
+#define TXBSIDL(n)  (((n) * 0x10) + 0x30 + TXBSIDL_OFF)
+#  define SIDL_SID_MASK    7
+#  define SIDL_SID_SHIFT   5
+#  define SIDL_EXIDE_SHIFT 3
+#  define SIDL_EID_SHIFT   16
+#  define SIDL_EID_MASK    3
+#define TXBEID8(n)  (((n) * 0x10) + 0x30 + TXBEID8_OFF)
+#define TXBEID0(n)  (((n) * 0x10) + 0x30 + TXBEID0_OFF)
+#define TXBDLC(n)   (((n) * 0x10) + 0x30 + TXBDLC_OFF)
+#  define DLC_RTR_SHIFT    6
+#define TXBCTRL_OFF 0
+#define TXBSIDH_OFF 1
+#define TXBSIDL_OFF 2
+#define TXBEID8_OFF 3
+#define TXBEID0_OFF 4
+#define TXBDLC_OFF  5
+#define TXBDAT_OFF  6
+#define RXBCTRL(n)  (((n) * 0x10) + 0x60 + RXBCTRL_OFF)
+#  define RXBCTRL_BUKT	0x04
+#  define RXBCTRL_RXM0	0x20
+#  define RXBCTRL_RXM1	0x40
+#define RXBSIDH(n)  (((n) * 0x10) + 0x60 + RXBSIDH_OFF)
+#  define RXBSIDH_SHIFT 3
+#define RXBSIDL(n)  (((n) * 0x10) + 0x60 + RXBSIDL_OFF)
+#  define RXBSIDL_IDE   0x08
+#  define RXBSIDL_EID   3
+#  define RXBSIDL_SHIFT 5
+#define RXBEID8(n)  (((n) * 0x10) + 0x60 + RXBEID8_OFF)
+#define RXBEID0(n)  (((n) * 0x10) + 0x60 + RXBEID0_OFF)
+#define RXBDLC(n)   (((n) * 0x10) + 0x60 + RXBDLC_OFF)
+#  define RXBDLC_LEN_MASK  0x0f
+#  define RXBDLC_RTR       0x40
+#define RXBCTRL_OFF 0
+#define RXBSIDH_OFF 1
+#define RXBSIDL_OFF 2
+#define RXBEID8_OFF 3
+#define RXBEID0_OFF 4
+#define RXBDLC_OFF  5
+#define RXBDAT_OFF  6
+
+#define GET_BYTE(val, byte)			\
+	(((val) >> ((byte) * 8)) & 0xff)
+#define SET_BYTE(val, byte)			\
+	(((val) & 0xff) << ((byte) * 8))
+
+/*
+ * Buffer size required for the largest SPI transfer (i.e., reading a
+ * frame)
+ */
+#define CAN_FRAME_MAX_DATA_LEN	8
+#define SPI_TRANSFER_BUF_LEN	(6 + CAN_FRAME_MAX_DATA_LEN)
+#define CAN_FRAME_MAX_BITS	128
+
+#define TX_ECHO_SKB_MAX	1
+
+#define DEVICE_NAME "mcp251x"
+
+static int mcp251x_enable_dma; /* Enable SPI DMA. Default: 0 (Off) */
+module_param(mcp251x_enable_dma, int, S_IRUGO);
+MODULE_PARM_DESC(mcp251x_enable_dma, "Enable SPI DMA. Default: 0 (Off)");
+
+static struct can_bittiming_const mcp251x_bittiming_const = {
+	.name = DEVICE_NAME,
+	.tseg1_min = 3,
+	.tseg1_max = 16,
+	.tseg2_min = 2,
+	.tseg2_max = 8,
+	.sjw_max = 4,
+	.brp_min = 1,
+	.brp_max = 64,
+	.brp_inc = 1,
+};
+
+struct mcp251x_priv {
+	struct can_priv	   can;
+	struct net_device *net;
+	struct spi_device *spi;
+
+	struct mutex spi_lock; /* SPI buffer lock */
+	u8 *spi_tx_buf;
+	u8 *spi_rx_buf;
+	dma_addr_t spi_tx_dma;
+	dma_addr_t spi_rx_dma;
+
+	struct sk_buff *tx_skb;
+	int tx_len;
+	struct workqueue_struct *wq;
+	struct work_struct tx_work;
+	struct work_struct irq_work;
+
+	int force_quit;
+	int after_suspend;
+#define AFTER_SUSPEND_UP 1
+#define AFTER_SUSPEND_DOWN 2
+#define AFTER_SUSPEND_POWER 4
+#define AFTER_SUSPEND_RESTART 8
+	int restart_tx;
+};
+
+static void mcp251x_clean(struct net_device *net)
+{
+	struct mcp251x_priv *priv = netdev_priv(net);
+
+	net->stats.tx_errors++;
+	if (priv->tx_skb)
+		dev_kfree_skb(priv->tx_skb);
+	if (priv->tx_len)
+		can_free_echo_skb(priv->net, 0);
+	priv->tx_skb = NULL;
+	priv->tx_len = 0;
+}
+
+/*
+ * Note about handling of error return of mcp251x_spi_trans: accessing
+ * registers via SPI is not really different conceptually than using
+ * normal I/O assembler instructions, although it's much more
+ * complicated from a practical POV. So it's not advisable to always
+ * check the return value of this function. Imagine that every
+ * read{b,l}, write{b,l} and friends would be bracketed in "if ( < 0)
+ * error();", it would be a great mess (well there are some situation
+ * when exception handling C++ like could be useful after all). So we
+ * just check that transfers are OK at the beginning of our
+ * conversation with the chip and to avoid doing really nasty things
+ * (like injecting bogus packets in the network stack).
+ */
+static int mcp251x_spi_trans(struct spi_device *spi, int len)
+{
+	struct mcp251x_priv *priv = dev_get_drvdata(&spi->dev);
+	struct spi_transfer t = {
+		.tx_buf = priv->spi_tx_buf,
+		.rx_buf = priv->spi_rx_buf,
+		.len = len,
+		.cs_change = 0,
+	};
+	struct spi_message m;
+	int ret;
+
+	spi_message_init(&m);
+
+	if (mcp251x_enable_dma) {
+		t.tx_dma = priv->spi_tx_dma;
+		t.rx_dma = priv->spi_rx_dma;
+		m.is_dma_mapped = 1;
+	}
+
+	spi_message_add_tail(&t, &m);
+
+	ret = spi_sync(spi, &m);
+	if (ret)
+		dev_err(&spi->dev, "spi transfer failed: ret = %d\n", ret);
+	return ret;
+}
+
+static u8 mcp251x_read_reg(struct spi_device *spi, uint8_t reg)
+{
+	struct mcp251x_priv *priv = dev_get_drvdata(&spi->dev);
+	u8 val = 0;
+
+	mutex_lock(&priv->spi_lock);
+
+	priv->spi_tx_buf[0] = INSTRUCTION_READ;
+	priv->spi_tx_buf[1] = reg;
+
+	mcp251x_spi_trans(spi, 3);
+	val = priv->spi_rx_buf[2];
+
+	mutex_unlock(&priv->spi_lock);
+
+	return val;
+}
+
+static void mcp251x_write_reg(struct spi_device *spi, u8 reg, uint8_t val)
+{
+	struct mcp251x_priv *priv = dev_get_drvdata(&spi->dev);
+
+	mutex_lock(&priv->spi_lock);
+
+	priv->spi_tx_buf[0] = INSTRUCTION_WRITE;
+	priv->spi_tx_buf[1] = reg;
+	priv->spi_tx_buf[2] = val;
+
+	mcp251x_spi_trans(spi, 3);
+
+	mutex_unlock(&priv->spi_lock);
+}
+
+static void mcp251x_write_bits(struct spi_device *spi, u8 reg,
+			       u8 mask, uint8_t val)
+{
+	struct mcp251x_priv *priv = dev_get_drvdata(&spi->dev);
+
+	mutex_lock(&priv->spi_lock);
+
+	priv->spi_tx_buf[0] = INSTRUCTION_BIT_MODIFY;
+	priv->spi_tx_buf[1] = reg;
+	priv->spi_tx_buf[2] = mask;
+	priv->spi_tx_buf[3] = val;
+
+	mcp251x_spi_trans(spi, 4);
+
+	mutex_unlock(&priv->spi_lock);
+}
+
+static void mcp251x_hw_tx_frame(struct spi_device *spi, u8 *buf,
+				int len, int tx_buf_idx)
+{
+	struct mcp251x_platform_data *pdata = spi->dev.platform_data;
+	struct mcp251x_priv *priv = dev_get_drvdata(&spi->dev);
+
+	if (pdata->model == CAN_MCP251X_MCP2510) {
+		int i;
+
+		for (i = 1; i < TXBDAT_OFF + len; i++)
+			mcp251x_write_reg(spi, TXBCTRL(tx_buf_idx) + i,
+					  buf[i]);
+	} else {
+		mutex_lock(&priv->spi_lock);
+
+		memcpy(priv->spi_tx_buf, buf, TXBDAT_OFF + len);
+		mcp251x_spi_trans(spi, TXBDAT_OFF + len);
+
+		mutex_unlock(&priv->spi_lock);
+	}
+}
+
+static void mcp251x_hw_tx(struct spi_device *spi, struct can_frame *frame,
+			  int tx_buf_idx)
+{
+	u32 sid, eid, exide, rtr;
+	u8 buf[SPI_TRANSFER_BUF_LEN];
+
+	exide = (frame->can_id & CAN_EFF_FLAG) ? 1 : 0; /* Extended ID Enable */
+	if (exide)
+		sid = (frame->can_id & CAN_EFF_MASK) >> 18;
+	else
+		sid = frame->can_id & CAN_SFF_MASK; /* Standard ID */
+	eid = frame->can_id & CAN_EFF_MASK; /* Extended ID */
+	rtr = (frame->can_id & CAN_RTR_FLAG) ? 1 : 0; /* Remote transmission */
+
+	buf[TXBCTRL_OFF] = INSTRUCTION_LOAD_TXB(tx_buf_idx);
+	buf[TXBSIDH_OFF] = sid >> SIDH_SHIFT;
+	buf[TXBSIDL_OFF] = ((sid & SIDL_SID_MASK) << SIDL_SID_SHIFT) |
+		(exide << SIDL_EXIDE_SHIFT) |
+		((eid >> SIDL_EID_SHIFT) & SIDL_EID_MASK);
+	buf[TXBEID8_OFF] = GET_BYTE(eid, 1);
+	buf[TXBEID0_OFF] = GET_BYTE(eid, 0);
+	buf[TXBDLC_OFF] = (rtr << DLC_RTR_SHIFT) | frame->can_dlc;
+	memcpy(buf + TXBDAT_OFF, frame->data, frame->can_dlc);
+	mcp251x_hw_tx_frame(spi, buf, frame->can_dlc, tx_buf_idx);
+	mcp251x_write_reg(spi, TXBCTRL(tx_buf_idx), TXBCTRL_TXREQ);
+}
+
+static void mcp251x_hw_rx_frame(struct spi_device *spi, u8 *buf,
+				int buf_idx)
+{
+	struct mcp251x_priv *priv = dev_get_drvdata(&spi->dev);
+	struct mcp251x_platform_data *pdata = spi->dev.platform_data;
+
+	if (pdata->model == CAN_MCP251X_MCP2510) {
+		int i, len;
+
+		for (i = 1; i < RXBDAT_OFF; i++)
+			buf[i] = mcp251x_read_reg(spi, RXBCTRL(buf_idx) + i);
+
+		len = get_can_dlc(buf[RXBDLC_OFF] & RXBDLC_LEN_MASK);
+		for (; i < (RXBDAT_OFF + len); i++)
+			buf[i] = mcp251x_read_reg(spi, RXBCTRL(buf_idx) + i);
+	} else {
+		mutex_lock(&priv->spi_lock);
+
+		priv->spi_tx_buf[RXBCTRL_OFF] = INSTRUCTION_READ_RXB(buf_idx);
+		mcp251x_spi_trans(spi, SPI_TRANSFER_BUF_LEN);
+		memcpy(buf, priv->spi_rx_buf, SPI_TRANSFER_BUF_LEN);
+
+		mutex_unlock(&priv->spi_lock);
+	}
+}
+
+static void mcp251x_hw_rx(struct spi_device *spi, int buf_idx)
+{
+	struct mcp251x_priv *priv = dev_get_drvdata(&spi->dev);
+	struct sk_buff *skb;
+	struct can_frame *frame;
+	u8 buf[SPI_TRANSFER_BUF_LEN];
+
+	skb = alloc_can_skb(priv->net, &frame);
+	if (!skb) {
+		dev_err(&spi->dev, "cannot allocate RX skb\n");
+		priv->net->stats.rx_dropped++;
+		return;
+	}
+
+	mcp251x_hw_rx_frame(spi, buf, buf_idx);
+	if (buf[RXBSIDL_OFF] & RXBSIDL_IDE) {
+		/* Extended ID format */
+		frame->can_id = CAN_EFF_FLAG;
+		frame->can_id |=
+			/* Extended ID part */
+			SET_BYTE(buf[RXBSIDL_OFF] & RXBSIDL_EID, 2) |
+			SET_BYTE(buf[RXBEID8_OFF], 1) |
+			SET_BYTE(buf[RXBEID0_OFF], 0) |
+			/* Standard ID part */
+			(((buf[RXBSIDH_OFF] << RXBSIDH_SHIFT) |
+			  (buf[RXBSIDL_OFF] >> RXBSIDL_SHIFT)) << 18);
+		/* Remote transmission request */
+		if (buf[RXBDLC_OFF] & RXBDLC_RTR)
+			frame->can_id |= CAN_RTR_FLAG;
+	} else {
+		/* Standard ID format */
+		frame->can_id =
+			(buf[RXBSIDH_OFF] << RXBSIDH_SHIFT) |
+			(buf[RXBSIDL_OFF] >> RXBSIDL_SHIFT);
+	}
+	/* Data length */
+	frame->can_dlc = get_can_dlc(buf[RXBDLC_OFF] & RXBDLC_LEN_MASK);
+	memcpy(frame->data, buf + RXBDAT_OFF, frame->can_dlc);
+
+	priv->net->stats.rx_packets++;
+	priv->net->stats.rx_bytes += frame->can_dlc;
+	netif_rx(skb);
+}
+
+static void mcp251x_hw_sleep(struct spi_device *spi)
+{
+	mcp251x_write_reg(spi, CANCTRL, CANCTRL_REQOP_SLEEP);
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,32)
+static int mcp251x_hard_start_xmit(struct sk_buff *skb, struct net_device *net)
+#else
+static netdev_tx_t mcp251x_hard_start_xmit(struct sk_buff *skb,
+					   struct net_device *net)
+#endif
+{
+	struct mcp251x_priv *priv = netdev_priv(net);
+	struct spi_device *spi = priv->spi;
+
+	if (priv->tx_skb || priv->tx_len) {
+		dev_warn(&spi->dev, "hard_xmit called while tx busy\n");
+		netif_stop_queue(net);
+		return NETDEV_TX_BUSY;
+	}
+
+	if (can_dropped_invalid_skb(net, skb))
+		return NETDEV_TX_OK;
+
+	netif_stop_queue(net);
+	priv->tx_skb = skb;
+	net->trans_start = jiffies;
+	queue_work(priv->wq, &priv->tx_work);
+
+	return NETDEV_TX_OK;
+}
+
+static int mcp251x_do_set_mode(struct net_device *net, enum can_mode mode)
+{
+	struct mcp251x_priv *priv = netdev_priv(net);
+
+	switch (mode) {
+	case CAN_MODE_START:
+		/* We have to delay work since SPI I/O may sleep */
+		priv->can.state = CAN_STATE_ERROR_ACTIVE;
+		priv->restart_tx = 1;
+		if (priv->can.restart_ms == 0)
+			priv->after_suspend = AFTER_SUSPEND_RESTART;
+		queue_work(priv->wq, &priv->irq_work);
+		break;
+	default:
+		return -EOPNOTSUPP;
+	}
+
+	return 0;
+}
+
+static void mcp251x_set_normal_mode(struct spi_device *spi)
+{
+	struct mcp251x_platform_data *pdata = spi->dev.platform_data;
+	struct mcp251x_priv *priv = dev_get_drvdata(&spi->dev);
+	unsigned long timeout;
+
+	/* Enable interrupts */
+	mcp251x_write_reg(spi, CANINTE,
+			  CANINTE_ERRIE | CANINTE_TX2IE | CANINTE_TX1IE |
+			  CANINTE_TX0IE | CANINTE_RX1IE | CANINTE_RX0IE);
+
+	if (priv->can.ctrlmode & CAN_CTRLMODE_LOOPBACK) {
+		/* Put device into loopback mode */
+		mcp251x_write_reg(spi, CANCTRL, CANCTRL_REQOP_LOOPBACK);
+	} else if (priv->can.ctrlmode & CAN_CTRLMODE_LISTENONLY) {
+		/* Put device into listen-only mode */
+		mcp251x_write_reg(spi, CANCTRL, CANCTRL_REQOP_LISTEN_ONLY);
+ 	} else {
+		/* Put device into normal mode */
+		mcp251x_write_reg(spi, CANCTRL, CANCTRL_REQOP_NORMAL |
+				  ((pdata->model == CAN_MCP251X_MCP2515 &&
+				    priv->can.ctrlmode & CAN_CTRLMODE_ONE_SHOT) ?
+				   CANCTRL_OSM : 0));
+
+		/* Wait for the device to enter normal mode */
+		timeout = jiffies + HZ;
+		while (mcp251x_read_reg(spi, CANSTAT) & CANCTRL_REQOP_MASK) {
+			schedule();
+			if (time_after(jiffies, timeout)) {
+				dev_err(&spi->dev, "MCP251x didn't"
+					" enter in normal mode\n");
+				return;
+			}
+		}
+	}
+	priv->can.state = CAN_STATE_ERROR_ACTIVE;
+}
+
+static int mcp251x_do_set_bittiming(struct net_device *net)
+{
+	struct mcp251x_priv *priv = netdev_priv(net);
+	struct can_bittiming *bt = &priv->can.bittiming;
+	struct spi_device *spi = priv->spi;
+
+	mcp251x_write_reg(spi, CNF1, ((bt->sjw - 1) << CNF1_SJW_SHIFT) |
+			  (bt->brp - 1));
+	mcp251x_write_reg(spi, CNF2, CNF2_BTLMODE |
+			  (priv->can.ctrlmode & CAN_CTRLMODE_3_SAMPLES ?
+			   CNF2_SAM : 0) |
+			  ((bt->phase_seg1 - 1) << CNF2_PS1_SHIFT) |
+			  (bt->prop_seg - 1));
+	mcp251x_write_bits(spi, CNF3, CNF3_PHSEG2_MASK,
+			   (bt->phase_seg2 - 1));
+	dev_info(&spi->dev, "CNF: 0x%02x 0x%02x 0x%02x\n",
+		 mcp251x_read_reg(spi, CNF1),
+		 mcp251x_read_reg(spi, CNF2),
+		 mcp251x_read_reg(spi, CNF3));
+
+	return 0;
+}
+
+static int mcp251x_setup(struct net_device *net, struct mcp251x_priv *priv,
+			 struct spi_device *spi)
+{
+	mcp251x_do_set_bittiming(net);
+
+	/* Enable RX0->RX1 buffer roll over and disable filters */
+	mcp251x_write_reg(spi, RXBCTRL(0),
+			  RXBCTRL_BUKT | RXBCTRL_RXM0 | RXBCTRL_RXM1);
+	mcp251x_write_reg(spi, RXBCTRL(1),
+			  RXBCTRL_RXM0 | RXBCTRL_RXM1);
+	return 0;
+}
+
+static void mcp251x_hw_reset(struct spi_device *spi)
+{
+	struct mcp251x_priv *priv = dev_get_drvdata(&spi->dev);
+	int ret;
+	unsigned long timeout;
+
+	mutex_lock(&priv->spi_lock);
+
+	priv->spi_tx_buf[0] = INSTRUCTION_RESET;
+
+	ret = spi_write(spi, priv->spi_tx_buf, 1);
+	if (ret)
+		dev_err(&spi->dev, "reset failed: ret = %d\n", ret);
+
+	mutex_unlock(&priv->spi_lock);
+
+	/* Wait for reset to finish */
+	timeout = jiffies + HZ;
+	mdelay(10);
+	while ((mcp251x_read_reg(spi, CANSTAT) & CANCTRL_REQOP_MASK)
+	       != CANCTRL_REQOP_CONF) {
+		schedule();
+		if (time_after(jiffies, timeout)) {
+			dev_err(&spi->dev, "MCP251x didn't"
+				" enter in conf mode after reset\n");
+			break;
+		}
+	}
+}
+
+static int mcp251x_hw_probe(struct spi_device *spi)
+{
+	int st1, st2;
+
+	mcp251x_hw_reset(spi);
+
+	/*
+	 * Please note that these are "magic values" based on after
+	 * reset defaults taken from data sheet which allows us to see
+	 * if we really have a chip on the bus (we avoid common all
+	 * zeroes or all ones situations)
+	 */
+	st1 = mcp251x_read_reg(spi, CANSTAT) & 0xEE;
+	st2 = mcp251x_read_reg(spi, CANCTRL) & 0x17;
+
+	dev_dbg(&spi->dev, "CANSTAT 0x%02x CANCTRL 0x%02x\n", st1, st2);
+
+	/* Check for power up default values */
+	return (st1 == 0x80 && st2 == 0x07) ? 1 : 0;
+}
+
+static irqreturn_t mcp251x_can_isr(int irq, void *dev_id)
+{
+	struct net_device *net = (struct net_device *)dev_id;
+	struct mcp251x_priv *priv = netdev_priv(net);
+
+	/* Schedule bottom half */
+	if (!work_pending(&priv->irq_work))
+		queue_work(priv->wq, &priv->irq_work);
+
+	return IRQ_HANDLED;
+}
+
+static int mcp251x_open(struct net_device *net)
+{
+	struct mcp251x_priv *priv = netdev_priv(net);
+	struct spi_device *spi = priv->spi;
+	struct mcp251x_platform_data *pdata = spi->dev.platform_data;
+	int ret;
+
+	ret = open_candev(net);
+	if (ret) {
+		dev_err(&spi->dev, "unable to set initial baudrate!\n");
+		return ret;
+	}
+
+	if (pdata->transceiver_enable)
+		pdata->transceiver_enable(1);
+
+	priv->force_quit = 0;
+	priv->tx_skb = NULL;
+	priv->tx_len = 0;
+
+	ret = request_irq(spi->irq, mcp251x_can_isr,
+			  IRQF_TRIGGER_FALLING, DEVICE_NAME, net);
+	if (ret) {
+		dev_err(&spi->dev, "failed to acquire irq %d\n", spi->irq);
+		if (pdata->transceiver_enable)
+			pdata->transceiver_enable(0);
+		close_candev(net);
+		return ret;
+	}
+
+	mcp251x_hw_reset(spi);
+	ret = mcp251x_setup(net, priv, spi);
+	if (ret) {
+		free_irq(spi->irq, net);
+		mcp251x_hw_sleep(spi);
+		if (pdata->transceiver_enable)
+			pdata->transceiver_enable(0);
+		close_candev(net);
+		return ret;
+	}
+	mcp251x_set_normal_mode(spi);
+	netif_wake_queue(net);
+
+	return 0;
+}
+
+static int mcp251x_stop(struct net_device *net)
+{
+	struct mcp251x_priv *priv = netdev_priv(net);
+	struct spi_device *spi = priv->spi;
+	struct mcp251x_platform_data *pdata = spi->dev.platform_data;
+
+	close_candev(net);
+
+	/* Disable and clear pending interrupts */
+	mcp251x_write_reg(spi, CANINTE, 0x00);
+	mcp251x_write_reg(spi, CANINTF, 0x00);
+
+	priv->force_quit = 1;
+	free_irq(spi->irq, net);
+	flush_workqueue(priv->wq);
+
+	mcp251x_write_reg(spi, TXBCTRL(0), 0);
+	if (priv->tx_skb || priv->tx_len)
+		mcp251x_clean(net);
+
+	mcp251x_hw_sleep(spi);
+
+	if (pdata->transceiver_enable)
+		pdata->transceiver_enable(0);
+
+	priv->can.state = CAN_STATE_STOPPED;
+
+	return 0;
+}
+
+static void mcp251x_tx_work_handler(struct work_struct *ws)
+{
+	struct mcp251x_priv *priv = container_of(ws, struct mcp251x_priv,
+						 tx_work);
+	struct spi_device *spi = priv->spi;
+	struct net_device *net = priv->net;
+	struct can_frame *frame;
+
+	if (priv->tx_skb) {
+		frame = (struct can_frame *)priv->tx_skb->data;
+
+		if (priv->can.state == CAN_STATE_BUS_OFF) {
+			mcp251x_clean(net);
+			netif_wake_queue(net);
+			return;
+		}
+		if (frame->can_dlc > CAN_FRAME_MAX_DATA_LEN)
+			frame->can_dlc = CAN_FRAME_MAX_DATA_LEN;
+		mcp251x_hw_tx(spi, frame, 0);
+		priv->tx_len = 1 + frame->can_dlc;
+		can_put_echo_skb(priv->tx_skb, net, 0);
+		priv->tx_skb = NULL;
+	}
+}
+
+static void mcp251x_irq_work_handler(struct work_struct *ws)
+{
+	struct mcp251x_priv *priv = container_of(ws, struct mcp251x_priv,
+						 irq_work);
+	struct spi_device *spi = priv->spi;
+	struct net_device *net = priv->net;
+	u8 intf;
+	enum can_state new_state;
+
+	if (priv->after_suspend) {
+		mdelay(10);
+		mcp251x_hw_reset(spi);
+		mcp251x_setup(net, priv, spi);
+		if (priv->after_suspend & AFTER_SUSPEND_RESTART) {
+			mcp251x_set_normal_mode(spi);
+		} else if (priv->after_suspend & AFTER_SUSPEND_UP) {
+			netif_device_attach(net);
+			/* Clean since we lost tx buffer */
+			if (priv->tx_skb || priv->tx_len) {
+				mcp251x_clean(net);
+				netif_wake_queue(net);
+			}
+			mcp251x_set_normal_mode(spi);
+		} else {
+			mcp251x_hw_sleep(spi);
+		}
+		priv->after_suspend = 0;
+	}
+
+	if (priv->can.restart_ms == 0 && priv->can.state == CAN_STATE_BUS_OFF)
+		return;
+
+	while (!priv->force_quit && !freezing(current)) {
+		u8 eflag;
+		int can_id = 0, data1 = 0;
+
+		if (priv->restart_tx) {
+			priv->restart_tx = 0;
+			mcp251x_write_reg(spi, TXBCTRL(0), 0);
+			if (priv->tx_skb || priv->tx_len)
+				mcp251x_clean(net);
+			netif_wake_queue(net);
+			can_id |= CAN_ERR_RESTARTED;
+		}
+
+		intf = mcp251x_read_reg(spi, CANINTF);
+
+		if (intf & CANINTF_RX0IF) {
+			mcp251x_hw_rx(spi, 0);
+			/* Free one buffer ASAP */
+			mcp251x_write_bits(spi, CANINTF, intf & CANINTF_RX0IF, 0x00);
+                }
+
+		if (intf & CANINTF_RX1IF)
+			mcp251x_hw_rx(spi, 1);
+
+		mcp251x_write_bits(spi, CANINTF, intf, 0x00);
+
+		eflag = mcp251x_read_reg(spi, EFLG);
+		mcp251x_write_reg(spi, EFLG, 0x00);
+
+		/* Update can state */
+		if (eflag & EFLG_TXBO) {
+			new_state = CAN_STATE_BUS_OFF;
+			can_id |= CAN_ERR_BUSOFF;
+		} else if (eflag & EFLG_TXEP) {
+			new_state = CAN_STATE_ERROR_PASSIVE;
+			can_id |= CAN_ERR_CRTL;
+			data1 |= CAN_ERR_CRTL_TX_PASSIVE;
+		} else if (eflag & EFLG_RXEP) {
+			new_state = CAN_STATE_ERROR_PASSIVE;
+			can_id |= CAN_ERR_CRTL;
+			data1 |= CAN_ERR_CRTL_RX_PASSIVE;
+		} else if (eflag & EFLG_TXWAR) {
+			new_state = CAN_STATE_ERROR_WARNING;
+			can_id |= CAN_ERR_CRTL;
+			data1 |= CAN_ERR_CRTL_TX_WARNING;
+		} else if (eflag & EFLG_RXWAR) {
+			new_state = CAN_STATE_ERROR_WARNING;
+			can_id |= CAN_ERR_CRTL;
+			data1 |= CAN_ERR_CRTL_RX_WARNING;
+		} else {
+			new_state = CAN_STATE_ERROR_ACTIVE;
+		}
+
+		/* Update can state statistics */
+		switch (priv->can.state) {
+		case CAN_STATE_ERROR_ACTIVE:
+			if (new_state >= CAN_STATE_ERROR_WARNING &&
+			    new_state <= CAN_STATE_BUS_OFF)
+				priv->can.can_stats.error_warning++;
+		case CAN_STATE_ERROR_WARNING:	/* fallthrough */
+			if (new_state >= CAN_STATE_ERROR_PASSIVE &&
+			    new_state <= CAN_STATE_BUS_OFF)
+				priv->can.can_stats.error_passive++;
+			break;
+		default:
+			break;
+		}
+		priv->can.state = new_state;
+
+		if ((intf & CANINTF_ERRIF) || (can_id & CAN_ERR_RESTARTED)) {
+			struct sk_buff *skb;
+			struct can_frame *frame;
+
+			/* Create error frame */
+			skb = alloc_can_err_skb(net, &frame);
+			if (skb) {
+				/* Set error frame flags based on bus state */
+				frame->can_id = can_id;
+				frame->data[1] = data1;
+
+				/* Update net stats for overflows */
+				if (eflag & (EFLG_RX0OVR | EFLG_RX1OVR)) {
+					if (eflag & EFLG_RX0OVR)
+						net->stats.rx_over_errors++;
+					if (eflag & EFLG_RX1OVR)
+						net->stats.rx_over_errors++;
+					frame->can_id |= CAN_ERR_CRTL;
+					frame->data[1] |=
+						CAN_ERR_CRTL_RX_OVERFLOW;
+				}
+
+				netif_rx(skb);
+			} else {
+				dev_info(&spi->dev,
+					 "cannot allocate error skb\n");
+			}
+		}
+
+		if (priv->can.state == CAN_STATE_BUS_OFF) {
+			if (priv->can.restart_ms == 0) {
+				can_bus_off(net);
+				mcp251x_hw_sleep(spi);
+				return;
+			}
+		}
+
+		if (intf == 0)
+			break;
+
+		if (intf & (CANINTF_TX2IF | CANINTF_TX1IF | CANINTF_TX0IF)) {
+			net->stats.tx_packets++;
+			net->stats.tx_bytes += priv->tx_len - 1;
+			if (priv->tx_len) {
+				can_get_echo_skb(net, 0);
+				priv->tx_len = 0;
+			}
+			netif_wake_queue(net);
+		}
+	}
+}
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,28)
+static const struct net_device_ops mcp251x_netdev_ops = {
+	.ndo_open = mcp251x_open,
+	.ndo_stop = mcp251x_stop,
+	.ndo_start_xmit = mcp251x_hard_start_xmit,
+};
+#endif
+
+static int __devinit mcp251x_can_probe(struct spi_device *spi)
+{
+	struct net_device *net;
+	struct mcp251x_priv *priv;
+	struct mcp251x_platform_data *pdata = spi->dev.platform_data;
+	int ret = -ENODEV;
+
+	if (!pdata)
+		/* Platform data is required for osc freq */
+		goto error_out;
+
+	/* Allocate can/net device */
+	net = alloc_candev(sizeof(struct mcp251x_priv), TX_ECHO_SKB_MAX);
+	if (!net) {
+		ret = -ENOMEM;
+		goto error_alloc;
+	}
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,28)
+	net->netdev_ops = &mcp251x_netdev_ops;
+#else
+	net->open = mcp251x_open;
+	net->stop = mcp251x_stop;
+	net->hard_start_xmit = mcp251x_hard_start_xmit;
+#endif
+	net->flags |= IFF_ECHO;
+
+	priv = netdev_priv(net);
+	priv->can.bittiming_const = &mcp251x_bittiming_const;
+	priv->can.do_set_mode = mcp251x_do_set_mode;
+	priv->can.clock.freq = pdata->oscillator_frequency / 2;
+	priv->can.ctrlmode_supported = CAN_CTRLMODE_3_SAMPLES |
+		CAN_CTRLMODE_LOOPBACK | CAN_CTRLMODE_LISTENONLY;
+	if (pdata->model == CAN_MCP251X_MCP2515)
+		priv->can.ctrlmode_supported |= CAN_CTRLMODE_ONE_SHOT;
+	priv->net = net;
+	dev_set_drvdata(&spi->dev, priv);
+
+	priv->spi = spi;
+	mutex_init(&priv->spi_lock);
+
+	/* If requested, allocate DMA buffers */
+	if (mcp251x_enable_dma) {
+		spi->dev.coherent_dma_mask = ~0;
+
+		/*
+		 * Minimum coherent DMA allocation is PAGE_SIZE, so allocate
+		 * that much and share it between Tx and Rx DMA buffers.
+		 */
+		priv->spi_tx_buf = dma_alloc_coherent(&spi->dev,
+						      PAGE_SIZE,
+						      &priv->spi_tx_dma,
+						      GFP_DMA);
+
+		if (priv->spi_tx_buf) {
+			priv->spi_rx_buf = (u8 *)(priv->spi_tx_buf +
+						  (PAGE_SIZE / 2));
+			priv->spi_rx_dma = (dma_addr_t)(priv->spi_tx_dma +
+							(PAGE_SIZE / 2));
+		} else {
+			/* Fall back to non-DMA */
+			mcp251x_enable_dma = 0;
+		}
+	}
+
+	/* Allocate non-DMA buffers */
+	if (!mcp251x_enable_dma) {
+		priv->spi_tx_buf = kmalloc(SPI_TRANSFER_BUF_LEN, GFP_KERNEL);
+		if (!priv->spi_tx_buf) {
+			ret = -ENOMEM;
+			goto error_tx_buf;
+		}
+		priv->spi_rx_buf = kmalloc(SPI_TRANSFER_BUF_LEN, GFP_KERNEL);
+		if (!priv->spi_rx_buf) {
+			ret = -ENOMEM;
+			goto error_rx_buf;
+		}
+	}
+
+	if (pdata->power_enable)
+		pdata->power_enable(1);
+
+	/* Call out to platform specific setup */
+	if (pdata->board_specific_setup)
+		pdata->board_specific_setup(spi);
+
+	SET_NETDEV_DEV(net, &spi->dev);
+
+	priv->wq = create_freezeable_workqueue("mcp251x_wq");
+
+	INIT_WORK(&priv->tx_work, mcp251x_tx_work_handler);
+	INIT_WORK(&priv->irq_work, mcp251x_irq_work_handler);
+
+	/* Configure the SPI bus */
+	spi->mode = SPI_MODE_0;
+	spi->bits_per_word = 8;
+	spi_setup(spi);
+
+	if (!mcp251x_hw_probe(spi)) {
+		dev_info(&spi->dev, "Probe failed\n");
+		goto error_probe;
+	}
+	mcp251x_hw_sleep(spi);
+
+	if (pdata->transceiver_enable)
+		pdata->transceiver_enable(0);
+
+	ret = register_candev(net);
+	if (!ret) {
+		dev_info(&spi->dev, "probed\n");
+		return ret;
+	}
+error_probe:
+	if (!mcp251x_enable_dma)
+		kfree(priv->spi_rx_buf);
+error_rx_buf:
+	if (!mcp251x_enable_dma)
+		kfree(priv->spi_tx_buf);
+error_tx_buf:
+	free_candev(net);
+	if (mcp251x_enable_dma)
+		dma_free_coherent(&spi->dev, PAGE_SIZE,
+				  priv->spi_tx_buf, priv->spi_tx_dma);
+error_alloc:
+	if (pdata->power_enable)
+		pdata->power_enable(0);
+	dev_err(&spi->dev, "probe failed\n");
+error_out:
+	return ret;
+}
+
+static int __devexit mcp251x_can_remove(struct spi_device *spi)
+{
+	struct mcp251x_platform_data *pdata = spi->dev.platform_data;
+	struct mcp251x_priv *priv = dev_get_drvdata(&spi->dev);
+	struct net_device *net = priv->net;
+
+	unregister_candev(net);
+	free_candev(net);
+
+	priv->force_quit = 1;
+	flush_workqueue(priv->wq);
+	destroy_workqueue(priv->wq);
+
+	if (mcp251x_enable_dma) {
+		dma_free_coherent(&spi->dev, PAGE_SIZE,
+				  priv->spi_tx_buf, priv->spi_tx_dma);
+	} else {
+		kfree(priv->spi_tx_buf);
+		kfree(priv->spi_rx_buf);
+	}
+
+	if (pdata->power_enable)
+		pdata->power_enable(0);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int mcp251x_can_suspend(struct spi_device *spi, pm_message_t state)
+{
+	struct mcp251x_platform_data *pdata = spi->dev.platform_data;
+	struct mcp251x_priv *priv = dev_get_drvdata(&spi->dev);
+	struct net_device *net = priv->net;
+
+	if (netif_running(net)) {
+		netif_device_detach(net);
+
+		mcp251x_hw_sleep(spi);
+		if (pdata->transceiver_enable)
+			pdata->transceiver_enable(0);
+		priv->after_suspend = AFTER_SUSPEND_UP;
+	} else {
+		priv->after_suspend = AFTER_SUSPEND_DOWN;
+	}
+
+	if (pdata->power_enable) {
+		pdata->power_enable(0);
+		priv->after_suspend |= AFTER_SUSPEND_POWER;
+	}
+
+	return 0;
+}
+
+static int mcp251x_can_resume(struct spi_device *spi)
+{
+	struct mcp251x_platform_data *pdata = spi->dev.platform_data;
+	struct mcp251x_priv *priv = dev_get_drvdata(&spi->dev);
+
+	if (priv->after_suspend & AFTER_SUSPEND_POWER) {
+		pdata->power_enable(1);
+		queue_work(priv->wq, &priv->irq_work);
+	} else {
+		if (priv->after_suspend & AFTER_SUSPEND_UP) {
+			if (pdata->transceiver_enable)
+				pdata->transceiver_enable(1);
+			queue_work(priv->wq, &priv->irq_work);
+		} else {
+			priv->after_suspend = 0;
+		}
+	}
+	return 0;
+}
+#else
+#define mcp251x_can_suspend NULL
+#define mcp251x_can_resume NULL
+#endif
+
+static struct spi_driver mcp251x_can_driver = {
+	.driver = {
+		.name = DEVICE_NAME,
+		.bus = &spi_bus_type,
+		.owner = THIS_MODULE,
+	},
+
+	.probe = mcp251x_can_probe,
+	.remove = __devexit_p(mcp251x_can_remove),
+	.suspend = mcp251x_can_suspend,
+	.resume = mcp251x_can_resume,
+};
+
+static int __init mcp251x_can_init(void)
+{
+	return spi_register_driver(&mcp251x_can_driver);
+}
+
+static void __exit mcp251x_can_exit(void)
+{
+	spi_unregister_driver(&mcp251x_can_driver);
+}
+
+module_init(mcp251x_can_init);
+module_exit(mcp251x_can_exit);
+
+MODULE_AUTHOR("Chris Elston <celston@katalix.com>, "
+	      "Christian Pellegrin <chripell@evolware.org>");
+MODULE_DESCRIPTION("Microchip 251x CAN driver");
+MODULE_LICENSE("GPL v2");
diff --exclude CVS --exclude .git -uNr linux-2.6.27.8/drivers/net/can/mscan/Kconfig linux-2.6.27.8.modified/drivers/net/can/mscan/Kconfig
--- linux-2.6.27.8/drivers/net/can/mscan/Kconfig	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.27.8.modified/drivers/net/can/mscan/Kconfig	2013-05-30 03:44:17.000000000 -0400
@@ -0,0 +1,37 @@
+config CAN_MSCAN
+	depends on CAN_DEV && (PPC || M68K || M68KNOMMU)
+	tristate "Support for Freescale MSCAN based chips"
+	---help---
+	  The Motorola Scalable Controller Area Network (MSCAN) definition
+	  is based on the MSCAN12 definition which is the specific
+	  implementation of the Motorola Scalable CAN concept targeted for
+	  the Motorola MC68HC12 Microcontroller Family.
+
+if CAN_MSCAN
+
+config CAN_MPC5XXX
+	tristate "Freescale MPC5xxx onboard CAN controller"
+	depends on (PPC_MPC52xx || PPC_MPC512x)
+	---help---
+	  If you say yes here you get support for Freescale's MPC5xxx
+	  onboard CAN controller. Currently, the MPC5200, MPC5200B and
+	  MPC5121 (Rev. 2 and later) are supported.
+
+	  This driver can also be built as a module. If so, the module
+	  will be called mscan-mpc5xxx.ko.
+
+config CAN_MPC52XX
+	tristate "Freescale MPC5200 onboard CAN controller (old)"
+	depends on CAN_MSCAN && (PPC_MPC52xx || PPC_52xx)
+	default LITE5200
+	---help---
+	  If you say yes here you get support for Freescale MPC5200
+	  onboard dualCAN controller. This selects the old driver
+	  still available for backward compatibility. If possible,
+	  please use the new CAN_MPC5XXX driver.
+
+	  This driver can also be built as a module.  If so, the module
+	  will be called mscan-mpc52xx.ko.
+
+endif
+
diff --exclude CVS --exclude .git -uNr linux-2.6.27.8/drivers/net/can/mscan/Makefile linux-2.6.27.8.modified/drivers/net/can/mscan/Makefile
--- linux-2.6.27.8/drivers/net/can/mscan/Makefile	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.27.8.modified/drivers/net/can/mscan/Makefile	2013-05-30 03:44:17.000000000 -0400
@@ -0,0 +1,28 @@
+#
+#  $Id: Makefile 1087 2009-11-22 21:20:04Z wolf $
+#
+
+ifeq ($(KERNELRELEASE),)
+
+KERNELDIR := /lib/modules/$(shell uname -r)/build
+PWD       := $(shell pwd)
+TOPDIR    := $(PWD)/../../../..
+
+modules modules_install clean:
+	$(MAKE) -C $(KERNELDIR) M=$(PWD) $@ TOPDIR=$(TOPDIR)
+
+else
+
+-include $(TOPDIR)/Makefile.common
+
+obj-$(CONFIG_CAN_MPC52XX)	+= mscan-mpc52xx.o
+mscan-mpc52xx-objs		:= mscan.o mpc52xx_can.o
+
+obj-$(CONFIG_CAN_MPC5XXX)	+= mscan-mpc5xxx.o
+mscan-mpc5xxx-objs		:= mscan.o mpc5xxx_can.o
+
+ifeq ($(CONFIG_CAN_DEBUG_DEVICES),y)
+	EXTRA_CFLAGS += -DDEBUG
+endif
+
+endif
diff --exclude CVS --exclude .git -uNr linux-2.6.27.8/drivers/net/can/mscan/mpc52xx_can.c linux-2.6.27.8.modified/drivers/net/can/mscan/mpc52xx_can.c
--- linux-2.6.27.8/drivers/net/can/mscan/mpc52xx_can.c	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.27.8.modified/drivers/net/can/mscan/mpc52xx_can.c	2013-05-30 03:44:17.000000000 -0400
@@ -0,0 +1,528 @@
+/*
+ * CAN bus driver for the Freescale MPC52xx embedded CPU.
+ *
+ * Copyright (C) 2004-2005 Andrey Volkov <avolkov@varma-el.com>,
+ *                         Varma Electronics Oy
+ * Copyright (C) 2008-2009 Wolfgang Grandegger <wg@grandegger.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the version 2 of the GNU General Public License
+ * as published by the Free Software Foundation
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/netdevice.h>
+#include <socketcan/can.h>
+#include <socketcan/can/dev.h>
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,27)
+#include <linux/of_platform.h>
+#include <sysdev/fsl_soc.h>
+#endif
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,16)
+#include <linux/io.h>
+#else
+#include <asm/io.h>
+#endif
+#include <asm/mpc52xx.h>
+
+#include "mscan.h"
+
+#include <socketcan/can/version.h>	/* for RCSID. Removed by mkpatch script */
+
+RCSID("$Id: mpc52xx_can.c 1092 2009-11-30 18:16:35Z wolf $");
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,28)
+
+#define PDEV_MAX 2
+
+struct platform_device *pdev[PDEV_MAX];
+
+static int __devinit mpc52xx_can_probe(struct platform_device *pdev)
+{
+	struct resource *mem;
+	struct net_device *dev;
+	struct mscan_platform_data *pdata = pdev->dev.platform_data;
+	struct mscan_priv *priv;
+	u32 mem_size;
+	int ret = -ENODEV;
+
+	if (!pdata)
+		return ret;
+
+	dev = alloc_mscandev();
+	if (!dev)
+		return -ENOMEM;
+	priv = netdev_priv(dev);
+
+	mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	dev->irq = platform_get_irq(pdev, 0);
+	if (!mem || !dev->irq)
+		goto req_error;
+
+	mem_size = mem->end - mem->start + 1;
+	if (!request_mem_region(mem->start, mem_size, pdev->dev.driver->name)) {
+		dev_err(&pdev->dev, "resource unavailable\n");
+		goto req_error;
+	}
+
+	SET_NETDEV_DEV(dev, &pdev->dev);
+
+	priv->reg_base = ioremap_nocache(mem->start, mem_size);
+	if (!priv->reg_base) {
+		dev_err(&pdev->dev, "failed to map can port\n");
+		ret = -ENOMEM;
+		goto fail_map;
+	}
+
+	priv->can.clock.freq = pdata->clock_frq;
+
+	platform_set_drvdata(pdev, dev);
+
+	ret = register_mscandev(dev, pdata->clock_src);
+	if (ret >= 0) {
+		dev_info(&pdev->dev, "probe for port 0x%p done (irq=%d)\n",
+			 priv->reg_base, dev->irq);
+		return ret;
+	}
+
+	iounmap(priv->reg_base);
+
+fail_map:
+	release_mem_region(mem->start, mem_size);
+
+req_error:
+	free_candev(dev);
+	dev_err(&pdev->dev, "probe failed\n");
+	return ret;
+}
+
+static int __devexit mpc52xx_can_remove(struct platform_device *pdev)
+{
+	struct net_device *dev = platform_get_drvdata(pdev);
+	struct mscan_priv *priv = netdev_priv(dev);
+	struct resource *mem;
+
+	platform_set_drvdata(pdev, NULL);
+	unregister_mscandev(dev);
+
+	iounmap(priv->reg_base);
+	mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	release_mem_region(mem->start, mem->end - mem->start + 1);
+	free_candev(dev);
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static struct mscan_regs saved_regs;
+static int mpc52xx_can_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	struct net_device *dev = platform_get_drvdata(pdev);
+	struct mscan_priv *priv = netdev_priv(dev);
+	struct mscan_regs *regs = (struct mscan_regs *)priv->reg_base;
+
+	_memcpy_fromio(&saved_regs, regs, sizeof(*regs));
+
+	return 0;
+}
+
+static int mpc52xx_can_resume(struct platform_device *pdev)
+{
+	struct net_device *dev = platform_get_drvdata(pdev);
+	struct mscan_priv *priv = netdev_priv(dev);
+	struct mscan_regs *regs = (struct mscan_regs *)priv->reg_base;
+
+	regs->canctl0 |= MSCAN_INITRQ;
+	while ((regs->canctl1 & MSCAN_INITAK) == 0)
+		udelay(10);
+
+	regs->canctl1 = saved_regs.canctl1;
+	regs->canbtr0 = saved_regs.canbtr0;
+	regs->canbtr1 = saved_regs.canbtr1;
+	regs->canidac = saved_regs.canidac;
+
+	/* restore masks, buffers etc. */
+	_memcpy_toio(&regs->canidar1_0, (void *)&saved_regs.canidar1_0,
+		     sizeof(*regs) - offsetof(struct mscan_regs, canidar1_0));
+
+	regs->canctl0 &= ~MSCAN_INITRQ;
+	regs->cantbsel = saved_regs.cantbsel;
+	regs->canrier = saved_regs.canrier;
+	regs->cantier = saved_regs.cantier;
+	regs->canctl0 = saved_regs.canctl0;
+
+	return 0;
+}
+#endif
+
+static struct platform_driver mpc52xx_can_driver = {
+	.driver = {
+		   .name = "mpc52xx-mscan",
+		   },
+	.probe = mpc52xx_can_probe,
+	.remove = __devexit_p(mpc52xx_can_remove),
+#ifdef CONFIG_PM
+	.suspend = mpc52xx_can_suspend,
+	.resume = mpc52xx_can_resume,
+#endif
+};
+
+#ifdef CONFIG_PPC_MERGE
+static int __init mpc52xx_of_to_pdev(void)
+{
+	struct device_node *np = NULL;
+	unsigned int i;
+	int err = -ENODEV;
+
+	for (i = 0;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,25)
+ 	     (np = of_find_compatible_node(np, "mscan", "mpc5200-mscan"));
+#else
+	     (np = of_find_compatible_node(np, NULL, "fsl,mpc5200-mscan"));
+#endif
+	     i++) {
+		struct resource r[2] = { };
+		struct mscan_platform_data pdata;
+
+		if (i >= PDEV_MAX) {
+			printk(KERN_WARNING "%s: increase PDEV_MAX for more "
+			       "than %i devices\n", __func__, PDEV_MAX);
+			break;
+		}
+
+		err = of_address_to_resource(np, 0, &r[0]);
+		if (err)
+			break;
+
+		of_irq_to_resource(np, 0, &r[1]);
+
+		pdev[i] =
+		    platform_device_register_simple("mpc52xx-mscan", i, r, 2);
+		if (IS_ERR(pdev[i])) {
+			err = PTR_ERR(pdev[i]);
+			break;
+		}
+
+		pdata.clock_src = MSCAN_CLKSRC_BUS;
+		pdata.clock_frq = mpc52xx_find_ipb_freq(np);
+		err = platform_device_add_data(pdev[i], &pdata, sizeof(pdata));
+		if (err)
+			break;
+	}
+	return err;
+}
+#endif
+
+int __init mpc52xx_can_init(void)
+{
+#ifdef CONFIG_PPC_MERGE
+	int err = mpc52xx_of_to_pdev();
+
+	if (err) {
+		printk(KERN_ERR "%s init failed with err=%d\n",
+		       mpc52xx_can_driver.driver.name, err);
+		return err;
+	}
+#endif
+	return platform_driver_register(&mpc52xx_can_driver);
+}
+
+void __exit mpc52xx_can_exit(void)
+{
+	int i;
+	platform_driver_unregister(&mpc52xx_can_driver);
+	for (i = 0; i < PDEV_MAX; i++)
+		platform_device_unregister(pdev[i]);
+	printk(KERN_INFO "%s unloaded\n", mpc52xx_can_driver.driver.name);
+}
+
+module_init(mpc52xx_can_init);
+module_exit(mpc52xx_can_exit);
+
+MODULE_AUTHOR("Andrey Volkov <avolkov@varma-el.com>");
+#else /* LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,28) */
+#define DRV_NAME "mpc52xx_can"
+
+static struct of_device_id mpc52xx_cdm_ids[] __devinitdata = {
+	{ .compatible = "fsl,mpc5200-cdm", },
+	{ .compatible = "fsl,mpc5200b-cdm", },
+	{}
+};
+
+/*
+ * Get the frequency of the external oscillator clock connected
+ * to the SYS_XTAL_IN pin, or retrun 0 if it cannot be determined.
+ */
+static unsigned int  __devinit mpc52xx_can_xtal_freq(struct device_node *np)
+{
+	struct mpc52xx_cdm  __iomem *cdm;
+	struct device_node *np_cdm;
+	unsigned int freq;
+	u32 val;
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,31)
+	freq = mpc52xx_find_ipb_freq(np);
+#else
+	freq = mpc5xxx_get_bus_frequency(np);
+#endif
+	if (!freq)
+		return 0;
+
+	/*
+	 * Detemine SYS_XTAL_IN frequency from the clock domain settings
+	 */
+	np_cdm = of_find_matching_node(NULL, mpc52xx_cdm_ids);
+	cdm = of_iomap(np_cdm, 0);
+	of_node_put(np_cdm);
+	if (!np_cdm) {
+		printk(KERN_ERR "%s() failed abnormally\n", __func__);
+		return 0;
+	}
+
+	if (in_8(&cdm->ipb_clk_sel) & 0x1)
+		freq *= 2;
+	val  = in_be32(&cdm->rstcfg);
+	if (val & (1 << 5))
+		freq *= 8;
+	else
+		freq *= 4;
+	if (val & (1 << 6))
+		freq /= 12;
+	else
+		freq /= 16;
+
+	iounmap(cdm);
+
+	return freq;
+}
+
+/*
+ * Get frequency of the MSCAN clock source
+ *
+ * Either the oscillator clock (SYS_XTAL_IN) or the IP bus clock (IP_CLK)
+ * can be selected. According to the MPC5200 user's manual, the oscillator
+ * clock is the better choice as it has less jitter but due to a hardware
+ * bug, it can not be selected for the old MPC5200 Rev. A chips.
+ */
+
+static unsigned int  __devinit mpc52xx_can_clock_freq(struct device_node *np,
+						      int clock_src)
+{
+	unsigned int pvr;
+
+	pvr = mfspr(SPRN_PVR);
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,31)
+	if (clock_src == MSCAN_CLKSRC_BUS || pvr == 0x80822011)
+		return mpc52xx_find_ipb_freq(np);
+#else
+	if (clock_src == MSCAN_CLKSRC_BUS || pvr == 0x80822011)
+		return mpc5xxx_get_bus_frequency(np);
+#endif
+
+	return mpc52xx_can_xtal_freq(np);
+}
+
+static int __devinit mpc52xx_can_probe(struct of_device *ofdev,
+				       const struct of_device_id *id)
+{
+	struct device_node *np = ofdev->node;
+	struct net_device *dev;
+	struct mscan_priv *priv;
+	struct resource res;
+	void __iomem *base;
+	int err, irq, res_size, clock_src;
+
+	err = of_address_to_resource(np, 0, &res);
+	if (err) {
+		dev_err(&ofdev->dev, "invalid address\n");
+		return err;
+	}
+
+	res_size = res.end - res.start + 1;
+
+	if (!request_mem_region(res.start, res_size, DRV_NAME)) {
+		dev_err(&ofdev->dev, "couldn't request %#x..%#x\n",
+			res.start, res.end);
+		return -EBUSY;
+	}
+
+	base = ioremap_nocache(res.start, res_size);
+	if (!base) {
+		dev_err(&ofdev->dev, "couldn't ioremap %#x..%#x\n",
+			res.start, res.end);
+		err = -ENOMEM;
+		goto exit_release_mem;
+	}
+
+	irq = irq_of_parse_and_map(np, 0);
+	if (irq == NO_IRQ) {
+		dev_err(&ofdev->dev, "no irq found\n");
+		err = -ENODEV;
+		goto exit_unmap_mem;
+	}
+
+	dev = alloc_mscandev();
+	if (!dev) {
+		err = -ENOMEM;
+		goto exit_dispose_irq;
+	}
+
+	priv = netdev_priv(dev);
+
+	priv->reg_base = base;
+	dev->irq = irq;
+
+	/*
+	 * Either the oscillator clock (SYS_XTAL_IN) or the IP bus clock
+	 * (IP_CLK) can be selected as MSCAN clock source. According to
+	 * the MPC5200 user's manual, the oscillator clock is the better
+	 * choice as it has less jitter. For this reason, it is selected
+	 * by default.
+	 */
+	if (of_get_property(np, "clock-ipb", NULL))
+		clock_src = MSCAN_CLKSRC_BUS;
+	else
+		clock_src = MSCAN_CLKSRC_XTAL;
+	priv->can.clock.freq = mpc52xx_can_clock_freq(np, clock_src);
+	if (!priv->can.clock.freq) {
+		dev_err(&ofdev->dev, "couldn't get MSCAN clock frequency\n");
+		err = -ENODEV;
+		goto exit_free_mscan;
+	}
+
+	SET_NETDEV_DEV(dev, &ofdev->dev);
+
+	err = register_mscandev(dev, clock_src);
+	if (err) {
+		dev_err(&ofdev->dev, "registering %s failed (err=%d)\n",
+			DRV_NAME, err);
+		goto exit_free_mscan;
+	}
+
+	dev_set_drvdata(&ofdev->dev, dev);
+
+	dev_info(&ofdev->dev, "MSCAN at 0x%p, irq %d, clock %d Hz\n",
+		 priv->reg_base, dev->irq, priv->can.clock.freq);
+
+	return 0;
+
+exit_free_mscan:
+	free_candev(dev);
+exit_dispose_irq:
+	irq_dispose_mapping(irq);
+exit_unmap_mem:
+	iounmap(base);
+exit_release_mem:
+	release_mem_region(res.start, res_size);
+
+	return err;
+}
+
+static int __devexit mpc52xx_can_remove(struct of_device *ofdev)
+{
+	struct net_device *dev = dev_get_drvdata(&ofdev->dev);
+	struct mscan_priv *priv = netdev_priv(dev);
+	struct device_node *np = ofdev->node;
+	struct resource res;
+
+	dev_set_drvdata(&ofdev->dev, NULL);
+
+	unregister_mscandev(dev);
+	iounmap(priv->reg_base);
+	irq_dispose_mapping(dev->irq);
+	free_candev(dev);
+
+	of_address_to_resource(np, 0, &res);
+	release_mem_region(res.start, res.end - res.start + 1);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static struct mscan_regs saved_regs;
+static int mpc52xx_can_suspend(struct of_device *ofdev, pm_message_t state)
+{
+	struct net_device *dev = dev_get_drvdata(&ofdev->dev);
+	struct mscan_priv *priv = netdev_priv(dev);
+	struct mscan_regs *regs = (struct mscan_regs *)priv->reg_base;
+
+	_memcpy_fromio(&saved_regs, regs, sizeof(*regs));
+
+	return 0;
+}
+
+static int mpc52xx_can_resume(struct of_device *ofdev)
+{
+	struct net_device *dev = dev_get_drvdata(&ofdev->dev);
+	struct mscan_priv *priv = netdev_priv(dev);
+	struct mscan_regs *regs = (struct mscan_regs *)priv->reg_base;
+
+	regs->canctl0 |= MSCAN_INITRQ;
+	while ((regs->canctl1 & MSCAN_INITAK) == 0)
+		udelay(10);
+
+	regs->canctl1 = saved_regs.canctl1;
+	regs->canbtr0 = saved_regs.canbtr0;
+	regs->canbtr1 = saved_regs.canbtr1;
+	regs->canidac = saved_regs.canidac;
+
+	/* restore masks, buffers etc. */
+	_memcpy_toio(&regs->canidar1_0, (void *)&saved_regs.canidar1_0,
+		     sizeof(*regs) - offsetof(struct mscan_regs, canidar1_0));
+
+	regs->canctl0 &= ~MSCAN_INITRQ;
+	regs->cantbsel = saved_regs.cantbsel;
+	regs->canrier = saved_regs.canrier;
+	regs->cantier = saved_regs.cantier;
+	regs->canctl0 = saved_regs.canctl0;
+
+	return 0;
+}
+#endif
+
+static struct of_device_id __devinitdata mpc52xx_can_table[] = {
+	{.compatible = "fsl,mpc5200-mscan"},
+	{.compatible = "fsl,mpc5200b-mscan"},
+	{},
+};
+
+static struct of_platform_driver mpc52xx_can_driver = {
+	.owner = THIS_MODULE,
+	.name = "mpc52xx_can",
+	.probe = mpc52xx_can_probe,
+	.remove = __devexit_p(mpc52xx_can_remove),
+#ifdef CONFIG_PM
+	.suspend = mpc52xx_can_suspend,
+	.resume = mpc52xx_can_resume,
+#endif
+	.match_table = mpc52xx_can_table,
+};
+
+static int __init mpc52xx_can_init(void)
+{
+	return of_register_platform_driver(&mpc52xx_can_driver);
+}
+module_init(mpc52xx_can_init);
+
+static void __exit mpc52xx_can_exit(void)
+{
+	return of_unregister_platform_driver(&mpc52xx_can_driver);
+};
+module_exit(mpc52xx_can_exit);
+
+MODULE_AUTHOR("Wolfgang Grandegger <wg@grandegger.com>");
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(2,6,28) */
+MODULE_DESCRIPTION("Freescale MPC5200 CAN driver");
+MODULE_LICENSE("GPL v2");
diff --exclude CVS --exclude .git -uNr linux-2.6.27.8/drivers/net/can/mscan/mpc5xxx_can.c linux-2.6.27.8.modified/drivers/net/can/mscan/mpc5xxx_can.c
--- linux-2.6.27.8/drivers/net/can/mscan/mpc5xxx_can.c	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.27.8.modified/drivers/net/can/mscan/mpc5xxx_can.c	2013-05-30 03:44:17.000000000 -0400
@@ -0,0 +1,430 @@
+/*
+ * CAN bus driver for the Freescale MPC5xxx embedded CPU.
+ *
+ * Copyright (C) 2004-2005 Andrey Volkov <avolkov@varma-el.com>,
+ *                         Varma Electronics Oy
+ * Copyright (C) 2008-2009 Wolfgang Grandegger <wg@grandegger.com>
+ * Copyright (C) 2009 Wolfram Sang, Pengutronix <w.sang@pengutronix.de>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the version 2 of the GNU General Public License
+ * as published by the Free Software Foundation
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/netdevice.h>
+#include <socketcan/can.h>
+#include <socketcan/can/dev.h>
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,27)
+#include <linux/of_platform.h>
+#include <sysdev/fsl_soc.h>
+#endif
+#include <linux/clk.h>
+#include <linux/io.h>
+#include <asm/mpc52xx.h>
+
+#include "mscan.h"
+
+#include <socketcan/can/version.h>	/* for RCSID. Removed by mkpatch script */
+RCSID("$Id: mpc52xx_can.c 1038 2009-08-21 10:00:21Z hartkopp $");
+
+#define DRV_NAME "mpc5xxx_can"
+
+struct mpc5xxx_can_data {
+	unsigned int type;
+	u32 (*get_clock)(struct of_device *ofdev, const char *clock_name,
+			 int *mscan_clksrc);
+};
+
+#ifdef CONFIG_PPC_MPC52xx
+static struct of_device_id __devinitdata mpc52xx_cdm_ids[] = {
+	{ .compatible = "fsl,mpc5200-cdm", },
+	{}
+};
+
+static u32 __devinit mpc52xx_can_get_clock(struct of_device *ofdev,
+					   const char *clock_name,
+					   int *mscan_clksrc)
+{
+	unsigned int pvr;
+	struct mpc52xx_cdm  __iomem *cdm;
+	struct device_node *np_cdm;
+	unsigned int freq;
+	u32 val;
+
+	pvr = mfspr(SPRN_PVR);
+
+	/*
+	 * Either the oscillator clock (SYS_XTAL_IN) or the IP bus clock
+	 * (IP_CLK) can be selected as MSCAN clock source. According to
+	 * the MPC5200 user's manual, the oscillator clock is the better
+	 * choice as it has less jitter. For this reason, it is selected
+	 * by default. Unfortunately, it can not be selected for the old
+	 * MPC5200 Rev. A chips due to a hardware bug (check errata).
+	 */
+	if (clock_name && strcmp(clock_name, "ip") == 0)
+		*mscan_clksrc = MSCAN_CLKSRC_BUS;
+	else
+		*mscan_clksrc = MSCAN_CLKSRC_XTAL;
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,31)
+	freq = mpc52xx_find_ipb_freq(ofdev->node);
+#else
+	freq = mpc5xxx_get_bus_frequency(ofdev->node);
+#endif
+	if (!freq)
+		return 0;
+
+	if (*mscan_clksrc == MSCAN_CLKSRC_BUS || pvr == 0x80822011)
+		return freq;
+
+	/* Determine SYS_XTAL_IN frequency from the clock domain settings */
+	np_cdm = of_find_matching_node(NULL, mpc52xx_cdm_ids);
+	if (!np_cdm) {
+		dev_err(&ofdev->dev, "can't get clock node!\n");
+		return 0;
+	}
+	cdm = of_iomap(np_cdm, 0);
+
+	if (in_8(&cdm->ipb_clk_sel) & 0x1)
+		freq *= 2;
+	val = in_be32(&cdm->rstcfg);
+
+	freq *= (val & (1 << 5)) ? 8 : 4;
+	freq /= (val & (1 << 6)) ? 12 : 16;
+
+	of_node_put(np_cdm);
+	iounmap(cdm);
+
+	return freq;
+}
+#else /* !CONFIG_PPC_MPC52xx */
+static u32 __devinit mpc52xx_can_get_clock(struct of_device *ofdev,
+					   const char *clock_name,
+					   int *mscan_clksrc)
+{
+	return 0;
+}
+#endif /* CONFIG_PPC_MPC52xx */
+
+#ifdef CONFIG_PPC_MPC512x
+struct mpc512x_clockctl {
+	u32 spmr;		/* System PLL Mode Reg */
+	u32 sccr[2];		/* System Clk Ctrl Reg 1 & 2 */
+	u32 scfr1;		/* System Clk Freq Reg 1 */
+	u32 scfr2;		/* System Clk Freq Reg 2 */
+	u32 reserved;
+	u32 bcr;		/* Bread Crumb Reg */
+	u32 pccr[12];		/* PSC Clk Ctrl Reg 0-11 */
+	u32 spccr;		/* SPDIF Clk Ctrl Reg */
+	u32 cccr;		/* CFM Clk Ctrl Reg */
+	u32 dccr;		/* DIU Clk Cnfg Reg */
+	u32 mccr[4];		/* MSCAN Clk Ctrl Reg 1-3 */
+};
+
+static struct of_device_id __devinitdata mpc512x_clock_ids[] = {
+	{ .compatible = "fsl,mpc5121-clock", },
+	{}
+};
+
+static u32 __devinit mpc512x_can_get_clock(struct of_device *ofdev,
+					   const char *clock_name,
+					   int *mscan_clksrc)
+{
+	struct mpc512x_clockctl __iomem *clockctl;
+	struct device_node *np_clock;
+	struct clk *sys_clk, *ref_clk;
+	int plen, clockidx, clocksrc = -1;
+	u32 sys_freq, val, clockdiv = 1, freq = 0;
+	const u32 *pval;
+
+	np_clock = of_find_matching_node(NULL, mpc512x_clock_ids);
+	if (!np_clock) {
+		dev_err(&ofdev->dev, "couldn't find clock node\n");
+		return -ENODEV;
+	}
+	clockctl = of_iomap(np_clock, 0);
+	if (!clockctl) {
+		dev_err(&ofdev->dev, "couldn't map clock registers\n");
+		return 0;
+	}
+
+	/* Determine the MSCAN device index from the physical address */
+	pval = of_get_property(ofdev->node, "reg", &plen);
+	BUG_ON(!pval || plen < sizeof(*pval));
+	clockidx = (*pval & 0x80) ? 1 : 0;
+	if (*pval & 0x2000)
+		clockidx += 2;
+
+	/*
+	 * Clock source and divider selection: 3 different clock sources
+	 * can be selected: "ip", "ref" or "sys". For the latter two, a
+	 * clock divider can be defined as well. If the clock source is
+	 * not specified by the device tree, we first try to find an
+	 * optimal CAN source clock based on the system clock. If that
+	 * is not posslible, the reference clock will be used.
+	 */
+	if (clock_name && !strcmp(clock_name, "ip")) {
+		*mscan_clksrc = MSCAN_CLKSRC_IPS;
+		freq = mpc5xxx_get_bus_frequency(ofdev->node);
+	} else {
+		*mscan_clksrc = MSCAN_CLKSRC_BUS;
+
+		pval = of_get_property(ofdev->node,
+				       "fsl,mscan-clock-divider", &plen);
+		if (pval && plen == sizeof(*pval))
+			clockdiv = *pval;
+		if (!clockdiv)
+			clockdiv = 1;
+
+		if (!clock_name || !strcmp(clock_name, "sys")) {
+			sys_clk = clk_get(&ofdev->dev, "sys_clk");
+			if (!sys_clk) {
+				dev_err(&ofdev->dev, "couldn't get sys_clk\n");
+				goto exit_unmap;
+			}
+			/* Get and round up/down sys clock rate */
+			sys_freq = 1000000 *
+				((clk_get_rate(sys_clk) + 499999) / 1000000);
+
+			if (!clock_name) {
+				/* A multiple of 16 MHz would be optimal */
+				if ((sys_freq % 16000000) == 0) {
+					clocksrc = 0;
+					clockdiv = sys_freq / 16000000;
+					freq = sys_freq / clockdiv;
+				}
+			} else {
+				clocksrc = 0;
+				freq = sys_freq / clockdiv;
+			}
+		}
+
+		if (clocksrc < 0) {
+			ref_clk = clk_get(&ofdev->dev, "ref_clk");
+			if (!ref_clk) {
+				dev_err(&ofdev->dev, "couldn't get ref_clk\n");
+				goto exit_unmap;
+			}
+			clocksrc = 1;
+			freq = clk_get_rate(ref_clk) / clockdiv;
+		}
+	}
+
+	/* Disable clock */
+	out_be32(&clockctl->mccr[clockidx], 0x0);
+	if (clocksrc >= 0) {
+		/* Set source and divider */
+		val = (clocksrc << 14) | ((clockdiv - 1) << 17);
+		out_be32(&clockctl->mccr[clockidx], val);
+		/* Enable clock */
+		out_be32(&clockctl->mccr[clockidx], val | 0x10000);
+	}
+
+	/* Enable MSCAN clock domain */
+	val = in_be32(&clockctl->sccr[1]);
+	if (!(val & (1 << 25)))
+		out_be32(&clockctl->sccr[1], val | (1 << 25));
+
+	dev_dbg(&ofdev->dev, "using '%s' with frequency divider %d\n",
+		*mscan_clksrc == MSCAN_CLKSRC_IPS ? "ips_clk" :
+		clocksrc == 1 ? "ref_clk" : "sys_clk", clockdiv);
+
+exit_unmap:
+	of_node_put(np_clock);
+	iounmap(clockctl);
+
+	return freq;
+}
+#else /* !CONFIG_PPC_MPC512x */
+static u32 __devinit mpc512x_can_get_clock(struct of_device *ofdev,
+					   const char *clock_name,
+					   int *mscan_clksrc)
+{
+	return 0;
+}
+#endif /* CONFIG_PPC_MPC512x */
+
+static int __devinit mpc5xxx_can_probe(struct of_device *ofdev,
+				       const struct of_device_id *id)
+{
+	struct mpc5xxx_can_data *data = (struct mpc5xxx_can_data *)id->data;
+	struct device_node *np = ofdev->node;
+	struct net_device *dev;
+	struct mscan_priv *priv;
+	void __iomem *base;
+	const char *clock_name = NULL;
+	int irq, mscan_clksrc = 0;
+	int err = -ENOMEM;
+
+	base = of_iomap(np, 0);
+	if (!base) {
+		dev_err(&ofdev->dev, "couldn't ioremap\n");
+		return err;
+	}
+
+	irq = irq_of_parse_and_map(np, 0);
+	if (!irq) {
+		dev_err(&ofdev->dev, "no irq found\n");
+		err = -ENODEV;
+		goto exit_unmap_mem;
+	}
+
+	dev = alloc_mscandev();
+	if (!dev)
+		goto exit_dispose_irq;
+
+	priv = netdev_priv(dev);
+	priv->reg_base = base;
+	dev->irq = irq;
+
+	clock_name = of_get_property(np, "fsl,mscan-clock-source", NULL);
+
+	BUG_ON(!data);
+	priv->type = data->type;
+	priv->can.clock.freq = data->get_clock(ofdev, clock_name,
+					       &mscan_clksrc);
+	if (!priv->can.clock.freq) {
+		dev_err(&ofdev->dev, "couldn't get MSCAN clock properties\n");
+		goto exit_free_mscan;
+	}
+
+	SET_NETDEV_DEV(dev, &ofdev->dev);
+
+	err = register_mscandev(dev, mscan_clksrc);
+	if (err) {
+		dev_err(&ofdev->dev, "registering %s failed (err=%d)\n",
+			DRV_NAME, err);
+		goto exit_free_mscan;
+	}
+
+	dev_set_drvdata(&ofdev->dev, dev);
+
+	dev_info(&ofdev->dev, "MSCAN at 0x%p, irq %d, clock %d Hz\n",
+		 priv->reg_base, dev->irq, priv->can.clock.freq);
+
+	return 0;
+
+exit_free_mscan:
+	free_candev(dev);
+exit_dispose_irq:
+	irq_dispose_mapping(irq);
+exit_unmap_mem:
+	iounmap(base);
+
+	return err;
+}
+
+static int __devexit mpc5xxx_can_remove(struct of_device *ofdev)
+{
+	struct net_device *dev = dev_get_drvdata(&ofdev->dev);
+	struct mscan_priv *priv = netdev_priv(dev);
+
+	dev_set_drvdata(&ofdev->dev, NULL);
+
+	unregister_mscandev(dev);
+	iounmap(priv->reg_base);
+	irq_dispose_mapping(dev->irq);
+	free_candev(dev);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static struct mscan_regs saved_regs;
+static int mpc5xxx_can_suspend(struct of_device *ofdev, pm_message_t state)
+{
+	struct net_device *dev = dev_get_drvdata(&ofdev->dev);
+	struct mscan_priv *priv = netdev_priv(dev);
+	struct mscan_regs *regs = (struct mscan_regs *)priv->reg_base;
+
+	_memcpy_fromio(&saved_regs, regs, sizeof(*regs));
+
+	return 0;
+}
+
+static int mpc5xxx_can_resume(struct of_device *ofdev)
+{
+	struct net_device *dev = dev_get_drvdata(&ofdev->dev);
+	struct mscan_priv *priv = netdev_priv(dev);
+	struct mscan_regs *regs = (struct mscan_regs *)priv->reg_base;
+
+	regs->canctl0 |= MSCAN_INITRQ;
+	while (!(regs->canctl1 & MSCAN_INITAK))
+		udelay(10);
+
+	regs->canctl1 = saved_regs.canctl1;
+	regs->canbtr0 = saved_regs.canbtr0;
+	regs->canbtr1 = saved_regs.canbtr1;
+	regs->canidac = saved_regs.canidac;
+
+	/* restore masks, buffers etc. */
+	_memcpy_toio(&regs->canidar1_0, (void *)&saved_regs.canidar1_0,
+		     sizeof(*regs) - offsetof(struct mscan_regs, canidar1_0));
+
+	regs->canctl0 &= ~MSCAN_INITRQ;
+	regs->cantbsel = saved_regs.cantbsel;
+	regs->canrier = saved_regs.canrier;
+	regs->cantier = saved_regs.cantier;
+	regs->canctl0 = saved_regs.canctl0;
+
+	return 0;
+}
+#endif
+
+static struct mpc5xxx_can_data __devinitdata mpc5200_can_data = {
+	.type = MSCAN_TYPE_MPC5200,
+	.get_clock = mpc52xx_can_get_clock,
+};
+
+static struct mpc5xxx_can_data __devinitdata mpc5121_can_data = {
+	.type = MSCAN_TYPE_MPC5121,
+	.get_clock = mpc512x_can_get_clock,
+};
+
+static struct of_device_id __devinitdata mpc5xxx_can_table[] = {
+	{ .compatible = "fsl,mpc5200-mscan", .data = &mpc5200_can_data, },
+	/* Note that only MPC5121 Rev. 2 (and later) is supported */
+	{ .compatible = "fsl,mpc5121-mscan", .data = &mpc5121_can_data, },
+	{},
+};
+
+static struct of_platform_driver mpc5xxx_can_driver = {
+	.owner = THIS_MODULE,
+	.name = "mpc5xxx_can",
+	.probe = mpc5xxx_can_probe,
+	.remove = __devexit_p(mpc5xxx_can_remove),
+#ifdef CONFIG_PM
+	.suspend = mpc5xxx_can_suspend,
+	.resume = mpc5xxx_can_resume,
+#endif
+	.match_table = mpc5xxx_can_table,
+};
+
+static int __init mpc5xxx_can_init(void)
+{
+	return of_register_platform_driver(&mpc5xxx_can_driver);
+}
+module_init(mpc5xxx_can_init);
+
+static void __exit mpc5xxx_can_exit(void)
+{
+	return of_unregister_platform_driver(&mpc5xxx_can_driver);
+};
+module_exit(mpc5xxx_can_exit);
+
+MODULE_AUTHOR("Wolfgang Grandegger <wg@grandegger.com>");
+MODULE_DESCRIPTION("Freescale MPC5xxx CAN driver");
+MODULE_LICENSE("GPL v2");
diff --exclude CVS --exclude .git -uNr linux-2.6.27.8/drivers/net/can/mscan/mscan.c linux-2.6.27.8.modified/drivers/net/can/mscan/mscan.c
--- linux-2.6.27.8/drivers/net/can/mscan/mscan.c	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.27.8.modified/drivers/net/can/mscan/mscan.c	2013-05-30 03:44:17.000000000 -0400
@@ -0,0 +1,782 @@
+/*
+ * CAN bus driver for the alone generic (as possible as) MSCAN controller.
+ *
+ * Copyright (C) 2005-2006 Andrey Volkov <avolkov@varma-el.com>,
+ *                         Varma Electronics Oy
+ * Copyright (C) 2008-2009 Wolfgang Grandegger <wg@grandegger.com>
+ * Copyright (C) 2008-2009 Pengutronix <kernel@pengutronix.de>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the version 2 of the GNU General Public License
+ * as published by the Free Software Foundation
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/interrupt.h>
+#include <linux/delay.h>
+#include <linux/netdevice.h>
+#include <linux/if_arp.h>
+#include <linux/if_ether.h>
+#include <linux/list.h>
+#include <socketcan/can.h>
+#include <socketcan/can/dev.h>
+#include <socketcan/can/error.h>
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,16)
+#include <linux/io.h>
+#else
+#include <asm/io.h>
+#endif
+
+#include "mscan.h"
+
+#include <socketcan/can/version.h>	/* for RCSID. Removed by mkpatch script */
+RCSID("$Id: mscan.c 1239 2011-04-19 14:15:21Z hartkopp $");
+
+static struct can_bittiming_const mscan_bittiming_const = {
+	.name = "mscan",
+	.tseg1_min = 4,
+	.tseg1_max = 16,
+	.tseg2_min = 2,
+	.tseg2_max = 8,
+	.sjw_max = 4,
+	.brp_min = 1,
+	.brp_max = 64,
+	.brp_inc = 1,
+};
+
+struct mscan_state {
+	u8 mode;
+	u8 canrier;
+	u8 cantier;
+};
+
+static enum can_state state_map[] = {
+	CAN_STATE_ERROR_ACTIVE,
+	CAN_STATE_ERROR_WARNING,
+	CAN_STATE_ERROR_PASSIVE,
+	CAN_STATE_BUS_OFF
+};
+
+static int mscan_set_mode(struct net_device *dev, u8 mode)
+{
+	struct mscan_priv *priv = netdev_priv(dev);
+	struct mscan_regs *regs = (struct mscan_regs *)priv->reg_base;
+	int ret = 0;
+	int i;
+	u8 canctl1;
+
+	if (mode != MSCAN_NORMAL_MODE) {
+		if (priv->tx_active) {
+			/* Abort transfers before going to sleep */#
+			out_8(&regs->cantarq, priv->tx_active);
+			/* Suppress TX done interrupts */
+			out_8(&regs->cantier, 0);
+		}
+
+		canctl1 = in_8(&regs->canctl1);
+		if ((mode & MSCAN_SLPRQ) && !(canctl1 & MSCAN_SLPAK)) {
+			setbits8(&regs->canctl0, MSCAN_SLPRQ);
+			for (i = 0; i < MSCAN_SET_MODE_RETRIES; i++) {
+				if (in_8(&regs->canctl1) & MSCAN_SLPAK)
+					break;
+				udelay(100);
+			}
+			/*
+			 * The mscan controller will fail to enter sleep mode,
+			 * while there are irregular activities on bus, like
+			 * somebody keeps retransmitting. This behavior is
+			 * undocumented and seems to differ between mscan built
+			 * in mpc5200b and mpc5200. We proceed in that case,
+			 * since otherwise the slprq will be kept set and the
+			 * controller will get stuck. NOTE: INITRQ or CSWAI
+			 * will abort all active transmit actions, if still
+			 * any, at once.
+			 */
+			if (i >= MSCAN_SET_MODE_RETRIES)
+				dev_dbg(ND2D(dev),
+					"device failed to enter sleep mode. "
+					"We proceed anyhow.\n");
+			else
+				priv->can.state = CAN_STATE_SLEEPING;
+		}
+
+		if ((mode & MSCAN_INITRQ) && !(canctl1 & MSCAN_INITAK)) {
+			setbits8(&regs->canctl0, MSCAN_INITRQ);
+			for (i = 0; i < MSCAN_SET_MODE_RETRIES; i++) {
+				if (in_8(&regs->canctl1) & MSCAN_INITAK)
+					break;
+			}
+			if (i >= MSCAN_SET_MODE_RETRIES)
+				ret = -ENODEV;
+		}
+		if (!ret)
+			priv->can.state = CAN_STATE_STOPPED;
+
+		if (mode & MSCAN_CSWAI)
+			setbits8(&regs->canctl0, MSCAN_CSWAI);
+
+	} else {
+		canctl1 = in_8(&regs->canctl1);
+		if (canctl1 & (MSCAN_SLPAK | MSCAN_INITAK)) {
+			clrbits8(&regs->canctl0, MSCAN_SLPRQ | MSCAN_INITRQ);
+			for (i = 0; i < MSCAN_SET_MODE_RETRIES; i++) {
+				canctl1 = in_8(&regs->canctl1);
+				if (!(canctl1 & (MSCAN_INITAK | MSCAN_SLPAK)))
+					break;
+			}
+			if (i >= MSCAN_SET_MODE_RETRIES)
+				ret = -ENODEV;
+			else
+				priv->can.state = CAN_STATE_ERROR_ACTIVE;
+		}
+	}
+	return ret;
+}
+
+static int mscan_start(struct net_device *dev)
+{
+	struct mscan_priv *priv = netdev_priv(dev);
+	struct mscan_regs *regs = (struct mscan_regs *)priv->reg_base;
+	u8 canrflg;
+	int err;
+
+	out_8(&regs->canrier, 0);
+
+	INIT_LIST_HEAD(&priv->tx_head);
+	priv->prev_buf_id = 0;
+	priv->cur_pri = 0;
+	priv->tx_active = 0;
+	priv->shadow_canrier = 0;
+	priv->flags = 0;
+
+	if (priv->type == MSCAN_TYPE_MPC5121) {
+		/* Clear pending bus-off condition */
+		if (in_8(&regs->canmisc) & MSCAN_BOHOLD)
+			out_8(&regs->canmisc, MSCAN_BOHOLD);
+	}
+
+	err = mscan_set_mode(dev, MSCAN_NORMAL_MODE);
+	if (err)
+		return err;
+
+	canrflg = in_8(&regs->canrflg);
+	priv->shadow_statflg = canrflg & MSCAN_STAT_MSK;
+	priv->can.state = state_map[max(MSCAN_STATE_RX(canrflg),
+				    MSCAN_STATE_TX(canrflg))];
+	out_8(&regs->cantier, 0);
+
+	/* Enable receive interrupts. */
+	out_8(&regs->canrier, MSCAN_RX_INTS_ENABLE);
+
+	return 0;
+}
+
+static int mscan_restart(struct net_device *dev)
+{
+	struct mscan_priv *priv = netdev_priv(dev);
+
+	if (priv->type == MSCAN_TYPE_MPC5121) {
+		struct mscan_regs *regs = (struct mscan_regs *)priv->reg_base;
+
+		priv->can.state = CAN_STATE_ERROR_ACTIVE;
+		WARN(!(in_8(&regs->canmisc) & MSCAN_BOHOLD),
+		     "bus-off state expected");
+		out_8(&regs->canmisc, MSCAN_BOHOLD);
+		/* Re-enable receive interrupts. */
+		out_8(&regs->canrier, MSCAN_RX_INTS_ENABLE);
+	} else {
+		if (priv->can.state <= CAN_STATE_BUS_OFF)
+			mscan_set_mode(dev, MSCAN_INIT_MODE);
+		return mscan_start(dev);
+	}
+
+	return 0;
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,32)
+static int mscan_start_xmit(struct sk_buff *skb, struct net_device *dev)
+#else
+static netdev_tx_t mscan_start_xmit(struct sk_buff *skb, struct net_device *dev)
+#endif
+{
+	struct can_frame *frame = (struct can_frame *)skb->data;
+	struct mscan_priv *priv = netdev_priv(dev);
+	struct mscan_regs *regs = (struct mscan_regs *)priv->reg_base;
+	int i, rtr, buf_id;
+	u32 can_id;
+
+	if (can_dropped_invalid_skb(dev, skb))
+		return NETDEV_TX_OK;
+
+	out_8(&regs->cantier, 0);
+
+	i = ~priv->tx_active & MSCAN_TXE;
+	buf_id = ffs(i) - 1;
+	switch (hweight8(i)) {
+	case 0:
+		netif_stop_queue(dev);
+		dev_err(ND2D(dev), "Tx Ring full when queue awake!\n");
+		return NETDEV_TX_BUSY;
+	case 1:
+		/*
+		 * if buf_id < 3, then current frame will be send out of order,
+		 * since buffer with lower id have higher priority (hell..)
+		 */
+		netif_stop_queue(dev);
+	case 2:
+		if (buf_id < priv->prev_buf_id) {
+			priv->cur_pri++;
+			if (priv->cur_pri == 0xff) {
+				set_bit(F_TX_WAIT_ALL, &priv->flags);
+				netif_stop_queue(dev);
+			}
+		}
+		set_bit(F_TX_PROGRESS, &priv->flags);
+		break;
+	}
+	priv->prev_buf_id = buf_id;
+	out_8(&regs->cantbsel, i);
+
+	rtr = frame->can_id & CAN_RTR_FLAG;
+
+	/* RTR is always the lowest bit of interest, then IDs follow */
+	if (frame->can_id & CAN_EFF_FLAG) {
+		can_id = (frame->can_id & CAN_EFF_MASK)
+			 << (MSCAN_EFF_RTR_SHIFT + 1);
+		if (rtr)
+			can_id |= 1 << MSCAN_EFF_RTR_SHIFT;
+		out_be16(&regs->tx.idr3_2, can_id);
+
+		can_id >>= 16;
+		/* EFF_FLAGS are between the IDs :( */
+		can_id = (can_id & 0x7) | ((can_id << 2) & 0xffe0)
+			 | MSCAN_EFF_FLAGS;
+	} else {
+		can_id = (frame->can_id & CAN_SFF_MASK)
+			 << (MSCAN_SFF_RTR_SHIFT + 1);
+		if (rtr)
+			can_id |= 1 << MSCAN_SFF_RTR_SHIFT;
+	}
+	out_be16(&regs->tx.idr1_0, can_id);
+
+	if (!rtr) {
+		void __iomem *data = &regs->tx.dsr1_0;
+		u16 *payload = (u16 *)frame->data;
+
+		/* It is safe to write into dsr[dlc+1] */
+		for (i = 0; i < (frame->can_dlc + 1) / 2; i++) {
+			out_be16(data, *payload++);
+			data += 2 + _MSCAN_RESERVED_DSR_SIZE;
+		}
+	}
+
+	out_8(&regs->tx.dlr, frame->can_dlc);
+	out_8(&regs->tx.tbpr, priv->cur_pri);
+
+	/* Start transmission. */
+	out_8(&regs->cantflg, 1 << buf_id);
+
+	if (!test_bit(F_TX_PROGRESS, &priv->flags))
+		dev->trans_start = jiffies;
+
+	list_add_tail(&priv->tx_queue[buf_id].list, &priv->tx_head);
+
+	can_put_echo_skb(skb, dev, buf_id);
+
+	/* Enable interrupt. */
+	priv->tx_active |= 1 << buf_id;
+	out_8(&regs->cantier, priv->tx_active);
+
+	return NETDEV_TX_OK;
+}
+
+/* This function returns the old state to see where we came from */
+static enum can_state check_set_state(struct net_device *dev, u8 canrflg)
+{
+	struct mscan_priv *priv = netdev_priv(dev);
+	enum can_state state, old_state = priv->can.state;
+
+	if (canrflg & MSCAN_CSCIF && old_state <= CAN_STATE_BUS_OFF) {
+		state = state_map[max(MSCAN_STATE_RX(canrflg),
+				      MSCAN_STATE_TX(canrflg))];
+		priv->can.state = state;
+	}
+	return old_state;
+}
+
+static void mscan_get_rx_frame(struct net_device *dev, struct can_frame *frame)
+{
+	struct mscan_priv *priv = netdev_priv(dev);
+	struct mscan_regs *regs = (struct mscan_regs *)priv->reg_base;
+	u32 can_id;
+	int i;
+
+	can_id = in_be16(&regs->rx.idr1_0);
+	if (can_id & (1 << 3)) {
+		frame->can_id = CAN_EFF_FLAG;
+		can_id = ((can_id << 16) | in_be16(&regs->rx.idr3_2));
+		can_id = ((can_id & 0xffe00000) |
+			  ((can_id & 0x7ffff) << 2)) >> 2;
+	} else {
+		can_id >>= 4;
+		frame->can_id = 0;
+	}
+
+	frame->can_id |= can_id >> 1;
+	if (can_id & 1)
+		frame->can_id |= CAN_RTR_FLAG;
+
+	frame->can_dlc = get_can_dlc(in_8(&regs->rx.dlr) & 0xf);
+
+	if (!(frame->can_id & CAN_RTR_FLAG)) {
+		void __iomem *data = &regs->rx.dsr1_0;
+		u16 *payload = (u16 *)frame->data;
+
+		for (i = 0; i < (frame->can_dlc + 1) / 2; i++) {
+			*payload++ = in_be16(data);
+			data += 2 + _MSCAN_RESERVED_DSR_SIZE;
+		}
+	}
+
+	out_8(&regs->canrflg, MSCAN_RXF);
+}
+
+static void mscan_get_err_frame(struct net_device *dev, struct can_frame *frame,
+				u8 canrflg)
+{
+	struct mscan_priv *priv = netdev_priv(dev);
+	struct mscan_regs *regs = (struct mscan_regs *)priv->reg_base;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,23)
+	struct net_device_stats *stats = can_get_stats(dev);
+#else
+	struct net_device_stats *stats = &dev->stats;
+#endif
+	enum can_state old_state;
+
+	dev_dbg(ND2D(dev), "error interrupt (canrflg=%#x)\n", canrflg);
+	frame->can_id = CAN_ERR_FLAG;
+
+	if (canrflg & MSCAN_OVRIF) {
+		frame->can_id |= CAN_ERR_CRTL;
+		frame->data[1] = CAN_ERR_CRTL_RX_OVERFLOW;
+		stats->rx_over_errors++;
+		stats->rx_errors++;
+	} else {
+		frame->data[1] = 0;
+	}
+
+	old_state = check_set_state(dev, canrflg);
+	/* State changed */
+	if (old_state != priv->can.state) {
+		switch (priv->can.state) {
+		case CAN_STATE_ERROR_WARNING:
+			frame->can_id |= CAN_ERR_CRTL;
+			priv->can.can_stats.error_warning++;
+			if ((priv->shadow_statflg & MSCAN_RSTAT_MSK) <
+			    (canrflg & MSCAN_RSTAT_MSK))
+				frame->data[1] |= CAN_ERR_CRTL_RX_WARNING;
+			if ((priv->shadow_statflg & MSCAN_TSTAT_MSK) <
+			    (canrflg & MSCAN_TSTAT_MSK))
+				frame->data[1] |= CAN_ERR_CRTL_TX_WARNING;
+			break;
+		case CAN_STATE_ERROR_PASSIVE:
+			frame->can_id |= CAN_ERR_CRTL;
+			priv->can.can_stats.error_passive++;
+			frame->data[1] |= CAN_ERR_CRTL_RX_PASSIVE;
+			break;
+		case CAN_STATE_BUS_OFF:
+			frame->can_id |= CAN_ERR_BUSOFF;
+			/*
+			 * The MSCAN on the MPC5200 does recover from bus-off
+			 * automatically. To avoid that we stop the chip doing
+			 * a light-weight stop (we are in irq-context).
+			 */
+			if (priv->type != MSCAN_TYPE_MPC5121) {
+				out_8(&regs->cantier, 0);
+				out_8(&regs->canrier, 0);
+				setbits8(&regs->canctl0,
+					 MSCAN_SLPRQ | MSCAN_INITRQ);
+			}
+			can_bus_off(dev);
+			break;
+		default:
+			break;
+		}
+	}
+	priv->shadow_statflg = canrflg & MSCAN_STAT_MSK;
+	frame->can_dlc = CAN_ERR_DLC;
+	out_8(&regs->canrflg, MSCAN_ERR_IF);
+}
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,23)
+static int mscan_rx_poll(struct napi_struct *napi, int quota)
+#else
+static int mscan_rx_poll(struct net_device *dev, int *budget)
+#endif
+{
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,28)
+	struct mscan_priv *priv = container_of(napi, struct mscan_priv, napi);
+	struct net_device *dev = napi->dev;
+#elif LINUX_VERSION_CODE > KERNEL_VERSION(2,6,23)
+	struct mscan_priv *priv = container_of(napi, struct mscan_priv, napi);
+	struct net_device *dev = priv->dev;
+#else
+	struct mscan_priv *priv = netdev_priv(dev);
+	int quota = min(dev->quota, *budget);
+#endif
+	struct mscan_regs *regs = (struct mscan_regs *)priv->reg_base;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,23)
+	struct net_device_stats *stats = can_get_stats(dev);
+#else
+	struct net_device_stats *stats = &dev->stats;
+#endif
+	int npackets = 0;
+	int ret = 1;
+	struct sk_buff *skb;
+	struct can_frame *frame;
+	u8 canrflg;
+
+	while (npackets < quota) {
+		canrflg = in_8(&regs->canrflg);
+		if (!(canrflg & (MSCAN_RXF | MSCAN_ERR_IF)))
+			break;
+
+		skb = alloc_can_skb(dev, &frame);
+		if (!skb) {
+			if (printk_ratelimit())
+				dev_notice(ND2D(dev), "packet dropped\n");
+			stats->rx_dropped++;
+			out_8(&regs->canrflg, canrflg);
+			continue;
+		}
+
+		if (canrflg & MSCAN_RXF)
+			mscan_get_rx_frame(dev, frame);
+		else if (canrflg & MSCAN_ERR_IF)
+			mscan_get_err_frame(dev, frame, canrflg);
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,32)
+		dev->last_rx = jiffies;
+#endif
+		stats->rx_packets++;
+		stats->rx_bytes += frame->can_dlc;
+		npackets++;
+		netif_receive_skb(skb);
+	}
+
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2,6,23)
+	*budget -= npackets;
+	dev->quota -= npackets;
+#endif
+
+	if (!(in_8(&regs->canrflg) & (MSCAN_RXF | MSCAN_ERR_IF))) {
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,28)
+		napi_complete(&priv->napi);
+#elif LINUX_VERSION_CODE > KERNEL_VERSION(2,6,23)
+		netif_rx_complete(dev, &priv->napi);
+#else
+		netif_rx_complete(dev);
+#endif
+		clear_bit(F_RX_PROGRESS, &priv->flags);
+		if (priv->can.state < CAN_STATE_BUS_OFF)
+			out_8(&regs->canrier, priv->shadow_canrier);
+		ret = 0;
+	}
+	return ret;
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,19)
+static irqreturn_t mscan_isr(int irq, void *dev_id, struct pt_regs *r)
+#else
+static irqreturn_t mscan_isr(int irq, void *dev_id)
+#endif
+{
+	struct net_device *dev = (struct net_device *)dev_id;
+	struct mscan_priv *priv = netdev_priv(dev);
+	struct mscan_regs *regs = (struct mscan_regs *)priv->reg_base;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,23)
+	struct net_device_stats *stats = can_get_stats(dev);
+#else
+	struct net_device_stats *stats = &dev->stats;
+#endif
+	u8 cantier, cantflg, canrflg;
+	irqreturn_t ret = IRQ_NONE;
+
+	cantier = in_8(&regs->cantier) & MSCAN_TXE;
+	cantflg = in_8(&regs->cantflg) & cantier;
+
+	if (cantier && cantflg) {
+		struct list_head *tmp, *pos;
+
+		list_for_each_safe(pos, tmp, &priv->tx_head) {
+			struct tx_queue_entry *entry =
+			    list_entry(pos, struct tx_queue_entry, list);
+			u8 mask = entry->mask;
+
+			if (!(cantflg & mask))
+				continue;
+
+			out_8(&regs->cantbsel, mask);
+			stats->tx_bytes += in_8(&regs->tx.dlr);
+			stats->tx_packets++;
+			can_get_echo_skb(dev, entry->id);
+			priv->tx_active &= ~mask;
+			list_del(pos);
+		}
+
+		if (list_empty(&priv->tx_head)) {
+			clear_bit(F_TX_WAIT_ALL, &priv->flags);
+			clear_bit(F_TX_PROGRESS, &priv->flags);
+			priv->cur_pri = 0;
+		} else {
+			dev->trans_start = jiffies;
+		}
+
+		if (!test_bit(F_TX_WAIT_ALL, &priv->flags))
+			netif_wake_queue(dev);
+
+		out_8(&regs->cantier, priv->tx_active);
+		ret = IRQ_HANDLED;
+	}
+
+	canrflg = in_8(&regs->canrflg);
+	if ((canrflg & ~MSCAN_STAT_MSK) &&
+	    !test_and_set_bit(F_RX_PROGRESS, &priv->flags)) {
+		if (canrflg & ~MSCAN_STAT_MSK) {
+			priv->shadow_canrier = in_8(&regs->canrier);
+			out_8(&regs->canrier, 0);
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,28)
+			napi_schedule(&priv->napi);
+#elif LINUX_VERSION_CODE > KERNEL_VERSION(2,6,23)
+			netif_rx_schedule(dev, &priv->napi);
+#else
+			netif_rx_schedule(dev);
+#endif
+			ret = IRQ_HANDLED;
+		} else {
+			clear_bit(F_RX_PROGRESS, &priv->flags);
+		}
+	}
+	return ret;
+}
+
+static int mscan_do_set_mode(struct net_device *dev, enum can_mode mode)
+{
+	struct mscan_priv *priv = netdev_priv(dev);
+	int ret = 0;
+
+	if (!priv->open_time)
+		return -EINVAL;
+
+	switch (mode) {
+	case CAN_MODE_START:
+		ret = mscan_restart(dev);
+		if (ret)
+			break;
+		if (netif_queue_stopped(dev))
+			netif_wake_queue(dev);
+		break;
+
+	default:
+		ret = -EOPNOTSUPP;
+		break;
+	}
+	return ret;
+}
+
+static int mscan_do_set_bittiming(struct net_device *dev)
+{
+	struct mscan_priv *priv = netdev_priv(dev);
+	struct mscan_regs *regs = (struct mscan_regs *)priv->reg_base;
+	struct can_bittiming *bt = &priv->can.bittiming;
+	u8 btr0, btr1;
+
+	btr0 = BTR0_SET_BRP(bt->brp) | BTR0_SET_SJW(bt->sjw);
+	btr1 = (BTR1_SET_TSEG1(bt->prop_seg + bt->phase_seg1) |
+		BTR1_SET_TSEG2(bt->phase_seg2) |
+		BTR1_SET_SAM(priv->can.ctrlmode & CAN_CTRLMODE_3_SAMPLES));
+
+	dev_info(ND2D(dev), "setting BTR0=0x%02x BTR1=0x%02x\n",
+		btr0, btr1);
+
+	out_8(&regs->canbtr0, btr0);
+	out_8(&regs->canbtr1, btr1);
+
+	return 0;
+}
+
+static int mscan_open(struct net_device *dev)
+{
+	int ret;
+	struct mscan_priv *priv = netdev_priv(dev);
+	struct mscan_regs *regs = (struct mscan_regs *)priv->reg_base;
+
+	/* common open */
+	ret = open_candev(dev);
+	if (ret)
+		return ret;
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,23)
+	napi_enable(&priv->napi);
+#endif
+
+	ret = request_irq(dev->irq, mscan_isr, 0, dev->name, dev);
+	if (ret < 0) {
+		dev_err(ND2D(dev), "failed to attach interrupt\n");
+		goto exit_napi_disable;
+	}
+
+	priv->open_time = jiffies;
+
+	clrbits8(&regs->canctl1, MSCAN_LISTEN);
+
+	ret = mscan_start(dev);
+	if (ret)
+		goto exit_free_irq;
+
+	netif_start_queue(dev);
+
+	return 0;
+
+exit_free_irq:
+	priv->open_time = 0;
+	free_irq(dev->irq, dev);
+exit_napi_disable:
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,23)
+	napi_disable(&priv->napi);
+#endif
+	close_candev(dev);
+	return ret;
+}
+
+static int mscan_close(struct net_device *dev)
+{
+	struct mscan_priv *priv = netdev_priv(dev);
+	struct mscan_regs *regs = (struct mscan_regs *)priv->reg_base;
+
+	netif_stop_queue(dev);
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,23)
+	napi_disable(&priv->napi);
+#endif
+
+	out_8(&regs->cantier, 0);
+	out_8(&regs->canrier, 0);
+	mscan_set_mode(dev, MSCAN_INIT_MODE);
+	close_candev(dev);
+	free_irq(dev->irq, dev);
+	priv->open_time = 0;
+
+	return 0;
+}
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,28)
+static const struct net_device_ops mscan_netdev_ops = {
+       .ndo_open               = mscan_open,
+       .ndo_stop               = mscan_close,
+       .ndo_start_xmit         = mscan_start_xmit,
+};
+#endif
+
+int register_mscandev(struct net_device *dev, int mscan_clksrc)
+{
+	struct mscan_priv *priv = netdev_priv(dev);
+	struct mscan_regs *regs = (struct mscan_regs *)priv->reg_base;
+	u8 ctl1;
+
+	ctl1 = in_8(&regs->canctl1);
+	if (mscan_clksrc)
+		ctl1 |= MSCAN_CLKSRC;
+	else
+		ctl1 &= ~MSCAN_CLKSRC;
+
+	if (priv->type == MSCAN_TYPE_MPC5121)
+		ctl1 |= MSCAN_BORM; /* bus-off recovery upon request */
+
+	ctl1 |= MSCAN_CANE;
+	out_8(&regs->canctl1, ctl1);
+	udelay(100);
+
+	/* acceptance mask/acceptance code (accept everything) */
+	out_be16(&regs->canidar1_0, 0);
+	out_be16(&regs->canidar3_2, 0);
+	out_be16(&regs->canidar5_4, 0);
+	out_be16(&regs->canidar7_6, 0);
+
+	out_be16(&regs->canidmr1_0, 0xffff);
+	out_be16(&regs->canidmr3_2, 0xffff);
+	out_be16(&regs->canidmr5_4, 0xffff);
+	out_be16(&regs->canidmr7_6, 0xffff);
+	/* Two 32 bit Acceptance Filters */
+	out_8(&regs->canidac, MSCAN_AF_32BIT);
+
+	mscan_set_mode(dev, MSCAN_INIT_MODE);
+
+	return register_candev(dev);
+}
+
+void unregister_mscandev(struct net_device *dev)
+{
+	struct mscan_priv *priv = netdev_priv(dev);
+	struct mscan_regs *regs = (struct mscan_regs *)priv->reg_base;
+	mscan_set_mode(dev, MSCAN_INIT_MODE);
+	clrbits8(&regs->canctl1, MSCAN_CANE);
+	unregister_candev(dev);
+}
+
+struct net_device *alloc_mscandev(void)
+{
+	struct net_device *dev;
+	struct mscan_priv *priv;
+	int i;
+
+	dev = alloc_candev(sizeof(struct mscan_priv), MSCAN_ECHO_SKB_MAX);
+	if (!dev)
+		return NULL;
+	priv = netdev_priv(dev);
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,28)
+	dev->netdev_ops = &mscan_netdev_ops;
+#else
+	dev->open = mscan_open;
+	dev->stop = mscan_close;
+	dev->hard_start_xmit = mscan_start_xmit;
+#endif
+
+	dev->flags |= IFF_ECHO;	/* we support local echo */
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,28)
+	netif_napi_add(dev, &priv->napi, mscan_rx_poll, 8);
+#elif LINUX_VERSION_CODE > KERNEL_VERSION(2,6,23)
+	priv->dev = dev;
+	netif_napi_add(dev, &priv->napi, mscan_rx_poll, 8);
+#else
+	dev->poll = mscan_rx_poll;
+	dev->weight = 8;
+#endif
+
+	priv->can.bittiming_const = &mscan_bittiming_const;
+	priv->can.do_set_bittiming = mscan_do_set_bittiming;
+	priv->can.do_set_mode = mscan_do_set_mode;
+	priv->can.ctrlmode_supported = CAN_CTRLMODE_3_SAMPLES;
+
+	for (i = 0; i < TX_QUEUE_SIZE; i++) {
+		priv->tx_queue[i].id = i;
+		priv->tx_queue[i].mask = 1 << i;
+	}
+
+	return dev;
+}
+
+MODULE_AUTHOR("Andrey Volkov <avolkov@varma-el.com>");
+MODULE_LICENSE("GPL v2");
+MODULE_DESCRIPTION("CAN port driver for a MSCAN based chips");
diff --exclude CVS --exclude .git -uNr linux-2.6.27.8/drivers/net/can/mscan/mscan.h linux-2.6.27.8.modified/drivers/net/can/mscan/mscan.h
--- linux-2.6.27.8/drivers/net/can/mscan/mscan.h	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.27.8.modified/drivers/net/can/mscan/mscan.h	2013-05-30 03:44:17.000000000 -0400
@@ -0,0 +1,320 @@
+/*
+ * $Id: mscan.h 1105 2010-01-09 09:36:24Z wolf $
+ *
+ * Definitions of consts/structs to drive the Freescale MSCAN.
+ *
+ * Copyright (C) 2005-2006 Andrey Volkov <avolkov@varma-el.com>,
+ *                         Varma Electronics Oy
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the version 2 of the GNU General Public License
+ * as published by the Free Software Foundation
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef __MSCAN_H__
+#define __MSCAN_H__
+
+#include <linux/version.h>
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,28)
+#include <linux/autoconf.h>
+#endif
+#include <linux/types.h>
+
+/* MSCAN control register 0 (CANCTL0) bits */
+#define MSCAN_RXFRM		0x80
+#define MSCAN_RXACT		0x40
+#define MSCAN_CSWAI		0x20
+#define MSCAN_SYNCH		0x10
+#define MSCAN_TIME		0x08
+#define MSCAN_WUPE		0x04
+#define MSCAN_SLPRQ		0x02
+#define MSCAN_INITRQ		0x01
+
+/* MSCAN control register 1 (CANCTL1) bits */
+#define MSCAN_CANE		0x80
+#define MSCAN_CLKSRC		0x40
+#define MSCAN_LOOPB		0x20
+#define MSCAN_LISTEN		0x10
+#define MSCAN_BORM		0x08
+#define MSCAN_WUPM		0x04
+#define MSCAN_SLPAK		0x02
+#define MSCAN_INITAK		0x01
+
+/* Use the MPC5XXX MSCAN variant? */
+#ifdef CONFIG_PPC
+#define MSCAN_FOR_MPC5XXX
+#endif
+
+#ifdef MSCAN_FOR_MPC5XXX
+#define MSCAN_CLKSRC_BUS	0
+#define MSCAN_CLKSRC_XTAL	MSCAN_CLKSRC
+#define MSCAN_CLKSRC_IPS	MSCAN_CLKSRC
+#else
+#define MSCAN_CLKSRC_BUS	MSCAN_CLKSRC
+#define MSCAN_CLKSRC_XTAL	0
+#endif
+
+/* MSCAN receiver flag register (CANRFLG) bits */
+#define MSCAN_WUPIF		0x80
+#define MSCAN_CSCIF		0x40
+#define MSCAN_RSTAT1		0x20
+#define MSCAN_RSTAT0		0x10
+#define MSCAN_TSTAT1		0x08
+#define MSCAN_TSTAT0		0x04
+#define MSCAN_OVRIF		0x02
+#define MSCAN_RXF		0x01
+#define MSCAN_ERR_IF 		(MSCAN_OVRIF | MSCAN_CSCIF)
+#define MSCAN_RSTAT_MSK		(MSCAN_RSTAT1 | MSCAN_RSTAT0)
+#define MSCAN_TSTAT_MSK		(MSCAN_TSTAT1 | MSCAN_TSTAT0)
+#define MSCAN_STAT_MSK		(MSCAN_RSTAT_MSK | MSCAN_TSTAT_MSK)
+
+#define MSCAN_STATE_BUS_OFF	(MSCAN_RSTAT1 | MSCAN_RSTAT0 | \
+				 MSCAN_TSTAT1 | MSCAN_TSTAT0)
+#define MSCAN_STATE_TX(canrflg)	(((canrflg)&MSCAN_TSTAT_MSK)>>2)
+#define MSCAN_STATE_RX(canrflg)	(((canrflg)&MSCAN_RSTAT_MSK)>>4)
+#define MSCAN_STATE_ACTIVE	0
+#define MSCAN_STATE_WARNING	1
+#define MSCAN_STATE_PASSIVE	2
+#define MSCAN_STATE_BUSOFF	3
+
+/* MSCAN receiver interrupt enable register (CANRIER) bits */
+#define MSCAN_WUPIE		0x80
+#define MSCAN_CSCIE		0x40
+#define MSCAN_RSTATE1		0x20
+#define MSCAN_RSTATE0		0x10
+#define MSCAN_TSTATE1		0x08
+#define MSCAN_TSTATE0		0x04
+#define MSCAN_OVRIE		0x02
+#define MSCAN_RXFIE		0x01
+
+/* MSCAN transmitter flag register (CANTFLG) bits */
+#define MSCAN_TXE2		0x04
+#define MSCAN_TXE1		0x02
+#define MSCAN_TXE0		0x01
+#define MSCAN_TXE		(MSCAN_TXE2 | MSCAN_TXE1 | MSCAN_TXE0)
+
+/* MSCAN transmitter interrupt enable register (CANTIER) bits */
+#define MSCAN_TXIE2		0x04
+#define MSCAN_TXIE1		0x02
+#define MSCAN_TXIE0		0x01
+#define MSCAN_TXIE		(MSCAN_TXIE2 | MSCAN_TXIE1 | MSCAN_TXIE0)
+
+/* MSCAN transmitter message abort request (CANTARQ) bits */
+#define MSCAN_ABTRQ2		0x04
+#define MSCAN_ABTRQ1		0x02
+#define MSCAN_ABTRQ0		0x01
+
+/* MSCAN transmitter message abort ack (CANTAAK) bits */
+#define MSCAN_ABTAK2		0x04
+#define MSCAN_ABTAK1		0x02
+#define MSCAN_ABTAK0		0x01
+
+/* MSCAN transmit buffer selection (CANTBSEL) bits */
+#define MSCAN_TX2		0x04
+#define MSCAN_TX1		0x02
+#define MSCAN_TX0		0x01
+
+/* MSCAN ID acceptance control register (CANIDAC) bits */
+#define MSCAN_IDAM1		0x20
+#define MSCAN_IDAM0		0x10
+#define MSCAN_IDHIT2		0x04
+#define MSCAN_IDHIT1		0x02
+#define MSCAN_IDHIT0		0x01
+
+#define MSCAN_AF_32BIT		0x00
+#define MSCAN_AF_16BIT		MSCAN_IDAM0
+#define MSCAN_AF_8BIT		MSCAN_IDAM1
+#define MSCAN_AF_CLOSED		(MSCAN_IDAM0|MSCAN_IDAM1)
+#define MSCAN_AF_MASK		(~(MSCAN_IDAM0|MSCAN_IDAM1))
+
+/* MSCAN Miscellaneous Register (CANMISC) bits */
+#define MSCAN_BOHOLD		0x01
+
+/* MSCAN Identifier Register (IDR) bits */
+#define MSCAN_SFF_RTR_SHIFT	4
+#define MSCAN_EFF_RTR_SHIFT	0
+#define MSCAN_EFF_FLAGS		0x18	/* IDE + SRR */
+
+#ifdef MSCAN_FOR_MPC5XXX
+#define _MSCAN_RESERVED_(n, num) u8 _res##n[num]
+#define _MSCAN_RESERVED_DSR_SIZE	2
+#else
+#define _MSCAN_RESERVED_(n, num)
+#define _MSCAN_RESERVED_DSR_SIZE	0
+#endif
+
+/* Structure of the hardware registers */
+struct mscan_regs {
+	/* (see doc S12MSCANV3/D)		  MPC5200    MSCAN */
+	u8 canctl0;				/* + 0x00     0x00 */
+	u8 canctl1;				/* + 0x01     0x01 */
+	_MSCAN_RESERVED_(1, 2);			/* + 0x02          */
+	u8 canbtr0;				/* + 0x04     0x02 */
+	u8 canbtr1;				/* + 0x05     0x03 */
+	_MSCAN_RESERVED_(2, 2);			/* + 0x06          */
+	u8 canrflg;				/* + 0x08     0x04 */
+	u8 canrier;				/* + 0x09     0x05 */
+	_MSCAN_RESERVED_(3, 2);			/* + 0x0a          */
+	u8 cantflg;				/* + 0x0c     0x06 */
+	u8 cantier;				/* + 0x0d     0x07 */
+	_MSCAN_RESERVED_(4, 2);			/* + 0x0e          */
+	u8 cantarq;				/* + 0x10     0x08 */
+	u8 cantaak;				/* + 0x11     0x09 */
+	_MSCAN_RESERVED_(5, 2);			/* + 0x12          */
+	u8 cantbsel;				/* + 0x14     0x0a */
+	u8 canidac;				/* + 0x15     0x0b */
+	u8 reserved;				/* + 0x16     0x0c */
+	_MSCAN_RESERVED_(6, 2);			/* + 0x17          */
+	u8 canmisc;				/* + 0x19     0x0d */
+	_MSCAN_RESERVED_(7, 2);			/* + 0x1a          */
+	u8 canrxerr;				/* + 0x1c     0x0e */
+	u8 cantxerr;				/* + 0x1d     0x0f */
+	_MSCAN_RESERVED_(8, 2);			/* + 0x1e          */
+	u16 canidar1_0;				/* + 0x20     0x10 */
+	_MSCAN_RESERVED_(9, 2);			/* + 0x22          */
+	u16 canidar3_2;				/* + 0x24     0x12 */
+	_MSCAN_RESERVED_(10, 2);		/* + 0x26          */
+	u16 canidmr1_0;				/* + 0x28     0x14 */
+	_MSCAN_RESERVED_(11, 2);		/* + 0x2a          */
+	u16 canidmr3_2;				/* + 0x2c     0x16 */
+	_MSCAN_RESERVED_(12, 2);		/* + 0x2e          */
+	u16 canidar5_4;				/* + 0x30     0x18 */
+	_MSCAN_RESERVED_(13, 2);		/* + 0x32          */
+	u16 canidar7_6;				/* + 0x34     0x1a */
+	_MSCAN_RESERVED_(14, 2);		/* + 0x36          */
+	u16 canidmr5_4;				/* + 0x38     0x1c */
+	_MSCAN_RESERVED_(15, 2);		/* + 0x3a          */
+	u16 canidmr7_6;				/* + 0x3c     0x1e */
+	_MSCAN_RESERVED_(16, 2);		/* + 0x3e          */
+	struct {
+		u16 idr1_0;			/* + 0x40     0x20 */
+		_MSCAN_RESERVED_(17, 2);	/* + 0x42          */
+		u16 idr3_2;			/* + 0x44     0x22 */
+		_MSCAN_RESERVED_(18, 2);	/* + 0x46          */
+		u16 dsr1_0;			/* + 0x48     0x24 */
+		_MSCAN_RESERVED_(19, 2);	/* + 0x4a          */
+		u16 dsr3_2;			/* + 0x4c     0x26 */
+		_MSCAN_RESERVED_(20, 2);	/* + 0x4e          */
+		u16 dsr5_4;			/* + 0x50     0x28 */
+		_MSCAN_RESERVED_(21, 2);	/* + 0x52          */
+		u16 dsr7_6;			/* + 0x54     0x2a */
+		_MSCAN_RESERVED_(22, 2);	/* + 0x56          */
+		u8 dlr;				/* + 0x58     0x2c */
+		u8 reserved;			/* + 0x59     0x2d */
+		_MSCAN_RESERVED_(23, 2);	/* + 0x5a          */
+		u16 time;			/* + 0x5c     0x2e */
+	} rx;
+	_MSCAN_RESERVED_(24, 2);		/* + 0x5e          */
+	struct {
+		u16 idr1_0;			/* + 0x60     0x30 */
+		_MSCAN_RESERVED_(25, 2);	/* + 0x62          */
+		u16 idr3_2;			/* + 0x64     0x32 */
+		_MSCAN_RESERVED_(26, 2);	/* + 0x66          */
+		u16 dsr1_0;			/* + 0x68     0x34 */
+		_MSCAN_RESERVED_(27, 2);	/* + 0x6a          */
+		u16 dsr3_2;			/* + 0x6c     0x36 */
+		_MSCAN_RESERVED_(28, 2);	/* + 0x6e          */
+		u16 dsr5_4;			/* + 0x70     0x38 */
+		_MSCAN_RESERVED_(29, 2);	/* + 0x72          */
+		u16 dsr7_6;			/* + 0x74     0x3a */
+		_MSCAN_RESERVED_(30, 2);	/* + 0x76          */
+		u8 dlr;				/* + 0x78     0x3c */
+		u8 tbpr;			/* + 0x79     0x3d */
+		_MSCAN_RESERVED_(31, 2);	/* + 0x7a          */
+		u16 time;			/* + 0x7c     0x3e */
+	} tx;
+	_MSCAN_RESERVED_(32, 2);		/* + 0x7e          */
+} __attribute__ ((packed));
+
+#undef _MSCAN_RESERVED_
+#define MSCAN_REGION 	sizeof(struct mscan)
+
+#define MSCAN_NORMAL_MODE	0
+#define MSCAN_SLEEP_MODE	MSCAN_SLPRQ
+#define MSCAN_INIT_MODE		(MSCAN_INITRQ | MSCAN_SLPRQ)
+#define MSCAN_POWEROFF_MODE	(MSCAN_CSWAI | MSCAN_SLPRQ)
+#define MSCAN_SET_MODE_RETRIES	255
+#define MSCAN_ECHO_SKB_MAX	3
+#define MSCAN_RX_INTS_ENABLE	(MSCAN_OVRIE | MSCAN_RXFIE | MSCAN_CSCIE | \
+				 MSCAN_RSTATE1 | MSCAN_RSTATE0 | \
+				 MSCAN_TSTATE1 | MSCAN_TSTATE0)
+
+/* MSCAN type variants */
+enum {
+	MSCAN_TYPE_MPC5200,
+	MSCAN_TYPE_MPC5121
+};
+
+#define BTR0_BRP_MASK		0x3f
+#define BTR0_SJW_SHIFT		6
+#define BTR0_SJW_MASK		(0x3 << BTR0_SJW_SHIFT)
+
+#define BTR1_TSEG1_MASK 	0xf
+#define BTR1_TSEG2_SHIFT	4
+#define BTR1_TSEG2_MASK 	(0x7 << BTR1_TSEG2_SHIFT)
+#define BTR1_SAM_SHIFT  	7
+
+#define BTR0_SET_BRP(brp)	(((brp) - 1) & BTR0_BRP_MASK)
+#define BTR0_SET_SJW(sjw)	((((sjw) - 1) << BTR0_SJW_SHIFT) & \
+				 BTR0_SJW_MASK)
+
+#define BTR1_SET_TSEG1(tseg1)	(((tseg1) - 1) &  BTR1_TSEG1_MASK)
+#define BTR1_SET_TSEG2(tseg2)	((((tseg2) - 1) << BTR1_TSEG2_SHIFT) & \
+				 BTR1_TSEG2_MASK)
+#define BTR1_SET_SAM(sam)	((sam) ? 1 << BTR1_SAM_SHIFT : 0)
+
+#define F_RX_PROGRESS	0
+#define F_TX_PROGRESS	1
+#define F_TX_WAIT_ALL	2
+
+#define TX_QUEUE_SIZE	3
+
+struct tx_queue_entry {
+	struct list_head list;
+	u8 mask;
+	u8 id;
+};
+
+struct mscan_priv {
+	struct can_priv can;	/* must be the first member */
+	unsigned int type; 	/* MSCAN type variants */
+	long open_time;
+	unsigned long flags;
+	void __iomem *reg_base;	/* ioremap'ed address to registers */
+	u8 shadow_statflg;
+	u8 shadow_canrier;
+	u8 cur_pri;
+	u8 prev_buf_id;
+	u8 tx_active;
+
+	struct list_head tx_head;
+	struct tx_queue_entry tx_queue[TX_QUEUE_SIZE];
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,28)
+	struct napi_struct napi;
+#elif LINUX_VERSION_CODE > KERNEL_VERSION(2,6,23)
+	struct napi_struct napi;
+	struct net_device *dev;
+#endif
+};
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,28)
+struct mscan_platform_data {
+	u8 clock_src;		/* MSCAN_CLKSRC_BUS or MSCAN_CLKSRC_XTAL */
+	u32 clock_frq;		/* can ref. clock, in Hz */
+};
+#endif
+
+extern struct net_device *alloc_mscandev(void);
+extern int register_mscandev(struct net_device *dev, int mscan_clksrc);
+extern void unregister_mscandev(struct net_device *dev);
+
+#endif /* __MSCAN_H__ */
diff --exclude CVS --exclude .git -uNr linux-2.6.27.8/drivers/net/can/old/Kconfig linux-2.6.27.8.modified/drivers/net/can/old/Kconfig
--- linux-2.6.27.8/drivers/net/can/old/Kconfig	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.27.8.modified/drivers/net/can/old/Kconfig	2013-05-30 03:44:18.000000000 -0400
@@ -0,0 +1,67 @@
+
+config CAN_SJA1000_OLD
+	depends on CAN_OLD_DRIVERS
+	tristate "Philips SJA1000 (old)"
+	---help---
+	  The SJA1000 is one of the top CAN controllers out there. As it
+	  has a multiplexed interface it fits directly to 8051
+	  microcontrollers or into the PC I/O port space. The SJA1000
+	  is a full CAN controller, with shadow registers for RX and TX.
+	  It can send and receive any kinds of CAN frames (SFF/EFF/RTR)
+	  with a single (simple) filter setup.
+	  REMARK: This is the 'old' driver originally written by Matthias
+	  Brukner and Oliver Hartkopp which uses a non-standard hardware
+	  abstaction layer (HAL) inspired by the OCAN driver.
+
+config CAN_I82527_OLD
+	depends on CAN_OLD_DRIVERS
+	tristate "Intel 82527 (old)"
+	---help---
+	  The i82527 is a complex CAN controller that can handle RTR
+	  frame replies on it's own. This feature (and diffent RX filters)
+	  lead to an amount of 15 message objects (for RX & TX). Message
+	  object 15 has (as only) a shadow register for a reliable
+	  receiption of EFF or(!) SFF frames at high CAN traffic.
+	  This driver can send each type of CAN frames (SFF/EFF/RTR).
+	  Using 4 message objects it can also receive each type of CAN
+	  frames. But due to the onchip filter matching trigger method
+	  it is not possible to determine the received RTR CAN-ID.
+	  The reliable message object 15 receives SFF frames by default.
+	  This message object 15 usage maybe changed with the mo15 param.
+	  REMARK: This is the 'old' driver originally written by Oliver
+	  Hartkopp which uses a non-standard hardware abstaction layer (HAL)
+	  inspired by the OCAN driver. http://ar.linux.it/software/#ocan
+
+config CAN_MSCAN_OLD
+	depends on CAN_OLD_DRIVERS && (PPC || M68K || M68KNOMMU)
+	tristate "Support for a Freescale MSCAN based chips (old)"
+	---help---
+	  The Motorola Scalable Controller Area Network (MSCAN) definition
+	  is based on the MSCAN12 definition which is the specific
+	  implementation of the Motorola Scalable CAN concept targeted for
+	  the Motorola MC68HC12 Microcontroller Family.
+
+config CAN_MPC52XX_OLD
+	tristate "Freescale MPC5200 onboard CAN controller (old)"
+	depends on CAN_MSCAN_OLD && (PPC_MPC52xx || PPC_52xx)
+	default LITE5200
+	---help---
+	  If you say yes here you get support for Freescale MPC5200
+	  onboard dualCAN controller.
+
+	  This driver can also be built as a module.  If so, the module
+	  will be called mpc52xx_can.
+
+config CAN_CCAN_OLD
+	depends on CAN_OLD_DRIVERS
+	tristate "Bosch CCAN driver (old)"
+	---help---
+	  This is a driver for the Bosch CCAN controller found for example
+	  on the hynix h7202 chip.
+
+config CAN_H7202_OLD
+	tristate "Hynix H7202 onboard CAN controller (old)"
+	depends on CAN_CCAN_OLD
+	---help---
+	  This is a driver for the hynix h7202 can controller.
+
diff --exclude CVS --exclude .git -uNr linux-2.6.27.8/drivers/net/can/old/ccan/Makefile linux-2.6.27.8.modified/drivers/net/can/old/ccan/Makefile
--- linux-2.6.27.8/drivers/net/can/old/ccan/Makefile	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.27.8.modified/drivers/net/can/old/ccan/Makefile	2013-05-30 03:44:19.000000000 -0400
@@ -0,0 +1,21 @@
+#
+#  $Id: Makefile 438 2007-07-21 17:53:09Z hartkopp $
+#
+
+ifeq ($(KERNELRELEASE),)
+
+KERNELDIR := /lib/modules/$(shell uname -r)/build
+PWD       := $(shell pwd)
+TOPDIR    := $(PWD)/../../../..
+
+modules modules_install clean:
+	$(MAKE) -C $(KERNELDIR) M=$(PWD) $@ TOPDIR=$(TOPDIR)
+
+else
+
+-include $(TOPDIR)/Makefile.common
+
+obj-$(CONFIG_CAN_CCAN_OLD)		+= ccan.o
+obj-$(CONFIG_CAN_H7202_OLD)		+= h7202_can.o
+
+endif
diff --exclude CVS --exclude .git -uNr linux-2.6.27.8/drivers/net/can/old/ccan/ccan.c linux-2.6.27.8.modified/drivers/net/can/old/ccan/ccan.c
--- linux-2.6.27.8/drivers/net/can/old/ccan/ccan.c	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.27.8.modified/drivers/net/can/old/ccan/ccan.c	2013-05-30 03:44:18.000000000 -0400
@@ -0,0 +1,566 @@
+/*
+ * drivers/can/c_can.c
+ *
+ * Copyright (C) 2007
+ *
+ * - Sascha Hauer, Marc Kleine-Budde, Pengutronix
+ * - Simon Kallweit, intefo AG
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the version 2 of the GNU General Public License
+ * as published by the Free Software Foundation
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifdef CONFIG_CAN_DEBUG_DEVICES
+#define DBG(args...) printk(args)
+#else
+#define DBG(args...)
+#endif
+
+#include <linux/kernel.h>
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/interrupt.h>
+#include <linux/delay.h>
+#include <linux/netdevice.h>
+#include <linux/if_arp.h>
+#include <linux/if_ether.h>
+#include <socketcan/can.h>
+#include <linux/list.h>
+#include <linux/delay.h>
+#include <linux/workqueue.h>
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,16)
+#include <linux/io.h>
+#else
+#include <asm/io.h>
+#endif
+
+#include <socketcan/can/dev.h>
+#include <socketcan/can/error.h>
+#include "ccan.h"
+
+static u32 ccan_read_reg32(struct net_device *dev, enum c_regs reg)
+{
+	struct ccan_priv *priv = netdev_priv(dev);
+
+	u32 val = priv->read_reg(dev, reg);
+	val |= ((u32) priv->read_reg(dev, reg + 2)) << 16;
+
+	return val;
+}
+
+static void ccan_write_reg32(struct net_device *dev, enum c_regs reg, u32 val)
+{
+	struct ccan_priv *priv = netdev_priv(dev);
+
+	priv->write_reg(dev, reg, val & 0xffff);
+	priv->write_reg(dev, reg + 2, val >> 16);
+}
+
+static inline void ccan_object_get(struct net_device *dev,
+				   int iface, int objno, int mask)
+{
+	struct ccan_priv *priv = netdev_priv(dev);
+
+	priv->write_reg(dev, CAN_IF_COMM(iface), mask);
+	priv->write_reg(dev, CAN_IF_COMR(iface), objno + 1);
+	while (priv->read_reg(dev, CAN_IF_COMR(iface)) & IF_COMR_BUSY)
+		DBG("busy\n");
+}
+
+static inline void ccan_object_put(struct net_device *dev,
+				   int iface, int objno, int mask)
+{
+	struct ccan_priv *priv = netdev_priv(dev);
+
+	priv->write_reg(dev, CAN_IF_COMM(iface), IF_COMM_WR | mask);
+	priv->write_reg(dev, CAN_IF_COMR(iface), objno + 1);
+	while (priv->read_reg(dev, CAN_IF_COMR(iface)) & IF_COMR_BUSY)
+		DBG("busy\n");
+}
+
+static int ccan_write_object(struct net_device *dev,
+			     int iface, struct can_frame *frame, int objno)
+{
+	struct ccan_priv *priv = netdev_priv(dev);
+	unsigned int val;
+
+	if (frame->can_id & CAN_EFF_FLAG)
+		val = IF_ARB_MSGXTD | (frame->can_id & CAN_EFF_MASK);
+	else
+		val = ((frame->can_id & CAN_SFF_MASK) << 18);
+
+	if (!(frame->can_id & CAN_RTR_FLAG))
+		val |=  IF_ARB_TRANSMIT;
+
+	val |=  IF_ARB_MSGVAL;
+	ccan_write_reg32(dev, CAN_IF_ARB(iface), val);
+
+	memcpy(&val, &frame->data[0], 4);
+	ccan_write_reg32(dev, CAN_IF_DATAA(iface), val);
+	memcpy(&val, &frame->data[4], 4);
+	ccan_write_reg32(dev, CAN_IF_DATAB(iface), val);
+	priv->write_reg(dev, CAN_IF_MCONT(iface),
+			IF_MCONT_TXIE |	IF_MCONT_TXRQST | IF_MCONT_EOB |
+			(frame->can_dlc & 0xf));
+
+	ccan_object_put(dev, 0, objno, IF_COMM_ALL);
+
+	return 0;
+}
+
+static int ccan_read_object(struct net_device *dev, int iface, int objno)
+{
+	struct ccan_priv *priv = netdev_priv(dev);
+	unsigned int val, ctrl, data;
+	struct sk_buff *skb;
+	struct can_frame *frame;
+
+	skb = dev_alloc_skb(sizeof(struct can_frame));
+	skb->dev = dev;
+
+	ccan_object_get(dev, 0, objno, IF_COMM_ALL & ~IF_COMM_TXRQST);
+#ifdef CCAN_DEBUG
+	priv->bufstat[objno]++;
+#endif
+	frame = (struct can_frame *)skb_put(skb, sizeof(struct can_frame));
+
+	ctrl = priv->read_reg(dev, CAN_IF_MCONT(iface));
+
+	if (ctrl & IF_MCONT_MSGLST) {
+		priv->can.net_stats.rx_errors++;
+		DBG("%s: msg lost in buffer %d\n", __func__, objno);
+	}
+
+	frame->can_dlc = ctrl & 0xf;
+
+	val = ccan_read_reg32(dev, CAN_IF_ARB(iface));
+
+	data = ccan_read_reg32(dev, CAN_IF_DATAA(iface));
+	memcpy(&frame->data[0], &data, 4);
+	data = ccan_read_reg32(dev, CAN_IF_DATAB(iface));
+	memcpy(&frame->data[4], &data, 4);
+
+	if (val & IF_ARB_MSGXTD)
+		frame->can_id = (val & CAN_EFF_MASK) | CAN_EFF_FLAG;
+	else
+		frame->can_id = (val >> 18) & CAN_SFF_MASK;
+
+	if (val & IF_ARB_TRANSMIT)
+		frame->can_id |= CAN_RTR_FLAG;
+
+	priv->write_reg(dev, CAN_IF_MCONT(iface), ctrl &
+			~(IF_MCONT_MSGLST | IF_MCONT_INTPND | IF_MCONT_NEWDAT));
+
+	ccan_object_put(dev, 0, objno, IF_COMM_CONTROL);
+
+	skb->protocol = __constant_htons(ETH_P_CAN);
+	netif_rx(skb);
+
+	priv->can.net_stats.rx_packets++;
+	priv->can.net_stats.rx_bytes += frame->can_dlc;
+
+	return 0;
+}
+
+static int ccan_setup_receive_object(struct net_device *dev, int iface,
+				     int objno, unsigned int mask,
+				     unsigned int id, unsigned int mcont)
+{
+	struct ccan_priv *priv = netdev_priv(dev);
+
+	ccan_write_reg32(dev, CAN_IF_MASK(iface), mask);
+	ccan_write_reg32(dev, CAN_IF_ARB(iface), IF_ARB_MSGVAL | id);
+
+	priv->write_reg(dev, CAN_IF_MCONT(iface), mcont);
+
+	ccan_object_put(dev, 0, objno, IF_COMM_ALL & ~IF_COMM_TXRQST);
+
+	DBG("%s: obj no %d msgval: 0x%08x\n", __func__,
+		objno, ccan_read_reg32(dev, CAN_MSGVAL));
+
+	return 0;
+}
+
+static int ccan_inval_object(struct net_device *dev, int iface, int objno)
+{
+	struct ccan_priv *priv = netdev_priv(dev);
+
+	ccan_write_reg32(dev, CAN_IF_ARB(iface), 0);
+	priv->write_reg(dev, CAN_IF_MCONT(iface), 0);
+	ccan_object_put(dev, 0, objno, IF_COMM_ARB | IF_COMM_CONTROL);
+
+	DBG("%s: obj no %d msgval: 0x%08x\n", __func__,
+		objno, ccan_read_reg32(dev, CAN_MSGVAL));
+
+	return 0;
+}
+
+static int ccan_hard_start_xmit(struct sk_buff *skb, struct net_device *dev)
+{
+	struct ccan_priv *priv = netdev_priv(dev);
+	struct can_frame *frame = (struct can_frame *)skb->data;
+
+	spin_lock_irq(&priv->can.irq_lock);
+
+	ccan_write_object(dev, 0, frame, priv->tx_object);
+#ifdef CCAN_DEBUG
+	priv->bufstat[priv->tx_object]++;
+#endif
+	priv->tx_object++;
+	if (priv->tx_object > 5)
+		netif_stop_queue(dev);
+
+	spin_unlock_irq(&priv->can.irq_lock);
+
+	priv->can.net_stats.tx_packets++;
+	priv->can.net_stats.tx_bytes += frame->can_dlc;
+
+	dev->trans_start = jiffies;
+	dev_kfree_skb(skb);
+
+	return 0;
+}
+
+static void ccan_tx_timeout(struct net_device *dev)
+{
+	struct ccan_priv *priv = netdev_priv(dev);
+
+	priv->can.net_stats.tx_errors++;
+}
+
+static int ccan_set_bittime(struct net_device *dev, struct can_bittime *br)
+{
+	struct ccan_priv *priv = netdev_priv(dev);
+	unsigned int reg_timing, ctrl_save;
+	u8 brp, sjw, tseg1, tseg2;
+
+	if (br->type != CAN_BITTIME_STD)
+		return -EINVAL;
+
+	brp = br->std.brp - 1;
+	sjw = br->std.sjw - 1;
+	tseg1 = br->std.prop_seg + br->std.phase_seg1 - 1;
+	tseg2 = br->std.phase_seg2 - 1;
+
+	reg_timing = (brp & BTR_BRP_MASK) |
+		     ((sjw << BTR_SJW_SHIFT) & BTR_SJW_MASK) |
+		     ((tseg1 << BTR_TSEG1_SHIFT) & BTR_TSEG1_MASK) |
+		     ((tseg2 << BTR_TSEG2_SHIFT) & BTR_TSEG2_MASK);
+
+	DBG("%s: brp = %d sjw = %d seg1 = %d seg2 = %d\n", __func__,
+		brp, sjw, tseg1, tseg2);
+	DBG("%s: setting BTR to %04x\n", __func__, reg_timing);
+
+	spin_lock_irq(&priv->can.irq_lock);
+
+	ctrl_save = priv->read_reg(dev, CAN_CONTROL);
+	priv->write_reg(dev, CAN_CONTROL,
+			ctrl_save | CONTROL_CCE | CONTROL_INIT);
+	priv->write_reg(dev, CAN_BTR, reg_timing);
+	priv->write_reg(dev, CAN_CONTROL, ctrl_save);
+
+	spin_unlock_irq(&priv->can.irq_lock);
+
+	return 0;
+}
+
+static int ccan_set_mode(struct net_device *dev, enum can_mode mode)
+{
+	switch (mode) {
+	case CAN_MODE_START:
+		DBG("%s: CAN_MODE_START requested\n", __func__);
+		break;
+	default:
+		return -EOPNOTSUPP;
+	}
+
+	return 0;
+}
+
+static int ccan_get_state(struct net_device *dev, enum can_state *state)
+{
+	struct ccan_priv *priv = netdev_priv(dev);
+	u32 reg_status;
+#ifdef CCAN_DEBUG
+	int i;
+#endif
+
+	reg_status = priv->read_reg(dev, CAN_STATUS);
+
+	if (reg_status & STATUS_EPASS)
+		*state = CAN_STATE_BUS_PASSIVE;
+	else if (reg_status & STATUS_EWARN)
+		*state = CAN_STATE_BUS_WARNING;
+	else if (reg_status & STATUS_BOFF)
+		*state = CAN_STATE_BUS_OFF;
+	else
+		*state = CAN_STATE_ACTIVE;
+#ifdef CCAN_DEBUG
+	DBG("buffer statistic:\n");
+	for (i = 0; i <= MAX_OBJECT; i++)
+		DBG("%d: %d\n", i, priv->bufstat[i]);
+#endif
+	return 0;
+}
+
+static int ccan_do_status_irq(struct net_device *dev)
+{
+	struct ccan_priv *priv = netdev_priv(dev);
+	int status, diff;
+
+	status = priv->read_reg(dev, CAN_STATUS);
+	status &= ~(STATUS_TXOK | STATUS_RXOK);
+	diff = status ^ priv->last_status;
+
+	if (diff & STATUS_EPASS) {
+		if (status & STATUS_EPASS)
+			dev_info(ND2D(dev), "entered error passive state\n");
+		else
+			dev_info(ND2D(dev), "left error passive state\n");
+	}
+	if (diff & STATUS_EWARN) {
+		if (status & STATUS_EWARN)
+			dev_info(ND2D(dev), "entered error warning state\n");
+		else
+			dev_info(ND2D(dev), "left error warning state\n");
+	}
+	if (diff & STATUS_BOFF) {
+		if (status & STATUS_BOFF)
+			dev_info(ND2D(dev), "entered busoff state\n");
+		else
+			dev_info(ND2D(dev), "left busoff state\n");
+	}
+
+	if (diff & STATUS_LEC_MASK) {
+		switch (status & STATUS_LEC_MASK) {
+		case LEC_STUFF_ERROR:
+			dev_info(ND2D(dev), "suffing error\n");
+			break;
+		case LEC_FORM_ERROR:
+			dev_info(ND2D(dev), "form error\n");
+			break;
+		case LEC_ACK_ERROR:
+			dev_info(ND2D(dev), "ack error\n");
+			break;
+		case LEC_BIT1_ERROR:
+			dev_info(ND2D(dev), "bit1 error\n");
+			break;
+		}
+	}
+
+	priv->write_reg(dev, CAN_STATUS, 0);
+	priv->last_status = status;
+
+	return diff ? 1 : 0;
+}
+
+static void ccan_do_object_irq(struct net_device *dev, u16 irqstatus)
+{
+	struct ccan_priv *priv = netdev_priv(dev);
+	int i;
+	u32 val;
+
+	if (irqstatus > MAX_TRANSMIT_OBJECT) {
+		val = ccan_read_reg32(dev, CAN_NEWDAT);
+		while (val & RECEIVE_OBJECT_BITS) {
+			for (i = MAX_TRANSMIT_OBJECT + 1; i <= MAX_OBJECT; i++)
+				if (val & (1<<i))
+					ccan_read_object(dev, 0, i);
+			val = ccan_read_reg32(dev, CAN_NEWDAT);
+		}
+	} else {
+		ccan_inval_object(dev, 0, irqstatus - 1);
+		val = ccan_read_reg32(dev, CAN_TXRQST);
+		if (!val) {
+			priv->tx_object = 0;
+			netif_wake_queue(dev);
+		}
+	}
+}
+
+static void do_statuspoll(struct work_struct *work)
+{
+	struct ccan_priv *priv = container_of(((struct delayed_work *) work),
+					      struct ccan_priv, work);
+
+	priv->write_reg(priv->dev, CAN_CONTROL,
+			CONTROL_SIE | CONTROL_EIE | CONTROL_IE);
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,19)
+static irqreturn_t ccan_isr(int irq, void *dev_id, struct pt_regs *regs)
+#else
+static irqreturn_t ccan_isr(int irq, void *dev_id)
+#endif
+{
+	struct net_device *dev = (struct net_device *) dev_id;
+	struct ccan_priv *priv = netdev_priv(dev);
+	u16 irqstatus;
+	unsigned long flags;
+
+	spin_lock_irqsave(&priv->can.irq_lock, flags);
+
+	irqstatus = priv->read_reg(dev, CAN_IR);
+	while (irqstatus) {
+		if (irqstatus == 0x8000) {
+			if (ccan_do_status_irq(dev)) {
+				/* The c_can core tends to flood us with
+				 * interrupts when certain error states don't
+				 * disappear. Disable interrupts and see if it's
+				 * getting better later. This is at least the
+				 * case on the Magnachip h7202.
+				 */
+				priv->write_reg(dev, CAN_CONTROL, CONTROL_EIE |
+						CONTROL_IE);
+				schedule_delayed_work(&priv->work, HZ / 10);
+				goto exit;
+			}
+		} else {
+			ccan_do_object_irq(dev, irqstatus);
+		}
+		irqstatus = priv->read_reg(dev, CAN_IR);
+	}
+
+exit:
+	spin_unlock_irqrestore(&priv->can.irq_lock, flags);
+
+	return IRQ_HANDLED;
+}
+
+static int ccan_open(struct net_device *dev)
+{
+	struct ccan_priv *priv = netdev_priv(dev);
+
+	if (request_irq(dev->irq, &ccan_isr, 0, dev->name, dev)) {
+		dev_err(ND2D(dev), "failed to attach interrupt\n");
+		return -EAGAIN;
+	}
+
+	priv->write_reg(dev, CAN_CONTROL,
+			CONTROL_EIE | CONTROL_SIE | CONTROL_IE);
+
+	netif_wake_queue(dev);
+
+	return 0;
+}
+
+static int ccan_stop(struct net_device *dev)
+{
+	struct ccan_priv *priv = netdev_priv(dev);
+	unsigned long flags;
+
+	netif_stop_queue(dev);
+
+	cancel_delayed_work(&priv->work);
+	flush_scheduled_work();
+
+	/* mask all IRQs */
+	spin_lock_irqsave(&priv->can.irq_lock, flags);
+	priv->write_reg(dev, CAN_CONTROL, 0);
+	spin_unlock_irqrestore(&priv->can.irq_lock, flags);
+
+	free_irq(dev->irq, dev);
+
+	return 0;
+}
+
+static int ccan_chip_config(struct net_device *dev)
+{
+	struct ccan_priv *priv = netdev_priv(dev);
+	int i;
+
+	/* setup message objects */
+	for (i = 0; i <= MAX_OBJECT; i++)
+		ccan_inval_object(dev, 0, i);
+
+	for (i = MAX_TRANSMIT_OBJECT + 1; i < MAX_OBJECT; i++)
+		ccan_setup_receive_object(dev, 0, i, 0, 0,
+					  IF_MCONT_RXIE | IF_MCONT_UMASK);
+
+	ccan_setup_receive_object(dev, 0, MAX_OBJECT, 0, 0, IF_MCONT_EOB |
+				  IF_MCONT_RXIE | IF_MCONT_UMASK);
+
+#ifdef CCAN_DEBUG
+	for (i = 0; i <= MAX_OBJECT; i++)
+		priv->bufstat[i] = 0;
+#endif
+
+	return 0;
+}
+
+struct net_device *alloc_ccandev(int sizeof_priv)
+{
+	struct net_device *dev;
+	struct ccan_priv *priv;
+
+	dev = alloc_candev(sizeof_priv);
+	if (!dev)
+		return NULL;
+
+	priv = netdev_priv(dev);
+
+	dev->open = ccan_open;
+	dev->stop = ccan_stop;
+	dev->hard_start_xmit = ccan_hard_start_xmit;
+	dev->tx_timeout = ccan_tx_timeout;
+
+	priv->can.bitrate = 500000;
+
+	priv->can.do_set_bittime = ccan_set_bittime;
+	priv->can.do_get_state = ccan_get_state;
+	priv->can.do_set_mode = ccan_set_mode;
+
+	priv->dev = dev;
+	priv->tx_object = 0;
+
+	return dev;
+}
+EXPORT_SYMBOL(alloc_ccandev);
+
+void free_ccandev(struct net_device *dev)
+{
+	free_candev(dev);
+}
+EXPORT_SYMBOL(free_ccandev);
+
+int register_ccandev(struct net_device *dev)
+{
+	struct ccan_priv *priv = netdev_priv(dev);
+
+	ccan_set_mode(dev, CAN_MODE_START);
+
+	ccan_chip_config(dev);
+	INIT_DELAYED_WORK(&priv->work, do_statuspoll);
+
+	return register_netdev(dev);
+}
+EXPORT_SYMBOL(register_ccandev);
+
+void unregister_ccandev(struct net_device *dev)
+{
+	struct ccan_priv *priv = netdev_priv(dev);
+
+	ccan_set_mode(dev, CAN_MODE_START);
+
+	cancel_delayed_work(&priv->work);
+	flush_scheduled_work();
+
+	unregister_netdev(dev);
+}
+EXPORT_SYMBOL(unregister_ccandev);
+
+
+MODULE_AUTHOR("Sascha Hauer <s.hauer@pengutronix.de>");
+MODULE_AUTHOR("Simon Kallweit <simon.kallweit@intefo.ch>");
+MODULE_LICENSE("GPL v2");
+MODULE_DESCRIPTION("CAN port driver for C_CAN based chips");
diff --exclude CVS --exclude .git -uNr linux-2.6.27.8/drivers/net/can/old/ccan/ccan.h linux-2.6.27.8.modified/drivers/net/can/old/ccan/ccan.h
--- linux-2.6.27.8/drivers/net/can/old/ccan/ccan.h	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.27.8.modified/drivers/net/can/old/ccan/ccan.h	2013-05-30 03:44:18.000000000 -0400
@@ -0,0 +1,140 @@
+/*
+ * drivers/can/c_can.h
+ *
+ * Copyright (C) 2007
+ *
+ * - Sascha Hauer, Marc Kleine-Budde, Pengutronix
+ * - Simon Kallweit, intefo AG
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the version 2 of the GNU General Public License
+ * as published by the Free Software Foundation
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef __CCAN_H__
+#define __CCAN_H__
+
+#include <socketcan/can.h>
+#include <linux/platform_device.h>
+
+#undef CCAN_DEBUG
+
+enum c_regs {
+	CAN_CONTROL = 0x00,
+	CAN_STATUS  = 0x02,
+	CAN_ERROR   = 0x04,
+	CAN_BTR     = 0x06,
+	CAN_IR      = 0x08,
+	CAN_TEST    = 0x0a,
+	CAN_BRP_EXT = 0x0c,
+	CAN_IF1     = 0x10,
+	CAN_IF2     = 0x40,
+	CAN_TXRQST  = 0x80, /* 32bit */
+	CAN_NEWDAT  = 0x90, /* 32bit */
+	CAN_INTPND  = 0xa0, /* 32bit */
+	CAN_MSGVAL  = 0xb0, /* 32bit */
+};
+
+#define CAN_IF_COMR(x)   (CAN_IF1 + (x) * 0x30 + 0x00)
+#define CAN_IF_COMM(x)   (CAN_IF1 + (x) * 0x30 + 0x02)
+#define CAN_IF_MASK(x)   (CAN_IF1 + (x) * 0x30 + 0x04)  /* 32bit */
+#define CAN_IF_ARB(x)    (CAN_IF1 + (x) * 0x30 + 0x08)  /* 32bit */
+#define CAN_IF_MCONT(x)  (CAN_IF1 + (x) * 0x30 + 0x0c)
+#define CAN_IF_DATAA(x)  (CAN_IF1 + (x) * 0x30 + 0x0e)  /* 32bit */
+#define CAN_IF_DATAB(x)  (CAN_IF1 + (x) * 0x30 + 0x12)  /* 32bit */
+
+#define CONTROL_TEST (1<<7)
+#define CONTROL_CCE  (1<<6)
+#define CONTROL_DAR  (1<<5)
+#define CONTROL_EIE  (1<<3)
+#define CONTROL_SIE  (1<<2)
+#define CONTROL_IE   (1<<1)
+#define CONTROL_INIT (1<<0)
+
+#define TEST_RX     (1<<7)
+#define TEST_TX1    (1<<6)
+#define TEST_TX2    (1<<5)
+#define TEST_LBACK  (1<<4)
+#define TEST_SILENT (1<<3)
+#define TEST_BASIC  (1<<2)
+
+#define STATUS_BOFF     (1<<7)
+#define STATUS_EWARN    (1<<6)
+#define STATUS_EPASS    (1<<5)
+#define STATUS_RXOK     (1<<4)
+#define STATUS_TXOK     (1<<3)
+#define STATUS_LEC_MASK (1<<2)
+#define LEC_STUFF_ERROR 1
+#define LEC_FORM_ERROR  2
+#define LEC_ACK_ERROR   3
+#define LEC_BIT1_ERROR  4
+
+#define BTR_BRP_MASK	0x3f
+#define BTR_BRP_SHIFT	0
+#define BTR_SJW_SHIFT	6
+#define BTR_SJW_MASK	(0x3 << BTR_SJW_SHIFT)
+#define BTR_TSEG1_SHIFT	8
+#define BTR_TSEG1_MASK	(0xf << BTR_TSEG1_SHIFT)
+#define BTR_TSEG2_SHIFT	12
+#define BTR_TSEG2_MASK	(0x7 << BTR_TSEG2_SHIFT)
+
+#define IF_COMR_BUSY (1<<15)
+
+#define IF_COMM_WR          (1<<7)
+#define IF_COMM_MASK        (1<<6)
+#define IF_COMM_ARB         (1<<5)
+#define IF_COMM_CONTROL     (1<<4)
+#define IF_COMM_CLR_INT_PND (1<<3)
+#define IF_COMM_TXRQST      (1<<2)
+#define IF_COMM_DATAA       (1<<1)
+#define IF_COMM_DATAB       (1<<0)
+
+#define IF_COMM_ALL (IF_COMM_MASK | IF_COMM_ARB | IF_COMM_CONTROL | \
+		     IF_COMM_TXRQST | IF_COMM_DATAA | IF_COMM_DATAB)
+
+#define IF_ARB_MSGVAL   (1<<31)
+#define IF_ARB_MSGXTD   (1<<30)
+#define IF_ARB_TRANSMIT (1<<29)
+
+#define IF_MCONT_NEWDAT (1<<15)
+#define IF_MCONT_MSGLST (1<<14)
+#define IF_MCONT_INTPND (1<<13)
+#define IF_MCONT_UMASK  (1<<12)
+#define IF_MCONT_TXIE   (1<<11)
+#define IF_MCONT_RXIE   (1<<10)
+#define IF_MCONT_RMTEN  (1<<9)
+#define IF_MCONT_TXRQST (1<<8)
+#define IF_MCONT_EOB    (1<<7)
+
+#define MAX_OBJECT 31
+#define MAX_TRANSMIT_OBJECT 15
+#define RECEIVE_OBJECT_BITS 0xffff0000
+
+struct ccan_priv {
+	struct can_priv can;
+	struct net_device *dev;
+	int tx_object;
+	int last_status;
+	struct delayed_work work;
+	u16 (*read_reg)(struct net_device *dev, enum c_regs reg);
+	void (*write_reg)(struct net_device *dev, enum c_regs reg, u16 val);
+#ifdef CCAN_DEBUG
+	unsigned int bufstat[MAX_OBJECT + 1];
+#endif
+};
+
+extern struct net_device *alloc_ccandev(int sizeof_priv);
+extern void free_ccandev(struct net_device *dev);
+extern int register_ccandev(struct net_device *dev);
+extern void unregister_ccandev(struct net_device *dev);
+
+#endif /* __CCAN_H__ */
diff --exclude CVS --exclude .git -uNr linux-2.6.27.8/drivers/net/can/old/ccan/h7202_can.c linux-2.6.27.8.modified/drivers/net/can/old/ccan/h7202_can.c
--- linux-2.6.27.8/drivers/net/can/old/ccan/h7202_can.c	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.27.8.modified/drivers/net/can/old/ccan/h7202_can.c	2013-05-30 03:44:18.000000000 -0400
@@ -0,0 +1,203 @@
+/*
+ * drivers/can/h7202_can.c
+ *
+ * Copyright (C) 2007
+ *
+ * - Sascha Hauer, Marc Kleine-Budde, Pengutronix
+ * - Simon Kallweit, intefo AG
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the version 2 of the GNU General Public License
+ * as published by the Free Software Foundation
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/netdevice.h>
+#include <socketcan/can.h>
+#include <socketcan/can/dev.h>
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,16)
+#include <linux/io.h>
+#else
+#include <asm/io.h>
+#endif
+#include <asm/hardware.h>
+
+#include "ccan.h"
+
+#define DRV_NAME      "h7202can"
+#define DELAY         5
+#define CAN_ENABLE    0x0e
+
+static u16 h7202can_read_reg(struct net_device *dev, enum c_regs reg)
+{
+	u16 val;
+	volatile int i;
+
+	/* The big kernel lock is used to prevent any other AMBA devices from
+	 * interfering with the current register read operation. The register
+	 * is read twice because of braindamaged hynix cpu.
+	 */
+	lock_kernel();
+	val = inw(dev->base_addr + (reg<<1));
+	for (i = 0; i < DELAY; i++);
+	val = inw(dev->base_addr + (reg<<1));
+	for (i = 0; i < DELAY; i++);
+	unlock_kernel();
+
+	return val;
+}
+
+static void h7202can_write_reg(struct net_device *dev, enum c_regs reg, u16 val)
+{
+	volatile int i;
+
+	lock_kernel();
+	outw(val, dev->base_addr + (reg<<1));
+	for (i = 0; i < DELAY; i++);
+	unlock_kernel();
+}
+
+static int h7202can_drv_probe(struct platform_device *pdev)
+{
+	struct net_device *dev;
+	struct ccan_priv *priv;
+	struct resource *mem;
+	u32 mem_size;
+	int ret = -ENODEV;
+
+	dev = alloc_ccandev(sizeof(struct ccan_priv));
+	if (!dev)
+		return -ENOMEM;
+
+	mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	dev->irq = platform_get_irq(pdev, 0);
+	if (!mem || !dev->irq)
+		goto req_error;
+
+	mem_size = mem->end - mem->start + 1;
+	if (!request_mem_region(mem->start, mem_size, pdev->dev.driver->name)) {
+		dev_err(&pdev->dev, "resource unavailable\n");
+		goto req_error;
+	}
+
+	SET_NETDEV_DEV(dev, &pdev->dev);
+
+	dev->base_addr = (unsigned long)ioremap_nocache(mem->start, mem_size);
+
+	if (!dev->base_addr) {
+		dev_err(&pdev->dev, "failed to map can port\n");
+		ret = -ENOMEM;
+		goto fail_map;
+	}
+
+	priv = netdev_priv(dev);
+	priv->can.can_sys_clock = 8000000;
+	priv->read_reg = h7202can_read_reg;
+	priv->write_reg = h7202can_write_reg;
+
+	platform_set_drvdata(pdev, dev);
+
+	/* configure ports */
+	switch (mem->start) {
+	case CAN0_PHYS:
+		CPU_REG(GPIO_C_VIRT, GPIO_EN) &= ~(3<<1);
+		CPU_REG(GPIO_C_VIRT, GPIO_DIR) &= ~(1<<1);
+		CPU_REG(GPIO_C_VIRT, GPIO_DIR) |= (1<<2);
+		break;
+	case CAN1_PHYS:
+		CPU_REG(GPIO_E_VIRT, GPIO_EN) &= ~(3<<16);
+		CPU_REG(GPIO_E_VIRT, GPIO_DIR) |= (1<<16);
+		CPU_REG(GPIO_E_VIRT, GPIO_DIR) &= ~(1<<17);
+		break;
+	}
+
+	/* enable can */
+	h7202can_write_reg(dev, CAN_ENABLE, 1);
+
+	ret = register_ccandev(dev);
+	if (ret >= 0) {
+		dev_info(&pdev->dev, "probe for a port 0x%lX done\n",
+			 dev->base_addr);
+		return ret;
+	}
+
+	iounmap((unsigned long *)dev->base_addr);
+fail_map:
+	release_mem_region(mem->start, mem_size);
+req_error:
+	free_ccandev(dev);
+	dev_err(&pdev->dev, "probe failed\n");
+	return ret;
+}
+
+static int h7202can_drv_remove(struct platform_device *pdev)
+{
+	struct net_device *dev = platform_get_drvdata(pdev);
+	struct resource *mem;
+
+	platform_set_drvdata(pdev, NULL);
+	unregister_ccandev(dev);
+
+	iounmap((volatile void __iomem *)(dev->base_addr));
+	mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	release_mem_region(mem->start, mem->end - mem->start + 1);
+	free_ccandev(dev);
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int h7202can_drv_suspend(struct platform_device *pdev,
+				pm_message_t state)
+{
+	return 0;
+}
+
+static int h7202can_drv_resume(struct platform_device *pdev)
+{
+	return 0;
+}
+#endif /* CONFIG_PM */
+
+static struct platform_driver h7202can_driver = {
+	.driver		= {
+		.name		= DRV_NAME,
+	},
+	.probe		= h7202can_drv_probe,
+	.remove		= h7202can_drv_remove,
+#ifdef CONFIG_PM
+	.suspend	= h7202can_drv_suspend,
+	.resume		= h7202can_drv_resume,
+#endif	/* CONFIG_PM */
+};
+
+static int __init h7202can_init(void)
+{
+	printk(KERN_INFO "%s initializing\n", h7202can_driver.driver.name);
+	return platform_driver_register(&h7202can_driver);
+}
+
+static void __exit h7202can_cleanup(void)
+{
+	platform_driver_unregister(&h7202can_driver);
+	printk(KERN_INFO "%s unloaded\n", h7202can_driver.driver.name);
+}
+
+module_init(h7202can_init);
+module_exit(h7202can_cleanup);
+
+MODULE_AUTHOR("Sascha Hauer <s.hauer@pengutronix.de>");
+MODULE_AUTHOR("Simon Kallweit <simon.kallweit@intefo.ch>");
+MODULE_LICENSE("GPL v2");
+MODULE_DESCRIPTION("CAN port driver Hynix H7202 processor");
diff --exclude CVS --exclude .git -uNr linux-2.6.27.8/drivers/net/can/old/hal/c200.c linux-2.6.27.8.modified/drivers/net/can/old/hal/c200.c
--- linux-2.6.27.8/drivers/net/can/old/hal/c200.c	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.27.8.modified/drivers/net/can/old/hal/c200.c	2013-05-30 03:44:19.000000000 -0400
@@ -0,0 +1,208 @@
+/*
+ * c200.c - low cost parallelport CAN adaptor hardware abstraction layer
+ *          ( direct register access without parport subsystem support )
+ *
+ *          CAN200 project homepage http://private.addcom.de/horo/can200
+ *
+ *          This hal is based on a patch from Uwe Bonnes.
+ *
+ * $Id: c200.c 496 2007-09-27 12:29:32Z hartkopp $
+ *
+ * Inspired by the OCAN driver http://ar.linux.it/software/#ocan
+ *
+ * Copyright (c) 2002-2007 Volkswagen Group Electronic Research
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of Volkswagen nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * Alternatively, provided that this notice is retained in full, this
+ * software may be distributed under the terms of the GNU General
+ * Public License ("GPL") version 2, in which case the provisions of the
+ * GPL apply INSTEAD OF those given above.
+ *
+ * The provided data structures and external interfaces from this code
+ * are not restricted to be used by modules with a GPL compatible license.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * Send feedback to <socketcan-users@lists.berlios.de>
+ *
+ */
+
+#include <linux/netdevice.h>
+#include <linux/ioport.h>
+#include <linux/spinlock.h>
+#include <asm/io.h>
+#include "hal.h"
+
+/* init the HAL - call at driver module init */
+int hal_init(void) { return 0; }
+
+/* exit the HAL - call at driver module exit */
+int hal_exit(void) { return 0; }
+
+/* get name of this CAN HAL */
+char *hal_name(void) { return "c200"; }
+
+/* fill arrays base[] and irq[] with HAL specific defaults */
+void hal_use_defaults(void)
+{
+	extern unsigned long base[];
+	extern unsigned int  irq[];
+
+	base[0]		= 0x378UL;
+	irq[0]		= 7;
+}
+
+#define ECR_REGS_OFFSET 0x400
+#define ECR_CTRL_OFFSET (ECR_REGS_OFFSET + 2)
+
+static u8 ecr_crtl_save;
+
+/* request controller register access space */
+int hal_request_region(int dev_num,
+		       unsigned int num_regs,
+		       char *drv_name)
+{
+	extern unsigned long base[];
+	extern unsigned long rbase[];
+
+	/* set for device base_addr */
+	rbase[dev_num] = base[dev_num];
+
+	/* grab ECR control registers and set parport to 'byte mode' */
+	if (request_region(rbase[dev_num] + ECR_REGS_OFFSET, 3, drv_name)) {
+
+		ecr_crtl_save = inb(rbase[dev_num] + ECR_CTRL_OFFSET);
+
+		outb((ecr_crtl_save & 0x1F) | 0x20,
+		     rbase[dev_num] + ECR_CTRL_OFFSET);
+	} else
+		return 0;
+
+	if (request_region(rbase[dev_num], 4, drv_name))
+		return 1;
+
+	release_region(rbase[dev_num] + ECR_REGS_OFFSET, 3);
+
+	return 0;
+}
+
+/* release controller register access space */
+void hal_release_region(int dev_num,
+			unsigned int num_regs)
+{
+	extern unsigned long base[];
+
+	release_region(base[dev_num], 4);
+
+	/* restore original ECR control register value */
+	outb(ecr_crtl_save, base[dev_num] + ECR_CTRL_OFFSET);
+	release_region(base[dev_num] + ECR_REGS_OFFSET, 3);
+}
+
+/* enable non controller hardware (e.g. irq routing, etc.) */
+int hw_attach(int dev_num)
+{
+	extern unsigned long rbase[];
+	unsigned long pc = rbase[dev_num] + 2;
+
+	/* enable irq */
+	outb(inb(pc) | 0x10, pc);
+
+	return 0;
+}
+
+/* disable non controller hardware (e.g. irq routing, etc.) */
+int hw_detach(int dev_num)
+{
+	extern unsigned long rbase[];
+	unsigned long pc = rbase[dev_num] + 2;
+
+	/* disable irq */
+	outb(inb(pc) & ~0x10, pc);
+
+	return 0;
+}
+
+/* reset controller hardware (with specific non controller hardware) */
+int hw_reset_dev(int dev_num) { return 0; }
+
+#define WRITEP		0x01 /* inverted at port  */
+#define DATASTB		0x02 /* inverted at port and at device*/
+#define ADDRSTB		0x08 /* inverted at port and at device*/
+#define PORTREAD	0x20
+
+static DEFINE_SPINLOCK(c200_lock);
+
+/* read from controller register */
+u8 hw_readreg(unsigned long base, int reg)
+{
+	unsigned long pa = base;
+	unsigned long pc = pa + 2;
+	unsigned long flags;
+	u8 irqstatus = (inb(pc) & 0x10) | 0x04;
+	u8 val;
+
+	spin_lock_irqsave(&c200_lock, flags);
+
+	outb(irqstatus | ADDRSTB, pc);
+	outb((reg & 0x1F) | 0x80, pa);
+	outb(irqstatus, pc);
+	outb(irqstatus | PORTREAD, pc);
+	outb(irqstatus | DATASTB | PORTREAD, pc);
+	val = inb(pa);
+	outb(irqstatus, pc);
+
+	spin_unlock_irqrestore(&c200_lock, flags);
+
+	return val;
+}
+
+/* write to controller register */
+void hw_writereg(unsigned long base, int reg, u8 val)
+{
+	unsigned long pa = base;
+	unsigned long pc = pa + 2;
+	unsigned long flags;
+	u8 irqstatus = (inb(pc) & 0x10) | 0x04;
+
+	spin_lock_irqsave(&c200_lock, flags);
+
+	outb(irqstatus | ADDRSTB, pc);
+	outb(reg & 0x1F, pa);
+	outb(irqstatus, pc);
+	outb(irqstatus | WRITEP, pc);
+	outb(irqstatus | DATASTB | WRITEP, pc);
+	outb(val, pa);
+	outb(irqstatus, pc);
+
+	spin_unlock_irqrestore(&c200_lock, flags);
+}
+
+/* hardware specific work to do at start of irq handler */
+void hw_preirq(struct net_device *dev) { return; }
+
+/* hardware specific work to do at end of irq handler */
+void hw_postirq(struct net_device *dev) { return; }
diff --exclude CVS --exclude .git -uNr linux-2.6.27.8/drivers/net/can/old/hal/esdio.c linux-2.6.27.8.modified/drivers/net/can/old/hal/esdio.c
--- linux-2.6.27.8/drivers/net/can/old/hal/esdio.c	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.27.8.modified/drivers/net/can/old/hal/esdio.c	2013-05-30 03:44:19.000000000 -0400
@@ -0,0 +1,188 @@
+/*
+ * esdio.c - multiplex register access CAN hardware abstraction layer
+ *           for the esd 3xCAN pc104 board
+ *           http://www.esd-electronics.de/products/CAN/can-pc104-200_e.htm
+ *
+ * $Id: esdio.c 496 2007-09-27 12:29:32Z hartkopp $
+ *
+ * Inspired by the OCAN driver http://ar.linux.it/software/#ocan
+ *
+ * Copyright (c) 2007 Fraunhofer FOKUS
+ *
+ * Provided that this notice is retained in full, this
+ * software may be distributed under the terms of the GNU General
+ * Public License ("GPL") version 2, in which case the provisions of the
+ * GPL apply INSTEAD OF those given above.
+ *
+ * The provided data structures and external interfaces from this code
+ * are not restricted to be used by modules with a GPL compatible license.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * Send feedback to <socketcan-users@lists.berlios.de>
+ *
+ * History:
+ * 2007-05-22 Bjoern Riemer: initial release
+ */
+
+#include <linux/netdevice.h>
+#include <linux/ioport.h>
+#include <asm/io.h>
+#include "hal.h"
+
+#ifdef CONFIG_CAN_DEBUG_DEVICES
+#define DBG(args...) printk(args)
+#else
+#define DBG(args...)
+#endif
+
+//#define DBG(args...)   printk(args)
+
+int esd_ale_offset = 1;	//default for the sja1000 chip
+int esd_cs_offset = 0;	//default for the sja1000 chip
+
+/* init the HAL - call at driver module init */
+int hal_init(void) { return 0; }
+
+/* exit the HAL - call at driver module exit */
+int hal_exit(void) { return 0; }
+
+/* get name of this CAN HAL */
+char *hal_name(void) { return "esdio"; }
+
+/* fill arrays base[] and irq[] with HAL specific defaults */
+void hal_use_defaults(void)
+{
+	extern unsigned long base[];
+	extern unsigned int  irq[];
+
+	base[0]		= 0x1e8UL;
+	irq[0]		= 5;
+}
+
+/* request controller register access space */
+int hal_request_region(int dev_num,
+		       unsigned int num_regs,
+		       char *drv_name)
+{
+	extern unsigned long base[];
+	extern unsigned long rbase[];
+	
+	if (!memcmp(drv_name,"i82527-esdio",sizeof("i82527-esdio"))){
+		esd_ale_offset = 7; 
+		esd_cs_offset = 4;
+	} else if (!memcmp(drv_name,"sja1000-esdio",sizeof("sja1000-esdio"))){
+		esd_ale_offset = 1;
+		esd_cs_offset = 0;
+	}
+	
+	/* set for device base_addr */
+	rbase[dev_num] = base[dev_num];
+
+	/* ignore num_regs and create the 2 register region: */
+	/* address register = base + esd_ale_offset          */
+	/* data register    = base + esd_cs_offset           */
+	if (request_region(base[dev_num] + esd_ale_offset, 1, drv_name)){
+		if (request_region(base[dev_num] + esd_cs_offset, 1,drv_name)){
+			return 1;
+		} else {
+			release_region(base[dev_num]+esd_ale_offset, 1);
+			return 0; // error
+		}
+	}
+
+	return 0; // error 
+}
+
+/* release controller register access space */
+void hal_release_region(int dev_num,
+			unsigned int num_regs)
+{
+	extern unsigned long base[];
+
+	/* ignore num_regs and create the 2 register region: */
+	/* address register = base + esd_ale_offset          */
+	/* data register    = base + esd_cs_offset           */
+	release_region(base[dev_num] + esd_cs_offset, 1);
+	release_region(base[dev_num] + esd_ale_offset, 1);
+}
+
+/* enable non controller hardware (e.g. irq routing, etc.) */
+int hw_attach(int dev_num)
+{
+	int i, stat, i1;
+	extern unsigned long base[];
+	extern unsigned int  irq[];
+	 
+	i1 = irq[dev_num]; //get IRQ number
+	DBG(KERN_INFO "esdio.c: enabling IRQ %d for dev_num %d\n",i1,dev_num);
+	
+	for (i=0; i<4; i++){
+		stat=i; // bit 0,1 selects the latch bit to write
+		if (i1 & 0x01){
+			stat |= 0x80; //bit7 carrys the value of the latch bit
+		}
+		outb(stat,base[dev_num]+3);
+		i1 = i1>>1;
+	}
+
+	outb(0x87,base[dev_num]+3); //enable irq selection
+	outb(0x86,base[dev_num]+3); //enable irq tristate buffer
+
+	return 1; 
+}
+
+/* disable non controller hardware (e.g. irq routing, etc.) */
+int hw_detach(int dev_num)
+{
+	int i;
+	extern unsigned long base[];
+	
+	DBG(KERN_INFO "esdio.c: diabling IRQ for dev_num %d\n",dev_num);
+	
+	outb(0x07,base[dev_num]+3); //disable irq selection
+	outb(0x06,base[dev_num]+3); //disable irq tristate buffer
+	
+	for (i=0; i<4; i++)
+		outb(i,base[dev_num]+3);
+
+	return 1;
+}
+
+/* reset controller hardware (with specific non controller hardware) */
+int hw_reset_dev(int dev_num) {	return 0; }
+
+/* read from controller register */
+u8 hw_readreg(unsigned long base, int reg) {	
+	
+	outb(reg, base + esd_ale_offset);	/* address */
+	return inb(base + esd_cs_offset);	/* data */
+}
+
+/* write to controller register */
+void hw_writereg(unsigned long base, int reg, u8 val) {
+	
+	outb(reg, base + esd_ale_offset);	/* address */
+	outb(val, base + esd_cs_offset);	/* data */
+}
+
+/* hardware specific work to do at start of irq handler */
+void hw_preirq(struct net_device *dev) { return; }
+
+/* hardware specific work to do at end of irq handler */
+void hw_postirq(struct net_device *dev) {	
+
+	outb(0x86,dev->base_addr+3); //enable irq tristate buffer 
+	return; 
+}
diff --exclude CVS --exclude .git -uNr linux-2.6.27.8/drivers/net/can/old/hal/gw2.c linux-2.6.27.8.modified/drivers/net/can/old/hal/gw2.c
--- linux-2.6.27.8/drivers/net/can/old/hal/gw2.c	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.27.8.modified/drivers/net/can/old/hal/gw2.c	2013-05-30 03:44:19.000000000 -0400
@@ -0,0 +1,163 @@
+/*
+ * gw2.c - Trajet GW2 register access CAN hardware abstraction layer
+ *
+ * $Id: gw2.c 496 2007-09-27 12:29:32Z hartkopp $
+ *
+ * Inspired by the OCAN driver http://ar.linux.it/software/#ocan
+ *
+ * Copyright (c) 2002-2007 Volkswagen Group Electronic Research
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of Volkswagen nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * Alternatively, provided that this notice is retained in full, this
+ * software may be distributed under the terms of the GNU General
+ * Public License ("GPL") version 2, in which case the provisions of the
+ * GPL apply INSTEAD OF those given above.
+ *
+ * The provided data structures and external interfaces from this code
+ * are not restricted to be used by modules with a GPL compatible license.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * Send feedback to <socketcan-users@lists.berlios.de>
+ *
+ */
+
+#include <linux/netdevice.h>
+#include <linux/ioport.h>
+#include <asm/io.h>
+#include "hal.h"
+
+#define ADDR_GAP 1
+
+/* init the HAL - call at driver module init */
+int hal_init(void) { return 0; }
+
+/* exit the HAL - call at driver module exit */
+int hal_exit(void) { return 0; }
+
+/* get name of this CAN HAL */
+char *hal_name(void) { return "gw2"; }
+
+/* fill arrays base[] and irq[] with HAL specific defaults */
+void hal_use_defaults(void)
+{
+	extern unsigned long base[];
+	extern unsigned int  irq[];
+	extern unsigned int  speed[];
+
+	base[0]		= 0xF0100200UL;
+	irq[0]		= 26;
+	speed[0]	= 500;
+
+	base[1]		= 0xF0100300UL;
+	irq[1]		= 26;
+	speed[1]	= 100;
+
+	base[2]		= 0xF0100400UL;
+	irq[2]		= 26;
+	speed[2]	= 100;
+
+	base[3]		= 0xF0100500UL;
+	irq[3]		= 26;
+	speed[3]	= 500;
+}
+
+/* request controller register access space */
+int hal_request_region(int dev_num,
+		       unsigned int num_regs,
+		       char *drv_name)
+{
+	extern unsigned long base[];
+	extern unsigned long rbase[];
+
+	unsigned int gw2_regs = num_regs * (ADDR_GAP + 1);
+
+	/* creating the region for IOMEM is pretty easy */
+	if (!request_mem_region(base[dev_num], gw2_regs, drv_name))
+		return 0; /* failed */
+
+	/* set device base_addr */
+	rbase[dev_num] = (unsigned long)ioremap(base[dev_num], gw2_regs);
+
+	if (rbase[dev_num])
+		return 1; /* success */
+
+	/* cleanup due to failed ioremap() */
+	release_mem_region(base[dev_num], gw2_regs);
+	return 0; /* failed */
+}
+
+/* release controller register access space */
+void hal_release_region(int dev_num,
+			unsigned int num_regs)
+{
+	extern unsigned long base[];
+	extern unsigned long rbase[];
+
+	unsigned int gw2_regs = num_regs * (ADDR_GAP + 1);
+
+	iounmap((void *)rbase[dev_num]);
+	release_mem_region(base[dev_num], gw2_regs);
+}
+
+/* enable non controller hardware (e.g. irq routing, etc.) */
+int hw_attach(int dev_num) { return 0; }
+
+/* disable non controller hardware (e.g. irq routing, etc.) */
+int hw_detach(int dev_num) { return 0; }
+
+/* reset controller hardware (with specific non controller hardware) */
+int hw_reset_dev(int dev_num) { return 0; }
+
+/* read from controller register */
+u8 hw_readreg(unsigned long base, int reg) {
+
+	static u8 val;
+	void __iomem *addr = (void __iomem *)base +
+		reg * (ADDR_GAP + 1) + ADDR_GAP;
+
+	val = (u8)readw(addr);
+	rmb();
+
+        return val;
+}
+
+/* write to controller register */
+void hw_writereg(unsigned long base, int reg, u8 val) {
+
+	void __iomem *addr = (void __iomem *)base +
+		reg * (ADDR_GAP + 1) + ADDR_GAP;
+
+	writew(val, addr);
+	wmb();
+}
+
+/* hardware specific work to do at start of irq handler */
+void hw_preirq(struct net_device *dev) { return; }
+
+/* hardware specific work to do at end of irq handler */
+void hw_postirq(struct net_device *dev) { return; }
+
diff --exclude CVS --exclude .git -uNr linux-2.6.27.8/drivers/net/can/old/hal/hal.h linux-2.6.27.8.modified/drivers/net/can/old/hal/hal.h
--- linux-2.6.27.8/drivers/net/can/old/hal/hal.h	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.27.8.modified/drivers/net/can/old/hal/hal.h	2013-05-30 03:44:19.000000000 -0400
@@ -0,0 +1,99 @@
+/*
+ * hal.h - definitions for CAN controller hardware abstraction layer
+ *
+ * Inspired by the OCAN driver http://ar.linux.it/software/#ocan
+ *
+ * Copyright (c) 2002-2007 Volkswagen Group Electronic Research
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of Volkswagen nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * Alternatively, provided that this notice is retained in full, this
+ * software may be distributed under the terms of the GNU General
+ * Public License ("GPL") version 2, in which case the provisions of the
+ * GPL apply INSTEAD OF those given above.
+ *
+ * The provided data structures and external interfaces from this code
+ * are not restricted to be used by modules with a GPL compatible license.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * Send feedback to <socketcan-users@lists.berlios.de>
+ *
+ */
+
+#ifndef CAN_HAL_H
+#define CAN_HAL_H
+
+#include <linux/types.h>
+#include <linux/netdevice.h>
+
+/* Number of supported CAN devices for each HAL (default) */
+#define MAXDEV 8
+
+/* general function prototypes for CAN HAL */
+
+/* init the HAL - call at driver module init */
+int hal_init(void);
+
+/* exit the HAL - call at driver module exit */
+int hal_exit(void);
+
+/* get name of this CAN HAL */
+char *hal_name(void);
+
+/* fill arrays base[] and irq[] with HAL specific defaults */
+void hal_use_defaults(void);
+
+/* request controller register access space */
+int hal_request_region(int dev_num,
+		       unsigned int num_regs,
+		       char *drv_name);
+
+/* release controller register access space */
+void hal_release_region(int dev_num,
+			unsigned int num_regs);
+
+/* enable non controller hardware (e.g. irq routing, etc.) */
+int hw_attach(int dev_num);
+
+/* disable non controller hardware (e.g. irq routing, etc.) */
+int hw_detach(int dev_num);
+
+/* reset controller hardware (with specific non controller hardware) */
+int hw_reset_dev(int dev_num);
+
+/* read from controller register */
+u8 hw_readreg(unsigned long base, int reg);
+
+/* write to controller register */
+void hw_writereg(unsigned long base, int reg, u8 val);
+
+/* hardware specific work to do at start of irq handler */
+void hw_preirq(struct net_device *dev);
+
+/* hardware specific work to do at end of irq handler */
+void hw_postirq(struct net_device *dev);
+
+#endif /* CAN_HAL_H */
diff --exclude CVS --exclude .git -uNr linux-2.6.27.8/drivers/net/can/old/hal/io.c linux-2.6.27.8.modified/drivers/net/can/old/hal/io.c
--- linux-2.6.27.8/drivers/net/can/old/hal/io.c	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.27.8.modified/drivers/net/can/old/hal/io.c	2013-05-30 03:44:19.000000000 -0400
@@ -0,0 +1,125 @@
+/*
+ * io.c - linear register access CAN hardware abstraction layer
+ *
+ * $Id: io.c 496 2007-09-27 12:29:32Z hartkopp $
+ *
+ * Inspired by the OCAN driver http://ar.linux.it/software/#ocan
+ *
+ * Copyright (c) 2002-2007 Volkswagen Group Electronic Research
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of Volkswagen nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * Alternatively, provided that this notice is retained in full, this
+ * software may be distributed under the terms of the GNU General
+ * Public License ("GPL") version 2, in which case the provisions of the
+ * GPL apply INSTEAD OF those given above.
+ *
+ * The provided data structures and external interfaces from this code
+ * are not restricted to be used by modules with a GPL compatible license.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * Send feedback to <socketcan-users@lists.berlios.de>
+ *
+ */
+
+#include <linux/netdevice.h>
+#include <linux/ioport.h>
+#include <asm/io.h>
+#include "hal.h"
+
+/* init the HAL - call at driver module init */
+int hal_init(void) { return 0; }
+
+/* exit the HAL - call at driver module exit */
+int hal_exit(void) { return 0; }
+
+/* get name of this CAN HAL */
+char *hal_name(void) { return "io"; }
+
+/* fill arrays base[] and irq[] with HAL specific defaults */
+void hal_use_defaults(void)
+{
+	extern unsigned long base[];
+	extern unsigned int  irq[];
+
+	base[0]		= 0x2C0UL;
+	irq[0]		= 10;
+
+	base[1]		= 0x320UL;
+	irq[1]		= 5;
+}
+
+/* request controller register access space */
+int hal_request_region(int dev_num,
+		       unsigned int num_regs,
+		       char *drv_name)
+{
+	extern unsigned long base[];
+	extern unsigned long rbase[];
+
+	/* set for device base_addr */
+	rbase[dev_num] = base[dev_num];
+
+	/* creating the region for IO is pretty easy */
+	return (request_region(base[dev_num], num_regs, drv_name))? 1 : 0;
+}
+
+/* release controller register access space */
+void hal_release_region(int dev_num,
+			unsigned int num_regs)
+{
+	extern unsigned long base[];
+
+	release_region(base[dev_num], num_regs);
+}
+
+/* enable non controller hardware (e.g. irq routing, etc.) */
+int hw_attach(int dev_num) { return 0; }
+
+/* disable non controller hardware (e.g. irq routing, etc.) */
+int hw_detach(int dev_num) { return 0; }
+
+/* reset controller hardware (with specific non controller hardware) */
+int hw_reset_dev(int dev_num) { return 0; }
+
+/* read from controller register */
+u8 hw_readreg(unsigned long base, int reg) {
+
+	return inb(base + reg);
+}
+
+/* write to controller register */
+void hw_writereg(unsigned long base, int reg, u8 val) {
+
+	outb(val, base + reg);
+}
+
+/* hardware specific work to do at start of irq handler */
+void hw_preirq(struct net_device *dev) { return; }
+
+/* hardware specific work to do at end of irq handler */
+void hw_postirq(struct net_device *dev) { return; }
+
diff --exclude CVS --exclude .git -uNr linux-2.6.27.8/drivers/net/can/old/hal/iomem.c linux-2.6.27.8.modified/drivers/net/can/old/hal/iomem.c
--- linux-2.6.27.8/drivers/net/can/old/hal/iomem.c	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.27.8.modified/drivers/net/can/old/hal/iomem.c	2013-05-30 03:44:19.000000000 -0400
@@ -0,0 +1,144 @@
+/*
+ * iomem.c - linear register access CAN hardware abstraction layer
+ *
+ * $Id: iomem.c 496 2007-09-27 12:29:32Z hartkopp $
+ *
+ * Inspired by the OCAN driver http://ar.linux.it/software/#ocan
+ *
+ * Copyright (c) 2002-2007 Volkswagen Group Electronic Research
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of Volkswagen nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * Alternatively, provided that this notice is retained in full, this
+ * software may be distributed under the terms of the GNU General
+ * Public License ("GPL") version 2, in which case the provisions of the
+ * GPL apply INSTEAD OF those given above.
+ *
+ * The provided data structures and external interfaces from this code
+ * are not restricted to be used by modules with a GPL compatible license.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * Send feedback to <socketcan-users@lists.berlios.de>
+ *
+ */
+
+#include <linux/netdevice.h>
+#include <linux/ioport.h>
+#include <asm/io.h>
+#include "hal.h"
+
+/* init the HAL - call at driver module init */
+int hal_init(void) { return 0; }
+
+/* exit the HAL - call at driver module exit */
+int hal_exit(void) { return 0; }
+
+/* get name of this CAN HAL */
+char *hal_name(void) { return "iomem"; }
+
+/* fill arrays base[] and irq[] with HAL specific defaults */
+void hal_use_defaults(void)
+{
+	extern unsigned long base[];
+	extern unsigned int  irq[];
+
+	base[0]		= 0xd8000UL;
+	irq[0]		= 5;
+
+	base[1]		= 0xd8100UL;
+	irq[1]		= 15;
+}
+
+/* request controller register access space */
+int hal_request_region(int dev_num,
+		       unsigned int num_regs,
+		       char *drv_name)
+{
+	extern unsigned long base[];
+	extern unsigned long rbase[];
+
+	/* creating the region for IOMEM is pretty easy */
+	if (!request_mem_region(base[dev_num], num_regs, drv_name))
+		return 0; /* failed */
+
+	/* set device base_addr */
+	rbase[dev_num] = (unsigned long)ioremap(base[dev_num], num_regs);
+
+	if (rbase[dev_num])
+		return 1; /* success */
+
+	/* cleanup due to failed ioremap() */
+	release_mem_region(base[dev_num], num_regs);
+	return 0; /* failed */
+}
+
+/* release controller register access space */
+void hal_release_region(int dev_num,
+			unsigned int num_regs)
+{
+	extern unsigned long base[];
+	extern unsigned long rbase[];
+
+	iounmap((void *)rbase[dev_num]);
+	release_mem_region(base[dev_num], num_regs);
+}
+
+/* enable non controller hardware (e.g. irq routing, etc.) */
+int hw_attach(int dev_num) { return 0; }
+
+/* disable non controller hardware (e.g. irq routing, etc.) */
+int hw_detach(int dev_num) { return 0; }
+
+/* reset controller hardware (with specific non controller hardware) */
+int hw_reset_dev(int dev_num) { return 0; }
+
+/* read from controller register */
+u8 hw_readreg(unsigned long base, int reg) {
+
+	static u8 val;
+	void __iomem *addr = (void __iomem *)base + reg;
+
+	val = (u8)readb(addr);
+	rmb();
+
+        return val;
+}
+
+/* write to controller register */
+void hw_writereg(unsigned long base, int reg, u8 val) {
+
+	void __iomem *addr = (void __iomem *)base + reg;
+
+	writeb(val, addr);
+	wmb();
+}
+
+/* hardware specific work to do at start of irq handler */
+void hw_preirq(struct net_device *dev) { return; }
+
+/* hardware specific work to do at end of irq handler */
+void hw_postirq(struct net_device *dev) { return; }
+
diff --exclude CVS --exclude .git -uNr linux-2.6.27.8/drivers/net/can/old/hal/iomux.c linux-2.6.27.8.modified/drivers/net/can/old/hal/iomux.c
--- linux-2.6.27.8/drivers/net/can/old/hal/iomux.c	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.27.8.modified/drivers/net/can/old/hal/iomux.c	2013-05-30 03:44:19.000000000 -0400
@@ -0,0 +1,127 @@
+/*
+ * iomux.c - multiplex register access CAN hardware abstraction layer
+ *
+ * $Id: iomux.c 496 2007-09-27 12:29:32Z hartkopp $
+ *
+ * Inspired by the OCAN driver http://ar.linux.it/software/#ocan
+ *
+ * Copyright (c) 2002-2007 Volkswagen Group Electronic Research
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of Volkswagen nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * Alternatively, provided that this notice is retained in full, this
+ * software may be distributed under the terms of the GNU General
+ * Public License ("GPL") version 2, in which case the provisions of the
+ * GPL apply INSTEAD OF those given above.
+ *
+ * The provided data structures and external interfaces from this code
+ * are not restricted to be used by modules with a GPL compatible license.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * Send feedback to <socketcan-users@lists.berlios.de>
+ *
+ */
+
+#include <linux/netdevice.h>
+#include <linux/ioport.h>
+#include <asm/io.h>
+#include "hal.h"
+
+/* init the HAL - call at driver module init */
+int hal_init(void) { return 0; }
+
+/* exit the HAL - call at driver module exit */
+int hal_exit(void) { return 0; }
+
+/* get name of this CAN HAL */
+char *hal_name(void) { return "iomux"; }
+
+/* fill arrays base[] and irq[] with HAL specific defaults */
+void hal_use_defaults(void)
+{
+	extern unsigned long base[];
+	extern unsigned int  irq[];
+
+	base[0]		= 0x300UL;
+	irq[0]		= 5;
+}
+
+/* request controller register access space */
+int hal_request_region(int dev_num,
+		       unsigned int num_regs,
+		       char *drv_name)
+{
+	extern unsigned long base[];
+	extern unsigned long rbase[];
+
+	/* set for device base_addr */
+	rbase[dev_num] = base[dev_num];
+
+	/* ignore num_regs and create the 2 register region:  */
+	/* address register = base / data register = base + 1 */
+	return (request_region(base[dev_num], 2, drv_name))? 1 : 0;
+}
+
+/* release controller register access space */
+void hal_release_region(int dev_num,
+			unsigned int num_regs)
+{
+	extern unsigned long base[];
+
+	/* ignore num_regs and create the 2 register region:  */
+	/* address register = base / data register = base + 1 */
+	release_region(base[dev_num], 2);
+}
+
+/* enable non controller hardware (e.g. irq routing, etc.) */
+int hw_attach(int dev_num) { return 0; }
+
+/* disable non controller hardware (e.g. irq routing, etc.) */
+int hw_detach(int dev_num) { return 0; }
+
+/* reset controller hardware (with specific non controller hardware) */
+int hw_reset_dev(int dev_num) { return 0; }
+
+/* read from controller register */
+u8 hw_readreg(unsigned long base, int reg) {
+
+	outb(reg, base);	/* address */
+	return inb(base + 1);	/* data */
+}
+
+/* write to controller register */
+void hw_writereg(unsigned long base, int reg, u8 val) {
+
+	outb(reg, base);	/* address */
+	outb(val, base + 1);	/* data */
+}
+
+/* hardware specific work to do at start of irq handler */
+void hw_preirq(struct net_device *dev) { return; }
+
+/* hardware specific work to do at end of irq handler */
+void hw_postirq(struct net_device *dev) { return; }
+
diff --exclude CVS --exclude .git -uNr linux-2.6.27.8/drivers/net/can/old/hal/pc7io.c linux-2.6.27.8.modified/drivers/net/can/old/hal/pc7io.c
--- linux-2.6.27.8/drivers/net/can/old/hal/pc7io.c	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.27.8.modified/drivers/net/can/old/hal/pc7io.c	2013-05-30 03:44:19.000000000 -0400
@@ -0,0 +1,128 @@
+/*
+ * pc7io.c - linear register access CAN hardware abstraction layer
+ *
+ * $Id: pc7io.c 496 2007-09-27 12:29:32Z hartkopp $
+ *
+ * Inspired by the OCAN driver http://ar.linux.it/software/#ocan
+ *
+ * Copyright (c) 2002-2007 Volkswagen Group Electronic Research
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of Volkswagen nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * Alternatively, provided that this notice is retained in full, this
+ * software may be distributed under the terms of the GNU General
+ * Public License ("GPL") version 2, in which case the provisions of the
+ * GPL apply INSTEAD OF those given above.
+ *
+ * The provided data structures and external interfaces from this code
+ * are not restricted to be used by modules with a GPL compatible license.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * Send feedback to <socketcan-users@lists.berlios.de>
+ *
+ */
+
+#include <linux/netdevice.h>
+#include <linux/ioport.h>
+#include <asm/io.h>
+#include "hal.h"
+
+/* init the HAL - call at driver module init */
+int hal_init(void) { return 0; }
+
+/* exit the HAL - call at driver module exit */
+int hal_exit(void) { return 0; }
+
+/* get name of this CAN HAL */
+char *hal_name(void) { return "pc7io"; }
+
+/* fill arrays base[] and irq[] with HAL specific defaults */
+void hal_use_defaults(void)
+{
+	extern unsigned long base[];
+	extern unsigned int  irq[];
+
+	base[0]		= 0x1000UL;
+	irq[0]		= 9;
+}
+
+/* request controller register access space */
+int hal_request_region(int dev_num,
+		       unsigned int num_regs,
+		       char *drv_name)
+{
+	extern unsigned long base[];
+	extern unsigned long rbase[];
+
+	/* set for device base_addr */
+	rbase[dev_num] = base[dev_num];
+
+	/* creating the region for IO is pretty easy */
+	return (request_region(base[dev_num], num_regs, drv_name))? 1 : 0;
+}
+
+/* release controller register access space */
+void hal_release_region(int dev_num,
+			unsigned int num_regs)
+{
+	extern unsigned long base[];
+
+	release_region(base[dev_num], num_regs);
+}
+
+/* enable non controller hardware (e.g. irq routing, etc.) */
+int hw_attach(int dev_num) {
+
+	/* Unlock special function register */
+	outb(5, 0x169);
+
+	return 0;
+}
+
+/* disable non controller hardware (e.g. irq routing, etc.) */
+int hw_detach(int dev_num) { return 0; }
+
+/* reset controller hardware (with specific non controller hardware) */
+int hw_reset_dev(int dev_num) { return 0; }
+
+/* read from controller register */
+u8 hw_readreg(unsigned long base, int reg) {
+
+	return inb(base + reg);
+}
+
+/* write to controller register */
+void hw_writereg(unsigned long base, int reg, u8 val) {
+
+	outb(val, base + reg);
+}
+
+/* hardware specific work to do at start of irq handler */
+void hw_preirq(struct net_device *dev) { return; }
+
+/* hardware specific work to do at end of irq handler */
+void hw_postirq(struct net_device *dev) { return; }
+
diff --exclude CVS --exclude .git -uNr linux-2.6.27.8/drivers/net/can/old/i82527/Makefile linux-2.6.27.8.modified/drivers/net/can/old/i82527/Makefile
--- linux-2.6.27.8/drivers/net/can/old/i82527/Makefile	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.27.8.modified/drivers/net/can/old/i82527/Makefile	2013-05-30 03:44:18.000000000 -0400
@@ -0,0 +1,25 @@
+#
+#  $Id: Makefile 797 2008-06-24 06:12:18Z hartkopp $
+#
+
+ifeq ($(KERNELRELEASE),)
+
+KERNELDIR := /lib/modules/$(shell uname -r)/build
+PWD       := $(shell pwd)
+TOPDIR    := $(PWD)/../../../../..
+
+modules modules_install clean:
+	$(MAKE) -C $(KERNELDIR) M=$(PWD) $@ TOPDIR=$(TOPDIR)
+
+else
+
+-include $(TOPDIR)/Makefile.common
+EXTRA_CFLAGS += -I$(TOPDIR)/drivers/net/can/old/hal
+
+obj-m := i82527-pc7io.o i82527-iomem.o i82527-esdio.o
+
+i82527-pc7io-objs := i82527.o proc.o ../hal/pc7io.o
+i82527-iomem-objs := i82527.o proc.o ../hal/iomem.o
+i82527-esdio-objs := i82527.o proc.o ../hal/esdio.o
+
+endif
diff --exclude CVS --exclude .git -uNr linux-2.6.27.8/drivers/net/can/old/i82527/i82527.c linux-2.6.27.8.modified/drivers/net/can/old/i82527/i82527.c
--- linux-2.6.27.8/drivers/net/can/old/i82527/i82527.c	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.27.8.modified/drivers/net/can/old/i82527/i82527.c	2013-05-30 03:44:18.000000000 -0400
@@ -0,0 +1,1310 @@
+/*
+ * i82527.c -  Intel I82527 network device driver
+ *
+ * Copyright (c) 2002-2007 Volkswagen Group Electronic Research
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of Volkswagen nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * Alternatively, provided that this notice is retained in full, this
+ * software may be distributed under the terms of the GNU General
+ * Public License ("GPL") version 2, in which case the provisions of the
+ * GPL apply INSTEAD OF those given above.
+ *
+ * The provided data structures and external interfaces from this code
+ * are not restricted to be used by modules with a GPL compatible license.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * Send feedback to <socketcan-users@lists.berlios.de>
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/version.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/types.h>
+#include <linux/fcntl.h>
+#include <linux/interrupt.h>
+#include <linux/ptrace.h>
+#include <linux/string.h>
+#include <linux/errno.h>
+#include <linux/netdevice.h>
+#include <linux/if_arp.h>
+#include <linux/if_ether.h>
+#include <linux/skbuff.h>
+
+#include <socketcan/can.h>
+#include <socketcan/can/ioctl.h> /* for struct can_device_stats */
+#include "hal.h"
+#include "i82527.h"
+
+#include <socketcan/can/version.h> /* for RCSID. Removed by mkpatch script */
+RCSID("$Id: i82527.c 1038 2009-08-21 10:00:21Z hartkopp $");
+
+MODULE_AUTHOR("Oliver Hartkopp <oliver.hartkopp@volkswagen.de>");
+MODULE_LICENSE("Dual BSD/GPL");
+MODULE_DESCRIPTION("LLCF/socketcan '" CHIP_NAME "' network device driver");
+
+#ifdef CONFIG_CAN_DEBUG_DEVICES
+#define DBG(args...)   ((priv->debug > 0) ? printk(args) : 0)
+/* logging in interrupt context! */
+#define iDBG(args...)  ((priv->debug > 1) ? printk(args) : 0)
+#define iiDBG(args...) ((priv->debug > 2) ? printk(args) : 0)
+#else
+#define DBG(args...)
+#define iDBG(args...)
+#define iiDBG(args...)
+#endif
+
+char drv_name[DRV_NAME_LEN] = "undefined";
+
+/* driver and version information */
+static const char *drv_version	= "0.0.4";
+static const char *drv_reldate	= "2007-08-03";
+
+static const canid_t rxobjflags[] = {0, CAN_EFF_FLAG,
+				     CAN_RTR_FLAG, CAN_RTR_FLAG | CAN_EFF_FLAG,
+				     0, CAN_EFF_FLAG}; 
+#define RXOBJBASE 10
+
+/* array of all can chips */
+struct net_device *can_dev[MAXDEV];
+
+/* module parameters */
+unsigned long base[MAXDEV]	= { 0 }; /* hardware address */
+unsigned long rbase[MAXDEV]	= { 0 }; /* (remapped) device address */
+unsigned int  irq[MAXDEV]	= { 0 };
+
+unsigned int speed[MAXDEV]	= { DEFAULT_SPEED, DEFAULT_SPEED };
+unsigned int btr[MAXDEV]	= { 0 };
+unsigned int bcr[MAXDEV]	= { 0 }; /* bus configuration register */
+unsigned int cdv[MAXDEV]	= { 0 }; /* CLKOUT clock divider */
+unsigned int mo15[MAXDEV]	= { MO15_DEFLT, MO15_DEFLT }; /* msg obj 15 */
+
+static int rx_probe[MAXDEV]	= { 0 };
+static int clk			= DEFAULT_HW_CLK;
+static int force_dmc		= DEFAULT_FORCE_DMC;
+static int irq_mode		= DEFAULT_IRQ_MODE;
+static int debug		= 0;
+static int restart_ms		= 100;
+
+static int base_n;
+static int irq_n;
+static int speed_n;
+static int btr_n;
+static int bcr_n;
+static int cdv_n;
+static int mo15_n;
+static int rx_probe_n;
+
+static u8 dsc; /* devide system clock */
+static u8 dmc; /* devide memory clock */
+static unsigned long irqflags; /* for shared / disabled local interrupts */
+
+module_param_array(base, int, &base_n, 0);
+module_param_array(irq, int, &irq_n, 0);
+module_param_array(speed, int, &speed_n, 0);
+module_param_array(btr, int, &btr_n, 0);
+module_param_array(bcr, int, &bcr_n, 0);
+module_param_array(cdv, int, &cdv_n, 0);
+module_param_array(mo15, int, &mo15_n, 0);
+module_param_array(rx_probe, int, &rx_probe_n, 0);
+
+module_param(clk, int, 0);
+module_param(force_dmc, int, 0);
+module_param(irq_mode, int, 0);
+module_param(debug, int, 0);
+module_param(restart_ms, int, 0);
+
+MODULE_PARM_DESC(base, "CAN controller base address");
+MODULE_PARM_DESC(irq, "CAN controller interrupt");
+MODULE_PARM_DESC(speed, "CAN bus bitrate");
+MODULE_PARM_DESC(btr, "Bit Timing Register value 0x<btr0><btr1>, e.g. 0x4014");
+MODULE_PARM_DESC(bcr, "i82527 bus configuration register value (default: 0)");
+MODULE_PARM_DESC(cdv, "clockout devider value (0-14) (default: 0)");
+MODULE_PARM_DESC(mo15, "rx message object 15 usage. 0:none 1:sff(default) 2:eff");
+MODULE_PARM_DESC(rx_probe, "switch to trx mode after correct msg receiption. (default off)");
+
+MODULE_PARM_DESC(clk, "CAN controller chip clock (default: 16MHz)");
+MODULE_PARM_DESC(force_dmc, "set i82527 DMC bit (default: calculate from clk)"); 
+MODULE_PARM_DESC(irq_mode, "specify irq setup bits (1:shared 2:disable local irqs while processing) (default: 1)"); 
+MODULE_PARM_DESC(debug, "set debug mask (default: 0)");
+MODULE_PARM_DESC(restart_ms, "restart chip on heavy bus errors / bus off after x ms (default 100ms)");
+
+/* function declarations */
+
+static void chipset_init(struct net_device *dev, int wake);
+static void chipset_init_rx(struct net_device *dev);
+static void chipset_init_trx(struct net_device *dev);
+static void can_netdev_setup(struct net_device *dev);
+static struct net_device* can_create_netdev(int dev_num, int hw_regs);
+static int  can_set_drv_name(void);
+int set_reset_mode(struct net_device *dev);
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,23)
+static struct net_device_stats *can_get_stats(struct net_device *dev)
+{
+	struct can_priv *priv = netdev_priv(dev);
+
+	/* TODO: read statistics from chip */
+	return &priv->stats;
+}
+#endif
+
+static int i82527_probe_chip(unsigned long base)
+{
+	// Check if hardware reset is still inactive OR
+	// maybe there is no chip in this address space
+	if (CANin(base, cpuInterfaceReg) & iCPU_RST) {
+		printk(KERN_INFO "%s: probing @ 0x%lX failed (reset)\n",
+		       drv_name, base);
+		return 0;
+	}
+
+	// Write test pattern
+	CANout(base, message1Reg.dataReg[1], 0x25);
+	CANout(base, message2Reg.dataReg[3], 0x52);
+	CANout(base, message10Reg.dataReg[6], 0xc3);
+
+	// Read back test pattern
+	if ((CANin(base, message1Reg.dataReg[1]) != 0x25 ) ||
+	    (CANin(base, message2Reg.dataReg[3]) != 0x52 ) ||
+	    (CANin(base, message10Reg.dataReg[6]) != 0xc3 )) {
+		printk(KERN_INFO "%s: probing @ 0x%lX failed (pattern)\n",
+		       drv_name, base);
+		return 0;
+	}
+
+	return 1;
+}
+
+/*
+ * set baud rate divisor values
+ */
+static void set_btr(struct net_device *dev, int btr0, int btr1)
+{
+	struct can_priv *priv = netdev_priv(dev);
+	unsigned long base = dev->base_addr;
+
+	/* no bla bla when restarting the device */
+	if (priv->state == STATE_UNINITIALIZED)
+		printk(KERN_INFO "%s: setting BTR0=%02X BTR1=%02X\n",
+		       dev->name, btr0, btr1);
+
+	CANout(base, bitTiming0Reg, btr0);
+	CANout(base, bitTiming1Reg, btr1);
+}
+
+/*
+ * calculate baud rate divisor values
+ */
+static void set_baud(struct net_device *dev, int baud, int clock)
+{
+	struct can_priv *priv = netdev_priv(dev);
+
+	int error;
+	int brp;
+	int tseg;
+	int tseg1 = 0;
+	int tseg2 = 0;
+
+	int best_error = 1000000000;
+	int best_tseg = 0;
+	int best_brp = 0;
+	int best_baud = 0;
+
+	int SAM = (baud > 100000 ? 0 : 1);
+
+	if (dsc) /* devide system clock */
+		clock >>= 1; /* calculate BTR with this value */
+
+	for (tseg = (0 + 0 + 2) * 2;
+	     tseg <= (MAX_TSEG2 + MAX_TSEG1 + 2) * 2 + 1;
+	     tseg++) {
+		brp = clock / ((1 + tseg / 2) * baud) + tseg % 2;
+		if ((brp > 0) && (brp <= 64)) {
+			error = baud - clock / (brp * (1 + tseg / 2));
+			if (error < 0) {
+				error = -error;
+			}
+			if (error <= best_error) {
+				best_error = error;
+				best_tseg = tseg / 2;
+				best_brp = brp - 1;
+				best_baud = clock / (brp * (1 + tseg / 2));
+			}
+		}
+	}
+	if (best_error && (baud / best_error < 10)) {
+		printk("%s: unable to set baud rate %d (ext clock %dHz)\n",
+		       dev->name, baud, clock * 2);
+		return;
+//		return -EINVAL;
+	}
+	tseg2 = best_tseg - (SAMPLE_POINT * (best_tseg + 1)) / 100;
+	if (tseg2 < 0) {
+		tseg2 = 0;
+	} else if (tseg2 > MAX_TSEG2) {
+		tseg2 = MAX_TSEG2;
+	}
+	tseg1 = best_tseg - tseg2 - 2;
+	if (tseg1 > MAX_TSEG1) {
+		tseg1 = MAX_TSEG1;
+		tseg2 = best_tseg - tseg1 - 2;
+	}
+
+	priv->btr = ((best_brp | JUMPWIDTH)<<8) + 
+		((SAM << 7) | (tseg2 << 4) | tseg1);
+
+	printk(KERN_INFO "%s: calculated best baudrate: %d / btr is 0x%04X\n",
+	       dev->name, best_baud, priv->btr);
+
+	set_btr(dev, (priv->btr>>8) & 0xFF, priv->btr & 0xFF);
+//	set_btr(dev, best_brp | JUMPWIDTH, (SAM << 7) | (tseg2 << 4) | tseg1);
+}
+
+static inline int obj2rxo(int obj)
+{
+	/* obj4 = obj15 SFF, obj5 = obj15 EFF */ 
+	if (obj < 4)
+		return RXOBJBASE + obj;
+	else
+		return 15;
+}
+
+void enable_rx_obj(unsigned long base, int obj)
+{
+	u8 mcfg = 0;
+	int rxo = obj2rxo(obj);
+
+	// Configure message object for receiption
+	if (rxobjflags[obj] & CAN_EFF_FLAG)
+		mcfg = MCFG_XTD;
+
+	if (rxobjflags[obj] & CAN_RTR_FLAG) {
+		CANout(base, msgArr[rxo].messageReg.messageConfigReg,
+		       mcfg | MCFG_DIR);
+		CANout(base, msgArr[rxo].messageReg.msgCtrl0Reg,
+		       MVAL_SET | TXIE_RES | RXIE_SET | INTPD_RES);
+		CANout(base, msgArr[rxo].messageReg.msgCtrl1Reg,
+		       NEWD_RES | CPUU_SET | TXRQ_RES | RMPD_RES);
+	} else {
+		CANout(base, msgArr[rxo].messageReg.messageConfigReg, mcfg);
+		CANout(base, msgArr[rxo].messageReg.msgCtrl0Reg,
+		       MVAL_SET | TXIE_RES | RXIE_SET | INTPD_RES);
+		CANout(base, msgArr[rxo].messageReg.msgCtrl1Reg,
+		       NEWD_RES | MLST_RES | TXRQ_RES | RMPD_RES);
+	}
+}
+
+void disable_rx_obj(unsigned long base, int obj)
+{
+	int rxo = obj2rxo(obj);
+
+	CANout(base, msgArr[rxo].messageReg.msgCtrl1Reg,
+	       NEWD_RES | MLST_RES | TXRQ_RES | RMPD_RES);
+	CANout(base, msgArr[rxo].messageReg.msgCtrl0Reg,
+	       MVAL_RES | TXIE_RES | RXIE_RES | INTPD_RES);
+}
+
+int set_reset_mode(struct net_device *dev)
+{
+	struct can_priv *priv = netdev_priv(dev);
+	unsigned long base = dev->base_addr;
+
+	// Configure cpu interface
+	CANout(base, cpuInterfaceReg,(dsc | dmc | iCPU_CEN));
+
+	// Enable configuration and puts chip in bus-off, disable interrupts
+	CANout(base, controlReg, iCTL_CCE | iCTL_INI);
+
+	// Clear interrupts
+	CANin(base, interruptReg);
+
+	// Clear status register
+	CANout(base, statusReg, 0);
+
+	// Clear message objects for receiption
+	if (priv->mo15 == MO15_SFF)
+		disable_rx_obj(base, 4); /* rx via obj15 SFF */
+	else
+		disable_rx_obj(base, 0); /* rx via obj10 SFF */
+
+	if (priv->mo15 == MO15_EFF)
+		disable_rx_obj(base, 5); /* rx via obj15 EFF */
+	else
+		disable_rx_obj(base, 1); /* rx via obj11 EFF */
+
+	disable_rx_obj(base, 2);
+	disable_rx_obj(base, 3);
+
+	// Clear message object for send
+	CANout(base, message1Reg.msgCtrl1Reg,
+	       RMPD_RES | TXRQ_RES | CPUU_RES | NEWD_RES);
+	CANout(base, message1Reg.msgCtrl0Reg,
+	       MVAL_RES | TXIE_RES | RXIE_RES | INTPD_RES);
+
+	DBG(KERN_INFO "%s: %s: CtrlReg 0x%x CPUifReg 0x%x\n",
+	    dev->name, __FUNCTION__,
+	    CANin(base, controlReg), CANin(base, cpuInterfaceReg));
+
+	return 0;
+}
+
+static int set_normal_mode(struct net_device *dev)
+{
+	struct can_priv *priv = netdev_priv(dev);
+	unsigned long base = dev->base_addr;
+
+	// Clear interrupts
+	CANin(base, interruptReg);
+
+	// Clear status register
+	CANout(base, statusReg, 0);
+
+	// Configure message objects for receiption
+	if (priv->mo15 == MO15_SFF) {
+		enable_rx_obj(base, 4); /* rx via obj15 SFF */
+		printk(KERN_INFO "%s: %s: using msg object 15 for "
+		       "SFF receiption.\n",
+		       dev->name, CHIP_NAME);
+	} else
+		enable_rx_obj(base, 0); /* rx via obj10 SFF */
+
+	if (priv->mo15 == MO15_EFF) {
+		enable_rx_obj(base, 5); /* rx via obj15 EFF */
+		printk(KERN_INFO "%s: %s: using msg object 15 for "
+		       "EFF receiption.\n",
+		       dev->name, CHIP_NAME);
+	} else
+		enable_rx_obj(base, 1); /* rx via obj11 EFF */
+
+	enable_rx_obj(base, 2);
+	enable_rx_obj(base, 3);
+
+	// Clear message object for send
+	CANout(base, message1Reg.msgCtrl1Reg,
+	       RMPD_RES | TXRQ_RES | CPUU_RES | NEWD_RES);
+	CANout(base, message1Reg.msgCtrl0Reg,
+	       MVAL_RES | TXIE_RES | RXIE_RES | INTPD_RES);
+
+	return 0;
+}
+
+static int set_listen_mode(struct net_device *dev)
+{
+	return set_normal_mode(dev); /* for now */
+}
+
+/*
+ * Clear and invalidate message objects
+ */
+int i82527_clear_msg_objects(unsigned long base)
+{
+    int i;
+    int id;
+    int data;
+
+    for (i = 1; i <= 15; i++) {
+	    CANout(base, msgArr[i].messageReg.msgCtrl0Reg,
+		   INTPD_UNC | RXIE_RES | TXIE_RES | MVAL_RES);
+	    CANout(base, msgArr[i].messageReg.msgCtrl0Reg,
+		   INTPD_RES | RXIE_RES | TXIE_RES | MVAL_RES);
+	    CANout(base, msgArr[i].messageReg.msgCtrl1Reg,
+		   NEWD_RES | MLST_RES | TXRQ_RES | RMPD_RES);
+	    for (data = 0; data < 8; data++)
+		    CANout(base, msgArr[i].messageReg.dataReg[data], 0);
+	    for (id = 0; id < 4; id++)
+		    CANout(base, msgArr[i].messageReg.idReg[id], 0);
+	    CANout(base, msgArr[i].messageReg.messageConfigReg, 0);
+    }
+
+    return 0;
+}
+
+/*
+ * initialize I82527 chip:
+ *   - reset chip
+ *   - set output mode
+ *   - set baudrate
+ *   - enable interrupts
+ *   - start operating mode
+ */
+static void chipset_init_regs(struct net_device *dev)
+{
+	struct can_priv *priv = netdev_priv(dev);
+	unsigned long base = dev->base_addr;
+
+	// Enable configuration and puts chip in bus-off, disable interrupts
+	CANout(base, controlReg, (iCTL_CCE | iCTL_INI));
+
+	// Set CLKOUT devider and slew rates is was done in i82527_init_module
+
+	// Bus configuration was done in i82527_init_module
+
+	// Clear interrupts
+	CANin(base, interruptReg);
+
+	// Clear status register
+	CANout(base, statusReg, 0);
+
+	i82527_clear_msg_objects(base);
+
+	// Set all global ID masks to "don't care"
+	CANout(base, globalMaskStandardReg[0], 0);	
+	CANout(base, globalMaskStandardReg[1], 0);
+	CANout(base, globalMaskExtendedReg[0], 0);
+	CANout(base, globalMaskExtendedReg[1], 0);
+	CANout(base, globalMaskExtendedReg[2], 0);
+	CANout(base, globalMaskExtendedReg[3], 0);
+
+	DBG(KERN_INFO "%s: %s: CtrlReg 0x%x CPUifReg 0x%x\n",
+	    dev->name, __FUNCTION__,
+	    CANin(base, controlReg), CANin(base, cpuInterfaceReg));
+
+	// Note: At this stage the CAN ship is still in bus-off condition
+	// and must be started using StartChip()
+
+	/* set baudrate */
+	if (priv->btr) { /* no calculation when btr is provided */
+		set_btr(dev, (priv->btr>>8) & 0xFF, priv->btr & 0xFF);
+	} else {
+		if (priv->speed == 0) {
+			priv->speed = DEFAULT_SPEED;
+		}
+		set_baud(dev, priv->speed * 1000, priv->clock);
+	}
+
+}
+
+static void chipset_init(struct net_device *dev, int wake)
+{
+	struct can_priv *priv = netdev_priv(dev);
+
+	if (priv->rx_probe)
+		chipset_init_rx(dev); /* wait for valid reception first */
+	else
+		chipset_init_trx(dev);
+
+	if ((wake) && netif_queue_stopped(dev))
+		netif_wake_queue(dev);
+}
+
+static void chipset_init_rx(struct net_device *dev)
+{
+	struct can_priv *priv = netdev_priv(dev);
+	unsigned long base    = dev->base_addr;
+
+	iDBG(KERN_INFO "%s: %s()\n", dev->name, __FUNCTION__);
+
+	/* set chip into reset mode */
+	set_reset_mode(dev);
+
+	/* set registers */
+	chipset_init_regs(dev);
+
+	/* automatic bit rate detection */
+	set_listen_mode(dev);
+
+	priv->state = STATE_PROBE;
+
+	// Clear bus-off, Interrupts only for errors, not for status change
+	CANout(base, controlReg, iCTL_IE | iCTL_EIE);
+
+	DBG(KERN_INFO "%s: %s: CtrlReg 0x%x CPUifReg 0x%x\n",
+	    dev->name, __FUNCTION__,
+	    CANin(base, controlReg), CANin(base, cpuInterfaceReg));
+}
+
+static void chipset_init_trx(struct net_device *dev)
+{
+	struct can_priv *priv = netdev_priv(dev);
+	unsigned long base    = dev->base_addr;
+
+	iDBG(KERN_INFO "%s: %s()\n", dev->name, __FUNCTION__);
+
+	/* set chip into reset mode */
+	set_reset_mode(dev);
+
+	/* set registers */
+	chipset_init_regs(dev);
+
+	/* leave reset mode */
+	set_normal_mode(dev);
+
+	priv->state = STATE_ACTIVE;
+
+	// Clear bus-off, Interrupts only for errors, not for status change
+	CANout(base, controlReg, iCTL_IE | iCTL_EIE);
+
+	DBG(KERN_INFO "%s: %s: CtrlReg 0x%x CPUifReg 0x%x\n",
+	    dev->name, __FUNCTION__,
+	    CANin(base, controlReg), CANin(base, cpuInterfaceReg));
+}
+
+/*
+ * transmit a CAN message
+ * message layout in the sk_buff should be like this:
+ * xx xx xx xx  ll   00 11 22 33 44 55 66 77
+ * [  can-id ] [len] [can data (up to 8 bytes]
+ */
+static int can_start_xmit(struct sk_buff *skb, struct net_device *dev)
+{
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,23)
+	struct net_device_stats *stats = can_get_stats(dev);
+#else
+	struct net_device_stats *stats = &dev->stats;
+#endif
+	struct can_frame *cf	= (struct can_frame*)skb->data;
+	unsigned long base	= dev->base_addr;
+	uint8_t	dlc;
+	uint8_t	rtr;
+	canid_t	id;
+	int	i;
+
+	if ((CANin(base, message1Reg.msgCtrl1Reg) & TXRQ_UNC) == TXRQ_SET) {
+		printk(KERN_ERR "%s: %s: TX register is occupied!\n",
+		       dev->name, drv_name);
+		return 0;
+	}
+
+	netif_stop_queue(dev);
+
+	dlc = cf->can_dlc;
+	id  = cf->can_id;
+
+	if ( cf->can_id & CAN_RTR_FLAG )
+		rtr = 0;
+	else
+		rtr = MCFG_DIR;
+
+	CANout(base, message1Reg.msgCtrl1Reg,
+	       RMPD_RES | TXRQ_RES | CPUU_SET | NEWD_RES);
+	CANout(base, message1Reg.msgCtrl0Reg,
+	       MVAL_SET | TXIE_SET | RXIE_RES | INTPD_RES);
+
+	if (id & CAN_EFF_FLAG) {
+		id &= CAN_EFF_MASK;
+		CANout(base, message1Reg.messageConfigReg,
+		       (dlc << 4) + rtr + MCFG_XTD);
+		CANout(base, message1Reg.idReg[3], (id << 3) & 0xFFU);
+		CANout(base, message1Reg.idReg[2], (id >> 5) & 0xFFU);
+		CANout(base, message1Reg.idReg[1], (id >> 13) & 0xFFU);
+		CANout(base, message1Reg.idReg[0], (id >> 21) & 0xFFU);
+	}
+	else {
+		id &= CAN_SFF_MASK;
+		CANout(base, message1Reg.messageConfigReg,
+		       ( dlc << 4 ) + rtr);
+		CANout(base, message1Reg.idReg[0], (id >> 3) & 0xFFU);
+		CANout(base, message1Reg.idReg[1], (id << 5) & 0xFFU);
+	}
+
+	dlc &= 0x0f; //restore length only
+	for ( i=0; i < dlc; i++ ) {
+		CANout(base, message1Reg.dataReg[i],
+		       cf->data[i]);
+	}
+
+	CANout(base, message1Reg.msgCtrl1Reg,
+	       (RMPD_RES | TXRQ_SET | CPUU_RES | NEWD_UNC));
+
+	// HM: We had some cases of repeated IRQs
+	// so make sure the INT is acknowledged
+	// I know it's already further up, but doing again fixed the issue
+	CANout(base, message1Reg.msgCtrl0Reg,
+	       (MVAL_UNC | TXIE_UNC | RXIE_UNC | INTPD_RES));
+
+	stats->tx_bytes += dlc;
+
+	dev->trans_start = jiffies;
+
+	kfree_skb(skb);
+
+	return 0;
+}
+
+static void can_tx_timeout(struct net_device *dev)
+{
+	struct can_priv *priv = netdev_priv(dev);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,23)
+	struct net_device_stats *stats = can_get_stats(dev);
+#else
+	struct net_device_stats *stats = &dev->stats;
+#endif
+
+	stats->tx_errors++;
+
+	/* do not conflict with e.g. bus error handling */
+	if (!(priv->timer.expires)){ /* no restart on the run */
+		chipset_init_trx(dev); /* no tx queue wakeup */
+		netif_wake_queue(dev); /* wakeup here */
+	}
+	else
+		DBG(KERN_INFO "%s: %s: can_restart_dev already active.\n",
+		    dev->name, __FUNCTION__ );
+
+}
+
+# if 0
+static void can_restart_on(struct net_device *dev)
+{
+	struct can_priv *priv = netdev_priv(dev);
+
+	if (!(priv->timer.expires)){ /* no restart on the run */
+
+		set_reset_mode(dev);
+
+		priv->timer.function = can_restart_dev;
+		priv->timer.data = (unsigned long) dev;
+
+		/* restart chip on persistent error in <xxx> ms */
+		priv->timer.expires = jiffies + (priv->restart_ms * HZ) / 1000;
+		add_timer(&priv->timer);
+
+		iDBG(KERN_INFO "%s: %s start (%ld)\n",
+		     dev->name, __FUNCTION__ , jiffies);
+	} else
+		iDBG(KERN_INFO "%s: %s already (%ld)\n",
+		     dev->name, __FUNCTION__ , jiffies);
+}
+
+static void can_restart_dev(unsigned long data)
+{
+	struct net_device *dev = (struct net_device*) data;
+	struct can_priv *priv = netdev_priv(dev);
+
+	DBG(KERN_INFO "%s: can_restart_dev (%ld)\n",
+	    dev->name, jiffies);
+
+	/* mark inactive timer */
+	priv->timer.expires = 0;
+
+	if (priv->state != STATE_UNINITIALIZED) {
+
+		/* count number of restarts */
+		priv->can_stats.restarts++;
+
+		chipset_init(dev, 1);
+	}
+}
+#endif
+
+#if 0
+/* the timerless version */
+
+static void can_restart_now(struct net_device *dev)
+{
+	struct can_priv *priv = netdev_priv(dev);
+
+	if (priv->state != STATE_UNINITIALIZED) {
+
+		/* count number of restarts */
+		priv->can_stats.restarts++;
+
+		chipset_init(dev, 1);
+	}
+}
+#endif
+
+/*
+ * Subroutine of ISR for RX interrupts.
+ *
+ */
+static void can_rx(struct net_device *dev, int obj)
+{
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,23)
+	struct net_device_stats *stats = can_get_stats(dev);
+#else
+	struct net_device_stats *stats = &dev->stats;
+#endif
+	unsigned long base = dev->base_addr;
+	struct can_frame *cf;
+	struct sk_buff	*skb;
+	uint8_t msgctlreg;
+	uint8_t ctl1reg;
+	canid_t	id;
+	uint8_t	dlc;
+	int	i;
+	int	rxo = obj2rxo(obj);
+
+	skb = dev_alloc_skb(sizeof(struct can_frame));
+	if (skb == NULL) {
+		return;
+	}
+	skb->dev = dev;
+	skb->protocol = htons(ETH_P_CAN);
+	skb->pkt_type = PACKET_BROADCAST;
+	skb->ip_summed = CHECKSUM_UNNECESSARY;
+
+	ctl1reg = CANin(base, msgArr[rxo].messageReg.msgCtrl1Reg);
+	msgctlreg = CANin(base, msgArr[rxo].messageReg.messageConfigReg);
+
+	if( msgctlreg & MCFG_XTD ) {
+		id = CANin(base, msgArr[rxo].messageReg.idReg[3])
+			| (CANin(base, msgArr[rxo].messageReg.idReg[2]) << 8)
+			| (CANin(base, msgArr[rxo].messageReg.idReg[1]) << 16)
+			| (CANin(base, msgArr[rxo].messageReg.idReg[0]) << 24);
+		id >>= 3;
+		id |= CAN_EFF_FLAG;
+	} else {
+		id = CANin(base, msgArr[rxo].messageReg.idReg[1])
+			|(CANin(base, msgArr[rxo].messageReg.idReg[0]) << 8);
+		id >>= 5;
+	}
+
+	if (ctl1reg & RMPD_SET) {
+		id |= CAN_RTR_FLAG;
+	}
+
+	msgctlreg  &= 0xf0;/* strip length code */
+	dlc  = msgctlreg >> 4;
+	dlc %= 9;	/* limit count to 8 bytes */
+
+	cf = (struct can_frame*)skb_put(skb, sizeof(struct can_frame));
+	memset(cf, 0, sizeof(struct can_frame));
+	cf->can_id    = id;
+	cf->can_dlc   = dlc;
+	for (i = 0; i < dlc; i++) {
+		cf->data[i] = CANin(base, msgArr[rxo].messageReg.dataReg[i]);
+	}
+
+	// Make the chip ready to receive the next message
+	enable_rx_obj(base, obj);
+
+	netif_rx(skb);
+
+	dev->last_rx = jiffies;
+	stats->rx_packets++;
+	stats->rx_bytes += dlc;
+}
+
+/*
+ * I82527 interrupt handler
+ */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,19)
+static irqreturn_t can_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+#else
+static irqreturn_t can_interrupt(int irq, void *dev_id)
+#endif
+{
+	struct net_device *dev	= (struct net_device*)dev_id;
+	struct can_priv *priv	= netdev_priv(dev);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,23)
+	struct net_device_stats *stats = can_get_stats(dev);
+#else
+	struct net_device_stats *stats = &dev->stats;
+#endif
+	unsigned long base	= dev->base_addr;
+	uint8_t irqreg;
+	uint8_t lastIrqreg;
+	int n = 0;
+
+	hw_preirq(dev);
+
+	iiDBG(KERN_INFO "%s: interrupt\n", dev->name);
+
+	if (priv->state == STATE_UNINITIALIZED) {
+		printk(KERN_ERR "%s: %s: uninitialized controller!\n",
+		       dev->name, __FUNCTION__);
+		//chipset_init(dev, 1); /* should be possible at this stage */
+		return IRQ_NONE;
+	}
+
+	if (priv->state == STATE_RESET_MODE) {
+		iiDBG(KERN_ERR "%s: %s: controller is in reset mode!\n",
+		      dev->name, __FUNCTION__);
+		return IRQ_NONE;
+	}
+
+     
+	// Read the highest pending interrupt request
+	irqreg = CANin(base, interruptReg);
+	lastIrqreg = irqreg;
+    
+	while ( irqreg ) {
+		n++;
+		switch (irqreg)	{
+
+		case 1: // Status register
+		{
+			uint8_t status;
+
+			// Read the STATUS reg
+			status = CANin(base, statusReg);
+			CANout (base, statusReg, 0);
+
+			if ( status & iSTAT_RXOK ) {
+				// Intel: Software must clear this bit in ISR
+				CANout (base, statusReg, status & ~iSTAT_RXOK);
+			}
+			if ( status & iSTAT_TXOK ) {
+				// Intel: Software must clear this bit in ISR
+				CANout (base, statusReg, status & ~iSTAT_TXOK);
+			}
+			if ( status & iSTAT_WARN ) {
+				// Note: status bit is read-only, don't clear
+				/* error warning interrupt */
+				iDBG(KERN_INFO "%s: error warning\n",
+				     dev->name);
+				priv->can_stats.error_warning++;
+			}
+			if ( status & iSTAT_BOFF ) {
+				uint8_t flags;
+
+				// Note: status bit is read-only, don't clear
+
+				priv->can_stats.bus_error++;
+
+				// Clear init flag and reenable interrupts
+				flags = CANin(base, controlReg) |
+					( iCTL_IE | iCTL_EIE );
+
+				flags &= ~iCTL_INI; // Reset init flag
+				CANout(base, controlReg, flags);
+			}
+		}
+		break;
+
+		case 0x2: // Receiption, message object 15
+		{
+			uint8_t ctl1reg;
+
+			ctl1reg = CANin(base, message15Reg.msgCtrl1Reg);
+			while (ctl1reg & NEWD_SET) {
+				if (ctl1reg & MLST_SET)
+					priv->can_stats.data_overrun++;
+
+				if (priv->mo15 == MO15_SFF)
+					can_rx(dev, 4); /* rx via obj15 SFF */
+				else
+					can_rx(dev, 5); /* rx via obj15 EFF */
+
+				ctl1reg = CANin(base, message15Reg.msgCtrl1Reg);
+			}
+
+			if (priv->state == STATE_PROBE) {
+				/* valid RX -> switch to trx-mode */
+				chipset_init_trx(dev); /* no tx queue wakeup */
+				break; /* check again after init controller */
+			}
+		}
+		break;
+
+		case 0xC: // Receiption, message object 10
+		case 0xD: // Receiption, message object 11
+		{
+			int obj = irqreg - 0xC;
+			int rxo = obj2rxo(obj);
+			uint8_t ctl1reg;
+			ctl1reg = CANin(base, msgArr[rxo].messageReg.msgCtrl1Reg);
+			while (ctl1reg & NEWD_SET) {
+				if (ctl1reg & MLST_SET)
+					priv->can_stats.data_overrun++;
+				CANout(base, msgArr[rxo].messageReg.msgCtrl1Reg,
+				       NEWD_RES | MLST_RES | TXRQ_UNC | RMPD_UNC);
+				can_rx(dev, obj);
+				ctl1reg = CANin(base,
+						msgArr[rxo].messageReg.msgCtrl1Reg);
+			}
+
+			if (priv->state == STATE_PROBE) {
+				/* valid RX -> switch to trx-mode */
+				chipset_init_trx(dev); /* no tx queue wakeup */
+				break; /* check again after init controller */
+			}
+		}
+		break;
+
+		case 0xE: // Receiption, message object 12 (RTR)
+		case 0xF: // Receiption, message object 13 (RTR)
+		{
+			int obj = irqreg - 0xC;
+			int rxo = obj2rxo(obj);
+			uint8_t ctl0reg;
+			ctl0reg = CANin(base, msgArr[rxo].messageReg.msgCtrl0Reg);
+			while (ctl0reg & INTPD_SET) {
+				can_rx(dev, obj);
+				ctl0reg = CANin(base, msgArr[rxo].messageReg.msgCtrl0Reg);
+			}
+
+			if (priv->state == STATE_PROBE) {
+				/* valid RX -> switch to trx-mode */
+				chipset_init_trx(dev); /* no tx queue wakeup */
+				break; /* check again after init controller */
+			}
+		}
+		break;
+
+		case 3: // Message object 1 (our write object)
+			/* transmission complete interrupt */
+
+			// Nothing more to send, switch off interrupts
+			CANout(base, message1Reg.msgCtrl0Reg,
+			       (MVAL_RES | TXIE_RES | RXIE_RES | INTPD_RES));
+			// We had some cases of repeated IRQ
+			// so make sure the INT is acknowledged
+			CANout(base, message1Reg.msgCtrl0Reg,
+			       (MVAL_UNC | TXIE_UNC | RXIE_UNC | INTPD_RES));
+
+			stats->tx_packets++;
+			netif_wake_queue(dev);
+			break;
+
+		default: // Unexpected
+			iDBG(KERN_INFO "%s: Unexpected i82527 interrupt: "
+			     "irqreq=0x%X\n", dev->name, irqreg);
+			break;
+		}
+
+		// Get irq status again for next loop iteration
+		irqreg = CANin(base, interruptReg);
+		if (irqreg == lastIrqreg)
+			iDBG(KERN_INFO "%s: i82527 interrupt repeated: "
+			     "irqreq=0x%X\n", dev->name, irqreg);
+
+		lastIrqreg = irqreg;
+	} /* end while (irqreq) */
+
+	if (n > 1) {
+		iDBG(KERN_INFO "%s: handled %d IRQs\n", dev->name, n);
+	}
+
+	hw_postirq(dev);
+
+	return n == 0 ? IRQ_NONE : IRQ_HANDLED;
+}
+
+/*
+ * initialize CAN bus driver
+ */
+static int can_open(struct net_device *dev)
+{
+	struct can_priv *priv = netdev_priv(dev);
+
+	/* set chip into reset mode */
+	set_reset_mode(dev);
+
+	priv->state = STATE_UNINITIALIZED;
+
+	/* register interrupt handler */
+	if (request_irq(dev->irq, &can_interrupt, irqflags,
+			dev->name, (void*)dev))
+		return -EAGAIN;
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,23)
+	/* clear statistics */
+	memset(&priv->stats, 0, sizeof(priv->stats));
+#endif
+
+	/* init chip */
+	chipset_init(dev, 0);
+	priv->open_time = jiffies;
+
+	netif_start_queue(dev);
+
+	return 0;
+}
+
+/*
+ * stop CAN bus activity
+ */
+static int can_close(struct net_device *dev)
+{
+	struct can_priv *priv = netdev_priv(dev);
+
+	/* set chip into reset mode */
+	set_reset_mode(dev);
+
+	priv->open_time = 0;
+
+	if (priv->timer.expires) {
+		del_timer(&priv->timer);
+		priv->timer.expires = 0;
+	}
+
+	free_irq(dev->irq, (void*)dev);
+	priv->state = STATE_UNINITIALIZED;
+
+	netif_stop_queue(dev);
+
+	return 0;
+}
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,28)
+static const struct net_device_ops can_netdev_ops = {
+	.ndo_open               = can_open,
+	.ndo_stop               = can_close,
+	.ndo_start_xmit         = can_start_xmit,
+	.ndo_tx_timeout		= can_tx_timeout,
+};
+#endif
+
+void can_netdev_setup(struct net_device *dev)
+{
+	/* Fill in the the fields of the device structure
+	   with CAN netdev generic values */
+
+	dev->type			= ARPHRD_CAN;
+	dev->hard_header_len		= 0;
+	dev->mtu			= sizeof(struct can_frame);
+	dev->addr_len			= 0;
+	dev->tx_queue_len		= 10;
+
+	dev->flags			= IFF_NOARP;
+	dev->features			= NETIF_F_NO_CSUM;
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,28)
+	dev->netdev_ops = &can_netdev_ops;
+#else
+	dev->open			= can_open;
+	dev->stop			= can_close;
+	dev->hard_start_xmit		= can_start_xmit;
+	dev->tx_timeout			= can_tx_timeout;
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,23)
+	dev->get_stats			= can_get_stats;
+#endif
+
+	dev->watchdog_timeo		= TX_TIMEOUT;
+}
+
+static struct net_device* can_create_netdev(int dev_num, int hw_regs)
+{
+	struct net_device	*dev;
+	struct can_priv		*priv;
+
+	const char mo15mode [3][6] = {"none", "sff", "eff"};
+
+	if (!(dev = alloc_netdev(sizeof(struct can_priv), CAN_NETDEV_NAME,
+				 can_netdev_setup))) {
+		printk(KERN_ERR "%s: out of memory\n", CHIP_NAME);
+		return NULL;
+	}
+
+	printk(KERN_INFO "%s: base 0x%lX / irq %d / speed %d / "
+	       "btr 0x%X / rx_probe %d / mo15 %s\n",
+	       drv_name, rbase[dev_num], irq[dev_num],
+	       speed[dev_num], btr[dev_num], rx_probe[dev_num],
+	       mo15mode[mo15[dev_num]]);
+
+	/* fill net_device structure */
+
+	priv             = netdev_priv(dev);
+
+	dev->irq         = irq[dev_num];
+	dev->base_addr   = rbase[dev_num];
+
+	priv->speed      = speed[dev_num];
+	priv->btr        = btr[dev_num];
+	priv->rx_probe   = rx_probe[dev_num];
+	priv->mo15       = mo15[dev_num];
+	priv->clock      = clk;
+	priv->hw_regs    = hw_regs;
+	priv->restart_ms = restart_ms;
+	priv->debug      = debug;
+
+	init_timer(&priv->timer);
+	priv->timer.expires = 0;
+
+	if (register_netdev(dev)) {
+		printk(KERN_INFO "%s: register netdev failed\n", CHIP_NAME);
+		free_netdev(dev);
+		return NULL;
+	}
+
+	return dev;
+}
+
+int can_set_drv_name(void)
+{
+	char *hname = hal_name();
+
+	if (strlen(CHIP_NAME) + strlen(hname) >= DRV_NAME_LEN-1) {
+		printk(KERN_ERR "%s: driver name too long!\n", CHIP_NAME);
+		return -EINVAL;
+	}
+	sprintf(drv_name, "%s-%s", CHIP_NAME, hname);
+	return 0;
+}
+
+static void i82527_exit_module(void)
+{
+	int i, ret;
+
+	for (i = 0; i < MAXDEV; i++) {
+		if (can_dev[i] != NULL) {
+			struct can_priv *priv = netdev_priv(can_dev[i]);
+			unregister_netdev(can_dev[i]);
+			del_timer(&priv->timer);
+			hw_detach(i);
+			hal_release_region(i, I82527_IO_SIZE);
+			free_netdev(can_dev[i]);
+		}
+	}
+	can_proc_remove(drv_name);
+
+	if ((ret = hal_exit()))
+		printk(KERN_INFO "%s: hal_exit error %d.\n", drv_name, ret);
+}
+
+static __init int i82527_init_module(void)
+{
+	int i, ret;
+	struct net_device *dev;
+
+	if ((sizeof(canmessage_t) != 15) || (sizeof(canregs_t) != 256)) {
+		printk(KERN_WARNING "%s sizes: canmessage_t %d canregs_t %d\n",
+		       CHIP_NAME, (int)sizeof(canmessage_t),
+		       (int)sizeof(canregs_t));
+		return -EBUSY;
+	}
+
+	if ((ret = hal_init()))
+		return ret;
+
+	if ((ret = can_set_drv_name()))
+		return ret;
+
+	if (clk < 1000 ) /* MHz command line value */
+		clk *= 1000000;
+
+	if (clk < 1000000 ) /* kHz command line value */
+		clk *= 1000;
+
+	printk(KERN_INFO "%s driver v%s (%s)\n",
+	       drv_name, drv_version, drv_reldate);
+	printk(KERN_INFO "%s - options [clk %d.%06d MHz] [restart_ms %dms]"
+	       " [debug %d]\n",
+	       drv_name, clk/1000000, clk%1000000, restart_ms, debug);
+	printk(KERN_INFO "%s - options [force_dmc %d] [irq_mode %d]\n",
+	       drv_name, force_dmc, irq_mode);
+
+	if (!base[0]) {
+		printk(KERN_INFO "%s: loading defaults.\n", drv_name);
+		hal_use_defaults();
+	}
+		
+	/* to ensure the proper access to the i82527 registers */
+	/* the timing dependend settings have to be done first */
+	if (clk > 10000000)
+		dsc = iCPU_DSC; /* devide system clock => MCLK is 8MHz save */
+	else if (clk > 8000000) /* 8MHz < clk <= 10MHz */
+		dmc = iCPU_DMC; /* devide memory clock */
+
+	/* devide memory clock even if it's not needed (regarding the spec) */
+	if (force_dmc)
+		dmc = iCPU_DMC;
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,18)
+	if (irq_mode & IRQ_MODE_SHARED)
+		irqflags |= SA_SHIRQ;
+	if (irq_mode & IRQ_MODE_DISABLE_LOCAL_IRQS)
+		irqflags |= SA_INTERRUPT;
+#else
+	if (irq_mode & IRQ_MODE_SHARED)
+		irqflags |= IRQF_SHARED;
+	if (irq_mode & IRQ_MODE_DISABLE_LOCAL_IRQS)
+		irqflags |= IRQF_DISABLED;
+#endif
+
+	for (i = 0; base[i]; i++) {
+		int clkout;
+		u8 clockdiv;
+
+		printk(KERN_DEBUG "%s: checking for %s on address 0x%lX ...\n",
+		       drv_name, CHIP_NAME, base[i]);
+
+		if (!hal_request_region(i, I82527_IO_SIZE, drv_name)) {
+			printk(KERN_ERR "%s: memory already in use\n",
+			       drv_name);
+			i82527_exit_module();
+			return -EBUSY;
+		}
+
+		hw_attach(i);
+		hw_reset_dev(i);
+
+		// Enable configuration, put chip in bus-off, disable ints
+		CANout(rbase[i], controlReg, iCTL_CCE | iCTL_INI);
+
+		// Configure cpu interface / CLKOUT disable
+		CANout(rbase[i], cpuInterfaceReg,(dsc | dmc));
+
+		if (!i82527_probe_chip(rbase[i])) {
+			printk(KERN_ERR "%s: probably missing controller"
+			       " hardware\n", drv_name);
+			hw_detach(i);
+			hal_release_region(i, I82527_IO_SIZE);
+			i82527_exit_module();
+			return -ENODEV;
+		}
+
+		/* CLKOUT devider and slew rate calculation */
+		if ((cdv[i] < 0) || (cdv[i] > 14)) {
+			printk(KERN_WARNING "%s: adjusted cdv[%d]=%d to 0.\n",
+			       drv_name, i, cdv[i]);
+			cdv[i] = 0;
+		}
+
+		clkout = clk / (cdv[i] + 1); /* CLKOUT frequency */
+		clockdiv = (u8)cdv[i]; /* devider value (see i82527 spec) */
+
+		if (clkout <= 16000000) {
+			clockdiv |= iCLK_SL1;
+			if (clkout <= 8000000)
+				clockdiv |= iCLK_SL0;
+		} else if (clkout <= 24000000)
+				clockdiv |= iCLK_SL0;
+
+		// Set CLKOUT devider and slew rates
+		CANout(rbase[i], clkOutReg, clockdiv);
+
+		// Configure cpu interface / CLKOUT enable
+		CANout(rbase[i], cpuInterfaceReg,(dsc | dmc | iCPU_CEN));
+
+		CANout(rbase[i], busConfigReg, bcr[i]);
+
+		dev = can_create_netdev(i, I82527_IO_SIZE);
+
+		if (dev != NULL) {
+			can_dev[i] = dev;
+			set_reset_mode(dev);
+			can_proc_create(drv_name);
+		} else {
+			can_dev[i] = NULL;
+			hw_detach(i);
+			hal_release_region(i, I82527_IO_SIZE);
+		}
+	}
+	return 0;
+}
+
+module_init(i82527_init_module);
+module_exit(i82527_exit_module);
+
diff --exclude CVS --exclude .git -uNr linux-2.6.27.8/drivers/net/can/old/i82527/i82527.h linux-2.6.27.8.modified/drivers/net/can/old/i82527/i82527.h
--- linux-2.6.27.8/drivers/net/can/old/i82527/i82527.h	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.27.8.modified/drivers/net/can/old/i82527/i82527.h	2013-05-30 03:44:18.000000000 -0400
@@ -0,0 +1,305 @@
+/*
+ * $Id: i82527.h 496 2007-09-27 12:29:32Z hartkopp $
+ *
+ * i82527.h -  Intel I82527 network device driver
+ *
+ * Copyright (c) 2002-2007 Volkswagen Group Electronic Research
+ * All rights reserved.
+ *
+ * Original version Written by Arnaud Westenberg email:arnaud@wanadoo.nl
+ * This software is released under the GPL-License.
+ *
+ * Major Refactoring and Integration into can4linux version 3.1 by
+ * Henrik W Maier of FOCUS Software Engineering Pty Ltd <www.focus-sw.com>
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of Volkswagen nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * Alternatively, provided that this notice is retained in full, this
+ * software may be distributed under the terms of the GNU General
+ * Public License ("GPL") version 2, in which case the provisions of the
+ * GPL apply INSTEAD OF those given above.
+ *
+ * The provided data structures and external interfaces from this code
+ * are not restricted to be used by modules with a GPL compatible license.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * Send feedback to <socketcan-users@lists.berlios.de>
+ *
+ */
+
+#ifndef I82527_H
+#define I82527_H
+
+#define I82527_IO_SIZE 0x100
+
+#define CHIP_NAME	"i82527"
+
+#define DRV_NAME_LEN	30 /* for "<chip_name>-<hal_name>" */
+
+#define PROCBASE          "driver" /* /proc/ ... */
+
+#define DEFAULT_HW_CLK	16000000
+#define DEFAULT_SPEED	500 /* kBit/s */
+#define DEFAULT_FORCE_DMC 0 /* for critical register access, e.g. ser1274 */
+
+#define IRQ_MODE_SHARED 1 /* enable shared interrupts */
+#define IRQ_MODE_DISABLE_LOCAL_IRQS 2 /* when processing the irq handler */
+#define DEFAULT_IRQ_MODE IRQ_MODE_SHARED
+
+/* The message object 15 has a shadow register for reliable data receiption  */
+/* under heavy bus load. Therefore it makes sense to use this message object */
+/* (mo15) for the needed use case. The frame type (EFF/SFF) for the mo15 can */
+/* be defined on the module command line. The default is 11 bit SFF format.  */
+
+#define MO15_NONE 0
+#define MO15_SFF  1
+#define MO15_EFF  2
+
+#define MO15_DEFLT MO15_SFF /* the default */
+
+#define CAN_NETDEV_NAME	"can%d"
+
+#define TX_TIMEOUT      (50*HZ/1000) /* 50ms */ 
+#define RESTART_MS      100  /* restart chip on persistent errors in 100ms */
+#define MAX_BUS_ERRORS  200  /* prevent from flooding bus error interrupts */
+
+/* bus timing */
+#define MAX_TSEG1	15
+#define MAX_TSEG2	 7
+#define SAMPLE_POINT	62
+#define JUMPWIDTH     0x40
+
+typedef struct canmessage {
+	uint8_t	msgCtrl0Reg;	
+	uint8_t	msgCtrl1Reg;	
+	uint8_t	idReg[4];
+	uint8_t	messageConfigReg;
+	uint8_t	dataReg[8];	
+} canmessage_t; // __attribute__ ((packed));
+
+typedef struct canregs {
+  union
+  {
+    struct
+    {
+      canmessage_t messageReg;
+      uint8_t someOtherReg; // padding
+    } msgArr[16];
+    struct
+    {
+      uint8_t      controlReg;               // Control Register
+      uint8_t      statusReg;                // Status Register
+      uint8_t      cpuInterfaceReg;          // CPU Interface Register
+      uint8_t      reserved1Reg;
+      uint8_t      highSpeedReadReg[2];      // High Speed Read
+      uint8_t      globalMaskStandardReg[2]; // Standard Global Mask byte 0
+      uint8_t      globalMaskExtendedReg[4]; // Extended Global Mask bytes
+      uint8_t      message15MaskReg[4];      // Message 15 Mask bytes
+      canmessage_t message1Reg;
+      uint8_t      clkOutReg;                // Clock Out Register
+      canmessage_t message2Reg;
+      uint8_t      busConfigReg;             // Bus Configuration Register
+      canmessage_t message3Reg;
+      uint8_t      bitTiming0Reg;            // Bit Timing Register byte 0
+      canmessage_t message4Reg;
+      uint8_t      bitTiming1Reg;            // Bit Timing Register byte 1
+      canmessage_t message5Reg;
+      uint8_t      interruptReg;             // Interrupt Register
+      canmessage_t message6Reg;
+      uint8_t      reserved2Reg;
+      canmessage_t message7Reg;
+      uint8_t      reserved3Reg;
+      canmessage_t message8Reg;
+      uint8_t      reserved4Reg;
+      canmessage_t message9Reg;
+      uint8_t      p1ConfReg;
+      canmessage_t message10Reg;
+      uint8_t      p2ConfReg;
+      canmessage_t message11Reg;
+      uint8_t      p1InReg;
+      canmessage_t message12Reg;
+      uint8_t      p2InReg;
+      canmessage_t message13Reg;
+      uint8_t      p1OutReg;
+      canmessage_t message14Reg;
+      uint8_t      p2OutReg;
+      canmessage_t message15Reg;
+      uint8_t      serialResetAddressReg;
+    };
+  };
+} canregs_t; // __attribute__ ((packed));
+
+/* Control Register (0x00) */
+enum i82527_iCTL {
+	iCTL_INI = 1,		// Initialization
+	iCTL_IE  = 1<<1,	// Interrupt Enable
+	iCTL_SIE = 1<<2,	// Status Interrupt Enable
+	iCTL_EIE = 1<<3,	// Error Interrupt Enable
+	iCTL_CCE = 1<<6		// Change Configuration Enable
+};
+
+/* Status Register (0x01) */
+enum i82527_iSTAT {
+	iSTAT_TXOK = 1<<3,	// Transmit Message Successfully
+	iSTAT_RXOK = 1<<4,	// Receive Message Successfully
+	iSTAT_WAKE = 1<<5,	// Wake Up Status
+	iSTAT_WARN = 1<<6,	// Warning Status
+	iSTAT_BOFF = 1<<7	// Bus Off Status
+};
+
+/* CPU Interface Register (0x02) */
+enum i82527_iCPU {
+	iCPU_CEN = 1,		// Clock Out Enable
+	iCPU_MUX = 1<<2,	// Multiplex
+	iCPU_SLP = 1<<3,	// Sleep
+	iCPU_PWD = 1<<4,	// Power Down Mode
+	iCPU_DMC = 1<<5,	// Divide Memory Clock
+	iCPU_DSC = 1<<6,	// Divide System Clock
+	iCPU_RST = 1<<7,	// Hardware Reset Status
+};
+
+/* Clock Out Register (0x1f) */
+enum i82527_iCLK {
+	iCLK_CD0 = 1,		// Clock Divider bit 0
+	iCLK_CD1 = 1<<1,
+	iCLK_CD2 = 1<<2,
+	iCLK_CD3 = 1<<3,
+	iCLK_SL0 = 1<<4,	// Slew Rate bit 0
+	iCLK_SL1 = 1<<5
+};
+
+/* Bus Configuration Register (0x2f) */
+enum i82527_iBUS {
+	iBUS_DR0 = 1,		// Disconnect RX0 Input
+	iBUS_DR1 = 1<<1,	// Disconnect RX1 Input
+	iBUS_DT1 = 1<<3,	// Disconnect TX1 Output
+	iBUS_POL = 1<<5,	// Polarity
+	iBUS_CBY = 1<<6		// Comparator Bypass
+};
+
+#define RESET 1			// Bit Pair Reset Status
+#define SET 2			// Bit Pair Set Status
+#define UNCHANGED 3		// Bit Pair Unchanged
+
+/* Message Control Register 0 (Base Address + 0x0) */
+enum i82527_iMSGCTL0 {
+	INTPD_SET = SET,		// Interrupt pending
+	INTPD_RES = RESET,		// No Interrupt pending
+	INTPD_UNC = UNCHANGED,
+	RXIE_SET  = SET<<2,		// Receive Interrupt Enable
+	RXIE_RES  = RESET<<2,		// Receive Interrupt Disable
+	RXIE_UNC  = UNCHANGED<<2,
+	TXIE_SET  = SET<<4,		// Transmit Interrupt Enable
+	TXIE_RES  = RESET<<4,		// Transmit Interrupt Disable
+	TXIE_UNC  = UNCHANGED<<4,
+	MVAL_SET  = SET<<6,		// Message Valid
+	MVAL_RES  = RESET<<6,		// Message Invalid
+	MVAL_UNC  = UNCHANGED<<6
+};
+
+/* Message Control Register 1 (Base Address + 0x01) */
+enum i82527_iMSGCTL1 {
+	NEWD_SET = SET,			// New Data
+	NEWD_RES = RESET,		// No New Data
+	NEWD_UNC = UNCHANGED,
+	MLST_SET = SET<<2,		// Message Lost
+	MLST_RES = RESET<<2,		// No Message Lost
+	MLST_UNC = UNCHANGED<<2,
+	CPUU_SET = SET<<2,		// CPU Updating
+	CPUU_RES = RESET<<2,		// No CPU Updating
+	CPUU_UNC = UNCHANGED<<2,
+	TXRQ_SET = SET<<4,		// Transmission Request
+	TXRQ_RES = RESET<<4,		// No Transmission Request
+	TXRQ_UNC = UNCHANGED<<4,
+	RMPD_SET = SET<<6,		// Remote Request Pending
+	RMPD_RES = RESET<<6,		// No Remote Request Pending
+	RMPD_UNC = UNCHANGED<<6
+};
+
+/* Message Configuration Register (Base Address + 0x06) */
+enum i82527_iMSGCFG {
+	MCFG_XTD = 1<<2,		// Extended Identifier
+	MCFG_DIR = 1<<3			// Direction is Transmit
+};
+
+#undef IOPRINT
+#undef IODEBUG
+
+#ifdef IOPRINT
+#define CANout(base,adr,v) \
+	printk("CANout: (%lx+%x)=%x\n", base,\
+					(int)(long)&((canregs_t *)0)->adr,v)
+
+#define CANin(base,adr) \
+	printk("CANin: (%lx+%x)\n", base, (int)(long)&((canregs_t *)0)->adr)
+
+#else /* IOPRINT */
+
+#ifdef IODEBUG
+#define CANout(base,adr,v)      \
+	(printk("CANout: (%lx+%x)=%x\n", base,\
+		(int)(long)&((canregs_t *)0)->adr,v),\
+		hw_writereg(base, (int)(long)&((canregs_t *)0)->adr, v))
+#else
+#define CANout(base,adr,v) hw_writereg(base,\
+					(int)(long)&((canregs_t *)0)->adr, v)
+#endif
+
+#define CANin(base,adr)	hw_readreg(base, (int)(long)&((canregs_t *)0)->adr)
+
+#endif /* IOPRINT */
+
+/* CAN private data structure */
+
+struct can_priv {
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,23)
+	struct net_device_stats	stats;
+#endif
+	struct can_device_stats	can_stats;
+	long			open_time;
+	int			clock;
+	int			hw_regs;
+	int			restart_ms;
+	int			debug;
+	int			speed;
+	int			btr;
+	int			rx_probe;
+	int			mo15;
+	struct timer_list       timer;
+	int			state;
+};
+
+#define STATE_UNINITIALIZED	0
+#define STATE_PROBE		1
+#define STATE_ACTIVE		2
+#define STATE_ERROR_ACTIVE	3
+#define STATE_ERROR_PASSIVE	4
+#define STATE_BUS_OFF		5
+#define STATE_RESET_MODE	6
+
+void can_proc_create(const char *drv_name);
+void can_proc_remove(const char *drv_name);
+
+#endif /* I82527_H */
diff --exclude CVS --exclude .git -uNr linux-2.6.27.8/drivers/net/can/old/i82527/proc.c linux-2.6.27.8.modified/drivers/net/can/old/i82527/proc.c
--- linux-2.6.27.8/drivers/net/can/old/i82527/proc.c	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.27.8.modified/drivers/net/can/old/i82527/proc.c	2013-05-30 03:44:18.000000000 -0400
@@ -0,0 +1,218 @@
+/*
+ * proc.c -  proc file system functions for I82527 CAN driver.
+ *
+ * Copyright (c) 2002-2007 Volkswagen Group Electronic Research
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of Volkswagen nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * Alternatively, provided that this notice is retained in full, this
+ * software may be distributed under the terms of the GNU General
+ * Public License ("GPL") version 2, in which case the provisions of the
+ * GPL apply INSTEAD OF those given above.
+ *
+ * The provided data structures and external interfaces from this code
+ * are not restricted to be used by modules with a GPL compatible license.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * Send feedback to <socketcan-users@lists.berlios.de>
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/version.h>
+#include <linux/slab.h>
+#include <linux/proc_fs.h>
+#include <linux/netdevice.h>
+
+#include <socketcan/can.h>
+#include <socketcan/can/ioctl.h>
+#include "i82527.h"
+#include "hal.h"
+
+#include <socketcan/can/version.h> /* for RCSID. Removed by mkpatch script */
+RCSID("$Id: proc.c 1038 2009-08-21 10:00:21Z hartkopp $");
+
+extern struct net_device *can_dev[];
+
+static struct proc_dir_entry *pde       = NULL;
+static struct proc_dir_entry *pde_regs  = NULL;
+static struct proc_dir_entry *pde_reset = NULL;
+
+static int can_proc_read_stats(char *page, char **start, off_t off,
+			       int count, int *eof, void *data)
+{
+	int len = 0;
+	int i;
+
+	len += snprintf(page + len, PAGE_SIZE - len,
+			"CAN bus device statistics:\n");
+	len += snprintf(page + len, PAGE_SIZE - len,
+			"       errwarn  overrun   wakeup   buserr   "
+			"errpass  arbitr   restarts clock        baud\n");
+	for (i = 0; (i < MAXDEV) && (len < PAGE_SIZE - 200); i++) {
+		if (can_dev[i]) {
+			struct net_device *dev = can_dev[i];
+			struct can_priv *priv  = netdev_priv(dev);
+			len += snprintf(page + len, PAGE_SIZE - len,
+					"%s: %8d %8d %8d %8d %8d "
+					"%8d %8d %10d %8d\n", dev->name,
+					priv->can_stats.error_warning,
+					priv->can_stats.data_overrun,
+					priv->can_stats.wakeup,
+					priv->can_stats.bus_error,
+					priv->can_stats.error_passive,
+					priv->can_stats.arbitration_lost,
+					priv->can_stats.restarts,
+					priv->clock,
+					priv->speed
+				);
+
+		}
+	}
+
+	*eof = 1;
+	return len;
+}
+
+
+static int can_proc_dump_regs(char *page, int len, struct net_device *dev)
+{
+	int r,s;
+	struct can_priv	*priv = netdev_priv(dev);
+	int regs = priv->hw_regs;
+
+	len += snprintf(page + len, PAGE_SIZE - len,
+			"%s registers:\n", dev->name);
+
+	for (r = 0; r < regs; r += 0x10) {
+		len += snprintf(page + len, PAGE_SIZE - len, "%02X: ", r);
+		for (s = 0; s < 0x10; s++) {
+			if (r+s < regs)
+				len += snprintf(page + len, PAGE_SIZE-len,
+						"%02X ",
+						hw_readreg(dev->base_addr,
+							   r+s));
+		}
+		len += snprintf(page + len, PAGE_SIZE - len, "\n");
+	}
+
+        return len;
+}
+
+static int can_proc_read_regs(char *page, char **start, off_t off,
+				  int count, int *eof, void *data)
+{
+	int len = 0;
+	int i;
+
+	for (i = 0; (i < MAXDEV) && (len < PAGE_SIZE - 200); i++) {
+		if (can_dev[i])
+			len = can_proc_dump_regs(page, len, can_dev[i]);
+	}
+
+	*eof = 1;
+	return len;
+}
+
+static int can_proc_read_reset(char *page, char **start, off_t off,
+				   int count, int *eof, void *data)
+{
+	int len = 0;
+	struct net_device *dev;
+	int i;
+	struct can_priv   *priv;
+
+	len += snprintf(page + len, PAGE_SIZE - len, "resetting ");
+	for (i = 0; (i < MAXDEV) && (len < PAGE_SIZE - 200); i++) {
+		if (can_dev[i]) {
+			dev = can_dev[i];
+			priv = netdev_priv(can_dev[i]);
+			if ((priv->state != STATE_UNINITIALIZED)
+			    && (priv->state != STATE_RESET_MODE)) {
+				len += snprintf(page + len, PAGE_SIZE - len,
+						"%s ", dev->name);
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,28)
+				dev->netdev_ops->ndo_stop(dev);
+				dev->netdev_ops->ndo_open(dev);
+#else
+				dev->stop(dev);
+				dev->open(dev);
+#endif
+				/* count number of restarts */
+				priv->can_stats.restarts++;
+
+			} else {
+				len += snprintf(page + len, PAGE_SIZE - len,
+						"(%s|%d) ", dev->name,
+						priv->state);
+			}
+		}
+	}
+
+	len += snprintf(page + len, PAGE_SIZE - len, "done\n");
+
+	*eof = 1;
+	return len;
+}
+
+void can_proc_create(const char *drv_name)
+{
+	char fname[256];
+
+	if (pde == NULL) {
+		sprintf(fname, PROCBASE "/%s_stats", drv_name);
+		pde = create_proc_read_entry(fname, 0644, NULL,
+					     can_proc_read_stats, NULL);
+	}
+	if (pde_regs == NULL) {
+		sprintf(fname, PROCBASE "/%s_regs", drv_name);
+		pde_regs = create_proc_read_entry(fname, 0644, NULL,
+						  can_proc_read_regs, NULL);
+	}
+	if (pde_reset == NULL) {
+		sprintf(fname, PROCBASE "/%s_reset", drv_name);
+		pde_reset = create_proc_read_entry(fname, 0644, NULL,
+						   can_proc_read_reset, NULL);
+	}
+}
+
+void can_proc_remove(const char *drv_name)
+{
+	char fname[256];
+
+	if (pde) {
+		sprintf(fname, PROCBASE "/%s_stats", drv_name);
+		remove_proc_entry(fname, NULL);
+	}
+	if (pde_regs) {
+		sprintf(fname, PROCBASE "/%s_regs", drv_name);
+		remove_proc_entry(fname, NULL);
+	}
+	if (pde_reset) {
+		sprintf(fname, PROCBASE "/%s_reset", drv_name);
+		remove_proc_entry(fname, NULL);
+	}
+}
diff --exclude CVS --exclude .git -uNr linux-2.6.27.8/drivers/net/can/old/mscan/Makefile linux-2.6.27.8.modified/drivers/net/can/old/mscan/Makefile
--- linux-2.6.27.8/drivers/net/can/old/mscan/Makefile	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.27.8.modified/drivers/net/can/old/mscan/Makefile	2013-05-30 03:44:18.000000000 -0400
@@ -0,0 +1,22 @@
+#
+#  $Id: Makefile 797 2008-06-24 06:12:18Z hartkopp $
+#
+
+ifeq ($(KERNELRELEASE),)
+
+KERNELDIR := /lib/modules/$(shell uname -r)/build
+PWD       := $(shell pwd)
+TOPDIR    := $(PWD)/../../../..
+
+modules modules_install clean:
+	$(MAKE) -C $(KERNELDIR) M=$(PWD) $@ TOPDIR=$(TOPDIR)
+
+else
+
+-include $(TOPDIR)/Makefile.common
+
+obj-$(CONFIG_CAN_MPC52XX_OLD)	+= mscan-mpc52xx-old.o
+
+mscan-mpc52xx-old-objs	:= mscan.o mpc52xx_can.o
+
+endif
diff --exclude CVS --exclude .git -uNr linux-2.6.27.8/drivers/net/can/old/mscan/mpc52xx_can.c linux-2.6.27.8.modified/drivers/net/can/old/mscan/mpc52xx_can.c
--- linux-2.6.27.8/drivers/net/can/old/mscan/mpc52xx_can.c	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.27.8.modified/drivers/net/can/old/mscan/mpc52xx_can.c	2013-05-30 03:44:18.000000000 -0400
@@ -0,0 +1,255 @@
+/*
+ * DESCRIPTION:
+ *  CAN bus driver for the Freescale MPC52xx embedded CPU.
+ *
+ * AUTHOR:
+ *  Andrey Volkov <avolkov@varma-el.com>
+ *
+ * COPYRIGHT:
+ *  2004-2005, Varma Electronics Oy
+ *
+ * LICENCE:
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ * HISTORY:
+ *	 2005-02-03 created
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/netdevice.h>
+#include <socketcan/can.h>
+#include <socketcan/can/dev.h>
+#include <asm/io.h>
+#include <asm/mpc52xx.h>
+
+#include "mscan.h"
+
+#include <socketcan/can/version.h>	/* for RCSID. Removed by mkpatch script */
+
+RCSID("$Id: mpc52xx_can.c 1038 2009-08-21 10:00:21Z hartkopp $");
+
+#define PDEV_MAX 2
+
+struct platform_device *pdev[PDEV_MAX];
+
+static int __devinit mpc52xx_can_probe(struct platform_device *pdev)
+{
+	struct resource *mem;
+	struct net_device *dev;
+	struct mscan_platform_data *pdata = pdev->dev.platform_data;
+	struct can_priv *can;
+	u32 mem_size;
+	int ret = -ENODEV;
+
+	if (!pdata)
+		return ret;
+
+	dev = alloc_mscandev();
+	if (!dev)
+		return -ENOMEM;
+	can = netdev_priv(dev);
+
+	mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	dev->irq = platform_get_irq(pdev, 0);
+	if (!mem || !dev->irq)
+		goto req_error;
+
+	mem_size = mem->end - mem->start + 1;
+	if (!request_mem_region(mem->start, mem_size, pdev->dev.driver->name)) {
+		dev_err(&pdev->dev, "resource unavailable\n");
+		goto req_error;
+	}
+
+	SET_NETDEV_DEV(dev, &pdev->dev);
+
+	dev->base_addr = (unsigned long)ioremap_nocache(mem->start, mem_size);
+
+	if (!dev->base_addr) {
+		dev_err(&pdev->dev, "failed to map can port\n");
+		ret = -ENOMEM;
+		goto fail_map;
+	}
+
+	can->can_sys_clock = pdata->clock_frq;
+
+	platform_set_drvdata(pdev, dev);
+
+	ret = register_mscandev(dev, pdata->clock_src);
+	if (ret >= 0) {
+		dev_info(&pdev->dev, "probe for a port 0x%lX done\n",
+			 dev->base_addr);
+		return ret;
+	}
+
+	iounmap((unsigned long *)dev->base_addr);
+      fail_map:
+	release_mem_region(mem->start, mem_size);
+      req_error:
+	free_candev(dev);
+	dev_err(&pdev->dev, "probe failed\n");
+	return ret;
+}
+
+static int __devexit mpc52xx_can_remove(struct platform_device *pdev)
+{
+	struct net_device *dev = platform_get_drvdata(pdev);
+	struct resource *mem;
+
+	platform_set_drvdata(pdev, NULL);
+	unregister_mscandev(dev);
+
+	iounmap((volatile void __iomem *)dev->base_addr);
+	mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	release_mem_region(mem->start, mem->end - mem->start + 1);
+	free_candev(dev);
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static struct mscan_regs saved_regs;
+static int mpc52xx_can_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	struct net_device *dev = platform_get_drvdata(pdev);
+	struct mscan_regs *regs = (struct mscan_regs *)dev->base_addr;
+
+	_memcpy_fromio(&saved_regs, regs, sizeof(*regs));
+
+	return 0;
+}
+
+static int mpc52xx_can_resume(struct platform_device *pdev)
+{
+	struct net_device *dev = platform_get_drvdata(pdev);
+	struct mscan_regs *regs = (struct mscan_regs *)dev->base_addr;
+
+	regs->canctl0 |= MSCAN_INITRQ;
+	while ((regs->canctl1 & MSCAN_INITAK) == 0)
+		udelay(10);
+
+	regs->canctl1 = saved_regs.canctl1;
+	regs->canbtr0 = saved_regs.canbtr0;
+	regs->canbtr1 = saved_regs.canbtr1;
+	regs->canidac = saved_regs.canidac;
+
+	/* restore masks, buffers etc. */
+	_memcpy_toio(&regs->canidar1_0, (void *)&saved_regs.canidar1_0,
+		     sizeof(*regs) - offsetof(struct mscan_regs, canidar1_0));
+
+	regs->canctl0 &= ~MSCAN_INITRQ;
+	regs->cantbsel = saved_regs.cantbsel;
+	regs->canrier = saved_regs.canrier;
+	regs->cantier = saved_regs.cantier;
+	regs->canctl0 = saved_regs.canctl0;
+
+	return 0;
+}
+#endif
+
+static struct platform_driver mpc52xx_can_driver = {
+	.driver = {
+		   .name = "mpc52xx-mscan",
+		   },
+	.probe = mpc52xx_can_probe,
+	.remove = __devexit_p(mpc52xx_can_remove),
+#ifdef CONFIG_PM
+	.suspend = mpc52xx_can_suspend,
+	.resume = mpc52xx_can_resume,
+#endif
+};
+
+#ifdef CONFIG_PPC_MERGE
+static int __init mpc52xx_of_to_pdev(void)
+{
+	struct device_node *np = NULL;
+	unsigned int i;
+	int err = -ENODEV;
+
+	for (i = 0;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,25)
+ 	     (np = of_find_compatible_node(np, "mscan", "mpc5200-mscan"));
+#else
+	     (np = of_find_compatible_node(np, NULL, "fsl,mpc5200-mscan"));
+#endif
+	     i++) {
+		struct resource r[2] = { };
+		struct mscan_platform_data pdata;
+
+		if (i >= PDEV_MAX) {
+			printk(KERN_WARNING "%s: increase PDEV_MAX for more "
+			       "than %i devices\n", __func__, PDEV_MAX);
+			break;
+		}
+
+		err = of_address_to_resource(np, 0, &r[0]);
+		if (err)
+			break;
+
+		of_irq_to_resource(np, 0, &r[1]);
+
+		pdev[i] =
+		    platform_device_register_simple("mpc52xx-mscan", i, r, 2);
+		if (IS_ERR(pdev[i])) {
+			err = PTR_ERR(pdev[i]);
+			break;
+		}
+
+		pdata.clock_src = MSCAN_CLKSRC_BUS;
+		pdata.clock_frq = mpc52xx_find_ipb_freq(np);
+		err = platform_device_add_data(pdev[i], &pdata, sizeof(pdata));
+		if (err)
+			break;
+	}
+	return err;
+}
+#else
+#define mscan_of_to_pdev()
+#endif
+
+int __init mpc52xx_can_init(void)
+{
+	printk(KERN_WARNING
+	       "This %s driver is DEPRECATED, please switch!\n",
+	       mpc52xx_can_driver.driver.name);
+#ifdef CONFIG_PPC_MERGE
+	int err = mpc52xx_of_to_pdev();
+
+	if (err) {
+		printk(KERN_ERR "%s init failed with err=%d\n",
+		       mpc52xx_can_driver.driver.name, err);
+		return err;
+	}
+#endif
+	return platform_driver_register(&mpc52xx_can_driver);
+}
+
+void __exit mpc52xx_can_exit(void)
+{
+	int i;
+	platform_driver_unregister(&mpc52xx_can_driver);
+	for (i = 0; i < PDEV_MAX; i++)
+		platform_device_unregister(pdev[i]);
+	printk(KERN_INFO "%s unloaded\n", mpc52xx_can_driver.driver.name);
+}
+
+module_init(mpc52xx_can_init);
+module_exit(mpc52xx_can_exit);
+
+MODULE_AUTHOR("Andrey Volkov <avolkov@varma-el.com>");
+MODULE_DESCRIPTION("Freescale MPC5200 CAN driver");
+MODULE_LICENSE("GPL v2");
diff --exclude CVS --exclude .git -uNr linux-2.6.27.8/drivers/net/can/old/mscan/mscan.c linux-2.6.27.8.modified/drivers/net/can/old/mscan/mscan.c
--- linux-2.6.27.8/drivers/net/can/old/mscan/mscan.c	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.27.8.modified/drivers/net/can/old/mscan/mscan.c	2013-05-30 03:44:18.000000000 -0400
@@ -0,0 +1,752 @@
+/*
+ * mscan.c
+ *
+ * DESCRIPTION:
+ *  CAN bus driver for the alone generic (as possible as) MSCAN controller.
+ *
+ * AUTHOR:
+ *  Andrey Volkov <avolkov@varma-el.com>
+ *
+ * COPYRIGHT:
+ *  2005-2006, Varma Electronics Oy
+ *
+ * LICENCE:
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/interrupt.h>
+#include <linux/delay.h>
+#include <linux/netdevice.h>
+#include <linux/if_arp.h>
+#include <linux/if_ether.h>
+#include <socketcan/can.h>
+#include <linux/list.h>
+#include <asm/io.h>
+
+#include <socketcan/can/dev.h>
+#include <socketcan/can/error.h>
+#include "mscan.h"
+
+#include <socketcan/can/version.h>	/* for RCSID. Removed by mkpatch script */
+RCSID("$Id: mscan.c 1038 2009-08-21 10:00:21Z hartkopp $");
+
+#define MSCAN_NORMAL_MODE	0
+#define MSCAN_SLEEP_MODE	MSCAN_SLPRQ
+#define MSCAN_INIT_MODE		(MSCAN_INITRQ | MSCAN_SLPRQ)
+#define MSCAN_POWEROFF_MODE	(MSCAN_CSWAI | MSCAN_SLPRQ)
+#define MSCAN_SET_MODE_RETRIES	255
+
+
+#define BTR0_BRP_MASK		0x3f
+#define BTR0_SJW_SHIFT		6
+#define BTR0_SJW_MASK		(0x3 << BTR0_SJW_SHIFT)
+
+#define BTR1_TSEG1_MASK 	0xf
+#define BTR1_TSEG2_SHIFT	4
+#define BTR1_TSEG2_MASK 	(0x7 << BTR1_TSEG2_SHIFT)
+#define BTR1_SAM_SHIFT  	7
+
+#define BTR0_SET_BRP(brp)	(((brp) - 1) & BTR0_BRP_MASK)
+#define BTR0_SET_SJW(sjw)	((((sjw) - 1) << BTR0_SJW_SHIFT) & \
+				 BTR0_SJW_MASK)
+
+#define BTR1_SET_TSEG1(tseg1)	(((tseg1) - 1) &  BTR1_TSEG1_MASK)
+#define BTR1_SET_TSEG2(tseg2)	((((tseg2) - 1) << BTR1_TSEG2_SHIFT) & \
+				 BTR1_TSEG2_MASK)
+#define BTR1_SET_SAM(sam)	(((sam) & 1) << BTR1_SAM_SHIFT)
+
+struct mscan_state {
+	u8 mode;
+	u8 canrier;
+	u8 cantier;
+};
+
+#define TX_QUEUE_SIZE	3
+
+typedef struct {
+	struct list_head list;
+	u8 mask;
+} tx_queue_entry_t;
+
+struct mscan_priv {
+	struct can_priv can;
+	volatile unsigned long flags;
+	u8 shadow_statflg;
+	u8 shadow_canrier;
+	u8 cur_pri;
+	u8 tx_active;
+
+	struct list_head tx_head;
+	tx_queue_entry_t tx_queue[TX_QUEUE_SIZE];
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,23)
+	struct napi_struct napi;
+	struct net_device *dev;
+#endif
+};
+
+#define F_RX_PROGRESS	0
+#define F_TX_PROGRESS	1
+#define F_TX_WAIT_ALL	2
+
+static int mscan_set_mode(struct net_device *dev, u8 mode)
+{
+	struct mscan_regs *regs = (struct mscan_regs *)dev->base_addr;
+	int ret = 0;
+	int i;
+	u8 canctl1;
+
+	if (mode != MSCAN_NORMAL_MODE) {
+		canctl1 = in_8(&regs->canctl1);
+		if ((mode & MSCAN_SLPRQ) && (canctl1 & MSCAN_SLPAK) == 0) {
+			out_8(&regs->canctl0,
+			      in_8(&regs->canctl0) | MSCAN_SLPRQ);
+			for (i = 0; i < MSCAN_SET_MODE_RETRIES; i++) {
+				if (in_8(&regs->canctl1) & MSCAN_SLPAK)
+					break;
+				udelay(100);
+			}
+			if (i >= MSCAN_SET_MODE_RETRIES)
+				ret = -ENODEV;
+		}
+
+		if (!ret && (mode & MSCAN_INITRQ)
+		    && (canctl1 & MSCAN_INITAK) == 0) {
+			out_8(&regs->canctl0,
+			      in_8(&regs->canctl0) | MSCAN_INITRQ);
+			for (i = 0; i < MSCAN_SET_MODE_RETRIES; i++) {
+				if (in_8(&regs->canctl1) & MSCAN_INITAK)
+					break;
+			}
+			if (i >= MSCAN_SET_MODE_RETRIES)
+				ret = -ENODEV;
+		}
+
+		if (!ret && (mode & MSCAN_CSWAI))
+			out_8(&regs->canctl0,
+			      in_8(&regs->canctl0) | MSCAN_CSWAI);
+
+	} else {
+		canctl1 = in_8(&regs->canctl1);
+		if (canctl1 & (MSCAN_SLPAK | MSCAN_INITAK)) {
+			out_8(&regs->canctl0, in_8(&regs->canctl0) &
+			      ~(MSCAN_SLPRQ | MSCAN_INITRQ));
+			for (i = 0; i < MSCAN_SET_MODE_RETRIES; i++) {
+				canctl1 = in_8(&regs->canctl1);
+				if (!(canctl1 & (MSCAN_INITAK | MSCAN_SLPAK)))
+					break;
+			}
+			if (i >= MSCAN_SET_MODE_RETRIES)
+				ret = -ENODEV;
+		}
+	}
+	return ret;
+}
+
+static void mscan_push_state(struct net_device *dev, struct mscan_state *state)
+{
+	struct mscan_regs *regs = (struct mscan_regs *)dev->base_addr;
+
+	state->mode = in_8(&regs->canctl0) & (MSCAN_SLPRQ | MSCAN_INITRQ |
+					      MSCAN_CSWAI);
+	state->canrier = in_8(&regs->canrier);
+	state->cantier = in_8(&regs->cantier);
+}
+
+static int mscan_pop_state(struct net_device *dev, struct mscan_state *state)
+{
+	struct mscan_regs *regs = (struct mscan_regs *)dev->base_addr;
+
+	int ret;
+	ret = mscan_set_mode(dev, state->mode);
+	if (!ret) {
+		out_8(&regs->canrier, state->canrier);
+		out_8(&regs->cantier, state->cantier);
+	}
+	return ret;
+}
+
+static int mscan_hard_start_xmit(struct sk_buff *skb, struct net_device *dev)
+{
+	struct can_frame *frame = (struct can_frame *)skb->data;
+	struct mscan_regs *regs = (struct mscan_regs *)dev->base_addr;
+	struct mscan_priv *priv = netdev_priv(dev);
+
+	int i, rtr, buf_id;
+	u32 can_id;
+
+	if (frame->can_dlc > 8)
+		return -EINVAL;
+
+	dev_dbg(ND2D(dev), "%s\n", __FUNCTION__);
+	out_8(&regs->cantier, 0);
+
+	i = ~priv->tx_active & MSCAN_TXE;
+	buf_id = ffs(i) - 1;
+	switch (hweight8(i)) {
+	case 0:
+		netif_stop_queue(dev);
+		dev_err(ND2D(dev), "BUG! Tx Ring full when queue awake!\n");
+		return NETDEV_TX_BUSY;
+	case 1:
+		/* if buf_id < 3, then current frame will be send out of order,
+		   since  buffer with lower id have higher priority (hell..) */
+		if (buf_id < 3)
+			priv->cur_pri++;
+		if (priv->cur_pri == 0xff)
+			set_bit(F_TX_WAIT_ALL, &priv->flags);
+		netif_stop_queue(dev);
+	case 2:
+		set_bit(F_TX_PROGRESS, &priv->flags);
+	}
+	out_8(&regs->cantbsel, i);
+
+	rtr = frame->can_id & CAN_RTR_FLAG;
+
+	if (frame->can_id & CAN_EFF_FLAG) {
+		dev_dbg(ND2D(dev), "sending extended frame\n");
+
+		can_id = (frame->can_id & CAN_EFF_MASK) << 1;
+		if (rtr)
+			can_id |= 1;
+		out_be16(&regs->tx.idr3_2, can_id);
+
+		can_id >>= 16;
+		can_id = (can_id & 0x7) | ((can_id << 2) & 0xffe0) | (3 << 3);
+	} else {
+		dev_dbg(ND2D(dev), "sending standard frame\n");
+		can_id = (frame->can_id & CAN_SFF_MASK) << 5;
+		if (rtr)
+			can_id |= 1 << 4;
+	}
+	out_be16(&regs->tx.idr1_0, can_id);
+
+	if (!rtr) {
+		volatile void __iomem *data = &regs->tx.dsr1_0;
+		u16 *payload = (u16 *) frame->data;
+		/*Its safe to write into dsr[dlc+1] */
+		for (i = 0; i < (frame->can_dlc + 1) / 2; i++) {
+			out_be16(data, *payload++);
+			data += 2 + _MSCAN_RESERVED_DSR_SIZE;
+		}
+	}
+
+	out_8(&regs->tx.dlr, frame->can_dlc);
+	out_8(&regs->tx.tbpr, priv->cur_pri);
+
+	/* Start transmission. */
+	out_8(&regs->cantflg, 1 << buf_id);
+
+	if (!test_bit(F_TX_PROGRESS, &priv->flags))
+		dev->trans_start = jiffies;
+
+	list_add_tail(&priv->tx_queue[buf_id].list, &priv->tx_head);
+
+	kfree_skb(skb);
+
+	/* Enable interrupt. */
+	priv->tx_active |= 1 << buf_id;
+	out_8(&regs->cantier, priv->tx_active);
+
+	return NETDEV_TX_OK;
+}
+
+static void mscan_tx_timeout(struct net_device *dev)
+{
+	struct sk_buff *skb;
+	struct mscan_regs *regs = (struct mscan_regs *)dev->base_addr;
+	struct mscan_priv *priv = netdev_priv(dev);
+	struct can_frame *frame;
+	u8 mask;
+
+	printk("%s\n", __FUNCTION__);
+
+	out_8(&regs->cantier, 0);
+
+	mask = list_entry(priv->tx_head.next, tx_queue_entry_t, list)->mask;
+	dev->trans_start = jiffies;
+	out_8(&regs->cantarq, mask);
+	out_8(&regs->cantier, priv->tx_active);
+
+	skb = dev_alloc_skb(sizeof(struct can_frame));
+	if (!skb) {
+		if (printk_ratelimit())
+			dev_notice(ND2D(dev), "TIMEOUT packet dropped\n");
+		return;
+	}
+	frame = (struct can_frame *)skb_put(skb, sizeof(struct can_frame));
+
+	frame->can_id = CAN_ERR_FLAG | CAN_ERR_TX_TIMEOUT;
+	frame->can_dlc = CAN_ERR_DLC;
+
+	skb->dev = dev;
+	skb->protocol = __constant_htons(ETH_P_CAN);
+	skb->pkt_type = PACKET_BROADCAST;
+	skb->ip_summed = CHECKSUM_UNNECESSARY;
+
+	netif_rx(skb);
+
+}
+
+static can_state_t state_map[] = {
+	CAN_STATE_ACTIVE,
+	CAN_STATE_BUS_WARNING,
+	CAN_STATE_BUS_PASSIVE,
+	CAN_STATE_BUS_OFF
+};
+
+static inline int check_set_state(struct net_device *dev, u8 canrflg)
+{
+	struct mscan_priv *priv = netdev_priv(dev);
+	can_state_t state;
+	int ret = 0;
+
+	if (!(canrflg & MSCAN_CSCIF) || priv->can.state > CAN_STATE_BUS_OFF)
+		return 0;
+
+	state =
+	    state_map[max(MSCAN_STATE_RX(canrflg), MSCAN_STATE_TX(canrflg))];
+	if (priv->can.state < state)
+		ret = 1;
+	if (state == CAN_STATE_BUS_OFF)
+		netif_carrier_off(dev);
+	else if (priv->can.state == CAN_STATE_BUS_OFF
+		 && state != CAN_STATE_BUS_OFF)
+		netif_carrier_on(dev);
+	priv->can.state = state;
+	return ret;
+}
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,23)
+static int mscan_rx_poll(struct napi_struct *napi, int quota)
+#else
+static int mscan_rx_poll(struct net_device *dev, int *budget)
+#endif
+{
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,23)
+	struct mscan_priv *priv = container_of(napi, struct mscan_priv, napi);
+	struct net_device *dev = priv->dev;
+#else
+	struct mscan_priv *priv = netdev_priv(dev);
+	int quota = min(dev->quota, *budget);
+#endif
+	struct mscan_regs *regs = (struct mscan_regs *)dev->base_addr;
+	struct net_device_stats *stats = dev->get_stats(dev);
+	int npackets = 0;
+	int ret = 1;
+	struct sk_buff *skb;
+	struct can_frame *frame;
+	u32 can_id;
+	u8 canrflg;
+	int i;
+
+	while (npackets < quota && ((canrflg = in_8(&regs->canrflg)) &
+				    (MSCAN_RXF | MSCAN_ERR_IF))) {
+
+		skb = dev_alloc_skb(sizeof(struct can_frame));
+		if (!skb) {
+			if (printk_ratelimit())
+				dev_notice(ND2D(dev), "packet dropped\n");
+			stats->rx_dropped++;
+			out_8(&regs->canrflg, canrflg);
+			continue;
+		}
+
+		frame = (struct can_frame *)skb_put(skb,
+						    sizeof(struct can_frame));
+
+		if (canrflg & MSCAN_RXF) {
+			can_id = in_be16(&regs->rx.idr1_0);
+			if (can_id & (1 << 3)) {
+				frame->can_id = CAN_EFF_FLAG;
+				can_id = ((can_id << 16) |
+					  in_be16(&regs->rx.idr3_2));
+				can_id = ((can_id & 0xffe00000) |
+					  ((can_id & 0x7ffff) << 2)) >> 2;
+			} else {
+				can_id >>= 4;
+				frame->can_id = 0;
+			}
+
+			frame->can_id |= can_id >> 1;
+			if (can_id & 1)
+				frame->can_id |= CAN_RTR_FLAG;
+			frame->can_dlc = in_8(&regs->rx.dlr) & 0xf;
+
+			if (!(frame->can_id & CAN_RTR_FLAG)) {
+				volatile void __iomem *data = &regs->rx.dsr1_0;
+				u16 *payload = (u16 *) frame->data;
+				for (i = 0; i < (frame->can_dlc + 1) / 2; i++) {
+					*payload++ = in_be16(data);
+					data += 2 + _MSCAN_RESERVED_DSR_SIZE;
+				}
+			}
+
+			dev_dbg(ND2D(dev),
+				"received pkt: id: %u dlc: %u data: ",
+				frame->can_id, frame->can_dlc);
+#ifdef DEBUG
+			for (i = 0;
+			     i < frame->can_dlc && !(frame->can_id &
+						     CAN_FLAG_RTR); i++)
+				printk("%2x ", frame->data[i]);
+			printk("\n");
+#endif
+
+			out_8(&regs->canrflg, MSCAN_RXF);
+			dev->last_rx = jiffies;
+			stats->rx_packets++;
+			stats->rx_bytes += frame->can_dlc;
+		} else if (canrflg & MSCAN_ERR_IF) {
+			frame->can_id = CAN_ERR_FLAG;
+
+			if (canrflg & MSCAN_OVRIF) {
+				frame->can_id |= CAN_ERR_CRTL;
+				frame->data[1] = CAN_ERR_CRTL_RX_OVERFLOW;
+				stats->rx_over_errors++;
+			} else
+				frame->data[1] = 0;
+
+			if (check_set_state(dev, canrflg)) {
+				frame->can_id |= CAN_ERR_CRTL;
+				switch (priv->can.state) {
+				case CAN_STATE_BUS_WARNING:
+					if ((priv->shadow_statflg &
+					     MSCAN_RSTAT_MSK) <
+					    (canrflg & MSCAN_RSTAT_MSK))
+						frame->data[1] |=
+						    CAN_ERR_CRTL_RX_WARNING;
+
+					if ((priv->shadow_statflg &
+					     MSCAN_TSTAT_MSK) <
+					    (canrflg & MSCAN_TSTAT_MSK))
+						frame->data[1] |=
+							CAN_ERR_CRTL_TX_WARNING;
+					break;
+				case CAN_STATE_BUS_PASSIVE:
+					frame->data[1] |=
+					    CAN_ERR_CRTL_RX_PASSIVE;
+					break;
+				case CAN_STATE_BUS_OFF:
+					frame->can_id |= CAN_ERR_BUSOFF;
+					frame->can_id &= ~CAN_ERR_CRTL;
+					break;
+				default:
+					break;
+				}
+			}
+			priv->shadow_statflg = canrflg & MSCAN_STAT_MSK;
+			frame->can_dlc = CAN_ERR_DLC;
+			out_8(&regs->canrflg, MSCAN_ERR_IF);
+		}
+
+		npackets++;
+		skb->dev = dev;
+		skb->protocol = __constant_htons(ETH_P_CAN);
+		skb->ip_summed = CHECKSUM_UNNECESSARY;
+		netif_receive_skb(skb);
+	}
+
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2,6,23)
+	*budget -= npackets;
+	dev->quota -= npackets;
+#endif
+
+	if (!(in_8(&regs->canrflg) & (MSCAN_RXF | MSCAN_ERR_IF))) {
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,23)
+		netif_rx_complete(dev, &priv->napi);
+#else
+		netif_rx_complete(dev);
+#endif
+		clear_bit(F_RX_PROGRESS, &priv->flags);
+		out_8(&regs->canrier,
+		      in_8(&regs->canrier) | MSCAN_ERR_IF | MSCAN_RXFIE);
+		ret = 0;
+	}
+	return ret;
+}
+
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,19)
+static irqreturn_t mscan_isr(int irq, void *dev_id, struct pt_regs *r)
+#else
+static irqreturn_t mscan_isr(int irq, void *dev_id)
+#endif
+{
+	struct net_device *dev = (struct net_device *)dev_id;
+	struct mscan_priv *priv = netdev_priv(dev);
+	struct mscan_regs *regs = (struct mscan_regs *)dev->base_addr;
+	struct net_device_stats *stats = dev->get_stats(dev);
+	u8 cantier, cantflg, canrflg;
+	irqreturn_t ret = IRQ_NONE;
+
+	if ((cantier = in_8(&regs->cantier) & MSCAN_TXE) &&
+	    (cantflg = in_8(&regs->cantflg) & cantier)) {
+		struct list_head *tmp, *pos;
+
+		list_for_each_safe(pos, tmp, &priv->tx_head) {
+			tx_queue_entry_t *entry =
+			    list_entry(pos, tx_queue_entry_t, list);
+			u8 mask = entry->mask;
+
+			if (!(cantflg & mask))
+				continue;
+
+			if (in_8(&regs->cantaak) & mask) {
+				stats->tx_dropped++;
+				stats->tx_aborted_errors++;
+			} else {
+				out_8(&regs->cantbsel, mask);
+				stats->tx_bytes +=
+				    in_8(&regs->tx.dlr);
+				stats->tx_packets++;
+			}
+			priv->tx_active &= ~mask;
+			list_del(pos);
+		}
+
+		if (list_empty(&priv->tx_head)) {
+			clear_bit(F_TX_WAIT_ALL, &priv->flags);
+			clear_bit(F_TX_PROGRESS, &priv->flags);
+			priv->cur_pri = 0;
+		} else
+			dev->trans_start = jiffies;
+
+		if (!test_bit(F_TX_WAIT_ALL, &priv->flags))
+			netif_wake_queue(dev);
+
+		out_8(&regs->cantier, priv->tx_active);
+		ret = IRQ_HANDLED;
+	}
+
+	if ((((canrflg = in_8(&regs->canrflg)) & ~MSCAN_STAT_MSK)) &&
+	    !test_and_set_bit(F_RX_PROGRESS, &priv->flags)) {
+		if (check_set_state(dev, canrflg)) {
+			out_8(&regs->canrflg, MSCAN_CSCIF);
+			ret = IRQ_HANDLED;
+		}
+		if (canrflg & ~MSCAN_STAT_MSK) {
+			priv->shadow_canrier = in_8(&regs->canrier);
+			out_8(&regs->canrier, 0);
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,23)
+			netif_rx_schedule(dev, &priv->napi);
+#else
+			netif_rx_schedule(dev);
+#endif
+			ret = IRQ_HANDLED;
+		} else
+			clear_bit(F_RX_PROGRESS, &priv->flags);
+	}
+	return ret;
+}
+
+static int mscan_do_set_mode(struct net_device *dev, can_mode_t mode)
+{
+	switch (mode) {
+	case CAN_MODE_SLEEP:
+	case CAN_MODE_STOP:
+		netif_stop_queue(dev);
+		mscan_set_mode(dev,
+			       (mode ==
+				CAN_MODE_STOP) ? MSCAN_INIT_MODE :
+			       MSCAN_SLEEP_MODE);
+		break;
+	case CAN_MODE_START:
+		printk("%s: CAN_MODE_START requested\n", __FUNCTION__);
+		mscan_set_mode(dev, MSCAN_NORMAL_MODE);
+		netif_wake_queue(dev);
+		break;
+
+	default:
+		return -EOPNOTSUPP;
+	}
+	return 0;
+}
+
+static int mscan_do_set_bit_time(struct net_device *dev,
+				 struct can_bittime *bt)
+{
+	struct mscan_priv *priv = netdev_priv(dev);
+	struct mscan_regs *regs = (struct mscan_regs *)dev->base_addr;
+	int ret = 0;
+	u8 reg;
+	struct mscan_state state;
+
+	if (bt->type != CAN_BITTIME_STD)
+		return -EINVAL;
+
+	spin_lock_irq(&priv->can.irq_lock);
+
+	mscan_push_state(dev, &state);
+	ret = mscan_set_mode(dev, MSCAN_INIT_MODE);
+	if (!ret) {
+		reg = BTR0_SET_BRP(bt->std.brp) | BTR0_SET_SJW(bt->std.sjw);
+		out_8(&regs->canbtr0, reg);
+
+		reg = (BTR1_SET_TSEG1(bt->std.prop_seg + bt->std.phase_seg1) |
+		       BTR1_SET_TSEG2(bt->std.phase_seg2) |
+		       BTR1_SET_SAM(bt->std.sam));
+		out_8(&regs->canbtr1, reg);
+
+		ret = mscan_pop_state(dev, &state);
+	}
+
+	spin_unlock_irq(&priv->can.irq_lock);
+	return ret;
+}
+
+static int mscan_open(struct net_device *dev)
+{
+	int ret;
+	struct mscan_priv *priv = netdev_priv(dev);
+	struct mscan_regs *regs = (struct mscan_regs *)dev->base_addr;
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,23)
+	napi_enable(&priv->napi);
+#endif
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,18)
+	ret = request_irq(dev->irq, mscan_isr, SA_SHIRQ, dev->name, dev);
+#else
+	ret = request_irq(dev->irq, mscan_isr, IRQF_SHARED, dev->name, dev);
+#endif
+
+	if (ret  < 0) {
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,23)
+		napi_disable(&priv->napi);
+#endif
+		printk(KERN_ERR "%s - failed to attach interrupt\n",
+		       dev->name);
+		return ret;
+	}
+
+	INIT_LIST_HEAD(&priv->tx_head);
+	/* acceptance mask/acceptance code (accept everything) */
+	out_be16(&regs->canidar1_0, 0);
+	out_be16(&regs->canidar3_2, 0);
+	out_be16(&regs->canidar5_4, 0);
+	out_be16(&regs->canidar7_6, 0);
+
+	out_be16(&regs->canidmr1_0, 0xffff);
+	out_be16(&regs->canidmr3_2, 0xffff);
+	out_be16(&regs->canidmr5_4, 0xffff);
+	out_be16(&regs->canidmr7_6, 0xffff);
+	/* Two 32 bit Acceptance Filters */
+	out_8(&regs->canidac, MSCAN_AF_32BIT);
+
+	out_8(&regs->canctl1, in_8(&regs->canctl1) & ~MSCAN_LISTEN);
+	mscan_set_mode(dev, MSCAN_NORMAL_MODE);
+
+	priv->shadow_statflg = in_8(&regs->canrflg) & MSCAN_STAT_MSK;
+	priv->cur_pri = 0;
+	priv->tx_active = 0;
+
+	out_8(&regs->cantier, 0);
+	/* Enable receive interrupts. */
+	out_8(&regs->canrier, MSCAN_OVRIE | MSCAN_RXFIE | MSCAN_CSCIE |
+	      MSCAN_RSTATE1 | MSCAN_RSTATE0 | MSCAN_TSTATE1 | MSCAN_TSTATE0);
+
+	netif_start_queue(dev);
+
+	return 0;
+}
+
+static int mscan_close(struct net_device *dev)
+{
+	struct mscan_regs *regs = (struct mscan_regs *)dev->base_addr;
+
+	netif_stop_queue(dev);
+
+	/* disable interrupts */
+	out_8(&regs->cantier, 0);
+	out_8(&regs->canrier, 0);
+	free_irq(dev->irq, dev);
+
+	mscan_set_mode(dev, MSCAN_INIT_MODE);
+	return 0;
+}
+
+int register_mscandev(struct net_device *dev, int clock_src)
+{
+	struct mscan_regs *regs = (struct mscan_regs *)dev->base_addr;
+	u8 ctl1;
+
+	ctl1 = in_8(&regs->canctl1);
+	if (clock_src)
+		ctl1 |= MSCAN_CLKSRC;
+	else
+		ctl1 &= ~MSCAN_CLKSRC;
+
+	ctl1 |= MSCAN_CANE;
+	out_8(&regs->canctl1, ctl1);
+	udelay(100);
+
+	mscan_set_mode(dev, MSCAN_INIT_MODE);
+
+	return register_netdev(dev);
+}
+
+EXPORT_SYMBOL(register_mscandev);
+
+void unregister_mscandev(struct net_device *dev)
+{
+	struct mscan_regs *regs = (struct mscan_regs *)dev->base_addr;
+	mscan_set_mode(dev, MSCAN_INIT_MODE);
+	out_8(&regs->canctl1, in_8(&regs->canctl1) & ~MSCAN_CANE);
+	unregister_netdev(dev);
+}
+
+EXPORT_SYMBOL(unregister_mscandev);
+
+struct net_device *alloc_mscandev(void)
+{
+	struct net_device *dev;
+	struct mscan_priv *priv;
+	int i;
+
+	dev = alloc_candev(sizeof(struct mscan_priv));
+	if (!dev)
+		return NULL;
+	priv = netdev_priv(dev);
+
+	dev->watchdog_timeo = MSCAN_WATCHDOG_TIMEOUT;
+	dev->open = mscan_open;
+	dev->stop = mscan_close;
+	dev->hard_start_xmit = mscan_hard_start_xmit;
+	dev->tx_timeout = mscan_tx_timeout;
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,23)
+	priv->dev = dev;
+	netif_napi_add(dev, &priv->napi, mscan_rx_poll, 8);
+#else
+	dev->poll = mscan_rx_poll;
+	dev->weight = 8;
+#endif
+
+	priv->can.do_set_bittime = mscan_do_set_bit_time;
+	priv->can.do_set_mode = mscan_do_set_mode;
+
+	for (i = 0; i < TX_QUEUE_SIZE; i++)
+		priv->tx_queue[i].mask = 1 << i;
+
+	return dev;
+}
+
+EXPORT_SYMBOL(alloc_mscandev);
+
+MODULE_AUTHOR("Andrey Volkov <avolkov@varma-el.com>");
+MODULE_LICENSE("GPL v2");
+MODULE_DESCRIPTION("CAN port driver for a mscan based chips");
diff --exclude CVS --exclude .git -uNr linux-2.6.27.8/drivers/net/can/old/mscan/mscan.h linux-2.6.27.8.modified/drivers/net/can/old/mscan/mscan.h
--- linux-2.6.27.8/drivers/net/can/old/mscan/mscan.h	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.27.8.modified/drivers/net/can/old/mscan/mscan.h	2013-05-30 03:44:18.000000000 -0400
@@ -0,0 +1,249 @@
+/*
+ * $Id: mscan.h 440 2007-07-25 10:45:40Z wolf $
+ *
+ * DESCRIPTION:
+ *  Definitions of consts/structs to drive the Freescale MSCAN.
+ *
+ * AUTHOR:
+ *  Andrey Volkov <avolkov@varma-el.com>
+ *
+ * COPYRIGHT:
+ *  2004-2006, Varma Electronics Oy
+ *
+ * LICENCE:
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+#ifndef __MSCAN_H__
+#define __MSCAN_H__
+
+#include <linux/autoconf.h>
+#include <asm/types.h>
+
+/* MSCAN control register 0 (CANCTL0) bits */
+#define MSCAN_RXFRM		0x80
+#define MSCAN_RXACT		0x40
+#define MSCAN_CSWAI		0x20
+#define MSCAN_SYNCH		0x10
+#define MSCAN_TIME		0x08
+#define MSCAN_WUPE		0x04
+#define MSCAN_SLPRQ		0x02
+#define MSCAN_INITRQ		0x01
+
+/* MSCAN control register 1 (CANCTL1) bits */
+#define MSCAN_CANE		0x80
+#define MSCAN_CLKSRC		0x40
+#define MSCAN_LOOPB		0x20
+#define MSCAN_LISTEN		0x10
+#define MSCAN_WUPM		0x04
+#define MSCAN_SLPAK		0x02
+#define MSCAN_INITAK		0x01
+
+#ifdef	CONFIG_PPC_MPC52xx
+#define MSCAN_CLKSRC_BUS	0
+#define MSCAN_CLKSRC_XTAL	MSCAN_CLKSRC
+#else
+#define MSCAN_CLKSRC_BUS	MSCAN_CLKSRC
+#define MSCAN_CLKSRC_XTAL	0
+#endif
+
+/* MSCAN receiver flag register (CANRFLG) bits */
+#define MSCAN_WUPIF		0x80
+#define MSCAN_CSCIF		0x40
+#define MSCAN_RSTAT1		0x20
+#define MSCAN_RSTAT0		0x10
+#define MSCAN_TSTAT1		0x08
+#define MSCAN_TSTAT0		0x04
+#define MSCAN_OVRIF		0x02
+#define MSCAN_RXF		0x01
+#define MSCAN_ERR_IF 		(MSCAN_OVRIF | MSCAN_CSCIF)
+#define MSCAN_RSTAT_MSK		(MSCAN_RSTAT1 | MSCAN_RSTAT0)
+#define MSCAN_TSTAT_MSK		(MSCAN_TSTAT1 | MSCAN_TSTAT0)
+#define MSCAN_STAT_MSK		(MSCAN_RSTAT_MSK | MSCAN_TSTAT_MSK)
+
+#define MSCAN_STATE_BUS_OFF	(MSCAN_RSTAT1 | MSCAN_RSTAT0 | \
+				 MSCAN_TSTAT1 | MSCAN_TSTAT0)
+#define MSCAN_STATE_TX(canrflg)	(((canrflg)&MSCAN_TSTAT_MSK)>>2)
+#define MSCAN_STATE_RX(canrflg)	(((canrflg)&MSCAN_RSTAT_MSK)>>4)
+#define MSCAN_STATE_ACTIVE	0
+#define MSCAN_STATE_WARNING	1
+#define MSCAN_STATE_PASSIVE	2
+#define MSCAN_STATE_BUSOFF	3
+
+/* MSCAN receiver interrupt enable register (CANRIER) bits */
+#define MSCAN_WUPIE		0x80
+#define MSCAN_CSCIE		0x40
+#define MSCAN_RSTATE1		0x20
+#define MSCAN_RSTATE0		0x10
+#define MSCAN_TSTATE1		0x08
+#define MSCAN_TSTATE0		0x04
+#define MSCAN_OVRIE		0x02
+#define MSCAN_RXFIE		0x01
+
+/* MSCAN transmitter flag register (CANTFLG) bits */
+#define MSCAN_TXE2		0x04
+#define MSCAN_TXE1		0x02
+#define MSCAN_TXE0		0x01
+#define MSCAN_TXE		(MSCAN_TXE2 | MSCAN_TXE1 | MSCAN_TXE0)
+
+/* MSCAN transmitter interrupt enable register (CANTIER) bits */
+#define MSCAN_TXIE2		0x04
+#define MSCAN_TXIE1		0x02
+#define MSCAN_TXIE0		0x01
+#define MSCAN_TXIE		(MSCAN_TXIE2 | MSCAN_TXIE1 | MSCAN_TXIE0)
+
+/* MSCAN transmitter message abort request (CANTARQ) bits */
+#define MSCAN_ABTRQ2		0x04
+#define MSCAN_ABTRQ1		0x02
+#define MSCAN_ABTRQ0		0x01
+
+/* MSCAN transmitter message abort ack (CANTAAK) bits */
+#define MSCAN_ABTAK2		0x04
+#define MSCAN_ABTAK1		0x02
+#define MSCAN_ABTAK0		0x01
+
+/* MSCAN transmit buffer selection (CANTBSEL) bits */
+#define MSCAN_TX2		0x04
+#define MSCAN_TX1		0x02
+#define MSCAN_TX0		0x01
+
+/* MSCAN ID acceptance control register (CANIDAC) bits */
+#define MSCAN_IDAM1		0x20
+#define MSCAN_IDAM0		0x10
+#define MSCAN_IDHIT2		0x04
+#define MSCAN_IDHIT1		0x02
+#define MSCAN_IDHIT0		0x01
+
+#define MSCAN_AF_32BIT		0x00
+#define MSCAN_AF_16BIT		MSCAN_IDAM0
+#define MSCAN_AF_8BIT		MSCAN_IDAM1
+#define MSCAN_AF_CLOSED		(MSCAN_IDAM0|MSCAN_IDAM1)
+#define MSCAN_AF_MASK		(~(MSCAN_IDAM0|MSCAN_IDAM1))
+
+/* MSCAN Miscellaneous Register (CANMISC) bits */
+#define MSCAN_BOHOLD		0x01
+
+#ifdef	CONFIG_PPC_MPC52xx
+#define _MSCAN_RESERVED_(n,num)	u8	_res##n[num]
+#define _MSCAN_RESERVED_DSR_SIZE	2
+#else
+#define _MSCAN_RESERVED_(n,num)
+#define _MSCAN_RESERVED_DSR_SIZE	0
+#endif
+
+/* Structure of the hardware registers */
+struct mscan_regs {
+	/* (see doco S12MSCANV3/D)		  MPC5200    MSCAN */
+	u8 canctl0;				/* + 0x00     0x00 */
+	u8 canctl1;				/* + 0x01     0x01 */
+	_MSCAN_RESERVED_(1, 2);			/* + 0x02          */
+	u8 canbtr0;				/* + 0x04     0x02 */
+	u8 canbtr1;				/* + 0x05     0x03 */
+	_MSCAN_RESERVED_(2, 2);			/* + 0x06          */
+	u8 canrflg;				/* + 0x08     0x04 */
+	u8 canrier;				/* + 0x09     0x05 */
+	_MSCAN_RESERVED_(3, 2);			/* + 0x0a          */
+	u8 cantflg;				/* + 0x0c     0x06 */
+	u8 cantier;				/* + 0x0d     0x07 */
+	_MSCAN_RESERVED_(4, 2);			/* + 0x0e          */
+	u8 cantarq;				/* + 0x10     0x08 */
+	u8 cantaak;				/* + 0x11     0x09 */
+	_MSCAN_RESERVED_(5, 2);			/* + 0x12          */
+	u8 cantbsel;				/* + 0x14     0x0a */
+	u8 canidac;				/* + 0x15     0x0b */
+	u8 reserved;				/* + 0x16     0x0c */
+	_MSCAN_RESERVED_(6, 5);			/* + 0x17          */
+#ifndef CONFIG_PPC_MPC52xx
+	u8 canmisc;				/*            0x0d */
+#endif
+	u8 canrxerr;				/* + 0x1c     0x0e */
+	u8 cantxerr;				/* + 0x1d     0x0f */
+	_MSCAN_RESERVED_(7, 2);			/* + 0x1e          */
+	u16 canidar1_0;				/* + 0x20     0x10 */
+	_MSCAN_RESERVED_(8, 2);			/* + 0x22          */
+	u16 canidar3_2;				/* + 0x24     0x12 */
+	_MSCAN_RESERVED_(9, 2);			/* + 0x26          */
+	u16 canidmr1_0;				/* + 0x28     0x14 */
+	_MSCAN_RESERVED_(10, 2);		/* + 0x2a          */
+	u16 canidmr3_2;				/* + 0x2c     0x16 */
+	_MSCAN_RESERVED_(11, 2);		/* + 0x2e          */
+	u16 canidar5_4;				/* + 0x30     0x18 */
+	_MSCAN_RESERVED_(12, 2);		/* + 0x32          */
+	u16 canidar7_6;				/* + 0x34     0x1a */
+	_MSCAN_RESERVED_(13, 2);		/* + 0x36          */
+	u16 canidmr5_4;				/* + 0x38     0x1c */
+	_MSCAN_RESERVED_(14, 2);		/* + 0x3a          */
+	u16 canidmr7_6;				/* + 0x3c     0x1e */
+	_MSCAN_RESERVED_(15, 2);		/* + 0x3e          */
+	struct {
+		u16 idr1_0;			/* + 0x40     0x20 */
+		 _MSCAN_RESERVED_(16, 2);	/* + 0x42          */
+		u16 idr3_2;			/* + 0x44     0x22 */
+		 _MSCAN_RESERVED_(17, 2);	/* + 0x46          */
+		u16 dsr1_0;			/* + 0x48     0x24 */
+		 _MSCAN_RESERVED_(18, 2);	/* + 0x4a          */
+		u16 dsr3_2;			/* + 0x4c     0x26 */
+		 _MSCAN_RESERVED_(19, 2);	/* + 0x4e          */
+		u16 dsr5_4;			/* + 0x50     0x28 */
+		 _MSCAN_RESERVED_(20, 2);	/* + 0x52          */
+		u16 dsr7_6;			/* + 0x54     0x2a */
+		 _MSCAN_RESERVED_(21, 2);	/* + 0x56          */
+		u8 dlr;				/* + 0x58     0x2c */
+		 u8:8;				/* + 0x59     0x2d */
+		 _MSCAN_RESERVED_(22, 2);	/* + 0x5a          */
+		u16 time;			/* + 0x5c     0x2e */
+	} rx;
+	 _MSCAN_RESERVED_(23, 2);		/* + 0x5e          */
+	struct {
+		u16 idr1_0;			/* + 0x60     0x30 */
+		 _MSCAN_RESERVED_(24, 2);	/* + 0x62          */
+		u16 idr3_2;			/* + 0x64     0x32 */
+		 _MSCAN_RESERVED_(25, 2);	/* + 0x66          */
+		u16 dsr1_0;			/* + 0x68     0x34 */
+		 _MSCAN_RESERVED_(26, 2);	/* + 0x6a          */
+		u16 dsr3_2;			/* + 0x6c     0x36 */
+		 _MSCAN_RESERVED_(27, 2);	/* + 0x6e          */
+		u16 dsr5_4;			/* + 0x70     0x38 */
+		 _MSCAN_RESERVED_(28, 2);	/* + 0x72          */
+		u16 dsr7_6;			/* + 0x74     0x3a */
+		 _MSCAN_RESERVED_(29, 2);	/* + 0x76          */
+		u8 dlr;				/* + 0x78     0x3c */
+		u8 tbpr;			/* + 0x79     0x3d */
+		 _MSCAN_RESERVED_(30, 2);	/* + 0x7a          */
+		u16 time;			/* + 0x7c     0x3e */
+	} tx;
+	 _MSCAN_RESERVED_(31, 2);		/* + 0x7e          */
+} __attribute__ ((packed));
+
+#undef _MSCAN_RESERVED_
+#define MSCAN_REGION 	sizeof(struct mscan)
+
+#define MSCAN_WATCHDOG_TIMEOUT	((500*HZ)/1000)
+
+struct mscan_platform_data {
+	u8 clock_src;		/* MSCAN_CLKSRC_BUS or MSCAN_CLKSRC_XTAL */
+	u32 clock_frq;		/* can ref. clock, in Hz */
+};
+
+struct net_device *alloc_mscandev(void);
+/* @clock_src:
+	1 = The MSCAN clock source is the onchip Bus Clock.
+	0 = The MSCAN clock source is the chip Oscillator Clock.
+*/
+extern int register_mscandev(struct net_device *dev, int clock_src);
+extern void unregister_mscandev(struct net_device *dev);
+
+#endif				/* __MSCAN_H__ */
diff --exclude CVS --exclude .git -uNr linux-2.6.27.8/drivers/net/can/old/sja1000/Makefile linux-2.6.27.8.modified/drivers/net/can/old/sja1000/Makefile
--- linux-2.6.27.8/drivers/net/can/old/sja1000/Makefile	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.27.8.modified/drivers/net/can/old/sja1000/Makefile	2013-05-30 03:44:19.000000000 -0400
@@ -0,0 +1,28 @@
+#
+#  $Id: Makefile 797 2008-06-24 06:12:18Z hartkopp $
+#
+
+ifeq ($(KERNELRELEASE),)
+
+KERNELDIR := /lib/modules/$(shell uname -r)/build
+PWD       := $(shell pwd)
+TOPDIR    := $(PWD)/../../../../..
+
+modules modules_install clean:
+	$(MAKE) -C $(KERNELDIR) M=$(PWD) $@ TOPDIR=$(TOPDIR)
+
+else
+
+-include $(TOPDIR)/Makefile.common
+EXTRA_CFLAGS += -I$(TOPDIR)/drivers/net/can/old/hal
+
+obj-m := sja1000-io.o sja1000-iomem.o sja1000-iomux.o sja1000-gw2.o sja1000-esdio.o sja1000-c200.o
+
+sja1000-io-objs    := sja1000.o proc.o ../hal/io.o
+sja1000-iomem-objs := sja1000.o proc.o ../hal/iomem.o
+sja1000-iomux-objs := sja1000.o proc.o ../hal/iomux.o
+sja1000-gw2-objs   := sja1000.o proc.o ../hal/gw2.o
+sja1000-esdio-objs := sja1000.o proc.o ../hal/esdio.o
+sja1000-c200-objs  := sja1000.o proc.o ../hal/c200.o
+
+endif
diff --exclude CVS --exclude .git -uNr linux-2.6.27.8/drivers/net/can/old/sja1000/proc.c linux-2.6.27.8.modified/drivers/net/can/old/sja1000/proc.c
--- linux-2.6.27.8/drivers/net/can/old/sja1000/proc.c	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.27.8.modified/drivers/net/can/old/sja1000/proc.c	2013-05-30 03:44:19.000000000 -0400
@@ -0,0 +1,239 @@
+/*
+ * proc.c -  proc file system functions for SJA1000 CAN driver.
+ *
+ * Copyright (c) 2002-2007 Volkswagen Group Electronic Research
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of Volkswagen nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * Alternatively, provided that this notice is retained in full, this
+ * software may be distributed under the terms of the GNU General
+ * Public License ("GPL") version 2, in which case the provisions of the
+ * GPL apply INSTEAD OF those given above.
+ *
+ * The provided data structures and external interfaces from this code
+ * are not restricted to be used by modules with a GPL compatible license.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * Send feedback to <socketcan-users@lists.berlios.de>
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/version.h>
+#include <linux/slab.h>
+#include <linux/proc_fs.h>
+#include <linux/netdevice.h>
+
+#include <socketcan/can.h>
+#include <socketcan/can/ioctl.h>
+#include "sja1000.h"
+#include "hal.h"
+
+#include <socketcan/can/version.h> /* for RCSID. Removed by mkpatch script */
+RCSID("$Id: proc.c 1038 2009-08-21 10:00:21Z hartkopp $");
+
+extern struct net_device *can_dev[];
+
+static struct proc_dir_entry *pde       = NULL;
+static struct proc_dir_entry *pde_regs  = NULL;
+static struct proc_dir_entry *pde_reset = NULL;
+
+static int can_proc_read_stats(char *page, char **start, off_t off,
+			       int count, int *eof, void *data)
+{
+	int len = 0;
+	int i;
+
+	len += snprintf(page + len, PAGE_SIZE - len,
+			"CAN bus device statistics:\n");
+	len += snprintf(page + len, PAGE_SIZE - len,
+			"       errwarn  overrun   wakeup   buserr   "
+			"errpass  arbitr   restarts clock        baud\n");
+	for (i = 0; (i < MAXDEV) && (len < PAGE_SIZE - 200); i++) {
+		if (can_dev[i]) {
+			struct net_device *dev = can_dev[i];
+			struct can_priv *priv  = netdev_priv(dev);
+#ifdef SJA1000_H
+			u8 stat = hw_readreg(dev->base_addr, REG_SR);
+
+			if (stat & 0x80) {
+				len += snprintf(page + len, PAGE_SIZE - len,
+						"%s: bus status: "
+						"BUS OFF, ", dev->name);
+			} else if (stat & 0x40) {
+				len += snprintf(page + len, PAGE_SIZE - len,
+						"%s: bus status: ERROR "
+						"PASSIVE, ", dev->name);
+			} else {
+				len += snprintf(page + len, PAGE_SIZE - len,
+						"%s: bus status: OK, ",
+						dev->name);
+			}
+			len += snprintf(page + len, PAGE_SIZE - len,
+					"RXERR: %d, TXERR: %d\n",
+					hw_readreg(dev->base_addr, REG_RXERR),
+					hw_readreg(dev->base_addr, REG_TXERR));
+#endif
+			len += snprintf(page + len, PAGE_SIZE - len,
+					"%s: %8d %8d %8d %8d %8d "
+					"%8d %8d %10d %8d\n", dev->name,
+					priv->can_stats.error_warning,
+					priv->can_stats.data_overrun,
+					priv->can_stats.wakeup,
+					priv->can_stats.bus_error,
+					priv->can_stats.error_passive,
+					priv->can_stats.arbitration_lost,
+					priv->can_stats.restarts,
+					priv->clock,
+					priv->speed
+				);
+
+		}
+	}
+
+	*eof = 1;
+	return len;
+}
+
+
+static int can_proc_dump_regs(char *page, int len, struct net_device *dev)
+{
+	int r,s;
+	struct can_priv	*priv = netdev_priv(dev);
+	int regs = priv->hw_regs;
+
+	len += snprintf(page + len, PAGE_SIZE - len,
+			"%s registers:\n", dev->name);
+
+	for (r = 0; r < regs; r += 0x10) {
+		len += snprintf(page + len, PAGE_SIZE - len, "%02X: ", r);
+		for (s = 0; s < 0x10; s++) {
+			if (r+s < regs)
+				len += snprintf(page + len, PAGE_SIZE-len,
+						"%02X ",
+						hw_readreg(dev->base_addr,
+							   r+s));
+		}
+		len += snprintf(page + len, PAGE_SIZE - len, "\n");
+	}
+
+        return len;
+}
+
+static int can_proc_read_regs(char *page, char **start, off_t off,
+				  int count, int *eof, void *data)
+{
+	int len = 0;
+	int i;
+
+	for (i = 0; (i < MAXDEV) && (len < PAGE_SIZE - 200); i++) {
+		if (can_dev[i])
+			len = can_proc_dump_regs(page, len, can_dev[i]);
+	}
+
+	*eof = 1;
+	return len;
+}
+
+static int can_proc_read_reset(char *page, char **start, off_t off,
+				   int count, int *eof, void *data)
+{
+	int len = 0;
+	struct net_device *dev;
+	int i;
+	struct can_priv   *priv;
+
+	len += snprintf(page + len, PAGE_SIZE - len, "resetting ");
+	for (i = 0; (i < MAXDEV) && (len < PAGE_SIZE - 200); i++) {
+		if (can_dev[i]) {
+			dev = can_dev[i];
+			priv = netdev_priv(can_dev[i]);
+			if ((priv->state != STATE_UNINITIALIZED)
+			    && (priv->state != STATE_RESET_MODE)) {
+				len += snprintf(page + len, PAGE_SIZE - len,
+						"%s ", dev->name);
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,28)
+				dev->netdev_ops->ndo_stop(dev);
+				dev->netdev_ops->ndo_open(dev);
+#else
+				dev->stop(dev);
+				dev->open(dev);
+#endif
+				/* count number of restarts */
+				priv->can_stats.restarts++;
+
+			} else {
+				len += snprintf(page + len, PAGE_SIZE - len,
+						"(%s|%d) ", dev->name,
+						priv->state);
+			}
+		}
+	}
+
+	len += snprintf(page + len, PAGE_SIZE - len, "done\n");
+
+	*eof = 1;
+	return len;
+}
+
+void can_proc_create(const char *drv_name)
+{
+	char fname[256];
+
+	if (pde == NULL) {
+		sprintf(fname, PROCBASE "/%s_stats", drv_name);
+		pde = create_proc_read_entry(fname, 0644, NULL,
+					     can_proc_read_stats, NULL);
+	}
+	if (pde_regs == NULL) {
+		sprintf(fname, PROCBASE "/%s_regs", drv_name);
+		pde_regs = create_proc_read_entry(fname, 0644, NULL,
+						  can_proc_read_regs, NULL);
+	}
+	if (pde_reset == NULL) {
+		sprintf(fname, PROCBASE "/%s_reset", drv_name);
+		pde_reset = create_proc_read_entry(fname, 0644, NULL,
+						   can_proc_read_reset, NULL);
+	}
+}
+
+void can_proc_remove(const char *drv_name)
+{
+	char fname[256];
+
+	if (pde) {
+		sprintf(fname, PROCBASE "/%s_stats", drv_name);
+		remove_proc_entry(fname, NULL);
+	}
+	if (pde_regs) {
+		sprintf(fname, PROCBASE "/%s_regs", drv_name);
+		remove_proc_entry(fname, NULL);
+	}
+	if (pde_reset) {
+		sprintf(fname, PROCBASE "/%s_reset", drv_name);
+		remove_proc_entry(fname, NULL);
+	}
+}
diff --exclude CVS --exclude .git -uNr linux-2.6.27.8/drivers/net/can/old/sja1000/sja1000.c linux-2.6.27.8.modified/drivers/net/can/old/sja1000/sja1000.c
--- linux-2.6.27.8/drivers/net/can/old/sja1000/sja1000.c	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.27.8.modified/drivers/net/can/old/sja1000/sja1000.c	2013-05-30 03:44:19.000000000 -0400
@@ -0,0 +1,1200 @@
+/*
+ * sja1000.c -  Philips SJA1000 network device driver
+ *
+ * Copyright (c) 2003 Matthias Brukner, Trajet Gmbh, Rebenring 33,
+ * 38106 Braunschweig, GERMANY
+ *
+ * Copyright (c) 2002-2007 Volkswagen Group Electronic Research
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of Volkswagen nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * Alternatively, provided that this notice is retained in full, this
+ * software may be distributed under the terms of the GNU General
+ * Public License ("GPL") version 2, in which case the provisions of the
+ * GPL apply INSTEAD OF those given above.
+ *
+ * The provided data structures and external interfaces from this code
+ * are not restricted to be used by modules with a GPL compatible license.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * Send feedback to <socketcan-users@lists.berlios.de>
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/version.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/types.h>
+#include <linux/fcntl.h>
+#include <linux/interrupt.h>
+#include <linux/ptrace.h>
+#include <linux/string.h>
+#include <linux/errno.h>
+#include <linux/netdevice.h>
+#include <linux/if_arp.h>
+#include <linux/if_ether.h>
+#include <linux/skbuff.h>
+
+#include <socketcan/can.h>
+#include <socketcan/can/ioctl.h> /* for struct can_device_stats */
+#include "sja1000.h"
+#include "hal.h"
+
+#include <socketcan/can/version.h> /* for RCSID. Removed by mkpatch script */
+RCSID("$Id: sja1000.c 1038 2009-08-21 10:00:21Z hartkopp $");
+
+MODULE_AUTHOR("Oliver Hartkopp <oliver.hartkopp@volkswagen.de>");
+MODULE_LICENSE("Dual BSD/GPL");
+MODULE_DESCRIPTION("LLCF/socketcan '" CHIP_NAME "' network device driver");
+
+#ifdef CONFIG_CAN_DEBUG_DEVICES
+#define DBG(args...)   ((priv->debug > 0) ? printk(args) : 0)
+/* logging in interrupt context! */
+#define iDBG(args...)  ((priv->debug > 1) ? printk(args) : 0)
+#define iiDBG(args...) ((priv->debug > 2) ? printk(args) : 0)
+#else
+#define DBG(args...)
+#define iDBG(args...)
+#define iiDBG(args...)
+#endif
+
+char drv_name[DRV_NAME_LEN] = "undefined";
+
+/* driver and version information */
+static const char *drv_version	= "0.1.1";
+static const char *drv_reldate	= "2007-04-13";
+
+#ifdef CONFIG_CAN_DEBUG_DEVICES
+static const char *ecc_errors[] = {
+	NULL,
+	NULL,
+	"ID.28 to ID.28",
+	"start of frame",
+	"bit SRTR",
+	"bit IDE",
+	"ID.20 to ID.18",
+	"ID.17 to ID.13",
+	"CRC sequence",
+	"reserved bit 0",
+	"data field",
+	"data length code",
+	"bit RTR",
+	"reserved bit 1",
+	"ID.4 to ID.0",
+	"ID.12 to ID.5",
+	NULL,
+	"active error flag",
+	"intermission",
+	"tolerate dominant bits",
+	NULL,
+	NULL,
+	"passive error flag",
+	"error delimiter",
+	"CRC delimiter",
+	"acknowledge slot",
+	"end of frame",
+	"acknowledge delimiter",
+	"overload flag",
+	NULL,
+	NULL,
+	NULL
+};
+
+static const char *ecc_types[] = {
+	"bit error",
+	"form error",
+	"stuff error",
+	"other type of error"
+};
+#endif
+
+/* array of all can chips */
+struct net_device *can_dev[MAXDEV];
+
+/* module parameters */
+unsigned long base[MAXDEV]	= { 0 }; /* hardware address */
+unsigned long rbase[MAXDEV]	= { 0 }; /* (remapped) device address */
+unsigned int  irq[MAXDEV]	= { 0 };
+
+unsigned int speed[MAXDEV]	= { DEFAULT_SPEED, DEFAULT_SPEED };
+unsigned int btr[MAXDEV]	= { 0 };
+
+static int rx_probe[MAXDEV]	= { 0 };
+static int clk			= DEFAULT_HW_CLK;
+static int debug		= 0;
+static int restart_ms		= 100;
+static int echo			= 1;
+
+static int base_n;
+static int irq_n;
+static int speed_n;
+static int btr_n;
+static int rx_probe_n;
+
+module_param_array(base, int, &base_n, 0);
+module_param_array(irq, int, &irq_n, 0);
+module_param_array(speed, int, &speed_n, 0);
+module_param_array(btr, int, &btr_n, 0);
+module_param_array(rx_probe, int, &rx_probe_n, 0);
+
+module_param(clk, int, 0);
+module_param(debug, int, 0);
+module_param(restart_ms, int, 0);
+module_param(echo, int, S_IRUGO);
+
+MODULE_PARM_DESC(base, "CAN controller base address");
+MODULE_PARM_DESC(irq, "CAN controller interrupt");
+MODULE_PARM_DESC(speed, "CAN bus bitrate");
+MODULE_PARM_DESC(btr, "Bit Timing Register value 0x<btr0><btr1>, e.g. 0x4014");
+MODULE_PARM_DESC(rx_probe, "switch to trx mode after correct msg receiption. (default off)");
+
+MODULE_PARM_DESC(clk, "CAN controller chip clock (default: 16MHz)");
+MODULE_PARM_DESC(debug, "set debug mask (default: 0)");
+MODULE_PARM_DESC(restart_ms, "restart chip on heavy bus errors / bus off after x ms (default 100ms)");
+MODULE_PARM_DESC(echo, "Echo sent frames. default: 1 (On)");
+
+/*
+ * CAN network devices *should* support a local echo functionality
+ * (see Documentation/networking/can.txt). To test the handling of CAN
+ * interfaces that do not support the local echo both driver types are
+ * implemented inside this sja1000 driver. In the case that the driver does
+ * not support the echo the IFF_ECHO remains clear in dev->flags.
+ * This causes the PF_CAN core to perform the echo as a fallback solution.
+ */
+
+/* function declarations */
+
+static void can_restart_dev(unsigned long data);
+static void chipset_init(struct net_device *dev, int wake);
+static void chipset_init_rx(struct net_device *dev);
+static void chipset_init_trx(struct net_device *dev);
+static void can_netdev_setup(struct net_device *dev);
+static struct net_device* can_create_netdev(int dev_num, int hw_regs);
+static int  can_set_drv_name(void);
+int set_reset_mode(struct net_device *dev);
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,23)
+static struct net_device_stats *can_get_stats(struct net_device *dev)
+{
+	struct can_priv *priv = netdev_priv(dev);
+
+	/* TODO: read statistics from chip */
+	return &priv->stats;
+}
+#endif
+
+static int sja1000_probe_chip(unsigned long base)
+{
+	if (base && (hw_readreg(base, 0) == 0xFF)) {
+		printk(KERN_INFO "%s: probing @0x%lX failed\n",
+		       drv_name, base);
+		return 0;
+	}
+	return 1;
+}
+
+/*
+ * set baud rate divisor values
+ */
+static void set_btr(struct net_device *dev, int btr0, int btr1)
+{
+	struct can_priv *priv = netdev_priv(dev);
+
+	/* no bla bla when restarting the device */
+	if (priv->state == STATE_UNINITIALIZED)
+		printk(KERN_INFO "%s: setting BTR0=%02X BTR1=%02X\n",
+		       dev->name, btr0, btr1);
+
+	hw_writereg(dev->base_addr, REG_BTR0, btr0);
+	hw_writereg(dev->base_addr, REG_BTR1, btr1);
+}
+
+/*
+ * calculate baud rate divisor values
+ */
+static void set_baud(struct net_device *dev, int baud, int clock)
+{
+	struct can_priv *priv = netdev_priv(dev);
+
+	int error;
+	int brp;
+	int tseg;
+	int tseg1 = 0;
+	int tseg2 = 0;
+
+	int best_error = 1000000000;
+	int best_tseg = 0;
+	int best_brp = 0;
+	int best_baud = 0;
+
+	int SAM = (baud > 100000 ? 0 : 1);
+
+	clock >>= 1;
+
+	for (tseg = (0 + 0 + 2) * 2;
+	     tseg <= (MAX_TSEG2 + MAX_TSEG1 + 2) * 2 + 1;
+	     tseg++) {
+		brp = clock / ((1 + tseg / 2) * baud) + tseg % 2;
+		if ((brp > 0) && (brp <= 64)) {
+			error = baud - clock / (brp * (1 + tseg / 2));
+			if (error < 0) {
+				error = -error;
+			}
+			if (error <= best_error) {
+				best_error = error;
+				best_tseg = tseg / 2;
+				best_brp = brp - 1;
+				best_baud = clock / (brp * (1 + tseg / 2));
+			}
+		}
+	}
+	if (best_error && (baud / best_error < 10)) {
+		printk("%s: unable to set baud rate %d (ext clock %dHz)\n",
+		       dev->name, baud, clock * 2);
+		return;
+//		return -EINVAL;
+	}
+	tseg2 = best_tseg - (SAMPLE_POINT * (best_tseg + 1)) / 100;
+	if (tseg2 < 0) {
+		tseg2 = 0;
+	} else if (tseg2 > MAX_TSEG2) {
+		tseg2 = MAX_TSEG2;
+	}
+	tseg1 = best_tseg - tseg2 - 2;
+	if (tseg1 > MAX_TSEG1) {
+		tseg1 = MAX_TSEG1;
+		tseg2 = best_tseg - tseg1 - 2;
+	}
+
+	priv->btr = ((best_brp | JUMPWIDTH)<<8) + 
+		((SAM << 7) | (tseg2 << 4) | tseg1);
+
+	printk(KERN_INFO "%s: calculated best baudrate: %d / btr is 0x%04X\n",
+	       dev->name, best_baud, priv->btr);
+
+	set_btr(dev, (priv->btr>>8) & 0xFF, priv->btr & 0xFF);
+//	set_btr(dev, best_brp | JUMPWIDTH, (SAM << 7) | (tseg2 << 4) | tseg1);
+}
+
+int set_reset_mode(struct net_device *dev)
+{
+	struct can_priv *priv = netdev_priv(dev);
+	unsigned char status = hw_readreg(dev->base_addr, REG_MOD);
+	int i;
+
+	priv->can_stats.bus_error_at_init = priv->can_stats.bus_error;
+
+	/* disable interrupts */
+	hw_writereg(dev->base_addr, REG_IER, IRQ_OFF);
+
+	for (i = 0; i < 10; i++) {
+		/* check reset bit */
+		if (status & MOD_RM) {
+			if (i > 1) {
+				iDBG(KERN_INFO "%s: %s looped %d times\n",
+				     dev->name, __FUNCTION__, i);
+			}
+			priv->state = STATE_RESET_MODE;
+			return 0;
+		}
+
+		hw_writereg(dev->base_addr, REG_MOD, MOD_RM); /* reset chip */
+		status = hw_readreg(dev->base_addr, REG_MOD);
+
+	}
+
+	printk(KERN_ERR "%s: setting sja1000 into reset mode failed!\n",
+	       dev->name);
+	return 1;
+
+}
+
+static int set_normal_mode(struct net_device *dev)
+{
+	unsigned char status = hw_readreg(dev->base_addr, REG_MOD);
+	int i;
+
+	for (i = 0; i < 10; i++) {
+		/* check reset bit */
+		if ((status & MOD_RM) == 0) {
+#ifdef CONFIG_CAN_DEBUG_DEVICES
+			if (i > 1) {
+				struct can_priv *priv = netdev_priv(dev);
+				iDBG(KERN_INFO "%s: %s looped %d times\n",
+				     dev->name, __FUNCTION__, i);
+			}
+#endif
+			return 0;
+		}
+
+		/* set chip to normal mode */
+		hw_writereg(dev->base_addr, REG_MOD, 0x00);
+		status = hw_readreg(dev->base_addr, REG_MOD);
+	}
+
+	printk(KERN_ERR "%s: setting sja1000 into normal mode failed!\n",
+	       dev->name);
+	return 1;
+
+}
+
+static int set_listen_mode(struct net_device *dev)
+{
+	unsigned char status = hw_readreg(dev->base_addr, REG_MOD);
+	int i;
+
+	for (i = 0; i < 10; i++) {
+		/* check reset mode bit */
+		if ((status & MOD_RM) == 0) {
+#ifdef CONFIG_CAN_DEBUG_DEVICES
+			if (i > 1) {
+				struct can_priv *priv = netdev_priv(dev);
+				iDBG(KERN_INFO "%s: %s looped %d times\n",
+				     dev->name, __FUNCTION__, i);
+			}
+#endif
+			return 0;
+		}
+
+		/* set listen only mode, clear reset */
+		hw_writereg(dev->base_addr, REG_MOD, MOD_LOM);
+		status = hw_readreg(dev->base_addr, REG_MOD);
+	}
+
+	printk(KERN_ERR "%s: setting sja1000 into listen mode failed!\n",
+	       dev->name);
+	return 1;
+
+}
+
+/*
+ * initialize SJA1000 chip:
+ *   - reset chip
+ *   - set output mode
+ *   - set baudrate
+ *   - enable interrupts
+ *   - start operating mode
+ */
+static void chipset_init_regs(struct net_device *dev)
+{
+	struct can_priv *priv = netdev_priv(dev);
+	unsigned long base = dev->base_addr;
+
+	/* go into Pelican mode, disable clkout, disable comparator */
+	hw_writereg(base, REG_CDR, 0xCF);
+
+	/* output control */
+	/* connected to external transceiver */
+	hw_writereg(base, REG_OCR, 0x1A);
+
+	/* set acceptance filter (accept all) */
+	hw_writereg(base, REG_ACCC0, 0x00);
+	hw_writereg(base, REG_ACCC1, 0x00);
+	hw_writereg(base, REG_ACCC2, 0x00);
+	hw_writereg(base, REG_ACCC3, 0x00);
+
+	hw_writereg(base, REG_ACCM0, 0xFF);
+	hw_writereg(base, REG_ACCM1, 0xFF);
+	hw_writereg(base, REG_ACCM2, 0xFF);
+	hw_writereg(base, REG_ACCM3, 0xFF);
+
+	/* set baudrate */
+	if (priv->btr) { /* no calculation when btr is provided */
+		set_btr(dev, (priv->btr>>8) & 0xFF, priv->btr & 0xFF);
+	} else {
+		if (priv->speed == 0) {
+			priv->speed = DEFAULT_SPEED;
+		}
+		set_baud(dev, priv->speed * 1000, priv->clock);
+	}
+
+	/* output control */
+	/* connected to external transceiver */
+	hw_writereg(base, REG_OCR, 0x1A);
+}
+
+static void chipset_init(struct net_device *dev, int wake)
+{
+	struct can_priv *priv = netdev_priv(dev);
+
+	if (priv->rx_probe)
+		chipset_init_rx(dev); /* wait for valid reception first */
+	else
+		chipset_init_trx(dev);
+
+	if ((wake) && netif_queue_stopped(dev)) {
+		if (priv->echo_skb) { /* pending echo? */
+			kfree_skb(priv->echo_skb);
+			priv->echo_skb = NULL;
+		}
+		netif_wake_queue(dev);
+	}
+}
+
+static void chipset_init_rx(struct net_device *dev)
+{
+	struct can_priv *priv = netdev_priv(dev);
+
+	iDBG(KERN_INFO "%s: %s()\n", dev->name, __FUNCTION__);
+
+	/* set chip into reset mode */
+	set_reset_mode(dev);
+
+	/* set registers */
+	chipset_init_regs(dev);
+
+	/* automatic bit rate detection */
+	set_listen_mode(dev);
+
+	priv->state = STATE_PROBE;
+
+	/* enable receive and error interrupts */
+	hw_writereg(dev->base_addr, REG_IER, IRQ_RI | IRQ_EI);
+}
+
+static void chipset_init_trx(struct net_device *dev)
+{
+	struct can_priv *priv = netdev_priv(dev);
+
+	iDBG(KERN_INFO "%s: %s()\n", dev->name, __FUNCTION__);
+
+	/* set chip into reset mode */
+	set_reset_mode(dev);
+
+	/* set registers */
+	chipset_init_regs(dev);
+
+	/* leave reset mode */
+	set_normal_mode(dev);
+
+	priv->state = STATE_ACTIVE;
+
+	/* enable all interrupts */
+	hw_writereg(dev->base_addr, REG_IER, IRQ_ALL);
+}
+
+/*
+ * transmit a CAN message
+ * message layout in the sk_buff should be like this:
+ * xx xx xx xx	 ff	 ll   00 11 22 33 44 55 66 77
+ * [  can-id ] [flags] [len] [can data (up to 8 bytes]
+ */
+static int can_start_xmit(struct sk_buff *skb, struct net_device *dev)
+{
+	struct can_priv  *priv	= netdev_priv(dev);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,23)
+	struct net_device_stats *stats = can_get_stats(dev);
+#else
+	struct net_device_stats *stats = &dev->stats;
+#endif
+	struct can_frame *cf	= (struct can_frame*)skb->data;
+	unsigned long base	= dev->base_addr;
+	uint8_t	fi;
+	uint8_t	dlc;
+	canid_t	id;
+	uint8_t	dreg;
+	int	loop;
+	int	i;
+
+	netif_stop_queue(dev);
+
+	fi = dlc = cf->can_dlc;
+	id = cf->can_id;
+
+	if (id & CAN_RTR_FLAG)
+		fi |= FI_RTR;
+
+	if (id & CAN_EFF_FLAG) {
+		fi |= FI_FF;
+		dreg = EFF_BUF;
+		hw_writereg(base, REG_FI, fi);
+		hw_writereg(base, REG_ID1, (id & 0x1fe00000) >> (5 + 16));
+		hw_writereg(base, REG_ID2, (id & 0x001fe000) >> (5 + 8));
+		hw_writereg(base, REG_ID3, (id & 0x00001fe0) >> 5);
+		hw_writereg(base, REG_ID4, (id & 0x0000001f) << 3);
+	} else {
+		dreg = SFF_BUF;
+		hw_writereg(base, REG_FI, fi);
+		hw_writereg(base, REG_ID1, (id & 0x000007f8) >> 3);
+		hw_writereg(base, REG_ID2, (id & 0x00000007) << 5);
+	}
+
+	for (i = 0; i < dlc; i++) {
+		hw_writereg(base, dreg++, cf->data[i]);
+	}
+
+	hw_writereg(base, REG_CMR, CMD_TR);
+
+	stats->tx_bytes += dlc;
+
+	dev->trans_start = jiffies;
+
+	/* set flag whether this packet has to be looped back */
+	loop = skb->pkt_type == PACKET_LOOPBACK;
+
+	if (!echo || !loop) {
+		kfree_skb(skb);
+		return 0;
+	}
+
+	if (!priv->echo_skb) {
+		struct sock *srcsk = skb->sk;
+
+		if (atomic_read(&skb->users) != 1) {
+			struct sk_buff *old_skb = skb;
+
+			skb = skb_clone(old_skb, GFP_ATOMIC);
+			DBG(KERN_INFO "%s: %s: freeing old skbuff %p, "
+			    "using new skbuff %p\n",
+			    dev->name, __FUNCTION__, old_skb, skb);
+			kfree_skb(old_skb);
+			if (!skb) {
+				return 0;
+			}
+		} else
+			skb_orphan(skb);
+
+		skb->sk = srcsk;
+
+		/* make settings for echo to reduce code in irq context */
+		skb->protocol	= htons(ETH_P_CAN);
+		skb->pkt_type	= PACKET_BROADCAST;
+		skb->ip_summed	= CHECKSUM_UNNECESSARY;
+		skb->dev	= dev;
+
+		/* save this skb for tx interrupt echo handling */
+		priv->echo_skb = skb;
+
+	} else {
+		/* locking problem with netif_stop_queue() ?? */
+		printk(KERN_ERR "%s: %s: occupied echo_skb!\n",
+		       dev->name, __FUNCTION__ );
+		kfree_skb(skb);
+	}
+
+	return 0;
+}
+
+static void can_tx_timeout(struct net_device *dev)
+{
+	struct can_priv *priv = netdev_priv(dev);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,23)
+	struct net_device_stats *stats = can_get_stats(dev);
+#else
+	struct net_device_stats *stats = &dev->stats;
+#endif
+
+	stats->tx_errors++;
+
+	/* do not conflict with e.g. bus error handling */
+	if (!(priv->timer.expires)){ /* no restart on the run */
+		chipset_init_trx(dev); /* no tx queue wakeup */
+		if (priv->echo_skb) { /* pending echo? */
+			kfree_skb(priv->echo_skb);
+			priv->echo_skb = NULL;
+		}
+		netif_wake_queue(dev); /* wakeup here */
+	}
+	else
+		DBG(KERN_INFO "%s: %s: can_restart_dev already active.\n",
+		    dev->name, __FUNCTION__ );
+
+}
+
+static void can_restart_on(struct net_device *dev)
+{
+	struct can_priv *priv = netdev_priv(dev);
+
+	if (!(priv->timer.expires)){ /* no restart on the run */
+
+		set_reset_mode(dev);
+
+		priv->timer.function = can_restart_dev;
+		priv->timer.data = (unsigned long) dev;
+
+		/* restart chip on persistent error in <xxx> ms */
+		priv->timer.expires = jiffies + (priv->restart_ms * HZ) / 1000;
+		add_timer(&priv->timer);
+
+		iDBG(KERN_INFO "%s: %s start (%ld)\n",
+		     dev->name, __FUNCTION__ , jiffies);
+	} else
+		iDBG(KERN_INFO "%s: %s already (%ld)\n",
+		     dev->name, __FUNCTION__ , jiffies);
+}
+
+static void can_restart_dev(unsigned long data)
+{
+	struct net_device *dev = (struct net_device*) data;
+	struct can_priv *priv = netdev_priv(dev);
+
+	DBG(KERN_INFO "%s: can_restart_dev (%ld)\n",
+	    dev->name, jiffies);
+
+	/* mark inactive timer */
+	priv->timer.expires = 0;
+
+	if (priv->state != STATE_UNINITIALIZED) {
+
+		/* count number of restarts */
+		priv->can_stats.restarts++;
+
+		chipset_init(dev, 1);
+	}
+}
+
+#if 0
+/* the timerless version */
+
+static void can_restart_now(struct net_device *dev)
+{
+	struct can_priv *priv = netdev_priv(dev);
+
+	if (priv->state != STATE_UNINITIALIZED) {
+
+		/* count number of restarts */
+		priv->can_stats.restarts++;
+
+		chipset_init(dev, 1);
+	}
+}
+#endif
+
+static void can_rx(struct net_device *dev)
+{
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,23)
+	struct net_device_stats *stats = can_get_stats(dev);
+#else
+	struct net_device_stats *stats = &dev->stats;
+#endif
+	unsigned long base = dev->base_addr;
+	struct can_frame *cf;
+	struct sk_buff	*skb;
+	uint8_t	fi;
+	uint8_t	dreg;
+	canid_t	id;
+	uint8_t	dlc;
+	int	i;
+
+	skb = dev_alloc_skb(sizeof(struct can_frame));
+	if (skb == NULL) {
+		return;
+	}
+	skb->dev = dev;
+	skb->protocol = htons(ETH_P_CAN);
+
+	fi = hw_readreg(base, REG_FI);
+	dlc = fi & 0x0F;
+
+	if (fi & FI_FF) {
+		/* extended frame format (EFF) */
+		dreg = EFF_BUF;
+		id = (hw_readreg(base, REG_ID1) << (5+16))
+			| (hw_readreg(base, REG_ID2) << (5+8))
+			| (hw_readreg(base, REG_ID3) << 5)
+			| (hw_readreg(base, REG_ID4) >> 3);
+		id |= CAN_EFF_FLAG;
+	} else {
+		/* standard frame format (SFF) */
+		dreg = SFF_BUF;
+		id = (hw_readreg(base, REG_ID1) << 3)
+			| (hw_readreg(base, REG_ID2) >> 5);
+	}
+
+	if (fi & FI_RTR)
+		id |= CAN_RTR_FLAG;
+
+	cf = (struct can_frame*)skb_put(skb, sizeof(struct can_frame));
+	memset(cf, 0, sizeof(struct can_frame));
+	cf->can_id    = id;
+	cf->can_dlc   = dlc;
+	for (i = 0; i < dlc; i++) {
+		cf->data[i] = hw_readreg(base, dreg++);
+	}
+	while (i < 8)
+		cf->data[i++] = 0;
+
+	/* release receive buffer */
+	hw_writereg(base, REG_CMR, CMD_RRB);
+
+	netif_rx(skb);
+
+	dev->last_rx = jiffies;
+	stats->rx_packets++;
+	stats->rx_bytes += dlc;
+}
+
+/*
+ * SJA1000 interrupt handler
+ */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,19)
+static irqreturn_t can_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+#else
+static irqreturn_t can_interrupt(int irq, void *dev_id)
+#endif
+{
+	struct net_device *dev	= (struct net_device*)dev_id;
+	struct can_priv *priv	= netdev_priv(dev);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,23)
+	struct net_device_stats *stats = can_get_stats(dev);
+#else
+	struct net_device_stats *stats = &dev->stats;
+#endif
+	unsigned long base	= dev->base_addr;
+	uint8_t isrc, status, ecc, alc;
+	int n = 0;
+
+	hw_preirq(dev);
+
+	iiDBG(KERN_INFO "%s: interrupt\n", dev->name);
+
+	if (priv->state == STATE_UNINITIALIZED) {
+		printk(KERN_ERR "%s: %s: uninitialized controller!\n",
+		       dev->name, __FUNCTION__);
+		chipset_init(dev, 1); /* should be possible at this stage */
+		return IRQ_NONE;
+	}
+
+	if (priv->state == STATE_RESET_MODE) {
+		iiDBG(KERN_ERR "%s: %s: controller is in reset mode! "
+		      "MOD=0x%02X IER=0x%02X IR=0x%02X SR=0x%02X!\n",
+		      dev->name, __FUNCTION__, hw_readreg(base, REG_MOD),
+		      hw_readreg(base, REG_IER), hw_readreg(base, REG_IR),
+		      hw_readreg(base, REG_SR));
+		return IRQ_NONE;
+	}
+
+	while ((isrc = hw_readreg(base, REG_IR)) && (n < 20)) {
+		n++;
+		status = hw_readreg(base, REG_SR);
+
+		if (isrc & IRQ_WUI) {
+			/* wake-up interrupt */
+			priv->can_stats.wakeup++;
+		}
+		if (isrc & IRQ_TI) {
+			/* transmission complete interrupt */
+			stats->tx_packets++;
+
+			if (echo && priv->echo_skb) {
+				netif_rx(priv->echo_skb);
+				priv->echo_skb = NULL;
+			}
+
+			netif_wake_queue(dev);
+		}
+		if (isrc & IRQ_RI) {
+			/* receive interrupt */
+
+			while (status & SR_RBS) {
+				can_rx(dev);
+				status = hw_readreg(base, REG_SR);
+			}
+			if (priv->state == STATE_PROBE) {
+				/* valid RX -> switch to trx-mode */
+				iDBG(KERN_INFO "%s: RI #%d#\n", dev->name, n);
+				chipset_init_trx(dev); /* no tx queue wakeup */
+				break; /* check again after init controller */
+			}
+		}
+		if (isrc & IRQ_DOI) {
+			/* data overrun interrupt */
+			iiDBG(KERN_INFO "%s: data overrun isrc=0x%02X "
+			      "status=0x%02X\n",
+			      dev->name, isrc, status);
+			iDBG(KERN_INFO "%s: DOI #%d#\n", dev->name, n);
+			priv->can_stats.data_overrun++;
+			hw_writereg(base, REG_CMR, CMD_CDO); /* clear bit */
+		}
+		if (isrc & IRQ_EI) {
+			/* error warning interrupt */
+			iiDBG(KERN_INFO "%s: error warning isrc=0x%02X "
+			      "status=0x%02X\n",
+			      dev->name, isrc, status);
+			iDBG(KERN_INFO "%s: EI #%d#\n", dev->name, n);
+			priv->can_stats.error_warning++;
+			if (status & SR_BS) {
+				printk(KERN_INFO "%s: BUS OFF, "
+				       "restarting device\n", dev->name);
+				can_restart_on(dev);
+				/* controller has been restarted: leave here */
+				goto out;
+			} else if (status & SR_ES) {
+				iDBG(KERN_INFO "%s: error\n", dev->name);
+			}
+		}
+		if (isrc & IRQ_BEI) {
+			/* bus error interrupt */
+			iiDBG(KERN_INFO "%s: bus error isrc=0x%02X "
+			      "status=0x%02X\n",
+			      dev->name, isrc, status);
+			iDBG(KERN_INFO "%s: BEI #%d# [%d]\n", dev->name, n,
+			     priv->can_stats.bus_error - 
+			     priv->can_stats.bus_error_at_init);
+			priv->can_stats.bus_error++;
+			ecc = hw_readreg(base, REG_ECC);
+			iDBG(KERN_INFO "%s: ECC = 0x%02X (%s, %s, %s)\n",
+			     dev->name, ecc,
+			     (ecc & ECC_DIR) ? "RX" : "TX",
+			     ecc_types[ecc >> ECC_ERR],
+			     ecc_errors[ecc & ECC_SEG]);
+
+			/* when the bus errors flood the system, */
+			/* restart the controller                */
+			if (priv->can_stats.bus_error_at_init +
+			    MAX_BUS_ERRORS < priv->can_stats.bus_error) {
+				iDBG(KERN_INFO "%s: heavy bus errors,"
+				     " restarting device\n", dev->name);
+				can_restart_on(dev);
+				/* controller has been restarted: leave here */
+				goto out;
+			}
+#if 1
+			/* don't know, if this is a good idea, */
+			/* but it works fine ...               */
+			if (hw_readreg(base, REG_RXERR) > 128) {
+				iDBG(KERN_INFO "%s: RX_ERR > 128,"
+				     " restarting device\n", dev->name);
+				can_restart_on(dev);
+				/* controller has been restarted: leave here */
+				goto out;
+			}
+#endif
+		}
+		if (isrc & IRQ_EPI) {
+			/* error passive interrupt */
+			iiDBG(KERN_INFO "%s: error passive isrc=0x%02X"
+			      " status=0x%02X\n",
+			      dev->name, isrc, status);
+			iDBG(KERN_INFO "%s: EPI #%d#\n", dev->name, n);
+			priv->can_stats.error_passive++;
+			if (status & SR_ES) {
+				iDBG(KERN_INFO "%s: -> ERROR PASSIVE, "
+				     "restarting device\n", dev->name);
+				can_restart_on(dev);
+				/* controller has been restarted: leave here */
+				goto out;
+			} else {
+				iDBG(KERN_INFO "%s: -> ERROR ACTIVE\n",
+				     dev->name);
+			}
+		}
+		if (isrc & IRQ_ALI) {
+			/* arbitration lost interrupt */
+			iiDBG(KERN_INFO "%s: error arbitration lost "
+			      "isrc=0x%02X status=0x%02X\n",
+			      dev->name, isrc, status);
+			iDBG(KERN_INFO "%s: ALI #%d#\n", dev->name, n);
+			priv->can_stats.arbitration_lost++;
+			alc = hw_readreg(base, REG_ALC);
+			iDBG(KERN_INFO "%s: ALC = 0x%02X\n", dev->name, alc);
+		}
+	}
+	if (n > 1) {
+		iDBG(KERN_INFO "%s: handled %d IRQs\n", dev->name, n);
+	}
+out:
+	hw_postirq(dev);
+
+	return n == 0 ? IRQ_NONE : IRQ_HANDLED;
+}
+
+/*
+ * initialize CAN bus driver
+ */
+static int can_open(struct net_device *dev)
+{
+	struct can_priv *priv = netdev_priv(dev);
+
+	/* set chip into reset mode */
+	set_reset_mode(dev);
+
+	priv->state = STATE_UNINITIALIZED;
+
+	/* register interrupt handler */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,18)
+	if (request_irq(dev->irq, &can_interrupt, SA_SHIRQ,
+			dev->name, (void*)dev)) {
+#else
+	if (request_irq(dev->irq, &can_interrupt, IRQF_SHARED,
+			dev->name, (void*)dev)) {
+#endif
+		return -EAGAIN;
+	}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,23)
+	/* clear statistics */
+	memset(&priv->stats, 0, sizeof(priv->stats));
+#endif
+
+	/* init chip */
+	chipset_init(dev, 0);
+	priv->open_time = jiffies;
+
+	netif_start_queue(dev);
+
+	return 0;
+}
+
+/*
+ * stop CAN bus activity
+ */
+static int can_close(struct net_device *dev)
+{
+	struct can_priv *priv = netdev_priv(dev);
+
+	/* set chip into reset mode */
+	set_reset_mode(dev);
+
+	priv->open_time = 0;
+
+	if (priv->timer.expires) {
+		del_timer(&priv->timer);
+		priv->timer.expires = 0;
+	}
+
+	free_irq(dev->irq, (void*)dev);
+	priv->state = STATE_UNINITIALIZED;
+
+	netif_stop_queue(dev);
+
+	return 0;
+}
+
+#if 0
+static void test_if(struct net_device *dev)
+{
+	int i;
+	int j;
+	int x;
+
+	hw_writereg(base, REG_CDR, 0xCF);
+	for (i = 0; i < 10000; i++) {
+		for (j = 0; j < 256; j++) {
+			hw_writereg(base, REG_EWL, j);
+			x = hw_readreg(base, REG_EWL);
+			if (x != j) {
+				printk(KERN_INFO "%s: is: %02X expected: "
+				       "%02X (%d)\n", dev->name, x, j, i);
+			}
+		}
+	}
+}
+#endif
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,28)
+static const struct net_device_ops can_netdev_ops = {
+	.ndo_open               = can_open,
+	.ndo_stop               = can_close,
+	.ndo_start_xmit         = can_start_xmit,
+	.ndo_tx_timeout		= can_tx_timeout,
+};
+#endif
+
+void can_netdev_setup(struct net_device *dev)
+{
+	/* Fill in the the fields of the device structure
+	   with CAN netdev generic values */
+
+	dev->type			= ARPHRD_CAN;
+	dev->hard_header_len		= 0;
+	dev->mtu			= sizeof(struct can_frame);
+	dev->addr_len			= 0;
+	dev->tx_queue_len		= 10;
+
+	dev->flags			= IFF_NOARP;
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,25)
+#define IFF_ECHO IFF_LOOPBACK
+#endif
+	/* set flags according to driver capabilities */
+	if (echo)
+		dev->flags |= IFF_ECHO;
+
+	dev->features			= NETIF_F_NO_CSUM;
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,28)
+	dev->netdev_ops = &can_netdev_ops;
+#else
+	dev->open			= can_open;
+	dev->stop			= can_close;
+	dev->hard_start_xmit		= can_start_xmit;
+	dev->tx_timeout			= can_tx_timeout;
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,23)
+	dev->get_stats			= can_get_stats;
+#endif
+
+	dev->watchdog_timeo		= TX_TIMEOUT;
+}
+
+static struct net_device* can_create_netdev(int dev_num, int hw_regs)
+{
+	struct net_device	*dev;
+	struct can_priv		*priv;
+
+	if (!(dev = alloc_netdev(sizeof(struct can_priv), CAN_NETDEV_NAME,
+				 can_netdev_setup))) {
+		printk(KERN_ERR "%s: out of memory\n", CHIP_NAME);
+		return NULL;
+	}
+
+	printk(KERN_INFO "%s: base 0x%lX / irq %d / speed %d / "
+	       "btr 0x%X / rx_probe %d\n",
+	       drv_name, rbase[dev_num], irq[dev_num],
+	       speed[dev_num], btr[dev_num], rx_probe[dev_num]);
+
+	/* fill net_device structure */
+
+	priv             = netdev_priv(dev);
+
+	dev->irq         = irq[dev_num];
+	dev->base_addr   = rbase[dev_num];
+
+	priv->speed      = speed[dev_num];
+	priv->btr        = btr[dev_num];
+	priv->rx_probe   = rx_probe[dev_num];
+	priv->clock      = clk;
+	priv->hw_regs    = hw_regs;
+	priv->restart_ms = restart_ms;
+	priv->debug      = debug;
+
+	init_timer(&priv->timer);
+	priv->timer.expires = 0;
+
+	if (register_netdev(dev)) {
+		printk(KERN_INFO "%s: register netdev failed\n", CHIP_NAME);
+		free_netdev(dev);
+		return NULL;
+	}
+
+	return dev;
+}
+
+int can_set_drv_name(void)
+{
+	char *hname = hal_name();
+
+	if (strlen(CHIP_NAME) + strlen(hname) >= DRV_NAME_LEN-1) {
+		printk(KERN_ERR "%s: driver name too long!\n", CHIP_NAME);
+		return -EINVAL;
+	}
+	sprintf(drv_name, "%s-%s", CHIP_NAME, hname);
+	return 0;
+}
+
+static void sja1000_exit_module(void)
+{
+	int i, ret;
+
+	for (i = 0; i < MAXDEV; i++) {
+		if (can_dev[i] != NULL) {
+			struct can_priv *priv = netdev_priv(can_dev[i]);
+			unregister_netdev(can_dev[i]);
+			del_timer(&priv->timer);
+			hw_detach(i);
+			hal_release_region(i, SJA1000_IO_SIZE_BASIC);
+			free_netdev(can_dev[i]);
+		}
+	}
+	can_proc_remove(drv_name);
+
+	if ((ret = hal_exit()))
+		printk(KERN_INFO "%s: hal_exit error %d.\n", drv_name, ret);
+}
+
+static __init int sja1000_init_module(void)
+{
+	int i, ret;
+	struct net_device *dev;
+
+	if ((ret = hal_init()))
+		return ret;
+
+	if ((ret = can_set_drv_name()))
+		return ret;
+
+	if (clk < 1000 ) /* MHz command line value */
+		clk *= 1000000;
+
+	if (clk < 1000000 ) /* kHz command line value */
+		clk *= 1000;
+
+	printk(KERN_INFO "%s driver v%s (%s)\n",
+	       drv_name, drv_version, drv_reldate);
+	printk(KERN_INFO "%s - options [clk %d.%06d MHz] [restart_ms %dms]"
+	       " [debug %d]\n",
+	       drv_name, clk/1000000, clk%1000000, restart_ms, debug);
+
+	if (!base[0]) {
+		printk(KERN_INFO "%s: loading defaults.\n", drv_name);
+		hal_use_defaults();
+	}
+		
+	for (i = 0; base[i]; i++) {
+		printk(KERN_DEBUG "%s: checking for %s on address 0x%lX ...\n",
+		       drv_name, CHIP_NAME, base[i]);
+
+		if (!hal_request_region(i, SJA1000_IO_SIZE_BASIC, drv_name)) {
+			printk(KERN_ERR "%s: memory already in use\n",
+			       drv_name);
+			sja1000_exit_module();
+			return -EBUSY;
+		}
+
+		hw_attach(i);
+		hw_reset_dev(i);
+
+		if (!sja1000_probe_chip(rbase[i])) {
+			printk(KERN_ERR "%s: probably missing controller"
+			       " hardware\n", drv_name);
+			hw_detach(i);
+			hal_release_region(i, SJA1000_IO_SIZE_BASIC);
+			sja1000_exit_module();
+			return -ENODEV;
+		}
+
+		dev = can_create_netdev(i, SJA1000_IO_SIZE_BASIC);
+
+		if (dev != NULL) {
+			can_dev[i] = dev;
+			set_reset_mode(dev);
+			can_proc_create(drv_name);
+		} else {
+			can_dev[i] = NULL;
+			hw_detach(i);
+			hal_release_region(i, SJA1000_IO_SIZE_BASIC);
+		}
+	}
+	return 0;
+}
+
+module_init(sja1000_init_module);
+module_exit(sja1000_exit_module);
+
diff --exclude CVS --exclude .git -uNr linux-2.6.27.8/drivers/net/can/old/sja1000/sja1000.h linux-2.6.27.8.modified/drivers/net/can/old/sja1000/sja1000.h
--- linux-2.6.27.8/drivers/net/can/old/sja1000/sja1000.h	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.27.8.modified/drivers/net/can/old/sja1000/sja1000.h	2013-05-30 03:44:19.000000000 -0400
@@ -0,0 +1,192 @@
+/*
+ * $Id: sja1000.h 505 2007-09-30 13:32:41Z hartkopp $
+ *
+ * sja1000.h -  Philips SJA1000 network device driver
+ *
+ * Copyright (c) 2003 Matthias Brukner, Trajet Gmbh, Rebenring 33,
+ * 38106 Braunschweig, GERMANY
+ *
+ * Copyright (c) 2002-2007 Volkswagen Group Electronic Research
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of Volkswagen nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * Alternatively, provided that this notice is retained in full, this
+ * software may be distributed under the terms of the GNU General
+ * Public License ("GPL") version 2, in which case the provisions of the
+ * GPL apply INSTEAD OF those given above.
+ *
+ * The provided data structures and external interfaces from this code
+ * are not restricted to be used by modules with a GPL compatible license.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * Send feedback to <socketcan-users@lists.berlios.de>
+ *
+ */
+
+#ifndef SJA1000_H
+#define SJA1000_H
+
+#define SJA1000_IO_SIZE_BASIC   0x20
+#define SJA1000_IO_SIZE_PELICAN 0x80 /* unused */
+
+#define CHIP_NAME	"sja1000"
+
+#define DRV_NAME_LEN	30 /* for "<chip_name>-<hal_name>" */
+
+#define PROCBASE          "driver" /* /proc/ ... */
+
+#define DEFAULT_HW_CLK	16000000
+#define DEFAULT_SPEED	500 /* kBit/s */
+
+#define CAN_NETDEV_NAME	"can%d"
+
+#define TX_TIMEOUT      (50*HZ/1000) /* 50ms */ 
+#define RESTART_MS      100  /* restart chip on persistent errors in 100ms */
+#define MAX_BUS_ERRORS  200  /* prevent from flooding bus error interrupts */
+
+/* SJA1000 registers - manual section 6.4 (Pelican Mode) */
+#define REG_MOD		0x00
+#define REG_CMR		0x01
+#define REG_SR		0x02
+#define REG_IR		0x03
+#define REG_IER		0x04
+#define REG_ALC		0x0B
+#define REG_ECC		0x0C
+#define REG_EWL		0x0D
+#define REG_RXERR	0x0E
+#define REG_TXERR	0x0F
+#define REG_ACCC0	0x10
+#define REG_ACCC1	0x11
+#define REG_ACCC2	0x12
+#define REG_ACCC3	0x13
+#define REG_ACCM0	0x14
+#define REG_ACCM1	0x15
+#define REG_ACCM2	0x16
+#define REG_ACCM3	0x17
+#define REG_RMC		0x1D
+#define REG_RBSA	0x1E
+
+/* Common registers - manual section 6.5 */
+#define REG_BTR0	0x06
+#define REG_BTR1	0x07
+#define REG_OCR		0x08
+#define REG_CDR		0x1F
+
+#define REG_FI		0x10
+#define SFF_BUF		0x13
+#define EFF_BUF		0x15
+
+#define FI_FF		0x80
+#define FI_RTR		0x40
+
+#define REG_ID1		0x11
+#define REG_ID2		0x12
+#define REG_ID3		0x13
+#define REG_ID4		0x14
+
+#define CAN_RAM		0x20
+
+/* mode register */
+#define MOD_RM		0x01
+#define MOD_LOM		0x02
+#define MOD_STM		0x04
+#define MOD_AFM		0x08
+#define MOD_SM		0x10
+
+/* commands */
+#define CMD_SRR		0x10
+#define CMD_CDO		0x08
+#define CMD_RRB		0x04
+#define CMD_AT		0x02
+#define CMD_TR		0x01
+
+/* interrupt sources */
+#define IRQ_BEI		0x80
+#define IRQ_ALI		0x40
+#define IRQ_EPI		0x20
+#define IRQ_WUI		0x10
+#define IRQ_DOI		0x08
+#define IRQ_EI		0x04
+#define IRQ_TI		0x02
+#define IRQ_RI		0x01
+#define IRQ_ALL		0xFF
+#define IRQ_OFF		0x00
+
+/* status register content */
+#define SR_BS		0x80
+#define SR_ES		0x40
+#define SR_TS		0x20
+#define SR_RS		0x10
+#define SR_TCS		0x08
+#define SR_TBS		0x04
+#define SR_DOS		0x02
+#define SR_RBS		0x01
+
+#define SR_CRIT (SR_BS|SR_ES)
+
+/* ECC register */
+#define ECC_DIR		0x20
+#define ECC_SEG		0x1F
+#define ECC_ERR		6
+
+/* bus timing */
+#define MAX_TSEG1	15
+#define MAX_TSEG2	 7
+#define SAMPLE_POINT	75
+#define JUMPWIDTH     0x40
+
+/* CAN private data structure */
+
+struct can_priv {
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,23)
+	struct net_device_stats	stats;
+#endif
+	struct can_device_stats	can_stats;
+	long			open_time;
+	int			clock;
+	int			hw_regs;
+	int			restart_ms;
+	int			debug;
+	int			speed;
+	int			btr;
+	int			rx_probe;
+	struct timer_list       timer;
+	int			state;
+	struct sk_buff		*echo_skb;
+};
+
+#define STATE_UNINITIALIZED	0
+#define STATE_PROBE		1
+#define STATE_ACTIVE		2
+#define STATE_ERROR_ACTIVE	3
+#define STATE_ERROR_PASSIVE	4
+#define STATE_BUS_OFF		5
+#define STATE_RESET_MODE	6
+
+void can_proc_create(const char *drv_name);
+void can_proc_remove(const char *drv_name);
+
+#endif /* SJA1000_H */
diff --exclude CVS --exclude .git -uNr linux-2.6.27.8/drivers/net/can/sja1000/Kconfig linux-2.6.27.8.modified/drivers/net/can/sja1000/Kconfig
--- linux-2.6.27.8/drivers/net/can/sja1000/Kconfig	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.27.8.modified/drivers/net/can/sja1000/Kconfig	2013-05-30 03:44:18.000000000 -0400
@@ -0,0 +1,103 @@
+menuconfig CAN_SJA1000
+	tristate "Philips/NXP SJA1000 devices"
+	depends on CAN_DEV && HAS_IOMEM
+
+if CAN_SJA1000
+
+config CAN_SJA1000_ISA
+	tristate "ISA Bus based legacy SJA1000 driver"
+	depends on ISA
+	---help---
+	  This driver adds legacy support for SJA1000 chips connected to
+	  the ISA bus using I/O port, memory mapped or indirect access.
+
+config CAN_SJA1000_PLATFORM
+	tristate "Generic Platform Bus based SJA1000 driver"
+	---help---
+	  This driver adds support for the SJA1000 chips connected to
+	  the "platform bus" (Linux abstraction for directly to the
+	  processor attached devices).  Which can be found on various
+	  boards from Phytec (http://www.phytec.de) like the PCM027,
+	  PCM038.
+
+config CAN_SJA1000_OF_PLATFORM
+	tristate "Generic OF Platform Bus based SJA1000 driver"
+	depends on PPC_OF
+	---help---
+	  This driver adds support for the SJA1000 chips connected to
+	  the OpenFirmware "platform bus" found on embedded systems with
+	  OpenFirmware bindings, e.g. if you have a PowerPC based system
+	  you may want to enable this option.
+
+config CAN_EMS_PCI
+	tristate "EMS CPC-PCI, CPC-PCIe and CPC-104P Card"
+	depends on PCI
+	---help---
+	  This driver is for the one, two or four channel CPC-PCI,
+	  CPC-PCIe and CPC-104P cards from EMS Dr. Thomas Wuensche
+	  (http://www.ems-wuensche.de).
+
+config CAN_EMS_PCMCIA
+	tristate "EMS CPC-CARD Card"
+	depends on PCMCIA && CAN_SJA1000
+	---help---
+	  This driver is for the one or two channel CPC-CARD cards from
+	  EMS Dr. Thomas Wuensche (http://www.ems-wuensche.de).
+
+config CAN_EMS_104M
+	tristate "EMS CPC-104M Card"
+	depends on ISA && CAN_SJA1000
+	---help---
+	  This driver is for the one, two or four channel CPC-104M cards
+	  from EMS Dr. Thomas Wuensche (http://www.ems-wuensche.de).
+
+config CAN_ESD_PCI
+	tristate "ESD PCI Cards"
+	depends on PCI && CAN_SJA1000
+	---help---
+	  This driver supports the esd PCI CAN cards CAN-PCI/200,
+	  CAN-PCI/266, CAN-PMC/266 (PMC), CAN-CPCI/200 (CompactPCI),
+	  CAN-PCIe2000 (PCI Express) and CAN-PCI104/200 (PCI104)
+	  from the esd electronic system design gmbh (http://www.esd.eu).
+
+config CAN_IXXAT_PCI
+	tristate "IXXAT PCI Card"
+	depends on PCI && CAN_SJA1000
+	---help---
+	  This driver is for the IXXAT PC-I 04/PCI card (1 or 2 channel)
+	  from the IXXAT Automation GmbH (http://www.ixxat.de).
+
+config CAN_KVASER_PCI
+	tristate "Kvaser PCIcanx and Kvaser PCIcan PCI Cards"
+	depends on PCI
+	---help---
+	  This driver is for the the PCIcanx and PCIcan cards (1, 2 or
+	  4 channel) from Kvaser (http://www.kvaser.com).
+
+config CAN_PEAK_PCI
+	tristate "PEAK PCAN PCI Card"
+	depends on PCI && CAN_SJA1000
+	---help---
+	  This driver is for the PCAN PCI, the PC-PCI CAN plug-in card (1 or
+	  2 channel) from PEAK Systems (http://www.peak-system.com).
+
+config CAN_PLX_PCI
+	tristate "PLX90xx PCI-bridge based Cards"
+	depends on PCI
+	---help---
+	  This driver is for CAN interface cards based on
+	  the PLX90xx PCI bridge.
+	  Driver supports now:
+	   - Adlink PCI-7841/cPCI-7841 card (http://www.adlinktech.com/)
+	   - Adlink PCI-7841/cPCI-7841 SE card
+	   - Marathon CAN-bus-PCI card (http://www.marathon.ru/)
+	   - TEWS TECHNOLOGIES TPMC810 card (http://www.tews.com/)
+
+config CAN_PIPCAN
+	depends on CAN_SJA1000
+	tristate "MPL PIPCAN CAN module driver (SJA1000)"
+	---help---
+	  This driver adds support for the PIPCAN module used on some SBC
+	  boards from MPL AG (http://www.mpl.ch).
+
+endif
diff --exclude CVS --exclude .git -uNr linux-2.6.27.8/drivers/net/can/sja1000/Makefile linux-2.6.27.8.modified/drivers/net/can/sja1000/Makefile
--- linux-2.6.27.8/drivers/net/can/sja1000/Makefile	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.27.8.modified/drivers/net/can/sja1000/Makefile	2013-05-30 03:44:18.000000000 -0400
@@ -0,0 +1,36 @@
+#
+#  $Id: Makefile 443 2007-07-25 11:41:27Z hartkopp $
+#
+
+ifeq ($(KERNELRELEASE),)
+
+KERNELDIR := /lib/modules/$(shell uname -r)/build
+PWD       := $(shell pwd)
+TOPDIR    := $(PWD)/../../../..
+
+modules modules_install clean:
+	$(MAKE) -C $(KERNELDIR) M=$(PWD) $@ TOPDIR=$(TOPDIR)
+
+else
+
+-include $(TOPDIR)/Makefile.common
+
+obj-$(CONFIG_CAN_SJA1000) += sja1000.o
+obj-$(CONFIG_CAN_SJA1000_ISA) += sja1000_isa.o
+obj-$(CONFIG_CAN_SJA1000_PLATFORM) += sja1000_platform.o
+obj-$(CONFIG_CAN_SJA1000_OF_PLATFORM) += sja1000_of_platform.o
+obj-$(CONFIG_CAN_EMS_PCI) += ems_pci.o
+obj-$(CONFIG_CAN_EMS_PCMCIA) += ems_pcmcia.o
+obj-$(CONFIG_CAN_EMS_104M) += ems_104m.o
+obj-$(CONFIG_CAN_ESD_PCI) += esd_pci.o
+obj-$(CONFIG_CAN_IXXAT_PCI) += ixxat_pci.o
+obj-$(CONFIG_CAN_PLX_PCI) += plx_pci.o
+obj-$(CONFIG_CAN_PEAK_PCI) += peak_pci.o
+obj-$(CONFIG_CAN_PIPCAN) += pipcan.o
+obj-$(CONFIG_CAN_KVASER_PCI) += kvaser_pci.o
+
+ifeq ($(CONFIG_CAN_DEBUG_DEVICES),y)
+	EXTRA_CFLAGS += -DDEBUG
+endif
+
+endif
diff --exclude CVS --exclude .git -uNr linux-2.6.27.8/drivers/net/can/sja1000/ems_104m.c linux-2.6.27.8.modified/drivers/net/can/sja1000/ems_104m.c
--- linux-2.6.27.8/drivers/net/can/sja1000/ems_104m.c	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.27.8.modified/drivers/net/can/sja1000/ems_104m.c	2013-05-30 03:44:18.000000000 -0400
@@ -0,0 +1,391 @@
+/*
+ * Copyright (C) 2009 Sebastian Haas <haas@ems-wuensche.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the version 2 of the GNU General Public License
+ * as published by the Free Software Foundation
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include <linux/kernel.h>
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/isa.h>
+#include <linux/interrupt.h>
+#include <linux/netdevice.h>
+#include <linux/delay.h>
+#include <socketcan/can.h>
+#include <socketcan/can/dev.h>
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,16)
+#include <linux/io.h>
+#else
+#include <asm/io.h>
+#endif
+
+#include "sja1000.h"
+
+#define DRV_NAME  "ems_104m"
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,16)
+#error This driver does not support Kernel versions < 2.6.16
+#endif
+
+MODULE_AUTHOR("Sebastian Haas <haas@ems-wuenche.com>");
+MODULE_DESCRIPTION("Socket-CAN driver for EMS CPC-104M cards");
+MODULE_SUPPORTED_DEVICE("EMS CPC-104M CAN card");
+MODULE_LICENSE("GPL v2");
+
+#define EMS_104M_MAX_DEV  4
+
+static unsigned long __devinitdata mem[EMS_104M_MAX_DEV];
+static int __devinitdata irq[EMS_104M_MAX_DEV];
+
+module_param_array(mem, ulong, NULL, S_IRUGO);
+MODULE_PARM_DESC(mem, "I/O memory address");
+
+module_param_array(irq, int, NULL, S_IRUGO);
+MODULE_PARM_DESC(irq, "IRQ number");
+
+#define EMS_104M_MAX_CHAN 4
+
+struct ems_104m_card {
+	int channels;
+
+	struct net_device *net_dev[EMS_104M_MAX_CHAN];
+
+	void __iomem *base;
+	int irq;
+};
+
+#define EMS_104M_CAN_CLOCK (16000000 / 2)
+
+/*
+ * The board configuration is probably following:
+ * RX1 is connected to ground.
+ * TX1 is not connected.
+ * CLKO is not connected.
+ * Setting the OCR register to 0xDA is a good idea.
+ * This means  normal output mode , push-pull and the correct polarity.
+ */
+#define EMS_104M_OCR         (OCR_TX0_PUSHPULL | OCR_TX1_PUSHPULL)
+
+/*
+ * In the CDR register, you should set CBP to 1.
+ * You will probably also want to set the clock divider value to 7
+ * (meaning direct oscillator output) because the second SJA1000 chip
+ * is driven by the first one CLKOUT output.
+ */
+#define EMS_104M_CDR             (CDR_CBP | CDR_CLKOUT_MASK)
+#define EMS_104M_MEM_SIZE        0x2000 /* Size of the remapped io-memory */
+#define EMS_104M_CAN_BASE_OFFSET 0x100  /* Offset where controllers starts */
+#define EMS_104M_CAN_CTRL_SIZE   0x80   /* Memory size for each controller */
+
+#define EMS_104M_CARD_REG_IRQ_CTRL    7
+#define EMS_104M_CARD_REG_IRQ_STATUS  8
+#define EMS_104M_CARD_REG_VERSION     9
+
+#define EMS_104M_CARD_REG_CONTROL     4
+#define EMS_104M_CARD_REG_STATUS      6
+
+#define EMS_CMD_RESET 0x00  /* Perform a reset of the card */
+#define EMS_CMD_MAP   0x03  /* Map CAN controllers into card' memory */
+#define EMS_CMD_UMAP  0x02  /* Unmap CAN controllers from card' memory */
+
+static u8 ems_104m_read_reg(const struct sja1000_priv *priv, int port)
+{
+	return readb(priv->reg_base + port);
+}
+
+static void ems_104m_write_reg(const struct sja1000_priv *priv,
+				 int port, u8 val)
+{
+	writeb(val, priv->reg_base + port);
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,19)
+static irqreturn_t ems_104m_interrupt(int irq, void *dev_id,
+					struct pt_regs *regs)
+#else
+static irqreturn_t ems_104m_interrupt(int irq, void *dev_id)
+#endif
+{
+	struct ems_104m_card *card = dev_id;
+	struct net_device *dev;
+	irqreturn_t retval = IRQ_NONE;
+	int i, again;
+
+	do {
+		again = 0;
+
+		/* Check interrupt for each channel */
+		for (i = 0; i < EMS_104M_MAX_CHAN; i++) {
+			dev = card->net_dev[i];
+			if (!dev)
+				continue;
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,19)
+			if (sja1000_interrupt(irq, dev, regs) == IRQ_HANDLED)
+					again = 1;
+#else
+			if (sja1000_interrupt(irq, dev) == IRQ_HANDLED)
+					again = 1;
+#endif
+		}
+
+		/* At least one channel handled the interrupt */
+		if (again)
+			retval = IRQ_HANDLED;
+	} while (again);
+
+	return retval;
+}
+
+/*
+ * Check if a CAN controller is present at the specified location
+ * by trying to set 'em into the PeliCAN mode
+ */
+static inline int ems_104m_check_chan(struct sja1000_priv *priv)
+{
+	unsigned char res;
+
+	/* Make sure SJA1000 is in reset mode */
+	ems_104m_write_reg(priv, REG_MOD, 1);
+
+	ems_104m_write_reg(priv, REG_CDR, CDR_PELICAN);
+
+	/* read reset-values */
+	res = ems_104m_read_reg(priv, REG_CDR);
+
+	if (res == CDR_PELICAN)
+		return 1;
+
+	return 0;
+}
+
+/*
+ * Probe ISA device for EMS CAN signature and register each available
+ * CAN channel to SJA1000 Socket-CAN subsystem.
+ */
+static int __devinit ems_104m_probe(struct device *pdev, unsigned int idx)
+{
+	struct sja1000_priv *priv;
+	struct net_device *dev;
+	struct ems_104m_card *card;
+
+	int err, i;
+
+	/* Allocating card structures to hold addresses, ... */
+	card = kzalloc(sizeof(struct ems_104m_card), GFP_KERNEL);
+	if (card == NULL) {
+		dev_err(pdev, "couldn't allocate memory\n");
+		return -ENOMEM;
+	}
+
+	dev_set_drvdata(pdev, card);
+
+	card->channels = 0;
+	card->irq = irq[idx];
+
+	card->base = ioremap_nocache(mem[idx], EMS_104M_MEM_SIZE);
+	if (card->base == NULL) {
+		dev_err(pdev, "couldn't map memory\n");
+		err = -ENOMEM;
+		goto failure_cleanup;
+	}
+
+	/* Check for unique EMS CAN signature */
+	if (readw(card->base) != 0xAA55) {
+		dev_err(pdev, "No EMS CPC Card hardware found.\n");
+
+		err = -ENODEV;
+		goto failure_cleanup;
+	}
+
+	writeb(EMS_CMD_RESET, card->base);
+
+	/* Wait for reset to finish */
+	i = 0;
+	while (readb(card->base + EMS_104M_CARD_REG_STATUS) == 0x01) {
+		/* Check for timeout (50ms.) */
+		if (i >= 50) {
+			dev_err(pdev, "couldn't reset card.\n");
+
+			err = -EBUSY;
+			goto failure_cleanup;
+		}
+
+		msleep(1);
+	}
+
+	/* Make sure CAN controllers are mapped into card's memory space */
+	writeb(EMS_CMD_MAP, card->base);
+	writeb(EMS_CMD_MAP, card->base); /* Second call to workaround bug */
+
+	/* Detect available channels */
+	for (i = 0; i < EMS_104M_MAX_CHAN; i++) {
+		dev = alloc_sja1000dev(0);
+		if (dev == NULL) {
+			err = -ENOMEM;
+			goto failure_cleanup;
+		}
+
+		card->net_dev[i] = dev;
+		priv = netdev_priv(dev);
+		priv->priv = card;
+		SET_NETDEV_DEV(dev, pdev);
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,18)
+		priv->irq_flags = SA_SHIRQ;
+#else
+		priv->irq_flags = IRQF_SHARED;
+#endif
+		dev->irq = irq[idx];
+		priv->reg_base = card->base + EMS_104M_CAN_BASE_OFFSET
+					+ (i * EMS_104M_CAN_CTRL_SIZE);
+
+		/* Check if channel is present */
+		if (ems_104m_check_chan(priv)) {
+			priv->read_reg  = ems_104m_read_reg;
+			priv->write_reg = ems_104m_write_reg;
+			priv->can.clock.freq = EMS_104M_CAN_CLOCK;
+			priv->ocr = EMS_104M_OCR;
+			priv->cdr = EMS_104M_CDR;
+			priv->flags |= SJA1000_CUSTOM_IRQ_HANDLER;
+
+			/* Register SJA1000 device */
+			err = register_sja1000dev(dev);
+			if (err) {
+				dev_err(pdev, "registering device failed"
+				    " (err=%d)\n", err);
+				free_sja1000dev(dev);
+				goto failure_cleanup;
+			}
+
+			/* Enable interrupts of this channel */
+			writeb(0x3 << (i * 2),
+			    card->base + EMS_104M_CARD_REG_IRQ_CTRL);
+
+			card->channels++;
+
+			dev_info(pdev, "registered %s on channel at 0x%p,"
+			    " irq %d\n", dev->name, priv->reg_base, dev->irq);
+		} else {
+			free_sja1000dev(dev);
+		}
+	}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,18)
+	err = request_irq(card->irq, &ems_104m_interrupt, SA_SHIRQ,
+		DRV_NAME, (void *)card);
+#else
+	err = request_irq(card->irq, &ems_104m_interrupt, IRQF_SHARED,
+		DRV_NAME, (void *)card);
+#endif
+
+	if (err) {
+		dev_err(pdev, "registering device failed (err=%d)\n", err);
+		goto failure_cleanup;
+	}
+
+	return 0;
+
+failure_cleanup:
+	dev_err(pdev, "error: %d. Cleaning Up.\n", err);
+
+	if (card->base)
+		iounmap(card->base);
+
+	kfree(card);
+
+	return err;
+}
+
+/*
+ * Release claimed resources
+ */
+static int __devexit ems_104m_remove(struct device *pdev, unsigned int idx)
+{
+	struct ems_104m_card *card = dev_get_drvdata(pdev);
+	struct net_device *dev;
+	int i = 0;
+
+	if (!card)
+		return 0;
+
+	free_irq(card->irq, card);
+
+	for (i = 0; i < card->channels; i++) {
+		dev = card->net_dev[i];
+
+		if (!dev)
+			continue;
+
+		dev_info(pdev, "removing %s on channel #%d\n", dev->name, i);
+		unregister_sja1000dev(dev);
+		free_sja1000dev(dev);
+	}
+
+	writeb(EMS_CMD_UMAP, card->base);
+
+	if (card->base != NULL)
+		iounmap(card->base);
+
+	kfree(card);
+
+	dev_set_drvdata(pdev, NULL);
+
+	return 0;
+}
+
+static int __devinit ems_104m_match(struct device *pdev, unsigned int idx)
+{
+	if (!mem[idx])
+		return 0;
+
+	if (!irq[idx]) {
+		dev_err(pdev, "insufficient parameters supplied\n");
+		return 0;
+	}
+
+	return 1;
+}
+
+static struct isa_driver ems_104m_driver = {
+	.match = ems_104m_match,
+	.probe = ems_104m_probe,
+	.remove = __devexit_p(ems_104m_remove),
+
+	.driver = {
+		.name = DRV_NAME,
+	},
+};
+
+static int __init ems_104m_init(void)
+{
+	int err = isa_register_driver(&ems_104m_driver, EMS_104M_MAX_DEV);
+
+	if (!err)
+		printk(KERN_INFO
+		       "Legacy %s driver for max. %d devices registered\n",
+		       DRV_NAME, EMS_104M_MAX_DEV);
+
+	return err;
+}
+
+static void __exit ems_104m_exit(void)
+{
+	isa_unregister_driver(&ems_104m_driver);
+}
+
+module_init(ems_104m_init);
+module_exit(ems_104m_exit);
+
diff --exclude CVS --exclude .git -uNr linux-2.6.27.8/drivers/net/can/sja1000/ems_pci.c linux-2.6.27.8.modified/drivers/net/can/sja1000/ems_pci.c
--- linux-2.6.27.8/drivers/net/can/sja1000/ems_pci.c	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.27.8.modified/drivers/net/can/sja1000/ems_pci.c	2013-05-30 03:44:18.000000000 -0400
@@ -0,0 +1,401 @@
+/*
+ * Copyright (C) 2007 Wolfgang Grandegger <wg@grandegger.com>
+ * Copyright (C) 2008 Markus Plessing <plessing@ems-wuensche.com>
+ * Copyright (C) 2008 Sebastian Haas <haas@ems-wuensche.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the version 2 of the GNU General Public License
+ * as published by the Free Software Foundation
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include <linux/kernel.h>
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/interrupt.h>
+#include <linux/netdevice.h>
+#include <linux/delay.h>
+#include <linux/pci.h>
+#include <socketcan/can.h>
+#include <socketcan/can/dev.h>
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,16)
+#include <linux/io.h>
+#else
+#include <asm/io.h>
+#endif
+
+#include "sja1000.h"
+
+#define DRV_NAME  "ems_pci"
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,23)
+#error This driver does not support Kernel versions < 2.6.23
+#endif
+
+MODULE_AUTHOR("Sebastian Haas <haas@ems-wuenche.com>");
+MODULE_DESCRIPTION("Socket-CAN driver for EMS CPC-PCI/PCIe CAN cards");
+MODULE_SUPPORTED_DEVICE("EMS CPC-PCI/PCIe CAN card");
+MODULE_LICENSE("GPL v2");
+
+#define EMS_PCI_V1_MAX_CHAN 2
+#define EMS_PCI_V2_MAX_CHAN 4
+#define EMS_PCI_MAX_CHAN    EMS_PCI_V2_MAX_CHAN
+
+struct ems_pci_card {
+	int version;
+	int channels;
+
+	struct pci_dev *pci_dev;
+	struct net_device *net_dev[EMS_PCI_MAX_CHAN];
+
+	void __iomem *conf_addr;
+	void __iomem *base_addr;
+};
+
+#define EMS_PCI_CAN_CLOCK (16000000 / 2)
+
+/*
+ * Register definitions and descriptions are from LinCAN 0.3.3.
+ *
+ * PSB4610 PITA-2 bridge control registers
+ */
+#define PITA2_ICR           0x00	/* Interrupt Control Register */
+#define PITA2_ICR_INT0      0x00000002	/* [RC] INT0 Active/Clear */
+#define PITA2_ICR_INT0_EN   0x00020000	/* [RW] Enable INT0 */
+
+#define PITA2_MISC          0x1c	/* Miscellaneous Register */
+#define PITA2_MISC_CONFIG   0x04000000	/* Multiplexed parallel interface */
+
+/*
+ * Register definitions for the PLX 9030
+ */
+#define PLX_ICSR            0x4c   /* Interrupt Control/Status register */
+#define PLX_ICSR_LINTI1_ENA 0x0001 /* LINTi1 Enable */
+#define PLX_ICSR_PCIINT_ENA 0x0040 /* PCI Interrupt Enable */
+#define PLX_ICSR_LINTI1_CLR 0x0400 /* Local Edge Triggerable Interrupt Clear */
+#define PLX_ICSR_ENA_CLR    (PLX_ICSR_LINTI1_ENA | PLX_ICSR_PCIINT_ENA | \
+			     PLX_ICSR_LINTI1_CLR)
+
+/*
+ * The board configuration is probably following:
+ * RX1 is connected to ground.
+ * TX1 is not connected.
+ * CLKO is not connected.
+ * Setting the OCR register to 0xDA is a good idea.
+ * This means normal output mode, push-pull and the correct polarity.
+ */
+#define EMS_PCI_OCR         (OCR_TX0_PUSHPULL | OCR_TX1_PUSHPULL)
+
+/*
+ * In the CDR register, you should set CBP to 1.
+ * You will probably also want to set the clock divider value to 7
+ * (meaning direct oscillator output) because the second SJA1000 chip
+ * is driven by the first one CLKOUT output.
+ */
+#define EMS_PCI_CDR             (CDR_CBP | CDR_CLKOUT_MASK)
+
+#define EMS_PCI_V1_BASE_BAR     1
+#define EMS_PCI_V1_MEM_SIZE     4096
+#define EMS_PCI_V2_BASE_BAR     2
+#define EMS_PCI_V2_MEM_SIZE     128
+#define EMS_PCI_CAN_BASE_OFFSET 0x400 /* offset where the controllers starts */
+#define EMS_PCI_CAN_CTRL_SIZE   0x200 /* memory size for each controller */
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,25)
+static struct pci_device_id ems_pci_tbl[] = {
+#else
+static DEFINE_PCI_DEVICE_TABLE(ems_pci_tbl) = {
+#endif
+ 	/* CPC-PCI v1 */
+	{PCI_VENDOR_ID_SIEMENS, 0x2104, PCI_ANY_ID, PCI_ANY_ID,},
+	/* CPC-PCI v2 */
+	{PCI_VENDOR_ID_PLX, PCI_DEVICE_ID_PLX_9030, PCI_VENDOR_ID_PLX, 0x4000},
+	/* CPC-104P v2 */
+	{PCI_VENDOR_ID_PLX, PCI_DEVICE_ID_PLX_9030, PCI_VENDOR_ID_PLX, 0x4002},
+	{0,}
+};
+MODULE_DEVICE_TABLE(pci, ems_pci_tbl);
+
+/*
+ * Helper to read internal registers from card logic (not CAN)
+ */
+static u8 ems_pci_v1_readb(struct ems_pci_card *card, unsigned int port)
+{
+	return readb(card->base_addr + (port * 4));
+}
+
+static u8 ems_pci_v1_read_reg(const struct sja1000_priv *priv, int port)
+{
+	return readb(priv->reg_base + (port * 4));
+}
+
+static void ems_pci_v1_write_reg(const struct sja1000_priv *priv,
+				 int port, u8 val)
+{
+	writeb(val, priv->reg_base + (port * 4));
+}
+
+static void ems_pci_v1_post_irq(const struct sja1000_priv *priv)
+{
+	struct ems_pci_card *card = (struct ems_pci_card *)priv->priv;
+
+	/* reset int flag of pita */
+	writel(PITA2_ICR_INT0_EN | PITA2_ICR_INT0,
+	       card->conf_addr + PITA2_ICR);
+}
+
+static u8 ems_pci_v2_read_reg(const struct sja1000_priv *priv, int port)
+{
+	return readb(priv->reg_base + port);
+}
+
+static void ems_pci_v2_write_reg(const struct sja1000_priv *priv,
+				 int port, u8 val)
+{
+	writeb(val, priv->reg_base + port);
+}
+
+static void ems_pci_v2_post_irq(const struct sja1000_priv *priv)
+{
+	struct ems_pci_card *card = (struct ems_pci_card *)priv->priv;
+
+	writel(PLX_ICSR_ENA_CLR, card->conf_addr + PLX_ICSR);
+}
+
+/*
+ * Check if a CAN controller is present at the specified location
+ * by trying to set 'em into the PeliCAN mode
+ */
+static inline int ems_pci_check_chan(const struct sja1000_priv *priv)
+{
+	unsigned char res;
+
+	/* Make sure SJA1000 is in reset mode */
+	priv->write_reg(priv, REG_MOD, 1);
+
+	priv->write_reg(priv, REG_CDR, CDR_PELICAN);
+
+	/* read reset-values */
+	res = priv->read_reg(priv, REG_CDR);
+
+	if (res == CDR_PELICAN)
+		return 1;
+
+	return 0;
+}
+
+static void ems_pci_del_card(struct pci_dev *pdev)
+{
+	struct ems_pci_card *card = pci_get_drvdata(pdev);
+	struct net_device *dev;
+	int i = 0;
+
+	for (i = 0; i < card->channels; i++) {
+		dev = card->net_dev[i];
+
+		if (!dev)
+			continue;
+
+		dev_info(&pdev->dev, "Removing %s.\n", dev->name);
+		unregister_sja1000dev(dev);
+		free_sja1000dev(dev);
+	}
+
+	if (card->base_addr != NULL)
+		pci_iounmap(card->pci_dev, card->base_addr);
+
+	if (card->conf_addr != NULL)
+		pci_iounmap(card->pci_dev, card->conf_addr);
+
+	kfree(card);
+
+	pci_disable_device(pdev);
+	pci_set_drvdata(pdev, NULL);
+}
+
+static void ems_pci_card_reset(struct ems_pci_card *card)
+{
+	/* Request board reset */
+	writeb(0, card->base_addr);
+}
+
+/*
+ * Probe PCI device for EMS CAN signature and register each available
+ * CAN channel to SJA1000 Socket-CAN subsystem.
+ */
+static int __devinit ems_pci_add_card(struct pci_dev *pdev,
+					const struct pci_device_id *ent)
+{
+	struct sja1000_priv *priv;
+	struct net_device *dev;
+	struct ems_pci_card *card;
+	int max_chan, mem_size, base_bar;
+	int err, i;
+
+	/* Enabling PCI device */
+	if (pci_enable_device(pdev) < 0) {
+		dev_err(&pdev->dev, "Enabling PCI device failed\n");
+		return -ENODEV;
+	}
+
+	/* Allocating card structures to hold addresses, ... */
+	card = kzalloc(sizeof(struct ems_pci_card), GFP_KERNEL);
+	if (card == NULL) {
+		dev_err(&pdev->dev, "Unable to allocate memory\n");
+		pci_disable_device(pdev);
+		return -ENOMEM;
+	}
+
+	pci_set_drvdata(pdev, card);
+
+	card->pci_dev = pdev;
+
+	card->channels = 0;
+
+	if (pdev->vendor == PCI_VENDOR_ID_PLX) {
+		card->version = 2; /* CPC-PCI v2 */
+		max_chan = EMS_PCI_V2_MAX_CHAN;
+		base_bar = EMS_PCI_V2_BASE_BAR;
+		mem_size = EMS_PCI_V2_MEM_SIZE;
+	} else {
+		card->version = 1; /* CPC-PCI v1 */
+		max_chan = EMS_PCI_V1_MAX_CHAN;
+		base_bar = EMS_PCI_V1_BASE_BAR;
+		mem_size = EMS_PCI_V1_MEM_SIZE;
+	}
+
+	/* Remap configuration space and controller memory area */
+	card->conf_addr = pci_iomap(pdev, 0, mem_size);
+	if (card->conf_addr == NULL) {
+		err = -ENOMEM;
+		goto failure_cleanup;
+	}
+
+	card->base_addr = pci_iomap(pdev, base_bar, mem_size);
+	if (card->base_addr == NULL) {
+		err = -ENOMEM;
+		goto failure_cleanup;
+	}
+
+	if (card->version == 1) {
+		/* Configure PITA-2 parallel interface (enable MUX) */
+		writel(PITA2_MISC_CONFIG, card->conf_addr + PITA2_MISC);
+
+		/* Check for unique EMS CAN signature */
+		if (ems_pci_v1_readb(card, 0) != 0x55 ||
+		    ems_pci_v1_readb(card, 1) != 0xAA ||
+		    ems_pci_v1_readb(card, 2) != 0x01 ||
+		    ems_pci_v1_readb(card, 3) != 0xCB ||
+		    ems_pci_v1_readb(card, 4) != 0x11) {
+			dev_err(&pdev->dev,
+				"Not EMS Dr. Thomas Wuensche interface\n");
+			err = -ENODEV;
+			goto failure_cleanup;
+		}
+  	}
+
+	ems_pci_card_reset(card);
+
+	/* Detect available channels */
+	for (i = 0; i < max_chan; i++) {
+		dev = alloc_sja1000dev(0);
+		if (dev == NULL) {
+			err = -ENOMEM;
+			goto failure_cleanup;
+		}
+
+		card->net_dev[i] = dev;
+		priv = netdev_priv(dev);
+		priv->priv = card;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,18)
+		priv->irq_flags = SA_SHIRQ;
+#else
+		priv->irq_flags = IRQF_SHARED;
+#endif
+
+		dev->irq = pdev->irq;
+		priv->reg_base = card->base_addr + EMS_PCI_CAN_BASE_OFFSET
+					+ (i * EMS_PCI_CAN_CTRL_SIZE);
+		if (card->version == 1) {
+			priv->read_reg  = ems_pci_v1_read_reg;
+			priv->write_reg = ems_pci_v1_write_reg;
+			priv->post_irq  = ems_pci_v1_post_irq;
+		} else {
+			priv->read_reg  = ems_pci_v2_read_reg;
+			priv->write_reg = ems_pci_v2_write_reg;
+			priv->post_irq  = ems_pci_v2_post_irq;
+		}
+
+		/* Check if channel is present */
+		if (ems_pci_check_chan(priv)) {
+			priv->can.clock.freq = EMS_PCI_CAN_CLOCK;
+			priv->ocr = EMS_PCI_OCR;
+			priv->cdr = EMS_PCI_CDR;
+
+			SET_NETDEV_DEV(dev, &pdev->dev);
+
+			if (card->version == 1)
+				/* reset int flag of pita */
+				writel(PITA2_ICR_INT0_EN | PITA2_ICR_INT0,
+				       card->conf_addr + PITA2_ICR);
+			else
+				/* enable IRQ in PLX 9030 */
+				writel(PLX_ICSR_ENA_CLR,
+				       card->conf_addr + PLX_ICSR);
+
+			/* Register SJA1000 device */
+			err = register_sja1000dev(dev);
+			if (err) {
+				dev_err(&pdev->dev, "Registering device failed "
+							"(err=%d)\n", err);
+				free_sja1000dev(dev);
+				goto failure_cleanup;
+			}
+
+			card->channels++;
+
+			dev_info(&pdev->dev, "Channel #%d at 0x%p, irq %d\n",
+					i + 1, priv->reg_base, dev->irq);
+		} else {
+			free_sja1000dev(dev);
+		}
+	}
+
+	return 0;
+
+failure_cleanup:
+	dev_err(&pdev->dev, "Error: %d. Cleaning Up.\n", err);
+
+	ems_pci_del_card(pdev);
+
+	return err;
+}
+
+static struct pci_driver ems_pci_driver = {
+	.name = DRV_NAME,
+	.id_table = ems_pci_tbl,
+	.probe = ems_pci_add_card,
+	.remove = ems_pci_del_card,
+};
+
+static int __init ems_pci_init(void)
+{
+	return pci_register_driver(&ems_pci_driver);
+}
+
+static void __exit ems_pci_exit(void)
+{
+	pci_unregister_driver(&ems_pci_driver);
+}
+
+module_init(ems_pci_init);
+module_exit(ems_pci_exit);
+
diff --exclude CVS --exclude .git -uNr linux-2.6.27.8/drivers/net/can/sja1000/ems_pcmcia.c linux-2.6.27.8.modified/drivers/net/can/sja1000/ems_pcmcia.c
--- linux-2.6.27.8/drivers/net/can/sja1000/ems_pcmcia.c	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.27.8.modified/drivers/net/can/sja1000/ems_pcmcia.c	2013-05-30 03:44:18.000000000 -0400
@@ -0,0 +1,484 @@
+/*
+ * Copyright (C) 2008 Sebastian Haas <haas@ems-wuensche.com>
+ * Copyright (C) 2010 Markus Plessing <plessing@ems-wuensche.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the version 2 of the GNU General Public License
+ * as published by the Free Software Foundation
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include <linux/kernel.h>
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/interrupt.h>
+#include <linux/netdevice.h>
+#include <linux/delay.h>
+#include <socketcan/can.h>
+#include <socketcan/can/dev.h>
+#include <asm/io.h>
+
+#include <pcmcia/cs_types.h>
+#include <pcmcia/cs.h>
+#include <pcmcia/cistpl.h>
+#include <pcmcia/ciscode.h>
+#include <pcmcia/ds.h>
+#include <pcmcia/cisreg.h>
+
+#include "sja1000.h"
+
+#define DRV_NAME  "ems_pcmcia"
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,16)
+#error This driver does not support Kernel versions < 2.6.16
+#endif
+
+MODULE_AUTHOR("Sebastian Haas <haas@ems-wuenche.com>");
+MODULE_DESCRIPTION("Socket-CAN driver for EMS CPC-CARD cards");
+MODULE_SUPPORTED_DEVICE("EMS CPC-CARD CAN card");
+MODULE_LICENSE("GPL v2");
+
+static int debug;
+
+module_param(debug, int, S_IRUGO | S_IWUSR);
+
+MODULE_PARM_DESC(debug, "Set debug level (default: 0)");
+
+#define EMS_PCMCIA_MAX_CHAN 2
+
+struct ems_pcmcia_card {
+	int channels;
+
+	struct pcmcia_device *pcmcia_dev;
+	struct net_device *net_dev[EMS_PCMCIA_MAX_CHAN];
+
+	void __iomem *base_addr;
+};
+
+#define EMS_PCMCIA_CAN_CLOCK (16000000 / 2)
+
+/*
+ * The board configuration is probably following:
+ * RX1 is connected to ground.
+ * TX1 is not connected.
+ * CLKO is not connected.
+ * Setting the OCR register to 0xDA is a good idea.
+ * This means  normal output mode , push-pull and the correct polarity.
+ */
+#define EMS_PCMCIA_OCR         (OCR_TX0_PUSHPULL | OCR_TX1_PUSHPULL)
+
+/*
+ * In the CDR register, you should set CBP to 1.
+ * You will probably also want to set the clock divider value to 7
+ * (meaning direct oscillator output) because the second SJA1000 chip
+ * is driven by the first one CLKOUT output.
+ */
+#define EMS_PCMCIA_CDR             (CDR_CBP | CDR_CLKOUT_MASK)
+#define EMS_PCMCIA_MEM_SIZE        4096  /* Size of the remapped io-memory */
+#define EMS_PCMCIA_CAN_BASE_OFFSET 0x100 /* Offset where controllers starts */
+#define EMS_PCMCIA_CAN_CTRL_SIZE   0x80  /* Memory size for each controller */
+
+#define EMS_CMD_RESET 0x00  /* Perform a reset of the card */
+#define EMS_CMD_MAP   0x03  /* Map CAN controllers into card' memory */
+#define EMS_CMD_UMAP  0x02  /* Unmap CAN controllers from card' memory */
+
+static struct pcmcia_device_id ems_pcmcia_tbl[] = {
+	PCMCIA_DEVICE_PROD_ID123("EMS_T_W", "CPC-Card", "V2.0", 0xeab1ea23,
+				 0xa338573f, 0xe4575800),
+	PCMCIA_DEVICE_NULL,
+};
+
+MODULE_DEVICE_TABLE (pcmcia, ems_pcmcia_tbl);
+
+static void ems_pcmcia_config(struct pcmcia_device *dev);
+
+static u8 ems_pcmcia_read_reg(const struct sja1000_priv *priv, int port)
+{
+	return readb(priv->reg_base + port);
+}
+
+static void ems_pcmcia_write_reg(const struct sja1000_priv *priv,
+				 int port, u8 val)
+{
+	writeb(val, priv->reg_base + port);
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,19)
+static irqreturn_t ems_pcmcia_interrupt(int irq, void *dev_id,
+					struct pt_regs *regs)
+#else
+static irqreturn_t ems_pcmcia_interrupt(int irq, void *dev_id)
+#endif
+{
+	struct ems_pcmcia_card *card = dev_id;
+	struct net_device *dev;
+	irqreturn_t retval = IRQ_NONE;
+	int i, again;
+
+	/* Card not present */
+	if (readw(card->base_addr) != 0xAA55)
+		return IRQ_HANDLED;
+
+	do {
+		again = 0;
+
+		/* Check interrupt for each channel */
+		for (i = 0; i < EMS_PCMCIA_MAX_CHAN; i++) {
+			dev = card->net_dev[i];
+			if (!dev)
+				continue;
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,19)
+			if (sja1000_interrupt(irq, dev, regs) == IRQ_HANDLED)
+			    again = 1;
+#else
+			if (sja1000_interrupt(irq, dev) == IRQ_HANDLED)
+			    again = 1;
+#endif
+		}
+		/* At least one channel handled the interrupt */
+		if (again)
+			retval = IRQ_HANDLED;
+
+	} while (again);
+
+	return retval;
+}
+
+/*
+ * Check if a CAN controller is present at the specified location
+ * by trying to set 'em into the PeliCAN mode
+ */
+static inline int ems_pcmcia_check_chan(struct sja1000_priv *priv)
+{
+	unsigned char res;
+
+	/* Make sure SJA1000 is in reset mode */
+	ems_pcmcia_write_reg(priv, REG_MOD, 1);
+
+	ems_pcmcia_write_reg(priv, REG_CDR, CDR_PELICAN);
+
+	/* read reset-values */
+	res = ems_pcmcia_read_reg(priv, REG_CDR);
+
+	if (res == CDR_PELICAN)
+		return 1;
+
+	return 0;
+}
+
+static void ems_pcmcia_del_card(struct pcmcia_device *pdev)
+{
+	struct ems_pcmcia_card *card = pdev->priv;
+	struct net_device *dev;
+	int i = 0;
+
+	if (!card)
+		return;
+
+	free_irq(pdev->irq.AssignedIRQ, card);
+
+	for (i = 0; i < card->channels; i++) {
+		dev = card->net_dev[i];
+
+		if (!dev)
+			continue;
+
+		printk(KERN_INFO "%s: removing %s on channel #%d\n",
+		       DRV_NAME, dev->name, i);
+		unregister_sja1000dev(dev);
+		free_sja1000dev(dev);
+	}
+
+	writeb(EMS_CMD_UMAP, card->base_addr);
+
+	if (card->base_addr != NULL )
+		iounmap(card->base_addr);
+
+	kfree(card);
+
+	pdev->priv = NULL;
+}
+
+static void ems_pcmcia_card_reset(struct ems_pcmcia_card *card)
+{
+	/* Request board reset */
+	writeb(EMS_CMD_RESET, card->base_addr);
+}
+
+/*
+ * Probe PCI device for EMS CAN signature and register each available
+ * CAN channel to SJA1000 Socket-CAN subsystem.
+ */
+static int __devinit ems_pcmcia_add_card(struct pcmcia_device *pdev,
+					 unsigned long base)
+{
+	struct sja1000_priv *priv;
+	struct net_device *dev;
+	struct ems_pcmcia_card *card;
+	int err, i;
+
+	/* Allocating card structures to hold addresses, ... */
+	card = kzalloc(sizeof(struct ems_pcmcia_card), GFP_KERNEL);
+	if (card == NULL) {
+		printk(KERN_ERR "%s: unable to allocate memory\n", DRV_NAME);
+		return -ENOMEM;
+	}
+
+	pdev->priv = card;
+
+	card->channels = 0;
+
+	card->base_addr = ioremap(base, EMS_PCMCIA_MEM_SIZE);
+	if (card->base_addr == NULL) {
+		err = -ENOMEM;
+		goto failure_cleanup;
+	}
+
+	/* Check for unique EMS CAN signature */
+	if (readw(card->base_addr) != 0xAA55) {
+		printk(KERN_ERR "%s: No EMS CPC Card hardware found.\n",
+		       DRV_NAME);
+
+		err = -ENODEV;
+		goto failure_cleanup;
+	}
+
+	ems_pcmcia_card_reset(card);
+
+	/* Make sure CAN controllers are mapped into card's memory space */
+	writeb(EMS_CMD_MAP, card->base_addr);
+
+	/* Detect available channels */
+	for (i = 0; i < EMS_PCMCIA_MAX_CHAN; i++) {
+		dev = alloc_sja1000dev(0);
+		if (dev == NULL) {
+			err = -ENOMEM;
+			goto failure_cleanup;
+		}
+
+		card->net_dev[i] = dev;
+		priv = netdev_priv(dev);
+		priv->priv = card;
+		SET_NETDEV_DEV(dev, &pdev->dev);
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,18)
+		priv->irq_flags = SA_SHIRQ;
+#else
+		priv->irq_flags = IRQF_SHARED;
+#endif
+		dev->irq = pdev->irq.AssignedIRQ;
+		priv->reg_base = (card->base_addr
+					+ EMS_PCMCIA_CAN_BASE_OFFSET
+					+ (i * EMS_PCMCIA_CAN_CTRL_SIZE));
+
+		/* Check if channel is present */
+		if (ems_pcmcia_check_chan(priv)) {
+			priv->read_reg  = ems_pcmcia_read_reg;
+			priv->write_reg = ems_pcmcia_write_reg;
+			priv->can.clock.freq = EMS_PCMCIA_CAN_CLOCK;
+			priv->ocr = EMS_PCMCIA_OCR;
+			priv->cdr = EMS_PCMCIA_CDR;
+			priv->flags |= SJA1000_CUSTOM_IRQ_HANDLER;
+
+			/* Register SJA1000 device */
+			err = register_sja1000dev(dev);
+			if (err) {
+				printk(KERN_INFO "%s: registering device "
+				       "failed (err=%d)\n", DRV_NAME, err);
+				free_sja1000dev(dev);
+				goto failure_cleanup;
+			}
+
+			card->channels++;
+
+			printk(KERN_INFO "%s: registered %s on channel "
+			       "#%d at 0x%p, irq %d\n", DRV_NAME, dev->name,
+			       i, priv->reg_base, dev->irq);
+		} else {
+			free_sja1000dev(dev);
+		}
+	}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,18)
+	err = request_irq(dev->irq, &ems_pcmcia_interrupt, SA_SHIRQ,
+		DRV_NAME, (void *)card);
+#else
+	err = request_irq(dev->irq, &ems_pcmcia_interrupt, IRQF_SHARED,
+		DRV_NAME, (void *)card);
+#endif
+	if (err) {
+		printk(KERN_INFO "Registering device failed (err=%d)\n", err);
+
+		goto failure_cleanup;
+	}
+
+	return 0;
+
+failure_cleanup:
+	printk(KERN_ERR "Error: %d. Cleaning Up.\n", err);
+
+	ems_pcmcia_del_card(pdev);
+
+	return err;
+}
+
+/*
+ * Setup PCMCIA socket and probe for EMS CPC-CARD
+ */
+static int __devinit ems_pcmcia_probe(struct pcmcia_device *dev)
+{
+	/* The io structure describes IO port mapping */
+	dev->io.NumPorts1 = 16;
+	dev->io.Attributes1 = IO_DATA_PATH_WIDTH_8;
+	dev->io.NumPorts2 = 16;
+	dev->io.Attributes2 = IO_DATA_PATH_WIDTH_16;
+	dev->io.IOAddrLines = 5;
+
+	/* Interrupt setup */
+	dev->irq.Attributes = IRQ_TYPE_DYNAMIC_SHARING;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,33)
+	dev->irq.IRQInfo1 = IRQ_LEVEL_ID;
+#endif
+
+	/* General socket configuration */
+	dev->conf.Attributes = CONF_ENABLE_IRQ;
+	dev->conf.IntType = INT_MEMORY_AND_IO;
+	dev->conf.ConfigIndex = 1;
+	dev->conf.Present = PRESENT_OPTION;
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,33)
+	dev->win = NULL;
+#else
+	dev->win = 0;
+#endif
+
+	ems_pcmcia_config(dev);
+
+	return 0;
+}
+
+/*
+ * Configure PCMCIA socket
+ */
+static void __devinit ems_pcmcia_config(struct pcmcia_device *dev)
+{
+	win_req_t req;
+	memreq_t mem;
+
+	int csval;
+
+	/* Allocate a memory window */
+	req.Attributes = WIN_DATA_WIDTH_8|WIN_MEMORY_TYPE_CM|WIN_ENABLE;
+	req.Base = req.Size = 0;
+	req.AccessSpeed = 0;
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,33)
+	csval = pcmcia_request_window(&dev, &req, &dev->win);
+#else
+	csval = pcmcia_request_window(dev, &req, &dev->win);
+#endif
+	if (csval) {
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,33)
+		cs_error(dev, RequestWindow, csval);
+#else
+		dev_err(&dev->dev, "RequestWindow failed (err=%d)\n",
+			csval);
+#endif
+		return;
+	}
+
+	mem.CardOffset = mem.Page = 0;
+	mem.CardOffset = dev->conf.ConfigBase;
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,33)
+	csval = pcmcia_map_mem_page(dev->win, &mem);
+#else
+	csval = pcmcia_map_mem_page(dev, dev->win, &mem);
+#endif
+
+	if (csval) {
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,33)
+		cs_error(dev, MapMemPage, csval);
+#else
+		dev_err(&dev->dev, "MapMemPage failed (err=%d)\n",
+			csval);
+#endif
+		return;
+	}
+
+	csval = pcmcia_request_irq(dev, &dev->irq);
+	if (csval) {
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,33)
+		cs_error(dev, RequestIRQ, csval);
+#else
+		dev_err(&dev->dev, "RequestIRQ failed (err=%d)\n",
+			csval);
+#endif
+		return;
+	}
+
+	/* This actually configures the PCMCIA socket */
+	csval = pcmcia_request_configuration(dev, &dev->conf);
+	if (csval) {
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,33)
+		cs_error(dev, RequestConfiguration, csval);
+#else
+		dev_err(&dev->dev, "RequestConfig failed (err=%d)\n",
+			csval);
+#endif
+		return;
+	}
+
+	ems_pcmcia_add_card(dev, req.Base);
+}
+
+/*
+ * Release claimed resources
+ */
+static void ems_pcmcia_remove(struct pcmcia_device *dev)
+{
+	ems_pcmcia_del_card(dev);
+
+	pcmcia_disable_device(dev);
+}
+
+/*
+ * The dev_info variable is the "key" that is used to match up this
+ * device driver with appropriate cards, through the card configuration
+ * database.
+ */
+static dev_info_t dev_info = "can-ems-pcmcia";
+
+static struct pcmcia_driver ems_pcmcia_driver = {
+	.drv = {
+		.name = dev_info,
+		},
+
+	.probe = ems_pcmcia_probe,
+	.remove = ems_pcmcia_remove,
+
+	.id_table = ems_pcmcia_tbl,
+};
+
+static int __init ems_pcmcia_init(void)
+{
+	return pcmcia_register_driver(&ems_pcmcia_driver);
+}
+
+static void __exit ems_pcmcia_exit(void)
+{
+	pcmcia_unregister_driver(&ems_pcmcia_driver);
+}
+
+module_init(ems_pcmcia_init);
+module_exit(ems_pcmcia_exit);
+
diff --exclude CVS --exclude .git -uNr linux-2.6.27.8/drivers/net/can/sja1000/esd_pci.c linux-2.6.27.8.modified/drivers/net/can/sja1000/esd_pci.c
--- linux-2.6.27.8/drivers/net/can/sja1000/esd_pci.c	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.27.8.modified/drivers/net/can/sja1000/esd_pci.c	2013-05-30 03:44:18.000000000 -0400
@@ -0,0 +1,333 @@
+/*
+ * Copyright (C) 2007 Wolfgang Grandegger <wg@grandegger.com>
+ * Copyright (C) 2008 Sascha Hauer <s.hauer@pengutronix.de>, Pengutronix
+ * Copyright (C) 2009 Matthias Fuchs <matthias.fuchs@esd.eu>, esd gmbh
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the version 2 of the GNU General Public License
+ * as published by the Free Software Foundation
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include <linux/kernel.h>
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/interrupt.h>
+#include <linux/netdevice.h>
+#include <linux/delay.h>
+#include <linux/pci.h>
+#include <linux/pci_ids.h>
+#include <socketcan/can.h>
+#include <socketcan/can/dev.h>
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,16)
+#include <linux/io.h>
+#else
+#include <asm/io.h>
+#endif
+
+#include "sja1000.h"
+
+#define DRV_NAME  "esd_pci"
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,21)
+#error This driver does not support Kernel versions < 2.6.21
+#endif
+
+MODULE_AUTHOR("Matthias Fuchs <matthias.fuchs@esd.eu");
+MODULE_DESCRIPTION("Socket-CAN driver for esd PCI/PMC/CPCI/PCIe/PCI104 " \
+		   "CAN cards");
+MODULE_SUPPORTED_DEVICE("esd CAN-PCI/200, CAN-PCI/266, CAN-PMC266, " \
+			"CAN-PCIe/2000, CAN-CPCI/200, CAN-PCI104");
+MODULE_LICENSE("GPL v2");
+
+/* Maximum number of interfaces supported on one card. */
+#define ESD_PCI_MAX_CAN 2
+
+struct esd_pci {
+	struct pci_dev *pci_dev;
+	struct net_device *dev[ESD_PCI_MAX_CAN];
+	void __iomem *conf_addr;
+	void __iomem *base_addr;
+};
+
+#define ESD_PCI_CAN_CLOCK	(16000000 / 2)
+
+#define ESD_PCI_OCR		(OCR_TX0_PUSHPULL | OCR_TX1_PUSHPULL)
+#define ESD_PCI_CDR		0
+
+#define CHANNEL_OFFSET		0x100
+
+#define INTCSR_OFFSET		0x4c /* Offset in PLX9050 conf registers */
+#define INTCSR_LINTI1		(1 << 0)
+#define INTCSR_PCI		(1 << 6)
+
+#define INTCSR9056_OFFSET	0x68 /* Offset in PLX9056 conf registers */
+#define INTCSR9056_LINTI	(1 << 11)
+#define INTCSR9056_PCI		(1 << 8)
+
+#ifndef PCI_DEVICE_ID_PLX_9056
+# define PCI_DEVICE_ID_PLX_9056 0x9056
+#endif
+
+/* PCI subsystem IDs of esd's SJA1000 based CAN cards */
+
+/* CAN-PCI/200: PCI, 33MHz only, bridge: PLX9050 */
+#define ESD_PCI_SUB_SYS_ID_PCI200	0x0004
+
+/* CAN-PCI/266: PCI, 33/66MHz, bridge: PLX9056 */
+#define ESD_PCI_SUB_SYS_ID_PCI266	0x0009
+
+/* CAN-PMC/266: PMC module, 33/66MHz, bridge: PLX9056 */
+#define ESD_PCI_SUB_SYS_ID_PMC266	0x000e
+
+/* CAN-CPCI/200: Compact PCI, 33MHz only, bridge: PLX9030 */
+#define ESD_PCI_SUB_SYS_ID_CPCI200	0x010b
+
+/* CAN-PCIE/2000: PCI Express 1x, bridge: PEX8311 = PEX8111 + PLX9056 */
+#define ESD_PCI_SUB_SYS_ID_PCIE2000	0x0200
+
+/* CAN-PCI/104: PCI104 module, 33MHz only, bridge: PLX9030 */
+#define ESD_PCI_SUB_SYS_ID_PCI104200	0x0501
+
+static struct pci_device_id esd_pci_tbl[] = {
+	{PCI_VENDOR_ID_PLX, PCI_DEVICE_ID_PLX_9050,
+	 PCI_VENDOR_ID_ESDGMBH, ESD_PCI_SUB_SYS_ID_PCI200},
+	{PCI_VENDOR_ID_PLX, PCI_DEVICE_ID_PLX_9056,
+	 PCI_VENDOR_ID_ESDGMBH, ESD_PCI_SUB_SYS_ID_PCI266},
+	{PCI_VENDOR_ID_PLX, PCI_DEVICE_ID_PLX_9056,
+	 PCI_VENDOR_ID_ESDGMBH, ESD_PCI_SUB_SYS_ID_PMC266},
+	{PCI_VENDOR_ID_PLX, PCI_DEVICE_ID_PLX_9030,
+	 PCI_VENDOR_ID_ESDGMBH, ESD_PCI_SUB_SYS_ID_CPCI200},
+	{PCI_VENDOR_ID_PLX, PCI_DEVICE_ID_PLX_9056,
+	 PCI_VENDOR_ID_ESDGMBH, ESD_PCI_SUB_SYS_ID_PCIE2000},
+	{PCI_VENDOR_ID_PLX, PCI_DEVICE_ID_PLX_9030,
+	 PCI_VENDOR_ID_ESDGMBH, ESD_PCI_SUB_SYS_ID_PCI104200},
+	{0,}
+};
+
+#define ESD_PCI_BASE_SIZE  0x200
+
+MODULE_DEVICE_TABLE(pci, esd_pci_tbl);
+
+static u8 esd_pci_read_reg(const struct sja1000_priv *priv, int port)
+{
+	return readb(priv->reg_base + port);
+}
+
+static void esd_pci_write_reg(const struct sja1000_priv *priv, int port, u8 val)
+{
+	writeb(val, priv->reg_base + port);
+}
+
+static void esd_pci_del_chan(struct pci_dev *pdev, struct net_device *ndev)
+{
+	dev_info(&pdev->dev, "Removing device %s\n", ndev->name);
+
+	unregister_sja1000dev(ndev);
+
+	free_sja1000dev(ndev);
+}
+
+static struct net_device * __devinit esd_pci_add_chan(struct pci_dev *pdev,
+						      void __iomem *base_addr)
+{
+	struct net_device *ndev;
+	struct sja1000_priv *priv;
+	int err;
+
+	ndev = alloc_sja1000dev(0);
+	if (ndev == NULL)
+		return ERR_PTR(-ENOMEM);
+
+	priv = netdev_priv(ndev);
+
+	priv->reg_base = base_addr;
+
+	priv->read_reg = esd_pci_read_reg;
+	priv->write_reg = esd_pci_write_reg;
+
+	priv->can.clock.freq = ESD_PCI_CAN_CLOCK;
+
+	priv->ocr = ESD_PCI_OCR;
+	priv->cdr = ESD_PCI_CDR;
+
+	/* Set and enable PCI interrupts */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,18)
+	priv->irq_flags = SA_SHIRQ;
+#else
+	priv->irq_flags = IRQF_SHARED;
+#endif
+	ndev->irq = pdev->irq;
+
+	dev_dbg(&pdev->dev, "reg_base=0x%p irq=%d\n",
+			priv->reg_base, ndev->irq);
+
+	SET_NETDEV_DEV(ndev, &pdev->dev);
+
+	err = register_sja1000dev(ndev);
+	if (err) {
+		dev_err(&pdev->dev, "Failed to register (err=%d)\n", err);
+		goto failure;
+	}
+
+	return ndev;
+
+failure:
+	free_sja1000dev(ndev);
+	return ERR_PTR(err);
+}
+
+static int __devinit esd_pci_init_one(struct pci_dev *pdev,
+				       const struct pci_device_id *ent)
+{
+	struct esd_pci *board;
+	int err;
+	void __iomem *base_addr;
+	void __iomem *conf_addr;
+
+	dev_info(&pdev->dev,
+		 "Initializing device %04x:%04x %04x:%04x\n",
+		 pdev->vendor, pdev->device,
+		 pdev->subsystem_vendor, pdev->subsystem_device);
+
+	board = kzalloc(sizeof(*board), GFP_KERNEL);
+	if (!board)
+		return -ENOMEM;
+
+	err = pci_enable_device(pdev);
+	if (err)
+		goto failure;
+
+	err = pci_request_regions(pdev, DRV_NAME);
+	if (err)
+		goto failure;
+
+	conf_addr = pci_iomap(pdev, 0, ESD_PCI_BASE_SIZE);
+	if (conf_addr == NULL) {
+		err = -ENODEV;
+		goto failure_release_pci;
+	}
+
+	board->conf_addr = conf_addr;
+
+	base_addr = pci_iomap(pdev, 2, ESD_PCI_BASE_SIZE);
+	if (base_addr == NULL) {
+		err = -ENODEV;
+		goto failure_iounmap_conf;
+	}
+
+	board->base_addr = base_addr;
+
+	board->dev[0] = esd_pci_add_chan(pdev, base_addr);
+	if (IS_ERR(board->dev[0]))
+		goto failure_iounmap_base;
+
+	/* Check if second channel is available */
+	writeb(MOD_RM, base_addr + CHANNEL_OFFSET + REG_MOD);
+	writeb(CDR_CBP, base_addr + CHANNEL_OFFSET + REG_CDR);
+	writeb(MOD_RM, base_addr + CHANNEL_OFFSET + REG_MOD);
+	if (readb(base_addr + CHANNEL_OFFSET + REG_MOD) == 0x21) {
+		writeb(MOD_SM | MOD_AFM | MOD_STM | MOD_LOM | MOD_RM,
+		       base_addr + CHANNEL_OFFSET + REG_MOD);
+		if (readb(base_addr + CHANNEL_OFFSET + REG_MOD) == 0x3f) {
+			writeb(MOD_RM, base_addr + CHANNEL_OFFSET + REG_MOD);
+			board->dev[1] =
+				esd_pci_add_chan(pdev,
+						 base_addr + CHANNEL_OFFSET);
+			if (IS_ERR(board->dev[1]))
+				goto failure_unreg_dev0;
+		} else
+			writeb(MOD_RM, base_addr + CHANNEL_OFFSET + REG_MOD);
+	} else
+		writeb(MOD_RM, base_addr + CHANNEL_OFFSET + REG_MOD);
+
+	if ((pdev->device == PCI_DEVICE_ID_PLX_9050) ||
+	    (pdev->device == PCI_DEVICE_ID_PLX_9030)) {
+		/* Enable interrupts in PLX9050 */
+		writel(INTCSR_LINTI1 | INTCSR_PCI,
+		       board->conf_addr + INTCSR_OFFSET);
+	} else {
+		/* Enable interrupts in PLX9056*/
+		writel(INTCSR9056_LINTI | INTCSR9056_PCI,
+		       board->conf_addr + INTCSR9056_OFFSET);
+	}
+
+	pci_set_drvdata(pdev, board);
+
+	return 0;
+
+failure_unreg_dev0:
+	esd_pci_del_chan(pdev, board->dev[0]);
+
+failure_iounmap_base:
+	pci_iounmap(pdev, board->base_addr);
+
+failure_iounmap_conf:
+	pci_iounmap(pdev, board->conf_addr);
+
+failure_release_pci:
+	pci_release_regions(pdev);
+
+failure:
+	kfree(board);
+
+	return err;
+}
+
+static void __devexit esd_pci_remove_one(struct pci_dev *pdev)
+{
+	struct esd_pci *board = pci_get_drvdata(pdev);
+	int i;
+
+	if ((pdev->device == PCI_DEVICE_ID_PLX_9050) ||
+	    (pdev->device == PCI_DEVICE_ID_PLX_9030)) {
+		/* Disable interrupts in PLX9050*/
+		writel(0, board->conf_addr + INTCSR_OFFSET);
+	} else {
+		/* Disable interrupts in PLX9056*/
+		writel(0, board->conf_addr + INTCSR9056_OFFSET);
+	}
+
+	for (i = 0; i < ESD_PCI_MAX_CAN; i++) {
+		if (!board->dev[i])
+			break;
+		esd_pci_del_chan(pdev, board->dev[i]);
+	}
+
+	pci_iounmap(pdev, board->base_addr);
+	pci_iounmap(pdev, board->conf_addr);
+
+	pci_release_regions(pdev);
+	pci_disable_device(pdev);
+	pci_set_drvdata(pdev, NULL);
+
+	kfree(board);
+}
+
+static struct pci_driver esd_pci_driver = {
+	.name = DRV_NAME,
+	.id_table = esd_pci_tbl,
+	.probe = esd_pci_init_one,
+	.remove = __devexit_p(esd_pci_remove_one),
+};
+
+static int __init esd_pci_init(void)
+{
+	return pci_register_driver(&esd_pci_driver);
+}
+
+static void __exit esd_pci_exit(void)
+{
+	pci_unregister_driver(&esd_pci_driver);
+}
+
+module_init(esd_pci_init);
+module_exit(esd_pci_exit);
diff --exclude CVS --exclude .git -uNr linux-2.6.27.8/drivers/net/can/sja1000/ixxat_pci.c linux-2.6.27.8.modified/drivers/net/can/sja1000/ixxat_pci.c
--- linux-2.6.27.8/drivers/net/can/sja1000/ixxat_pci.c	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.27.8.modified/drivers/net/can/sja1000/ixxat_pci.c	2013-05-30 03:44:18.000000000 -0400
@@ -0,0 +1,290 @@
+/*
+ * Copyright (C) 2007 Wolfgang Grandegger <wg@grandegger.com>
+ * Copyright (C) 2008 Sascha Hauer <s.hauer@pengutronix.de>, Pengutronix
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the version 2 of the GNU General Public License
+ * as published by the Free Software Foundation
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include <linux/kernel.h>
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/interrupt.h>
+#include <linux/netdevice.h>
+#include <linux/delay.h>
+#include <linux/pci.h>
+#include <socketcan/can.h>
+#include <socketcan/can/dev.h>
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,16)
+#include <linux/io.h>
+#else
+#include <asm/io.h>
+#endif
+
+#include "sja1000.h"
+
+#define DRV_NAME  "ixxat_pci"
+
+MODULE_AUTHOR("Sascha Hauer <s.hauer@pengutronix.de");
+MODULE_DESCRIPTION("Socket-CAN driver for IXXAT PC-I 04/PCI PCI cards");
+MODULE_SUPPORTED_DEVICE("IXXAT PC-I 04/PCI card");
+MODULE_LICENSE("GPL v2");
+
+/* Maximum number of interfaces supported on one card. Currently
+ * we only support a maximum of two interfaces, which is the maximum
+ * of what Ixxat sells anyway.
+ */
+#define IXXAT_PCI_MAX_CAN 2
+
+struct ixxat_pci {
+	struct pci_dev *pci_dev;
+	struct net_device *dev[IXXAT_PCI_MAX_CAN];
+	int conf_addr;
+	void __iomem *base_addr;
+};
+
+#define IXXAT_PCI_CAN_CLOCK  (16000000 / 2)
+
+#define IXXAT_PCI_OCR	     (OCR_TX0_PUSHPULL | OCR_TX0_INVERT | \
+			      OCR_TX1_PUSHPULL)
+#define IXXAT_PCI_CDR	     0
+
+#define CHANNEL_RESET_OFFSET 0x110
+#define CHANNEL_OFFSET      0x200
+
+#define INTCSR_OFFSET        0x4c /* Offset in PLX9050 conf registers */
+#define INTCSR_LINTI1        (1 << 0)
+#define INTCSR_LINTI2        (1 << 3)
+#define INTCSR_PCI           (1 << 6)
+
+/* PCI vender, device and sub-device ID */
+#define IXXAT_PCI_VENDOR_ID  0x10b5
+#define IXXAT_PCI_DEVICE_ID  0x9050
+#define IXXAT_PCI_SUB_SYS_ID 0x2540
+
+#define IXXAT_PCI_BASE_SIZE  0x400
+
+static struct pci_device_id ixxat_pci_tbl[] = {
+	{IXXAT_PCI_VENDOR_ID, IXXAT_PCI_DEVICE_ID, PCI_ANY_ID, PCI_ANY_ID,},
+	{0,}
+};
+
+MODULE_DEVICE_TABLE(pci, ixxat_pci_tbl);
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,14)
+static inline void *kzalloc(size_t size, unsigned int __nocast flags)
+{
+	void *ret = kmalloc(size, flags);
+	if (ret)
+		memset(ret, 0, size);
+	return ret;
+}
+#endif
+
+static u8 ixxat_pci_read_reg(const struct sja1000_priv *priv, int port)
+{
+	return readb(priv->reg_base + port);
+}
+
+static void ixxat_pci_write_reg(const struct sja1000_priv *priv,
+				int port, u8 val)
+{
+	writeb(val, priv->reg_base + port);
+}
+
+static void ixxat_pci_del_chan(struct pci_dev *pdev, struct net_device *ndev)
+{
+	dev_info(&pdev->dev, "Removing device %s\n", ndev->name);
+
+	unregister_sja1000dev(ndev);
+
+	free_sja1000dev(ndev);
+}
+
+static struct net_device *ixxat_pci_add_chan(struct pci_dev *pdev,
+		void __iomem *base_addr)
+{
+	struct net_device *ndev;
+	struct sja1000_priv *priv;
+	int err;
+
+	ndev = alloc_sja1000dev(0);
+	if (ndev == NULL)
+		return ERR_PTR(-ENOMEM);
+
+	priv = netdev_priv(ndev);
+
+	priv->reg_base = base_addr;
+
+	priv->read_reg = ixxat_pci_read_reg;
+	priv->write_reg = ixxat_pci_write_reg;
+
+	priv->can.clock.freq = IXXAT_PCI_CAN_CLOCK;
+
+	priv->ocr = IXXAT_PCI_OCR;
+	priv->cdr = IXXAT_PCI_CDR;
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,18)
+	priv->irq_flags = SA_SHIRQ;
+#else
+	priv->irq_flags = IRQF_SHARED;
+#endif
+	ndev->irq = pdev->irq;
+
+	dev_dbg(&pdev->dev, "reg_base=0x%p irq=%d\n",
+			priv->reg_base, ndev->irq);
+
+	SET_NETDEV_DEV(ndev, &pdev->dev);
+
+	err = register_sja1000dev(ndev);
+	if (err) {
+		dev_err(&pdev->dev, "Failed to register (err=%d)\n", err);
+		goto failure;
+	}
+
+	return ndev;
+
+failure:
+	free_sja1000dev(ndev);
+	return ERR_PTR(err);
+}
+
+static int __devinit ixxat_pci_init_one(struct pci_dev *pdev,
+				       const struct pci_device_id *ent)
+{
+	struct ixxat_pci *board;
+	int err, intcsr = INTCSR_LINTI1 | INTCSR_PCI;
+	u16 sub_sys_id;
+	void __iomem *base_addr;
+
+	dev_info(&pdev->dev, "Initializing device %04x:%04x\n",
+	       pdev->vendor, pdev->device);
+
+	board = kzalloc(sizeof(*board), GFP_KERNEL);
+	if (!board)
+		return -ENOMEM;
+
+	err = pci_enable_device(pdev);
+	if (err)
+		goto failure;
+
+	err = pci_request_regions(pdev, DRV_NAME);
+	if (err)
+		goto failure;
+
+	err = pci_read_config_word(pdev, 0x2e, &sub_sys_id);
+	if (err)
+		goto failure_release_pci;
+
+	if (sub_sys_id != IXXAT_PCI_SUB_SYS_ID)
+		return -ENODEV;
+
+	/* Enable memory and I/O space */
+	err = pci_write_config_word(pdev, 0x04, 0x3);
+	if (err)
+		goto failure_release_pci;
+
+	board->conf_addr = pci_resource_start(pdev, 1);
+
+	base_addr = pci_iomap(pdev, 2, IXXAT_PCI_BASE_SIZE);
+	if (base_addr == NULL) {
+		err = -ENODEV;
+		goto failure_release_pci;
+	}
+
+	board->base_addr = base_addr;
+
+	writeb(0x1, base_addr + CHANNEL_RESET_OFFSET);
+	writeb(0x1, base_addr + CHANNEL_OFFSET + CHANNEL_RESET_OFFSET);
+	udelay(100);
+
+	board->dev[0] = ixxat_pci_add_chan(pdev, base_addr);
+	if (IS_ERR(board->dev[0]))
+		goto failure_iounmap;
+
+	/* Check if second channel is available */
+	if ((readb(base_addr + CHANNEL_OFFSET + REG_MOD) & 0xa1) == 0x21 &&
+	    readb(base_addr + CHANNEL_OFFSET + REG_SR) == 0x0c &&
+	    readb(base_addr + CHANNEL_OFFSET + REG_IR) == 0xe0) {
+		board->dev[1] = ixxat_pci_add_chan(pdev,
+				base_addr + CHANNEL_OFFSET);
+		if (IS_ERR(board->dev[1]))
+			goto failure_unreg_dev0;
+
+		intcsr |= INTCSR_LINTI2;
+	}
+
+	/* enable interrupt(s) in PLX9050 */
+	outb(intcsr, board->conf_addr + INTCSR_OFFSET);
+
+	pci_set_drvdata(pdev, board);
+
+	return 0;
+
+failure_unreg_dev0:
+	ixxat_pci_del_chan(pdev, board->dev[0]);
+
+failure_iounmap:
+	pci_iounmap(pdev, board->base_addr);
+
+failure_release_pci:
+	pci_release_regions(pdev);
+
+failure:
+	kfree(board);
+
+	return err;
+}
+
+static void __devexit ixxat_pci_remove_one(struct pci_dev *pdev)
+{
+	struct ixxat_pci *board = pci_get_drvdata(pdev);
+	int i;
+
+	/* Disable interrupts in PLX9050*/
+	outb(0, board->conf_addr + INTCSR_OFFSET);
+
+	for (i = 0; i < IXXAT_PCI_MAX_CAN; i++) {
+		if (!board->dev[i])
+			break;
+		ixxat_pci_del_chan(pdev, board->dev[i]);
+	}
+
+	pci_iounmap(pdev, board->base_addr);
+
+	pci_release_regions(pdev);
+	pci_disable_device(pdev);
+	pci_set_drvdata(pdev, NULL);
+
+	kfree(board);
+}
+
+static struct pci_driver ixxat_pci_driver = {
+	.name = DRV_NAME,
+	.id_table = ixxat_pci_tbl,
+	.probe = ixxat_pci_init_one,
+	.remove = __devexit_p(ixxat_pci_remove_one),
+};
+
+static int __init ixxat_pci_init(void)
+{
+	return pci_register_driver(&ixxat_pci_driver);
+}
+
+static void __exit ixxat_pci_exit(void)
+{
+	pci_unregister_driver(&ixxat_pci_driver);
+}
+
+module_init(ixxat_pci_init);
+module_exit(ixxat_pci_exit);
diff --exclude CVS --exclude .git -uNr linux-2.6.27.8/drivers/net/can/sja1000/kvaser_pci.c linux-2.6.27.8.modified/drivers/net/can/sja1000/kvaser_pci.c
--- linux-2.6.27.8/drivers/net/can/sja1000/kvaser_pci.c	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.27.8.modified/drivers/net/can/sja1000/kvaser_pci.c	2013-05-30 03:44:18.000000000 -0400
@@ -0,0 +1,425 @@
+/*
+ * Copyright (C) 2008 Per Dalen <per.dalen@cnw.se>
+ *
+ * Parts of this software are based on (derived) the following:
+ *
+ * - Kvaser linux driver, version 4.72 BETA
+ *   Copyright (C) 2002-2007 KVASER AB
+ *
+ * - Lincan driver, version 0.3.3, OCERA project
+ *   Copyright (C) 2004 Pavel Pisa
+ *   Copyright (C) 2001 Arnaud Westenberg
+ *
+ * - Socketcan SJA1000 drivers
+ *   Copyright (C) 2007 Wolfgang Grandegger <wg@grandegger.com>
+ *   Copyright (c) 2002-2007 Volkswagen Group Electronic Research
+ *   Copyright (c) 2003 Matthias Brukner, Trajet Gmbh, Rebenring 33,
+ *   38106 Braunschweig, GERMANY
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the version 2 of the GNU General Public License
+ * as published by the Free Software Foundation
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include <linux/kernel.h>
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/interrupt.h>
+#include <linux/netdevice.h>
+#include <linux/delay.h>
+#include <linux/pci.h>
+#include <socketcan/can.h>
+#include <socketcan/can/dev.h>
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,16)
+#include <linux/io.h>
+#else
+#include <asm/io.h>
+#endif
+
+#include "sja1000.h"
+
+#define DRV_NAME  "kvaser_pci"
+
+MODULE_AUTHOR("Per Dalen <per.dalen@cnw.se>");
+MODULE_DESCRIPTION("Socket-CAN driver for KVASER PCAN PCI cards");
+MODULE_SUPPORTED_DEVICE("KVASER PCAN PCI CAN card");
+MODULE_LICENSE("GPL v2");
+
+#define MAX_NO_OF_CHANNELS        4 /* max no of channels on a single card */
+
+struct kvaser_pci {
+	int channel;
+	struct pci_dev *pci_dev;
+	struct net_device *slave_dev[MAX_NO_OF_CHANNELS-1];
+	void __iomem *conf_addr;
+	void __iomem *res_addr;
+	int no_channels;
+	u8 xilinx_ver;
+};
+
+#define KVASER_PCI_CAN_CLOCK      (16000000 / 2)
+
+/*
+ * The board configuration is probably following:
+ * RX1 is connected to ground.
+ * TX1 is not connected.
+ * CLKO is not connected.
+ * Setting the OCR register to 0xDA is a good idea.
+ * This means  normal output mode , push-pull and the correct polarity.
+ */
+#define KVASER_PCI_OCR            (OCR_TX0_PUSHPULL | OCR_TX1_PUSHPULL)
+
+/*
+ * In the CDR register, you should set CBP to 1.
+ * You will probably also want to set the clock divider value to 0
+ * (meaning divide-by-2), the Pelican bit, and the clock-off bit
+ * (you will have no need for CLKOUT anyway).
+ */
+#define KVASER_PCI_CDR            (CDR_CBP | CDR_CLKOUT_MASK)
+
+/*
+ * These register values are valid for revision 14 of the Xilinx logic.
+ */
+#define XILINX_VERINT             7   /* Lower nibble simulate interrupts,
+					 high nibble version number. */
+
+#define XILINX_PRESUMED_VERSION   14
+
+/*
+ * Important S5920 registers
+ */
+#define S5920_INTCSR              0x38
+#define S5920_PTCR                0x60
+#define INTCSR_ADDON_INTENABLE_M  0x2000
+
+
+#define KVASER_PCI_PORT_BYTES     0x20
+
+#define PCI_CONFIG_PORT_SIZE      0x80      /* size of the config io-memory */
+#define PCI_PORT_SIZE             0x80      /* size of a channel io-memory */
+#define PCI_PORT_XILINX_SIZE      0x08      /* size of a xilinx io-memory */
+
+#define KVASER_PCI_VENDOR_ID1     0x10e8    /* the PCI device and vendor IDs */
+#define KVASER_PCI_DEVICE_ID1     0x8406
+
+#define KVASER_PCI_VENDOR_ID2     0x1a07    /* the PCI device and vendor IDs */
+#define KVASER_PCI_DEVICE_ID2     0x0008
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,25)
+static struct pci_device_id kvaser_pci_tbl[] = {
+#else
+static DEFINE_PCI_DEVICE_TABLE(kvaser_pci_tbl) = {
+#endif
+	{KVASER_PCI_VENDOR_ID1, KVASER_PCI_DEVICE_ID1, PCI_ANY_ID, PCI_ANY_ID,},
+	{KVASER_PCI_VENDOR_ID2, KVASER_PCI_DEVICE_ID2, PCI_ANY_ID, PCI_ANY_ID,},
+	{ 0,}
+};
+
+MODULE_DEVICE_TABLE(pci, kvaser_pci_tbl);
+
+static u8 kvaser_pci_read_reg(const struct sja1000_priv *priv, int port)
+{
+	return ioread8(priv->reg_base + port);
+}
+
+static void kvaser_pci_write_reg(const struct sja1000_priv *priv,
+				 int port, u8 val)
+{
+	iowrite8(val, priv->reg_base + port);
+}
+
+static void kvaser_pci_disable_irq(struct net_device *dev)
+{
+	struct sja1000_priv *priv = netdev_priv(dev);
+	struct kvaser_pci *board = priv->priv;
+	u32 intcsr;
+
+	/* Disable interrupts from card */
+	intcsr = ioread32(board->conf_addr + S5920_INTCSR);
+	intcsr &= ~INTCSR_ADDON_INTENABLE_M;
+	iowrite32(intcsr, board->conf_addr + S5920_INTCSR);
+}
+
+static void kvaser_pci_enable_irq(struct net_device *dev)
+{
+	struct sja1000_priv *priv = netdev_priv(dev);
+	struct kvaser_pci *board = priv->priv;
+	u32 tmp_en_io;
+
+	/* Enable interrupts from card */
+	tmp_en_io = ioread32(board->conf_addr + S5920_INTCSR);
+	tmp_en_io |= INTCSR_ADDON_INTENABLE_M;
+	iowrite32(tmp_en_io, board->conf_addr + S5920_INTCSR);
+}
+
+static int number_of_sja1000_chip(void __iomem *base_addr)
+{
+	u8 status;
+	int i;
+
+	for (i = 0; i < MAX_NO_OF_CHANNELS; i++) {
+		/* reset chip */
+		iowrite8(MOD_RM, base_addr +
+			 (i * KVASER_PCI_PORT_BYTES) + REG_MOD);
+		status = ioread8(base_addr +
+				 (i * KVASER_PCI_PORT_BYTES) + REG_MOD);
+		/* check reset bit */
+		if (!(status & MOD_RM))
+			break;
+	}
+
+	return i;
+}
+
+static void kvaser_pci_del_chan(struct net_device *dev)
+{
+	struct sja1000_priv *priv;
+	struct kvaser_pci *board;
+	int i;
+
+	if (!dev)
+		return;
+	priv = netdev_priv(dev);
+	board = priv->priv;
+	if (!board)
+		return;
+
+	dev_info(&board->pci_dev->dev, "Removing device %s\n",
+		 dev->name);
+
+	/* Disable PCI interrupts */
+	kvaser_pci_disable_irq(dev);
+
+	for (i = 0; i < board->no_channels - 1; i++) {
+		if (board->slave_dev[i]) {
+			dev_info(&board->pci_dev->dev, "Removing device %s\n",
+				 board->slave_dev[i]->name);
+			unregister_sja1000dev(board->slave_dev[i]);
+			free_sja1000dev(board->slave_dev[i]);
+		}
+	}
+	unregister_sja1000dev(dev);
+
+	pci_iounmap(board->pci_dev, priv->reg_base);
+	pci_iounmap(board->pci_dev, board->conf_addr);
+	pci_iounmap(board->pci_dev, board->res_addr);
+
+	free_sja1000dev(dev);
+}
+
+static int kvaser_pci_add_chan(struct pci_dev *pdev, int channel,
+			       struct net_device **master_dev,
+			       void __iomem *conf_addr,
+			       void __iomem *res_addr,
+			       void __iomem *base_addr)
+{
+	struct net_device *dev;
+	struct sja1000_priv *priv;
+	struct kvaser_pci *board;
+	int err, init_step;
+
+	dev = alloc_sja1000dev(sizeof(struct kvaser_pci));
+	if (dev == NULL)
+		return -ENOMEM;
+
+	priv = netdev_priv(dev);
+	board = priv->priv;
+
+	board->pci_dev = pdev;
+	board->channel = channel;
+
+	/* S5920 */
+	board->conf_addr = conf_addr;
+
+	/* XILINX board wide address */
+	board->res_addr = res_addr;
+
+	if (channel == 0) {
+		board->xilinx_ver =
+			ioread8(board->res_addr + XILINX_VERINT) >> 4;
+		init_step = 2;
+
+		/* Assert PTADR# - we're in passive mode so the other bits are
+		   not important */
+		iowrite32(0x80808080UL, board->conf_addr + S5920_PTCR);
+
+		/* Enable interrupts from card */
+		kvaser_pci_enable_irq(dev);
+	} else {
+		struct sja1000_priv *master_priv = netdev_priv(*master_dev);
+		struct kvaser_pci *master_board = master_priv->priv;
+		master_board->slave_dev[channel - 1] = dev;
+		master_board->no_channels = channel + 1;
+		board->xilinx_ver = master_board->xilinx_ver;
+	}
+
+	priv->reg_base = base_addr + channel * KVASER_PCI_PORT_BYTES;
+
+	priv->read_reg = kvaser_pci_read_reg;
+	priv->write_reg = kvaser_pci_write_reg;
+
+	priv->can.clock.freq = KVASER_PCI_CAN_CLOCK;
+
+	priv->ocr = KVASER_PCI_OCR;
+	priv->cdr = KVASER_PCI_CDR;
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,18)
+	priv->irq_flags = SA_SHIRQ;
+#else
+	priv->irq_flags = IRQF_SHARED;
+#endif
+	dev->irq = pdev->irq;
+
+	init_step = 4;
+
+	dev_info(&pdev->dev, "reg_base=%p conf_addr=%p irq=%d\n",
+		 priv->reg_base, board->conf_addr, dev->irq);
+
+	SET_NETDEV_DEV(dev, &pdev->dev);
+
+	/* Register SJA1000 device */
+	err = register_sja1000dev(dev);
+	if (err) {
+		dev_err(&pdev->dev, "Registering device failed (err=%d)\n",
+			err);
+		goto failure;
+	}
+
+	if (channel == 0)
+		*master_dev = dev;
+
+	return 0;
+
+failure:
+	kvaser_pci_del_chan(dev);
+	return err;
+}
+
+static int __devinit kvaser_pci_init_one(struct pci_dev *pdev,
+					 const struct pci_device_id *ent)
+{
+	int err;
+	struct net_device *master_dev = NULL;
+	struct sja1000_priv *priv;
+	struct kvaser_pci *board;
+	int no_channels;
+	void __iomem *base_addr = NULL;
+	void __iomem *conf_addr = NULL;
+	void __iomem *res_addr = NULL;
+	int i;
+
+	dev_info(&pdev->dev, "initializing device %04x:%04x\n",
+		 pdev->vendor, pdev->device);
+
+	err = pci_enable_device(pdev);
+	if (err)
+		goto failure;
+
+	err = pci_request_regions(pdev, DRV_NAME);
+	if (err)
+		goto failure_release_pci;
+
+	/* S5920 */
+	conf_addr = pci_iomap(pdev, 0, PCI_CONFIG_PORT_SIZE);
+	if (conf_addr == NULL) {
+		err = -ENODEV;
+		goto failure_release_regions;
+	}
+
+	/* XILINX board wide address */
+	res_addr = pci_iomap(pdev, 2, PCI_PORT_XILINX_SIZE);
+	if (res_addr == NULL) {
+		err = -ENOMEM;
+		goto failure_iounmap;
+	}
+
+	base_addr = pci_iomap(pdev, 1, PCI_PORT_SIZE);
+	if (base_addr == NULL) {
+		err = -ENOMEM;
+		goto failure_iounmap;
+	}
+
+	no_channels = number_of_sja1000_chip(base_addr);
+	if (no_channels == 0) {
+		err = -ENOMEM;
+		goto failure_iounmap;
+	}
+
+	for (i = 0; i < no_channels; i++) {
+		err = kvaser_pci_add_chan(pdev, i, &master_dev,
+					  conf_addr, res_addr,
+					  base_addr);
+		if (err)
+			goto failure_cleanup;
+	}
+
+	priv = netdev_priv(master_dev);
+	board = priv->priv;
+
+	dev_info(&pdev->dev, "xilinx version=%d number of channels=%d\n",
+		 board->xilinx_ver, board->no_channels);
+
+	pci_set_drvdata(pdev, master_dev);
+	return 0;
+
+failure_cleanup:
+	kvaser_pci_del_chan(master_dev);
+
+failure_iounmap:
+	if (conf_addr != NULL)
+		pci_iounmap(pdev, conf_addr);
+	if (res_addr != NULL)
+		pci_iounmap(pdev, res_addr);
+	if (base_addr != NULL)
+		pci_iounmap(pdev, base_addr);
+
+failure_release_regions:
+	pci_release_regions(pdev);
+
+failure_release_pci:
+	pci_disable_device(pdev);
+
+failure:
+	return err;
+
+}
+
+static void __devexit kvaser_pci_remove_one(struct pci_dev *pdev)
+{
+	struct net_device *dev = pci_get_drvdata(pdev);
+
+	kvaser_pci_del_chan(dev);
+
+	pci_release_regions(pdev);
+	pci_disable_device(pdev);
+	pci_set_drvdata(pdev, NULL);
+}
+
+static struct pci_driver kvaser_pci_driver = {
+	.name = DRV_NAME,
+	.id_table = kvaser_pci_tbl,
+	.probe = kvaser_pci_init_one,
+	.remove = __devexit_p(kvaser_pci_remove_one),
+};
+
+static int __init kvaser_pci_init(void)
+{
+	return pci_register_driver(&kvaser_pci_driver);
+}
+
+static void __exit kvaser_pci_exit(void)
+{
+	pci_unregister_driver(&kvaser_pci_driver);
+}
+
+module_init(kvaser_pci_init);
+module_exit(kvaser_pci_exit);
diff --exclude CVS --exclude .git -uNr linux-2.6.27.8/drivers/net/can/sja1000/peak_pci.c linux-2.6.27.8.modified/drivers/net/can/sja1000/peak_pci.c
--- linux-2.6.27.8/drivers/net/can/sja1000/peak_pci.c	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.27.8.modified/drivers/net/can/sja1000/peak_pci.c	2013-05-30 03:44:18.000000000 -0400
@@ -0,0 +1,362 @@
+/*
+ * Copyright (C) 2007 Wolfgang Grandegger <wg@grandegger.com>
+ *
+ * Derived from the PCAN project file driver/src/pcan_pci.c:
+ *
+ * Copyright (C) 2001-2006  PEAK System-Technik GmbH
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the version 2 of the GNU General Public License
+ * as published by the Free Software Foundation
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include <linux/kernel.h>
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/interrupt.h>
+#include <linux/netdevice.h>
+#include <linux/delay.h>
+#include <linux/pci.h>
+#include <socketcan/can.h>
+#include <socketcan/can/dev.h>
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,16)
+#include <linux/io.h>
+#else
+#include <asm/io.h>
+#endif
+
+#include "sja1000.h"
+
+#define DRV_NAME  "peak_pci"
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,23)
+#error This driver does not support Kernel versions < 2.6.23
+#endif
+
+MODULE_AUTHOR("Wolfgang Grandegger <wg@grandegger.com>");
+MODULE_DESCRIPTION("Socket-CAN driver for PEAK PCAN PCI/PCIe cards");
+MODULE_SUPPORTED_DEVICE("PEAK PCAN PCI/PCIe CAN card");
+MODULE_LICENSE("GPL v2");
+
+struct peak_pci {
+	int channel;
+	struct pci_dev *pci_dev;
+	struct net_device *slave_dev;
+	volatile void __iomem *conf_addr;
+};
+
+#define PEAK_PCI_SINGLE	     0	/* single channel device */
+#define PEAK_PCI_MASTER	     1	/* multi channel master device */
+#define PEAK_PCI_SLAVE	     2	/* multi channel slave device */
+
+#define PEAK_PCI_CAN_CLOCK   (16000000 / 2)
+
+#define PEAK_PCI_CDR_SINGLE  (CDR_CBP | CDR_CLKOUT_MASK | CDR_CLK_OFF)
+#define PEAK_PCI_CDR_MASTER  (CDR_CBP | CDR_CLKOUT_MASK)
+
+#define PEAK_PCI_OCR 	     OCR_TX0_PUSHPULL
+
+/*
+ * Important PITA registers
+ */
+#define PITA_ICR	     0x00	/* interrupt control register */
+#define PITA_GPIOICR	     0x18	/* general purpose I/O interface
+					   control register */
+#define PITA_MISC	     0x1C	/* miscellanoes register */
+
+#define PCI_CONFIG_PORT_SIZE 0x1000	/* size of the config io-memory */
+#define PCI_PORT_SIZE        0x0400	/* size of a channel io-memory */
+
+#define PEAK_PCI_VENDOR_ID   0x001C	/* the PCI device and vendor IDs */
+#define PEAK_PCI_DEVICE_ID   0x0001	/* PCAN PCI and PCIe slot cards */
+#define PEAK_PCIE_CARD_ID    0x0002	/* PCAN ExpressCard */
+
+/* TODO: Add LED Status support for PCAN ExpressCard */
+
+static struct pci_device_id peak_pci_tbl[] = {
+	{PEAK_PCI_VENDOR_ID, PEAK_PCI_DEVICE_ID, PCI_ANY_ID, PCI_ANY_ID,},
+	{PEAK_PCI_VENDOR_ID, PEAK_PCIE_CARD_ID, PCI_ANY_ID, PCI_ANY_ID,},
+	{0,}
+};
+
+MODULE_DEVICE_TABLE(pci, peak_pci_tbl);
+
+static u8 peak_pci_read_reg(const struct sja1000_priv *priv, int port)
+{
+	return readb(priv->reg_base + (port << 2));
+}
+
+static void peak_pci_write_reg(const struct sja1000_priv *priv,
+			       int port, u8 val)
+{
+	writeb(val, priv->reg_base + (port << 2));
+}
+
+static void peak_pci_post_irq(const struct sja1000_priv *priv)
+{
+	struct peak_pci *board = priv->priv;
+	u16 icr_low;
+
+	/* Select and clear in Pita stored interrupt */
+	icr_low = readw(board->conf_addr + PITA_ICR);
+	if (board->channel == PEAK_PCI_SLAVE) {
+		if (icr_low & 0x0001)
+			writew(0x0001, board->conf_addr + PITA_ICR);
+	} else {
+		if (icr_low & 0x0002)
+			writew(0x0002, board->conf_addr + PITA_ICR);
+	}
+}
+
+static void peak_pci_del_chan(struct net_device *dev, int init_step)
+{
+	struct sja1000_priv *priv = netdev_priv(dev);
+	struct peak_pci *board;
+	u16 icr_high;
+
+	if (!dev)
+		return;
+	priv = netdev_priv(dev);
+	if (!priv)
+		return;
+	board = priv->priv;
+	if (!board)
+		return;
+
+	switch (init_step) {
+	case 0:		/* Full cleanup */
+		printk(KERN_INFO "Removing %s device %s\n",
+		       DRV_NAME, dev->name);
+		unregister_sja1000dev(dev);
+	case 4:
+		icr_high = readw(board->conf_addr + PITA_ICR + 2);
+		if (board->channel == PEAK_PCI_SLAVE)
+			icr_high &= ~0x0001;
+		else
+			icr_high &= ~0x0002;
+		writew(icr_high, board->conf_addr + PITA_ICR + 2);
+	case 3:
+		iounmap(priv->reg_base);
+	case 2:
+		if (board->channel != PEAK_PCI_SLAVE)
+			iounmap((void *)board->conf_addr);
+	case 1:
+		free_sja1000dev(dev);
+		break;
+	}
+
+}
+
+static int peak_pci_add_chan(struct pci_dev *pdev, int channel,
+			     struct net_device **master_dev)
+{
+	struct net_device *dev;
+	struct sja1000_priv *priv;
+	struct peak_pci *board;
+	u16 icr_high;
+	unsigned long addr;
+	int err, init_step;
+
+	dev = alloc_sja1000dev(sizeof(struct peak_pci));
+	if (dev == NULL)
+		return -ENOMEM;
+	init_step = 1;
+
+	priv = netdev_priv(dev);
+	board = priv->priv;
+
+	board->pci_dev = pdev;
+	board->channel = channel;
+
+	if (channel != PEAK_PCI_SLAVE) {
+
+		addr = pci_resource_start(pdev, 0);
+		board->conf_addr = ioremap(addr, PCI_CONFIG_PORT_SIZE);
+		if (board->conf_addr == 0) {
+			err = -ENODEV;
+			goto failure;
+		}
+		init_step = 2;
+
+		/* Set GPIO control register */
+		writew(0x0005, board->conf_addr + PITA_GPIOICR + 2);
+
+		/* Enable single or dual channel */
+		if (channel == PEAK_PCI_MASTER)
+			writeb(0x00, board->conf_addr + PITA_GPIOICR);
+		else
+			writeb(0x04, board->conf_addr + PITA_GPIOICR);
+		/* Toggle reset */
+		writeb(0x05, board->conf_addr + PITA_MISC + 3);
+		mdelay(5);
+		/* Leave parport mux mode */
+		writeb(0x04, board->conf_addr + PITA_MISC + 3);
+	} else {
+		struct sja1000_priv *master_priv = netdev_priv(*master_dev);
+		struct peak_pci *master_board = master_priv->priv;
+		master_board->slave_dev = dev;
+		board->conf_addr = master_board->conf_addr;
+	}
+
+	addr = pci_resource_start(pdev, 1);
+	if (channel == PEAK_PCI_SLAVE)
+		addr += PCI_PORT_SIZE;
+
+	priv->reg_base = ioremap(addr, PCI_PORT_SIZE);
+	if (priv->reg_base == 0) {
+		err = -ENOMEM;
+		goto failure;
+	}
+	init_step = 3;
+
+	priv->read_reg = peak_pci_read_reg;
+	priv->write_reg = peak_pci_write_reg;
+	priv->post_irq = peak_pci_post_irq;
+
+	priv->can.clock.freq = PEAK_PCI_CAN_CLOCK;
+
+	priv->ocr = PEAK_PCI_OCR;
+
+	if (channel == PEAK_PCI_MASTER)
+		priv->cdr = PEAK_PCI_CDR_MASTER;
+	else
+		priv->cdr = PEAK_PCI_CDR_SINGLE;
+
+	/* Setup interrupt handling */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,18)
+	priv->irq_flags = SA_SHIRQ;
+#else
+	priv->irq_flags = IRQF_SHARED;
+#endif
+	dev->irq = pdev->irq;
+	icr_high = readw(board->conf_addr + PITA_ICR + 2);
+	if (channel == PEAK_PCI_SLAVE)
+		icr_high |= 0x0001;
+	else
+		icr_high |= 0x0002;
+	writew(icr_high, board->conf_addr + PITA_ICR + 2);
+	init_step = 4;
+
+	SET_NETDEV_DEV(dev, &pdev->dev);
+
+	/* Register SJA1000 device */
+	err = register_sja1000dev(dev);
+	if (err) {
+		printk(KERN_ERR "Registering %s device failed (err=%d)\n",
+		       DRV_NAME, err);
+		goto failure;
+	}
+
+	if (channel != PEAK_PCI_SLAVE)
+		*master_dev = dev;
+
+	printk(KERN_INFO "%s: %s at reg_base=0x%p conf_addr=%p irq=%d\n",
+	       DRV_NAME, dev->name, priv->reg_base, board->conf_addr, dev->irq);
+
+	return 0;
+
+failure:
+	peak_pci_del_chan(dev, init_step);
+	return err;
+}
+
+static int __devinit peak_pci_init_one(struct pci_dev *pdev,
+				       const struct pci_device_id *ent)
+{
+	int err;
+	u16 sub_sys_id;
+	struct net_device *master_dev = NULL;
+
+	printk(KERN_INFO "%s: initializing device %04x:%04x\n",
+	       DRV_NAME, pdev->vendor, pdev->device);
+
+	err = pci_enable_device(pdev);
+	if (err)
+		goto failure;
+
+	err = pci_request_regions(pdev, DRV_NAME);
+	if (err)
+		goto failure;
+
+	err = pci_read_config_word(pdev, 0x2e, &sub_sys_id);
+	if (err)
+		goto failure_cleanup;
+
+	err = pci_write_config_word(pdev, 0x44, 0);
+	if (err)
+		goto failure_cleanup;
+
+	if (sub_sys_id > 3) {
+		err = peak_pci_add_chan(pdev,
+					PEAK_PCI_MASTER, &master_dev);
+		if (err)
+			goto failure_cleanup;
+
+		err = peak_pci_add_chan(pdev,
+					PEAK_PCI_SLAVE, &master_dev);
+		if (err)
+			goto failure_cleanup;
+	} else {
+		err = peak_pci_add_chan(pdev, PEAK_PCI_SINGLE,
+					     &master_dev);
+		if (err)
+			goto failure_cleanup;
+	}
+
+	pci_set_drvdata(pdev, master_dev);
+	return 0;
+
+failure_cleanup:
+	if (master_dev)
+		peak_pci_del_chan(master_dev, 0);
+
+	pci_release_regions(pdev);
+
+failure:
+	return err;
+
+}
+
+static void __devexit peak_pci_remove_one(struct pci_dev *pdev)
+{
+	struct net_device *dev = pci_get_drvdata(pdev);
+	struct sja1000_priv *priv = netdev_priv(dev);
+	struct peak_pci *board = priv->priv;
+
+	if (board->slave_dev)
+		peak_pci_del_chan(board->slave_dev, 0);
+	peak_pci_del_chan(dev, 0);
+
+	pci_release_regions(pdev);
+	pci_disable_device(pdev);
+	pci_set_drvdata(pdev, NULL);
+}
+
+static struct pci_driver peak_pci_driver = {
+	.name = DRV_NAME,
+	.id_table = peak_pci_tbl,
+	.probe = peak_pci_init_one,
+	.remove = __devexit_p(peak_pci_remove_one),
+};
+
+static int __init peak_pci_init(void)
+{
+	return pci_register_driver(&peak_pci_driver);
+}
+
+static void __exit peak_pci_exit(void)
+{
+	pci_unregister_driver(&peak_pci_driver);
+}
+
+module_init(peak_pci_init);
+module_exit(peak_pci_exit);
diff --exclude CVS --exclude .git -uNr linux-2.6.27.8/drivers/net/can/sja1000/pipcan.c linux-2.6.27.8.modified/drivers/net/can/sja1000/pipcan.c
--- linux-2.6.27.8/drivers/net/can/sja1000/pipcan.c	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.27.8.modified/drivers/net/can/sja1000/pipcan.c	2013-05-30 03:44:18.000000000 -0400
@@ -0,0 +1,212 @@
+/*
+ * Copyright (C) 2008 David M眉ller, <d.mueller@elsoft.ch>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the version 2 of the GNU General Public License
+ * as published by the Free Software Foundation
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/kernel.h>
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/interrupt.h>
+#include <linux/netdevice.h>
+#include <linux/delay.h>
+#include <linux/platform_device.h>
+#include <socketcan/can.h>
+#include <socketcan/can/dev.h>
+#include <linux/io.h>
+
+#include "sja1000.h"
+
+#define DRV_NAME "pipcan"
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,20)
+#error This driver does not support Kernel versions < 2.6.20
+#endif
+
+MODULE_AUTHOR("David M眉ller <d.mueller@elsoft.ch>");
+MODULE_DESCRIPTION("Socket-CAN driver for MPL PIPCAN module");
+MODULE_SUPPORTED_DEVICE("MPL PIPCAN module");
+MODULE_LICENSE("GPL v2");
+
+#define PIPCAN_CAN_CLOCK  (16000000 / 2)
+
+#define PIPCAN_OCR        (OCR_TX1_PUSHPULL)
+#define PIPCAN_CDR        (CDR_CBP | CDR_CLK_OFF)
+
+#define PIPCAN_IOSIZE     (0x100)
+
+#define PIPCAN_RES        (0x804)
+#define PIPCAN_RST        (0x805)
+
+static u8 pc_read_reg(const struct sja1000_priv *priv, int reg)
+{
+  return inb((unsigned long)priv->reg_base + reg);
+}
+
+static void pc_write_reg(const struct sja1000_priv *priv, int reg, u8 val)
+{
+  outb(val, (unsigned long)priv->reg_base + reg);
+}
+
+static int __init pc_probe(struct platform_device *pdev)
+{
+	struct net_device *dev;
+	struct sja1000_priv *priv;
+	struct resource *res;
+	int rc, irq;
+
+	rc = -ENODEV;
+	res = platform_get_resource(pdev, IORESOURCE_IO, 0);
+	irq = platform_get_irq(pdev, 0);
+	if (!res || !irq)
+		goto exit;
+
+	rc = -EBUSY;
+	if (!request_region(res->start, res->end - res->start + 1, DRV_NAME))
+		goto exit;
+
+	rc = -ENOMEM;
+	dev = alloc_sja1000dev(0);
+	if (!dev)
+		goto exit_release;
+
+	priv = netdev_priv(dev);
+
+	priv->read_reg = pc_read_reg;
+	priv->write_reg = pc_write_reg;
+	priv->can.clock.freq = PIPCAN_CAN_CLOCK;
+	priv->ocr = PIPCAN_OCR;
+	priv->cdr = PIPCAN_CDR;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,18)
+	priv->irq_flags = SA_SHIRQ;
+#else
+	priv->irq_flags = IRQF_SHARED;
+#endif
+
+	dev->irq = irq;
+	dev->base_addr = res->start;
+	priv->reg_base = (void __iomem *)res->start;
+
+	dev_set_drvdata(&pdev->dev, dev);
+	SET_NETDEV_DEV(dev, &pdev->dev);
+
+	/* deactivate RST */
+	outb(inb(PIPCAN_RST) & ~0x01, PIPCAN_RST);
+
+	rc = register_sja1000dev(dev);
+	if (rc) {
+		dev_err(&pdev->dev, "registering %s failed (err=%d)\n",
+			DRV_NAME, rc);
+		goto exit_free;
+	}
+
+	dev_info(&pdev->dev, "device registered (base_addr=%#lx, irq=%d)\n",
+		 dev->base_addr, dev->irq);
+	return 0;
+
+exit_free:
+	free_sja1000dev(dev);
+
+exit_release:
+	release_region(res->start, res->end - res->start + 1);
+
+exit:
+	return rc;
+}
+
+static int __exit pc_remove(struct platform_device *pdev)
+{
+	struct net_device *dev = dev_get_drvdata(&pdev->dev);
+	struct resource *res;
+
+	dev_set_drvdata(&pdev->dev, NULL);
+	unregister_sja1000dev(dev);
+	res = platform_get_resource(pdev, IORESOURCE_IO, 0);
+
+	free_sja1000dev(dev);
+
+	release_region(res->start, res->end - res->start + 1);
+
+	/* activate RST */
+	outb(inb(PIPCAN_RST) | 0x01, PIPCAN_RST);
+
+	return 0;
+}
+
+static struct platform_driver pc_driver = {
+	.remove = __exit_p(pc_remove),
+	.driver = {
+		   .name = DRV_NAME,
+		   .owner = THIS_MODULE,
+		   },
+};
+
+static struct platform_device *pc_pdev;
+static const u16 pipcan_ioport[] = {0x1000, 0x8000, 0xE000};
+
+static int __init pc_init(void)
+{
+	struct resource r[2];
+	int rc, addr, irq, idx;
+	u8 pc_res;
+
+	/* get PIPCAN resources from EPLD */
+	pc_res = inb(PIPCAN_RES);
+
+	idx = (pc_res & 0x0F);
+	if ((idx <= 0) || (idx > ARRAY_SIZE(pipcan_ioport))) {
+		printk(KERN_ERR DRV_NAME " invalid base address\n");
+		return -EINVAL;
+	}
+	addr = pipcan_ioport[idx-1];
+
+	irq = (pc_res >> 4) & 0x0F;
+	if ((irq < 3) || (irq == 8) || (irq == 13)) {
+		printk(KERN_ERR DRV_NAME " invalid IRQ\n");
+		return -EINVAL;
+	}
+
+	/* fill in resources */
+	memset(&r, 0, sizeof(r));
+	r[0].start = addr;
+	r[0].end = addr + PIPCAN_IOSIZE - 1;
+	r[0].name = DRV_NAME;
+	r[0].flags = IORESOURCE_IO;
+	r[1].start = r[1].end = irq;
+	r[1].name = DRV_NAME;
+	r[1].flags = IORESOURCE_IRQ;
+
+	pc_pdev = platform_device_register_simple(DRV_NAME, 0, r,
+						  ARRAY_SIZE(r));
+	if (IS_ERR(pc_pdev))
+		return PTR_ERR(pc_pdev);
+
+	rc = platform_driver_probe(&pc_driver, pc_probe);
+	if (rc) {
+		platform_device_unregister(pc_pdev);
+		printk(KERN_ERR DRV_NAME
+		       " platform_driver_probe() failed (%d)\n", rc);
+	}
+
+	return rc;
+}
+
+static void __exit pc_exit(void)
+{
+	platform_driver_unregister(&pc_driver);
+	platform_device_unregister(pc_pdev);
+}
+
+module_init(pc_init);
+module_exit(pc_exit);
diff --exclude CVS --exclude .git -uNr linux-2.6.27.8/drivers/net/can/sja1000/plx_pci.c linux-2.6.27.8.modified/drivers/net/can/sja1000/plx_pci.c
--- linux-2.6.27.8/drivers/net/can/sja1000/plx_pci.c	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.27.8.modified/drivers/net/can/sja1000/plx_pci.c	2013-05-30 03:44:18.000000000 -0400
@@ -0,0 +1,480 @@
+/*
+ * Copyright (C) 2008-2010 Pavel Cheblakov <P.B.Cheblakov@inp.nsk.su>
+ *
+ * Derived from the ems_pci.c driver:
+ *	Copyright (C) 2007 Wolfgang Grandegger <wg@grandegger.com>
+ *	Copyright (C) 2008 Markus Plessing <plessing@ems-wuensche.com>
+ *	Copyright (C) 2008 Sebastian Haas <haas@ems-wuensche.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the version 2 of the GNU General Public License
+ * as published by the Free Software Foundation
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/interrupt.h>
+#include <linux/netdevice.h>
+#include <linux/delay.h>
+#include <linux/pci.h>
+#include <socketcan/can.h>
+#include <socketcan/can/dev.h>
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,16)
+#include <linux/io.h>
+#else
+#include <asm/io.h>
+#endif
+
+#include "sja1000.h"
+
+#define DRV_NAME  "sja1000_plx_pci"
+
+MODULE_AUTHOR("Pavel Cheblakov <P.B.Cheblakov@inp.nsk.su>");
+MODULE_DESCRIPTION("Socket-CAN driver for PLX90xx PCI-bridge cards with "
+		   "the SJA1000 chips");
+MODULE_SUPPORTED_DEVICE("Adlink PCI-7841/cPCI-7841, "
+			"Adlink PCI-7841/cPCI-7841 SE, "
+			"Marathon CAN-bus-PCI, "
+			"TEWS TECHNOLOGIES TPMC810");
+MODULE_LICENSE("GPL v2");
+
+#define PLX_PCI_MAX_CHAN 2
+
+struct plx_pci_card {
+	int channels;			/* detected channels count */
+	struct net_device *net_dev[PLX_PCI_MAX_CHAN];
+	void __iomem *conf_addr;
+};
+
+#define PLX_PCI_CAN_CLOCK (16000000 / 2)
+
+/* PLX90xx registers */
+#define PLX_INTCSR	0x4c		/* Interrupt Control/Status */
+#define PLX_CNTRL	0x50		/* User I/O, Direct Slave Response,
+					 * Serial EEPROM, and Initialization
+					 * Control register
+					 */
+
+#define PLX_LINT1_EN	0x1		/* Local interrupt 1 enable */
+#define PLX_LINT2_EN	(1 << 3)	/* Local interrupt 2 enable */
+#define PLX_PCI_INT_EN	(1 << 6)	/* PCI Interrupt Enable */
+#define PLX_PCI_RESET	(1 << 30)	/* PCI Adapter Software Reset */
+
+/*
+ * The board configuration is probably following:
+ * RX1 is connected to ground.
+ * TX1 is not connected.
+ * CLKO is not connected.
+ * Setting the OCR register to 0xDA is a good idea.
+ * This means normal output mode, push-pull and the correct polarity.
+ */
+#define PLX_PCI_OCR	(OCR_TX0_PUSHPULL | OCR_TX1_PUSHPULL)
+
+/*
+ * In the CDR register, you should set CBP to 1.
+ * You will probably also want to set the clock divider value to 7
+ * (meaning direct oscillator output) because the second SJA1000 chip
+ * is driven by the first one CLKOUT output.
+ */
+#define PLX_PCI_CDR			(CDR_CBP | CDR_CLKOUT_MASK)
+
+/* SJA1000 Control Register in the BasicCAN Mode */
+#define REG_CR				0x00
+
+/* States of some SJA1000 registers after hardware reset in the BasicCAN mode*/
+#define REG_CR_BASICCAN_INITIAL		0x21
+#define REG_CR_BASICCAN_INITIAL_MASK	0xa1
+#define REG_SR_BASICCAN_INITIAL		0x0c
+#define REG_IR_BASICCAN_INITIAL		0xe0
+
+/* States of some SJA1000 registers after hardware reset in the PeliCAN mode*/
+#define REG_MOD_PELICAN_INITIAL		0x01
+#define REG_SR_PELICAN_INITIAL		0x3c
+#define REG_IR_PELICAN_INITIAL		0x00
+
+#define ADLINK_PCI_VENDOR_ID		0x144A
+#define ADLINK_PCI_DEVICE_ID		0x7841
+
+#define MARATHON_PCI_DEVICE_ID		0x2715
+
+#define TEWS_PCI_VENDOR_ID		0x1498
+#define TEWS_PCI_DEVICE_ID_TMPC810	0x032A
+
+static void plx_pci_reset_common(struct pci_dev *pdev);
+static void plx_pci_reset_marathon(struct pci_dev *pdev);
+
+struct plx_pci_channel_map {
+	u32 bar;
+	u32 offset;
+	u32 size;		/* 0x00 - auto, e.g. length of entire bar */
+};
+
+struct plx_pci_card_info {
+	const char *name;
+	int channel_count;
+	u32 can_clock;
+	u8 ocr;			/* output control register */
+	u8 cdr;			/* clock divider register */
+
+	/* Parameters for mapping local configuration space */
+	struct plx_pci_channel_map conf_map;
+
+	/* Parameters for mapping the SJA1000 chips */
+	struct plx_pci_channel_map chan_map_tbl[PLX_PCI_MAX_CHAN];
+
+	/* Pointer to device-dependent reset function */
+	void (*reset_func)(struct pci_dev *pdev);
+};
+
+static struct plx_pci_card_info plx_pci_card_info_adlink __devinitdata = {
+	"Adlink PCI-7841/cPCI-7841", 2,
+	PLX_PCI_CAN_CLOCK, PLX_PCI_OCR, PLX_PCI_CDR,
+	{1, 0x00, 0x00}, { {2, 0x00, 0x80}, {2, 0x80, 0x80} },
+	&plx_pci_reset_common
+	/* based on PLX9052 */
+};
+
+static struct plx_pci_card_info plx_pci_card_info_adlink_se __devinitdata = {
+	"Adlink PCI-7841/cPCI-7841 SE", 2,
+	PLX_PCI_CAN_CLOCK, PLX_PCI_OCR, PLX_PCI_CDR,
+	{0, 0x00, 0x00}, { {2, 0x00, 0x80}, {2, 0x80, 0x80} },
+	&plx_pci_reset_common
+	/* based on PLX9052 */
+};
+
+static struct plx_pci_card_info plx_pci_card_info_marathon __devinitdata = {
+	"Marathon CAN-bus-PCI", 2,
+	PLX_PCI_CAN_CLOCK, PLX_PCI_OCR, PLX_PCI_CDR,
+	{0, 0x00, 0x00}, { {2, 0x00, 0x00}, {4, 0x00, 0x00} },
+	&plx_pci_reset_marathon
+	/* based on PLX9052 */
+};
+
+static struct plx_pci_card_info plx_pci_card_info_tews __devinitdata = {
+	"TEWS TECHNOLOGIES TPMC810", 2,
+	PLX_PCI_CAN_CLOCK, PLX_PCI_OCR, PLX_PCI_CDR,
+	{0, 0x00, 0x00}, { {2, 0x000, 0x80}, {2, 0x100, 0x80} },
+	&plx_pci_reset_common
+	/* based on PLX9030 */
+};
+
+static DEFINE_PCI_DEVICE_TABLE(plx_pci_tbl) = {
+	{
+		/* Adlink PCI-7841/cPCI-7841 */
+		ADLINK_PCI_VENDOR_ID, ADLINK_PCI_DEVICE_ID,
+		PCI_ANY_ID, PCI_ANY_ID,
+		PCI_CLASS_NETWORK_OTHER << 8, ~0,
+		(kernel_ulong_t)&plx_pci_card_info_adlink
+	},
+	{
+		/* Adlink PCI-7841/cPCI-7841 SE */
+		ADLINK_PCI_VENDOR_ID, ADLINK_PCI_DEVICE_ID,
+		PCI_ANY_ID, PCI_ANY_ID,
+		PCI_CLASS_COMMUNICATION_OTHER << 8, ~0,
+		(kernel_ulong_t)&plx_pci_card_info_adlink_se
+	},
+	{
+		/* Marathon CAN-bus-PCI card */
+		PCI_VENDOR_ID_PLX, MARATHON_PCI_DEVICE_ID,
+		PCI_ANY_ID, PCI_ANY_ID,
+		0, 0,
+		(kernel_ulong_t)&plx_pci_card_info_marathon
+	},
+	{
+		/* TEWS TECHNOLOGIES TPMC810 card */
+		TEWS_PCI_VENDOR_ID, TEWS_PCI_DEVICE_ID_TMPC810,
+		PCI_ANY_ID, PCI_ANY_ID,
+		0, 0,
+		(kernel_ulong_t)&plx_pci_card_info_tews
+	},
+	{ 0,}
+};
+MODULE_DEVICE_TABLE(pci, plx_pci_tbl);
+
+static u8 plx_pci_read_reg(const struct sja1000_priv *priv, int port)
+{
+	return ioread8(priv->reg_base + port);
+}
+
+static void plx_pci_write_reg(const struct sja1000_priv *priv, int port, u8 val)
+{
+	iowrite8(val, priv->reg_base + port);
+}
+
+/*
+ * Check if a CAN controller is present at the specified location
+ * by trying to switch 'em from the Basic mode into the PeliCAN mode.
+ * Also check states of some registers in reset mode.
+ */
+static inline int plx_pci_check_sja1000(const struct sja1000_priv *priv)
+{
+	int flag = 0;
+
+	/*
+	 * Check registers after hardware reset (the Basic mode)
+	 * See states on p. 10 of the Datasheet.
+	 */
+	if ((priv->read_reg(priv, REG_CR) & REG_CR_BASICCAN_INITIAL_MASK) ==
+	    REG_CR_BASICCAN_INITIAL &&
+	    (priv->read_reg(priv, REG_SR) == REG_SR_BASICCAN_INITIAL) &&
+	    (priv->read_reg(priv, REG_IR) == REG_IR_BASICCAN_INITIAL))
+		flag = 1;
+
+	/* Bring the SJA1000 into the PeliCAN mode*/
+	priv->write_reg(priv, REG_CDR, CDR_PELICAN);
+
+	/*
+	 * Check registers after reset in the PeliCAN mode.
+	 * See states on p. 23 of the Datasheet.
+	 */
+	if (priv->read_reg(priv, REG_MOD) == REG_MOD_PELICAN_INITIAL &&
+	    priv->read_reg(priv, REG_SR) == REG_SR_PELICAN_INITIAL &&
+	    priv->read_reg(priv, REG_IR) == REG_IR_PELICAN_INITIAL)
+		return flag;
+
+	return 0;
+}
+
+/*
+ * PLX90xx software reset
+ * Also LRESET# asserts and brings to reset device on the Local Bus (if wired).
+ * For most cards it's enough for reset the SJA1000 chips.
+ */
+static void plx_pci_reset_common(struct pci_dev *pdev)
+{
+	struct plx_pci_card *card = pci_get_drvdata(pdev);
+	u32 cntrl;
+
+	cntrl = ioread32(card->conf_addr + PLX_CNTRL);
+	cntrl |= PLX_PCI_RESET;
+	iowrite32(cntrl, card->conf_addr + PLX_CNTRL);
+	udelay(100);
+	cntrl ^= PLX_PCI_RESET;
+	iowrite32(cntrl, card->conf_addr + PLX_CNTRL);
+};
+
+/* Special reset function for Marathon card */
+static void plx_pci_reset_marathon(struct pci_dev *pdev)
+{
+	void __iomem *reset_addr;
+	int i;
+	int reset_bar[2] = {3, 5};
+
+	plx_pci_reset_common(pdev);
+
+	for (i = 0; i < 2; i++) {
+		reset_addr = pci_iomap(pdev, reset_bar[i], 0);
+		if (!reset_addr) {
+			dev_err(&pdev->dev, "Failed to remap reset "
+				"space %d (BAR%d)\n", i, reset_bar[i]);
+		} else {
+			/* reset the SJA1000 chip */
+			iowrite8(0x1, reset_addr);
+			udelay(100);
+			pci_iounmap(pdev, reset_addr);
+		}
+	}
+}
+
+static void plx_pci_del_card(struct pci_dev *pdev)
+{
+	struct plx_pci_card *card = pci_get_drvdata(pdev);
+	struct net_device *dev;
+	struct sja1000_priv *priv;
+	int i = 0;
+
+	for (i = 0; i < card->channels; i++) {
+		dev = card->net_dev[i];
+		if (!dev)
+			continue;
+
+		dev_info(&pdev->dev, "Removing %s\n", dev->name);
+		unregister_sja1000dev(dev);
+		priv = netdev_priv(dev);
+		if (priv->reg_base)
+			pci_iounmap(pdev, priv->reg_base);
+		free_sja1000dev(dev);
+	}
+
+	plx_pci_reset_common(pdev);
+
+	/*
+	 * Disable interrupts from PCI-card (PLX90xx) and disable Local_1,
+	 * Local_2 interrupts
+	 */
+	iowrite32(0x0, card->conf_addr + PLX_INTCSR);
+
+	if (card->conf_addr)
+		pci_iounmap(pdev, card->conf_addr);
+
+	kfree(card);
+
+	pci_disable_device(pdev);
+	pci_set_drvdata(pdev, NULL);
+}
+
+/*
+ * Probe PLX90xx based device for the SJA1000 chips and register each
+ * available CAN channel to SJA1000 Socket-CAN subsystem.
+ */
+static int __devinit plx_pci_add_card(struct pci_dev *pdev,
+				      const struct pci_device_id *ent)
+{
+	struct sja1000_priv *priv;
+	struct net_device *dev;
+	struct plx_pci_card *card;
+	struct plx_pci_card_info *ci;
+	int err, i;
+	u32 val;
+	void __iomem *addr;
+
+	ci = (struct plx_pci_card_info *)ent->driver_data;
+
+	if (pci_enable_device(pdev) < 0) {
+		dev_err(&pdev->dev, "Failed to enable PCI device\n");
+		return -ENODEV;
+	}
+
+	dev_info(&pdev->dev, "Detected \"%s\" card at slot #%i\n",
+		 ci->name, PCI_SLOT(pdev->devfn));
+
+	/* Allocate card structures to hold addresses, ... */
+	card = kzalloc(sizeof(*card), GFP_KERNEL);
+	if (!card) {
+		dev_err(&pdev->dev, "Unable to allocate memory\n");
+		pci_disable_device(pdev);
+		return -ENOMEM;
+	}
+
+	pci_set_drvdata(pdev, card);
+
+	card->channels = 0;
+
+	/* Remap PLX90xx configuration space */
+	addr = pci_iomap(pdev, ci->conf_map.bar, ci->conf_map.size);
+	if (!addr) {
+		err = -ENOMEM;
+		dev_err(&pdev->dev, "Failed to remap configuration space "
+			"(BAR%d)\n", ci->conf_map.bar);
+		goto failure_cleanup;
+	}
+	card->conf_addr = addr + ci->conf_map.offset;
+
+	ci->reset_func(pdev);
+
+	/* Detect available channels */
+	for (i = 0; i < ci->channel_count; i++) {
+		struct plx_pci_channel_map *cm = &ci->chan_map_tbl[i];
+
+		dev = alloc_sja1000dev(0);
+		if (!dev) {
+			err = -ENOMEM;
+			goto failure_cleanup;
+		}
+
+		card->net_dev[i] = dev;
+		priv = netdev_priv(dev);
+		priv->priv = card;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,18)
+		priv->irq_flags = SA_SHIRQ;
+#else
+		priv->irq_flags = IRQF_SHARED;
+#endif
+
+		dev->irq = pdev->irq;
+
+		/*
+		 * Remap IO space of the SJA1000 chips
+		 * This is device-dependent mapping
+		 */
+		addr = pci_iomap(pdev, cm->bar, cm->size);
+		if (!addr) {
+			err = -ENOMEM;
+			dev_err(&pdev->dev, "Failed to remap BAR%d\n", cm->bar);
+			goto failure_cleanup;
+		}
+
+		priv->reg_base = addr + cm->offset;
+		priv->read_reg = plx_pci_read_reg;
+		priv->write_reg = plx_pci_write_reg;
+
+		/* Check if channel is present */
+		if (plx_pci_check_sja1000(priv)) {
+			priv->can.clock.freq = ci->can_clock;
+			priv->ocr = ci->ocr;
+			priv->cdr = ci->cdr;
+
+			SET_NETDEV_DEV(dev, &pdev->dev);
+
+			/* Register SJA1000 device */
+			err = register_sja1000dev(dev);
+			if (err) {
+				dev_err(&pdev->dev, "Registering device failed "
+					"(err=%d)\n", err);
+				free_sja1000dev(dev);
+				goto failure_cleanup;
+			}
+
+			card->channels++;
+
+			dev_info(&pdev->dev, "Channel #%d at 0x%p, irq %d "
+				 "registered as %s\n", i + 1, priv->reg_base,
+				 dev->irq, dev->name);
+		} else {
+			dev_err(&pdev->dev, "Channel #%d not detected\n",
+				i + 1);
+			free_sja1000dev(dev);
+		}
+	}
+
+	if (!card->channels) {
+		err = -ENODEV;
+		goto failure_cleanup;
+	}
+
+	/*
+	 * Enable interrupts from PCI-card (PLX90xx) and enable Local_1,
+	 * Local_2 interrupts from the SJA1000 chips
+	 */
+	val = ioread32(card->conf_addr + PLX_INTCSR);
+	val |= PLX_LINT1_EN | PLX_LINT2_EN | PLX_PCI_INT_EN;
+	iowrite32(val, card->conf_addr + PLX_INTCSR);
+
+	return 0;
+
+failure_cleanup:
+	dev_err(&pdev->dev, "Error: %d. Cleaning Up.\n", err);
+
+	plx_pci_del_card(pdev);
+
+	return err;
+}
+
+static struct pci_driver plx_pci_driver = {
+	.name = DRV_NAME,
+	.id_table = plx_pci_tbl,
+	.probe = plx_pci_add_card,
+	.remove = plx_pci_del_card,
+};
+
+static int __init plx_pci_init(void)
+{
+	return pci_register_driver(&plx_pci_driver);
+}
+
+static void __exit plx_pci_exit(void)
+{
+	pci_unregister_driver(&plx_pci_driver);
+}
+
+module_init(plx_pci_init);
+module_exit(plx_pci_exit);
diff --exclude CVS --exclude .git -uNr linux-2.6.27.8/drivers/net/can/sja1000/sja1000.c linux-2.6.27.8.modified/drivers/net/can/sja1000/sja1000.c
--- linux-2.6.27.8/drivers/net/can/sja1000/sja1000.c	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.27.8.modified/drivers/net/can/sja1000/sja1000.c	2013-05-30 03:44:18.000000000 -0400
@@ -0,0 +1,705 @@
+/*
+ * sja1000.c -  Philips SJA1000 network device driver
+ *
+ * Copyright (c) 2003 Matthias Brukner, Trajet Gmbh, Rebenring 33,
+ * 38106 Braunschweig, GERMANY
+ *
+ * Copyright (c) 2002-2007 Volkswagen Group Electronic Research
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of Volkswagen nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * Alternatively, provided that this notice is retained in full, this
+ * software may be distributed under the terms of the GNU General
+ * Public License ("GPL") version 2, in which case the provisions of the
+ * GPL apply INSTEAD OF those given above.
+ *
+ * The provided data structures and external interfaces from this code
+ * are not restricted to be used by modules with a GPL compatible license.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * Send feedback to <socketcan-users@lists.berlios.de>
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/version.h>
+#include <linux/sched.h>
+#include <linux/types.h>
+#include <linux/fcntl.h>
+#include <linux/interrupt.h>
+#include <linux/ptrace.h>
+#include <linux/string.h>
+#include <linux/errno.h>
+#include <linux/netdevice.h>
+#include <linux/if_arp.h>
+#include <linux/if_ether.h>
+#include <linux/skbuff.h>
+#include <linux/delay.h>
+
+#include <socketcan/can.h>
+#include <socketcan/can/dev.h>
+#include <socketcan/can/error.h>
+
+#include "sja1000.h"
+
+#include <socketcan/can/version.h>	/* for RCSID. Removed by mkpatch script */
+RCSID("$Id: sja1000.c 531 2007-10-19 07:38:29Z hartkopp $");
+
+#define DRV_NAME "sja1000"
+
+MODULE_AUTHOR("Oliver Hartkopp <oliver.hartkopp@volkswagen.de>");
+MODULE_LICENSE("Dual BSD/GPL");
+MODULE_DESCRIPTION(DRV_NAME "CAN netdevice driver");
+
+static struct can_bittiming_const sja1000_bittiming_const = {
+	.name = DRV_NAME,
+	.tseg1_min = 1,
+	.tseg1_max = 16,
+	.tseg2_min = 1,
+	.tseg2_max = 8,
+	.sjw_max = 4,
+	.brp_min = 1,
+	.brp_max = 64,
+	.brp_inc = 1,
+};
+
+static void sja1000_write_cmdreg(struct sja1000_priv *priv, u8 val)
+{
+	unsigned long flags;
+
+	/*
+	 * The command register needs some locking and time to settle
+	 * the write_reg() operation - especially on SMP systems.
+	 */
+	spin_lock_irqsave(&priv->cmdreg_lock, flags);
+	priv->write_reg(priv, REG_CMR, val);
+	priv->read_reg(priv, REG_SR);
+	spin_unlock_irqrestore(&priv->cmdreg_lock, flags);
+}
+
+static int sja1000_probe_chip(struct net_device *dev)
+{
+	struct sja1000_priv *priv = netdev_priv(dev);
+
+	if (priv->reg_base && (priv->read_reg(priv, 0) == 0xFF)) {
+		dev_info(ND2D(dev), "probing @0x%p failed\n",
+			 priv->reg_base);
+		return 0;
+	}
+	return -1;
+}
+
+static void set_reset_mode(struct net_device *dev)
+{
+	struct sja1000_priv *priv = netdev_priv(dev);
+	unsigned char status = priv->read_reg(priv, REG_MOD);
+	int i;
+
+	/* disable interrupts */
+	priv->write_reg(priv, REG_IER, IRQ_OFF);
+
+	for (i = 0; i < 100; i++) {
+		/* check reset bit */
+		if (status & MOD_RM) {
+			priv->can.state = CAN_STATE_STOPPED;
+			return;
+		}
+
+		priv->write_reg(priv, REG_MOD, MOD_RM);	/* reset chip */
+		udelay(10);
+		status = priv->read_reg(priv, REG_MOD);
+	}
+
+	dev_err(ND2D(dev), "setting SJA1000 into reset mode failed!\n");
+}
+
+static void set_normal_mode(struct net_device *dev)
+{
+	struct sja1000_priv *priv = netdev_priv(dev);
+	unsigned char status = priv->read_reg(priv, REG_MOD);
+	int i;
+
+	for (i = 0; i < 100; i++) {
+		/* check reset bit */
+		if ((status & MOD_RM) == 0) {
+			priv->can.state = CAN_STATE_ERROR_ACTIVE;
+			/* enable interrupts */
+			if (priv->can.ctrlmode & CAN_CTRLMODE_BERR_REPORTING)
+				priv->write_reg(priv, REG_IER, IRQ_ALL);
+			else
+				priv->write_reg(priv, REG_IER,
+						IRQ_ALL & ~IRQ_BEI);
+			return;
+		}
+
+		/* set chip to normal mode */
+		priv->write_reg(priv, REG_MOD, 0x00);
+		udelay(10);
+		status = priv->read_reg(priv, REG_MOD);
+	}
+
+	dev_err(ND2D(dev), "setting SJA1000 into normal mode failed!\n");
+}
+
+static void sja1000_start(struct net_device *dev)
+{
+	struct sja1000_priv *priv = netdev_priv(dev);
+
+	/* leave reset mode */
+	if (priv->can.state != CAN_STATE_STOPPED)
+		set_reset_mode(dev);
+
+	/* Clear error counters and error code capture */
+	priv->write_reg(priv, REG_TXERR, 0x0);
+	priv->write_reg(priv, REG_RXERR, 0x0);
+	priv->read_reg(priv, REG_ECC);
+
+	/* leave reset mode */
+	set_normal_mode(dev);
+}
+
+static int sja1000_set_mode(struct net_device *dev, enum can_mode mode)
+{
+	struct sja1000_priv *priv = netdev_priv(dev);
+
+	if (!priv->open_time)
+		return -EINVAL;
+
+	switch (mode) {
+	case CAN_MODE_START:
+		sja1000_start(dev);
+		if (netif_queue_stopped(dev))
+			netif_wake_queue(dev);
+		break;
+
+	default:
+		return -EOPNOTSUPP;
+	}
+
+	return 0;
+}
+
+static int sja1000_set_bittiming(struct net_device *dev)
+{
+	struct sja1000_priv *priv = netdev_priv(dev);
+	struct can_bittiming *bt = &priv->can.bittiming;
+	u8 btr0, btr1;
+
+	btr0 = ((bt->brp - 1) & 0x3f) | (((bt->sjw - 1) & 0x3) << 6);
+	btr1 = ((bt->prop_seg + bt->phase_seg1 - 1) & 0xf) |
+		(((bt->phase_seg2 - 1) & 0x7) << 4);
+	if (priv->can.ctrlmode & CAN_CTRLMODE_3_SAMPLES)
+		btr1 |= 0x80;
+
+	dev_info(ND2D(dev),
+		 "setting BTR0=0x%02x BTR1=0x%02x\n", btr0, btr1);
+
+	priv->write_reg(priv, REG_BTR0, btr0);
+	priv->write_reg(priv, REG_BTR1, btr1);
+
+	return 0;
+}
+
+static int sja1000_get_berr_counter(const struct net_device *dev,
+				    struct can_berr_counter *bec)
+{
+	struct sja1000_priv *priv = netdev_priv(dev);
+
+	bec->txerr = priv->read_reg(priv, REG_TXERR);
+	bec->rxerr = priv->read_reg(priv, REG_RXERR);
+
+	return 0;
+}
+
+/*
+ * initialize SJA1000 chip:
+ *   - reset chip
+ *   - set output mode
+ *   - set baudrate
+ *   - enable interrupts
+ *   - start operating mode
+ */
+static void chipset_init(struct net_device *dev)
+{
+	struct sja1000_priv *priv = netdev_priv(dev);
+
+	/* set clock divider and output control register */
+	priv->write_reg(priv, REG_CDR, priv->cdr | CDR_PELICAN);
+
+	/* set acceptance filter (accept all) */
+	priv->write_reg(priv, REG_ACCC0, 0x00);
+	priv->write_reg(priv, REG_ACCC1, 0x00);
+	priv->write_reg(priv, REG_ACCC2, 0x00);
+	priv->write_reg(priv, REG_ACCC3, 0x00);
+
+	priv->write_reg(priv, REG_ACCM0, 0xFF);
+	priv->write_reg(priv, REG_ACCM1, 0xFF);
+	priv->write_reg(priv, REG_ACCM2, 0xFF);
+	priv->write_reg(priv, REG_ACCM3, 0xFF);
+
+	priv->write_reg(priv, REG_OCR, priv->ocr | OCR_MODE_NORMAL);
+}
+
+/*
+ * transmit a CAN message
+ * message layout in the sk_buff should be like this:
+ * xx xx xx xx	 ff	 ll   00 11 22 33 44 55 66 77
+ * [  can-id ] [flags] [len] [can data (up to 8 bytes]
+ */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,32)
+static int sja1000_start_xmit(struct sk_buff *skb, struct net_device *dev)
+#else
+static netdev_tx_t sja1000_start_xmit(struct sk_buff *skb,
+				      struct net_device *dev)
+#endif
+{
+	struct sja1000_priv *priv = netdev_priv(dev);
+	struct can_frame *cf = (struct can_frame *)skb->data;
+	uint8_t fi;
+	uint8_t dlc;
+	canid_t id;
+	uint8_t dreg;
+	int i;
+
+	if (can_dropped_invalid_skb(dev, skb))
+		return NETDEV_TX_OK;
+
+	netif_stop_queue(dev);
+
+	fi = dlc = cf->can_dlc;
+	id = cf->can_id;
+
+	if (id & CAN_RTR_FLAG)
+		fi |= FI_RTR;
+
+	if (id & CAN_EFF_FLAG) {
+		fi |= FI_FF;
+		dreg = EFF_BUF;
+		priv->write_reg(priv, REG_FI, fi);
+		priv->write_reg(priv, REG_ID1, (id & 0x1fe00000) >> (5 + 16));
+		priv->write_reg(priv, REG_ID2, (id & 0x001fe000) >> (5 + 8));
+		priv->write_reg(priv, REG_ID3, (id & 0x00001fe0) >> 5);
+		priv->write_reg(priv, REG_ID4, (id & 0x0000001f) << 3);
+	} else {
+		dreg = SFF_BUF;
+		priv->write_reg(priv, REG_FI, fi);
+		priv->write_reg(priv, REG_ID1, (id & 0x000007f8) >> 3);
+		priv->write_reg(priv, REG_ID2, (id & 0x00000007) << 5);
+	}
+
+	for (i = 0; i < dlc; i++)
+		priv->write_reg(priv, dreg++, cf->data[i]);
+
+	dev->trans_start = jiffies;
+
+	can_put_echo_skb(skb, dev, 0);
+
+	sja1000_write_cmdreg(priv, CMD_TR);
+
+	return NETDEV_TX_OK;
+}
+
+static void sja1000_rx(struct net_device *dev)
+{
+	struct sja1000_priv *priv = netdev_priv(dev);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,23)
+	struct net_device_stats *stats = can_get_stats(dev);
+#else
+	struct net_device_stats *stats = &dev->stats;
+#endif
+	struct can_frame *cf;
+	struct sk_buff *skb;
+	uint8_t fi;
+	uint8_t dreg;
+	canid_t id;
+	int i;
+
+	/* create zero'ed CAN frame buffer */
+	skb = alloc_can_skb(dev, &cf);
+	if (skb == NULL)
+		return;
+
+	fi = priv->read_reg(priv, REG_FI);
+
+	if (fi & FI_FF) {
+		/* extended frame format (EFF) */
+		dreg = EFF_BUF;
+		id = (priv->read_reg(priv, REG_ID1) << (5 + 16))
+		    | (priv->read_reg(priv, REG_ID2) << (5 + 8))
+		    | (priv->read_reg(priv, REG_ID3) << 5)
+		    | (priv->read_reg(priv, REG_ID4) >> 3);
+		id |= CAN_EFF_FLAG;
+	} else {
+		/* standard frame format (SFF) */
+		dreg = SFF_BUF;
+		id = (priv->read_reg(priv, REG_ID1) << 3)
+		    | (priv->read_reg(priv, REG_ID2) >> 5);
+	}
+
+	if (fi & FI_RTR) {
+		id |= CAN_RTR_FLAG;
+	} else {
+		cf->can_dlc = get_can_dlc(fi & 0x0F);
+		for (i = 0; i < cf->can_dlc; i++)
+			cf->data[i] = priv->read_reg(priv, dreg++);
+	}
+
+	cf->can_id = id;
+
+	/* release receive buffer */
+	sja1000_write_cmdreg(priv, CMD_RRB);
+
+	netif_rx(skb);
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,32)
+	dev->last_rx = jiffies;
+#endif
+	stats->rx_packets++;
+	stats->rx_bytes += cf->can_dlc;
+}
+
+static int sja1000_err(struct net_device *dev, uint8_t isrc, uint8_t status)
+{
+	struct sja1000_priv *priv = netdev_priv(dev);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,23)
+	struct net_device_stats *stats = can_get_stats(dev);
+#else
+	struct net_device_stats *stats = &dev->stats;
+#endif
+	struct can_frame *cf;
+	struct sk_buff *skb;
+	enum can_state state = priv->can.state;
+	uint8_t ecc, alc;
+
+	skb = alloc_can_err_skb(dev, &cf);
+	if (skb == NULL)
+		return -ENOMEM;
+
+	if (isrc & IRQ_DOI) {
+		/* data overrun interrupt */
+		dev_dbg(ND2D(dev), "data overrun interrupt\n");
+		cf->can_id |= CAN_ERR_CRTL;
+		cf->data[1] = CAN_ERR_CRTL_RX_OVERFLOW;
+		stats->rx_over_errors++;
+		stats->rx_errors++;
+		sja1000_write_cmdreg(priv, CMD_CDO);	/* clear bit */
+	}
+
+	if (isrc & IRQ_EI) {
+		/* error warning interrupt */
+		dev_dbg(ND2D(dev), "error warning interrupt\n");
+
+		if (status & SR_BS) {
+			state = CAN_STATE_BUS_OFF;
+			cf->can_id |= CAN_ERR_BUSOFF;
+			can_bus_off(dev);
+		} else if (status & SR_ES) {
+			state = CAN_STATE_ERROR_WARNING;
+		} else
+			state = CAN_STATE_ERROR_ACTIVE;
+	}
+	if (isrc & IRQ_BEI) {
+		/* bus error interrupt */
+		priv->can.can_stats.bus_error++;
+		stats->rx_errors++;
+
+		ecc = priv->read_reg(priv, REG_ECC);
+
+		cf->can_id |= CAN_ERR_PROT | CAN_ERR_BUSERROR;
+
+		switch (ecc & ECC_MASK) {
+		case ECC_BIT:
+			cf->data[2] |= CAN_ERR_PROT_BIT;
+			break;
+		case ECC_FORM:
+			cf->data[2] |= CAN_ERR_PROT_FORM;
+			break;
+		case ECC_STUFF:
+			cf->data[2] |= CAN_ERR_PROT_STUFF;
+			break;
+		default:
+			cf->data[2] |= CAN_ERR_PROT_UNSPEC;
+			cf->data[3] = ecc & ECC_SEG;
+			break;
+		}
+		/* Error occurred during transmission? */
+		if ((ecc & ECC_DIR) == 0)
+			cf->data[2] |= CAN_ERR_PROT_TX;
+	}
+	if (isrc & IRQ_EPI) {
+		/* error passive interrupt */
+		dev_dbg(ND2D(dev), "error passive interrupt\n");
+		if (status & SR_ES)
+			state = CAN_STATE_ERROR_PASSIVE;
+		else
+			state = CAN_STATE_ERROR_ACTIVE;
+	}
+	if (isrc & IRQ_ALI) {
+		/* arbitration lost interrupt */
+		dev_dbg(ND2D(dev), "arbitration lost interrupt\n");
+		alc = priv->read_reg(priv, REG_ALC);
+		priv->can.can_stats.arbitration_lost++;
+		stats->tx_errors++;
+		cf->can_id |= CAN_ERR_LOSTARB;
+		cf->data[0] = alc & 0x1f;
+	}
+
+	if (state != priv->can.state && (state == CAN_STATE_ERROR_WARNING ||
+					 state == CAN_STATE_ERROR_PASSIVE)) {
+		uint8_t rxerr = priv->read_reg(priv, REG_RXERR);
+		uint8_t txerr = priv->read_reg(priv, REG_TXERR);
+		cf->can_id |= CAN_ERR_CRTL;
+		if (state == CAN_STATE_ERROR_WARNING) {
+			priv->can.can_stats.error_warning++;
+			cf->data[1] = (txerr > rxerr) ?
+				CAN_ERR_CRTL_TX_WARNING :
+				CAN_ERR_CRTL_RX_WARNING;
+		} else {
+			priv->can.can_stats.error_passive++;
+			cf->data[1] = (txerr > rxerr) ?
+				CAN_ERR_CRTL_TX_PASSIVE :
+				CAN_ERR_CRTL_RX_PASSIVE;
+		}
+		cf->data[6] = txerr;
+		cf->data[7] = rxerr;
+	}
+
+	priv->can.state = state;
+
+	netif_rx(skb);
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,32)
+	dev->last_rx = jiffies;
+#endif
+	stats->rx_packets++;
+	stats->rx_bytes += cf->can_dlc;
+
+	return 0;
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,19)
+irqreturn_t sja1000_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+#else
+irqreturn_t sja1000_interrupt(int irq, void *dev_id)
+#endif
+{
+	struct net_device *dev = (struct net_device *)dev_id;
+	struct sja1000_priv *priv = netdev_priv(dev);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,23)
+	struct net_device_stats *stats = can_get_stats(dev);
+#else
+	struct net_device_stats *stats = &dev->stats;
+#endif
+	uint8_t isrc, status;
+	int n = 0;
+
+	/* Shared interrupts and IRQ off? */
+	if (priv->read_reg(priv, REG_IER) == IRQ_OFF)
+		return IRQ_NONE;
+
+	if (priv->pre_irq)
+		priv->pre_irq(priv);
+
+	while ((isrc = priv->read_reg(priv, REG_IR)) && (n < SJA1000_MAX_IRQ)) {
+		n++;
+		status = priv->read_reg(priv, REG_SR);
+
+		if (isrc & IRQ_WUI)
+			dev_warn(ND2D(dev), "wakeup interrupt\n");
+
+		if (isrc & IRQ_TI) {
+			/* transmission complete interrupt */
+			stats->tx_bytes += priv->read_reg(priv, REG_FI) & 0xf;
+			stats->tx_packets++;
+			can_get_echo_skb(dev, 0);
+			netif_wake_queue(dev);
+		}
+		if (isrc & IRQ_RI) {
+			/* receive interrupt */
+			while (status & SR_RBS) {
+				sja1000_rx(dev);
+				status = priv->read_reg(priv, REG_SR);
+			}
+		}
+		if (isrc & (IRQ_DOI | IRQ_EI | IRQ_BEI | IRQ_EPI | IRQ_ALI)) {
+			/* error interrupt */
+			if (sja1000_err(dev, isrc, status))
+				break;
+		}
+	}
+
+	if (priv->post_irq)
+		priv->post_irq(priv);
+
+	if (n >= SJA1000_MAX_IRQ)
+		dev_dbg(ND2D(dev), "%d messages handled in ISR", n);
+
+	return (n) ? IRQ_HANDLED : IRQ_NONE;
+}
+EXPORT_SYMBOL_GPL(sja1000_interrupt);
+
+static int sja1000_open(struct net_device *dev)
+{
+	struct sja1000_priv *priv = netdev_priv(dev);
+	int err;
+
+	/* set chip into reset mode */
+	set_reset_mode(dev);
+
+	/* common open */
+	err = open_candev(dev);
+	if (err)
+		return err;
+
+	/* register interrupt handler, if not done by the device driver */
+	if (!(priv->flags & SJA1000_CUSTOM_IRQ_HANDLER)) {
+		err = request_irq(dev->irq, sja1000_interrupt, priv->irq_flags,
+				  dev->name, (void *)dev);
+		if (err) {
+			close_candev(dev);
+			return -EAGAIN;
+		}
+	}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,23)
+	/* clear statistics */
+	memset(&priv->can.net_stats, 0, sizeof(priv->can.net_stats));
+#endif
+
+	/* init and start chi */
+	sja1000_start(dev);
+	priv->open_time = jiffies;
+
+	netif_start_queue(dev);
+
+	return 0;
+}
+
+static int sja1000_close(struct net_device *dev)
+{
+	struct sja1000_priv *priv = netdev_priv(dev);
+
+	netif_stop_queue(dev);
+	set_reset_mode(dev);
+
+	if (!(priv->flags & SJA1000_CUSTOM_IRQ_HANDLER))
+		free_irq(dev->irq, (void *)dev);
+
+	close_candev(dev);
+
+	priv->open_time = 0;
+
+	return 0;
+}
+
+struct net_device *alloc_sja1000dev(int sizeof_priv)
+{
+	struct net_device *dev;
+	struct sja1000_priv *priv;
+
+	dev = alloc_candev(sizeof(struct sja1000_priv) + sizeof_priv,
+		SJA1000_ECHO_SKB_MAX);
+	if (!dev)
+		return NULL;
+
+	priv = netdev_priv(dev);
+
+	priv->dev = dev;
+	priv->can.bittiming_const = &sja1000_bittiming_const;
+	priv->can.do_set_bittiming = sja1000_set_bittiming;
+	priv->can.do_set_mode = sja1000_set_mode;
+	priv->can.do_get_berr_counter = sja1000_get_berr_counter;
+	priv->can.ctrlmode_supported = CAN_CTRLMODE_3_SAMPLES |
+		CAN_CTRLMODE_BERR_REPORTING;
+
+	spin_lock_init(&priv->cmdreg_lock);
+
+	if (sizeof_priv)
+		priv->priv = (void *)priv + sizeof(struct sja1000_priv);
+
+	return dev;
+}
+EXPORT_SYMBOL_GPL(alloc_sja1000dev);
+
+void free_sja1000dev(struct net_device *dev)
+{
+	free_candev(dev);
+}
+EXPORT_SYMBOL_GPL(free_sja1000dev);
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,28)
+static const struct net_device_ops sja1000_netdev_ops = {
+	.ndo_open = sja1000_open,
+	.ndo_stop = sja1000_close,
+	.ndo_start_xmit = sja1000_start_xmit,
+};
+#endif
+
+int register_sja1000dev(struct net_device *dev)
+{
+	if (!sja1000_probe_chip(dev))
+		return -ENODEV;
+
+	dev->flags |= IFF_ECHO;	/* we support local echo */
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,28)
+	dev->netdev_ops = &sja1000_netdev_ops;
+#else
+	dev->open = sja1000_open;
+	dev->stop = sja1000_close;
+	dev->hard_start_xmit = sja1000_start_xmit;
+#endif
+
+	set_reset_mode(dev);
+	chipset_init(dev);
+
+	return register_candev(dev);
+}
+EXPORT_SYMBOL_GPL(register_sja1000dev);
+
+void unregister_sja1000dev(struct net_device *dev)
+{
+	set_reset_mode(dev);
+	unregister_candev(dev);
+}
+EXPORT_SYMBOL_GPL(unregister_sja1000dev);
+
+static __init int sja1000_init(void)
+{
+	printk(KERN_INFO "%s CAN netdevice driver\n", DRV_NAME);
+
+	return 0;
+}
+
+module_init(sja1000_init);
+
+static __exit void sja1000_exit(void)
+{
+	printk(KERN_INFO "%s: driver removed\n", DRV_NAME);
+}
+
+module_exit(sja1000_exit);
diff --exclude CVS --exclude .git -uNr linux-2.6.27.8/drivers/net/can/sja1000/sja1000.h linux-2.6.27.8.modified/drivers/net/can/sja1000/sja1000.h
--- linux-2.6.27.8/drivers/net/can/sja1000/sja1000.h	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.27.8.modified/drivers/net/can/sja1000/sja1000.h	2013-05-30 03:44:18.000000000 -0400
@@ -0,0 +1,189 @@
+/*
+ * sja1000.h -  Philips SJA1000 network device driver
+ *
+ * Copyright (c) 2003 Matthias Brukner, Trajet Gmbh, Rebenring 33,
+ * 38106 Braunschweig, GERMANY
+ *
+ * Copyright (c) 2002-2007 Volkswagen Group Electronic Research
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of Volkswagen nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * Alternatively, provided that this notice is retained in full, this
+ * software may be distributed under the terms of the GNU General
+ * Public License ("GPL") version 2, in which case the provisions of the
+ * GPL apply INSTEAD OF those given above.
+ *
+ * The provided data structures and external interfaces from this code
+ * are not restricted to be used by modules with a GPL compatible license.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * Send feedback to <socketcan-users@lists.berlios.de>
+ *
+ */
+
+#ifndef SJA1000_DEV_H
+#define SJA1000_DEV_H
+
+#include <socketcan/can/dev.h>
+#include <socketcan/can/platform/sja1000.h>
+
+#define SJA1000_ECHO_SKB_MAX	1 /* the SJA1000 has one TX buffer object */
+
+#define SJA1000_MAX_IRQ 20	/* max. number of interrupts handled in ISR */
+
+/* SJA1000 registers - manual section 6.4 (Pelican Mode) */
+#define REG_MOD		0x00
+#define REG_CMR		0x01
+#define REG_SR		0x02
+#define REG_IR		0x03
+#define REG_IER		0x04
+#define REG_ALC		0x0B
+#define REG_ECC		0x0C
+#define REG_EWL		0x0D
+#define REG_RXERR	0x0E
+#define REG_TXERR	0x0F
+#define REG_ACCC0	0x10
+#define REG_ACCC1	0x11
+#define REG_ACCC2	0x12
+#define REG_ACCC3	0x13
+#define REG_ACCM0	0x14
+#define REG_ACCM1	0x15
+#define REG_ACCM2	0x16
+#define REG_ACCM3	0x17
+#define REG_RMC		0x1D
+#define REG_RBSA	0x1E
+
+/* Common registers - manual section 6.5 */
+#define REG_BTR0	0x06
+#define REG_BTR1	0x07
+#define REG_OCR		0x08
+#define REG_CDR		0x1F
+
+#define REG_FI		0x10
+#define SFF_BUF		0x13
+#define EFF_BUF		0x15
+
+#define FI_FF		0x80
+#define FI_RTR		0x40
+
+#define REG_ID1		0x11
+#define REG_ID2		0x12
+#define REG_ID3		0x13
+#define REG_ID4		0x14
+
+#define CAN_RAM		0x20
+
+/* mode register */
+#define MOD_RM		0x01
+#define MOD_LOM		0x02
+#define MOD_STM		0x04
+#define MOD_AFM		0x08
+#define MOD_SM		0x10
+
+/* commands */
+#define CMD_SRR		0x10
+#define CMD_CDO		0x08
+#define CMD_RRB		0x04
+#define CMD_AT		0x02
+#define CMD_TR		0x01
+
+/* interrupt sources */
+#define IRQ_BEI		0x80
+#define IRQ_ALI		0x40
+#define IRQ_EPI		0x20
+#define IRQ_WUI		0x10
+#define IRQ_DOI		0x08
+#define IRQ_EI		0x04
+#define IRQ_TI		0x02
+#define IRQ_RI		0x01
+#define IRQ_ALL		0xFF
+#define IRQ_OFF		0x00
+
+/* status register content */
+#define SR_BS		0x80
+#define SR_ES		0x40
+#define SR_TS		0x20
+#define SR_RS		0x10
+#define SR_TCS		0x08
+#define SR_TBS		0x04
+#define SR_DOS		0x02
+#define SR_RBS		0x01
+
+#define SR_CRIT (SR_BS|SR_ES)
+
+/* ECC register */
+#define ECC_SEG		0x1F
+#define ECC_DIR		0x20
+#define ECC_ERR		6
+#define ECC_BIT		0x00
+#define ECC_FORM	0x40
+#define ECC_STUFF	0x80
+#define ECC_MASK	0xc0
+
+/*
+ * Flags for sja1000priv.flags
+ */
+#define SJA1000_CUSTOM_IRQ_HANDLER 0x1
+
+/*
+ * SJA1000 private data structure
+ */
+struct sja1000_priv {
+	struct can_priv can;	/* must be the first member */
+	int open_time;
+	struct sk_buff *echo_skb;
+
+	/* the lower-layer is responsible for appropriate locking */
+	u8 (*read_reg) (const struct sja1000_priv *priv, int reg);
+	void (*write_reg) (const struct sja1000_priv *priv, int reg, u8 val);
+	void (*pre_irq) (const struct sja1000_priv *priv);
+	void (*post_irq) (const struct sja1000_priv *priv);
+
+	void *priv;		/* for board-specific data */
+	struct net_device *dev;
+
+	void __iomem *reg_base;	 /* ioremap'ed address to registers */
+	unsigned long irq_flags; /* for request_irq() */
+	spinlock_t cmdreg_lock;  /* lock for concurrent cmd register writes */
+
+
+	u16 flags;		/* custom mode flags */
+	u8 ocr;			/* output control register */
+	u8 cdr;			/* clock divider register */
+};
+
+struct net_device *alloc_sja1000dev(int sizeof_priv);
+void free_sja1000dev(struct net_device *dev);
+int register_sja1000dev(struct net_device *dev);
+void unregister_sja1000dev(struct net_device *dev);
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,19)
+irqreturn_t sja1000_interrupt(int irq, void *dev_id, struct pt_regs *regs);
+#else
+irqreturn_t sja1000_interrupt(int irq, void *dev_id);
+#endif
+
+#endif /* SJA1000_DEV_H */
diff --exclude CVS --exclude .git -uNr linux-2.6.27.8/drivers/net/can/sja1000/sja1000_isa.c linux-2.6.27.8.modified/drivers/net/can/sja1000/sja1000_isa.c
--- linux-2.6.27.8/drivers/net/can/sja1000/sja1000_isa.c	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.27.8.modified/drivers/net/can/sja1000/sja1000_isa.c	2013-05-30 03:44:18.000000000 -0400
@@ -0,0 +1,294 @@
+/*
+ * Copyright (C) 2009 Wolfgang Grandegger <wg@grandegger.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the version 2 of the GNU General Public License
+ * as published by the Free Software Foundation
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/kernel.h>
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/isa.h>
+#include <linux/interrupt.h>
+#include <linux/netdevice.h>
+#include <linux/delay.h>
+#include <linux/irq.h>
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,16)
+#include <linux/io.h>
+#else
+#include <asm/io.h>
+#endif
+#include <socketcan/can.h>
+#include <socketcan/can/dev.h>
+#include <socketcan/can/platform/sja1000.h>
+
+#include "sja1000.h"
+
+#define DRV_NAME "sja1000_isa"
+
+#define MAXDEV 8
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,16)
+#error This driver does not support Kernel versions < 2.6.16
+#endif
+
+MODULE_AUTHOR("Wolfgang Grandegger <wg@grandegger.com>");
+MODULE_DESCRIPTION("Socket-CAN driver for SJA1000 on the ISA bus");
+MODULE_LICENSE("GPL v2");
+
+#define CLK_DEFAULT	16000000	/* 16 MHz */
+#define CDR_DEFAULT	(CDR_CBP | CDR_CLK_OFF)
+#define OCR_DEFAULT	OCR_TX0_PUSHPULL
+
+static unsigned long port[MAXDEV];
+static unsigned long mem[MAXDEV];
+static int __devinitdata irq[MAXDEV];
+static int __devinitdata clk[MAXDEV];
+static char __devinitdata cdr[MAXDEV] = {[0 ... (MAXDEV - 1)] = -1};
+static char __devinitdata ocr[MAXDEV] = {[0 ... (MAXDEV - 1)] = -1};
+static char __devinitdata indirect[MAXDEV] = {[0 ... (MAXDEV - 1)] = -1};
+
+module_param_array(port, ulong, NULL, S_IRUGO);
+MODULE_PARM_DESC(port, "I/O port number");
+
+module_param_array(mem, ulong, NULL, S_IRUGO);
+MODULE_PARM_DESC(mem, "I/O memory address");
+
+module_param_array(indirect, byte, NULL, S_IRUGO);
+MODULE_PARM_DESC(indirect, "Indirect access via address and data port");
+
+module_param_array(irq, int, NULL, S_IRUGO);
+MODULE_PARM_DESC(irq, "IRQ number");
+
+module_param_array(clk, int, NULL, S_IRUGO);
+MODULE_PARM_DESC(clk, "External oscillator clock frequency "
+		 "(default=16000000 [16 MHz])");
+
+module_param_array(cdr, byte, NULL, S_IRUGO);
+MODULE_PARM_DESC(cdr, "Clock divider register "
+		 "(default=0x48 [CDR_CBP | CDR_CLK_OFF])");
+
+module_param_array(ocr, byte, NULL, S_IRUGO);
+MODULE_PARM_DESC(ocr, "Output control register "
+		 "(default=0x18 [OCR_TX0_PUSHPULL])");
+
+#define SJA1000_IOSIZE          0x20
+#define SJA1000_IOSIZE_INDIRECT 0x02
+
+static u8 sja1000_isa_mem_read_reg(const struct sja1000_priv *priv, int reg)
+{
+	return readb(priv->reg_base + reg);
+}
+
+static void sja1000_isa_mem_write_reg(const struct sja1000_priv *priv,
+				      int reg, u8 val)
+{
+	writeb(val, priv->reg_base + reg);
+}
+
+static u8 sja1000_isa_port_read_reg(const struct sja1000_priv *priv, int reg)
+{
+	return inb((unsigned long)priv->reg_base + reg);
+}
+
+static void sja1000_isa_port_write_reg(const struct sja1000_priv *priv,
+				       int reg, u8 val)
+{
+	outb(val, (unsigned long)priv->reg_base + reg);
+}
+
+static u8 sja1000_isa_port_read_reg_indirect(const struct sja1000_priv *priv,
+					     int reg)
+{
+	unsigned long base = (unsigned long)priv->reg_base;
+
+	outb(reg, base);
+	return inb(base + 1);
+}
+
+static void sja1000_isa_port_write_reg_indirect(const struct sja1000_priv *priv,
+						int reg, u8 val)
+{
+	unsigned long base = (unsigned long)priv->reg_base;
+
+	outb(reg, base);
+	outb(val, base + 1);
+}
+
+static int __devinit sja1000_isa_match(struct device *pdev, unsigned int idx)
+{
+	if (port[idx] || mem[idx]) {
+		if (irq[idx])
+			return 1;
+	} else if (idx)
+		return 0;
+
+	dev_err(pdev, "insufficient parameters supplied\n");
+	return 0;
+}
+
+static int __devinit sja1000_isa_probe(struct device *pdev, unsigned int idx)
+{
+	struct net_device *dev;
+	struct sja1000_priv *priv;
+	void __iomem *base = NULL;
+	int iosize = SJA1000_IOSIZE;
+	int err;
+
+	if (mem[idx]) {
+		if (!request_mem_region(mem[idx], iosize, DRV_NAME)) {
+			err = -EBUSY;
+			goto exit;
+		}
+		base = ioremap_nocache(mem[idx], iosize);
+		if (!base) {
+			err = -ENOMEM;
+			goto exit_release;
+		}
+	} else {
+		if (indirect[idx] > 0 ||
+		    (indirect[idx] == -1 && indirect[0] > 0))
+			iosize = SJA1000_IOSIZE_INDIRECT;
+		if (!request_region(port[idx], iosize, DRV_NAME)) {
+			err = -EBUSY;
+			goto exit;
+		}
+	}
+
+	dev = alloc_sja1000dev(0);
+	if (!dev) {
+		err = -ENOMEM;
+		goto exit_unmap;
+	}
+	priv = netdev_priv(dev);
+
+	dev->irq = irq[idx];
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,18)
+	priv->irq_flags = SA_SHIRQ;
+#else
+	priv->irq_flags = IRQF_SHARED;
+#endif
+	if (mem[idx]) {
+		priv->reg_base = base;
+		dev->base_addr = mem[idx];
+		priv->read_reg = sja1000_isa_mem_read_reg;
+		priv->write_reg = sja1000_isa_mem_write_reg;
+	} else {
+		priv->reg_base = (void __iomem *)port[idx];
+		dev->base_addr = port[idx];
+
+		if (iosize == SJA1000_IOSIZE_INDIRECT) {
+			priv->read_reg = sja1000_isa_port_read_reg_indirect;
+			priv->write_reg = sja1000_isa_port_write_reg_indirect;
+		} else {
+			priv->read_reg = sja1000_isa_port_read_reg;
+			priv->write_reg = sja1000_isa_port_write_reg;
+		}
+	}
+
+	if (clk[idx])
+		priv->can.clock.freq = clk[idx] / 2;
+	else if (clk[0])
+		priv->can.clock.freq = clk[0] / 2;
+	else
+		priv->can.clock.freq = CLK_DEFAULT / 2;
+
+	if (ocr[idx] != -1)
+		priv->ocr = ocr[idx] & 0xff;
+	else if (ocr[0] != -1)
+		priv->ocr = ocr[0] & 0xff;
+	else
+		priv->ocr = OCR_DEFAULT;
+
+	if (cdr[idx] != -1)
+		priv->cdr = cdr[idx] & 0xff;
+	else if (cdr[0] != -1)
+		priv->cdr = cdr[0] & 0xff;
+	else
+		priv->cdr = CDR_DEFAULT;
+
+	dev_set_drvdata(pdev, dev);
+	SET_NETDEV_DEV(dev, pdev);
+
+	err = register_sja1000dev(dev);
+	if (err) {
+		dev_err(pdev, "registering %s failed (err=%d)\n",
+			DRV_NAME, err);
+		goto exit_unmap;
+	}
+
+	dev_info(pdev, "%s device registered (reg_base=0x%p, irq=%d)\n",
+		 DRV_NAME, priv->reg_base, dev->irq);
+	return 0;
+
+ exit_unmap:
+	if (mem[idx])
+		iounmap(base);
+ exit_release:
+	if (mem[idx])
+		release_mem_region(mem[idx], iosize);
+	else
+		release_region(port[idx], iosize);
+ exit:
+	return err;
+}
+
+static int __devexit sja1000_isa_remove(struct device *pdev, unsigned int idx)
+{
+	struct net_device *dev = dev_get_drvdata(pdev);
+	struct sja1000_priv *priv = netdev_priv(dev);
+
+	unregister_sja1000dev(dev);
+	dev_set_drvdata(pdev, NULL);
+
+	if (mem[idx]) {
+		iounmap(priv->reg_base);
+		release_mem_region(mem[idx], SJA1000_IOSIZE);
+	} else {
+		if (priv->read_reg == sja1000_isa_port_read_reg_indirect)
+			release_region(port[idx], SJA1000_IOSIZE_INDIRECT);
+		else
+			release_region(port[idx], SJA1000_IOSIZE);
+	}
+	free_sja1000dev(dev);
+
+	return 0;
+}
+
+static struct isa_driver sja1000_isa_driver = {
+	.match = sja1000_isa_match,
+	.probe = sja1000_isa_probe,
+	.remove = __devexit_p(sja1000_isa_remove),
+	.driver = {
+		.name = DRV_NAME,
+	},
+};
+
+static int __init sja1000_isa_init(void)
+{
+	int err = isa_register_driver(&sja1000_isa_driver, MAXDEV);
+
+	if (!err)
+		printk(KERN_INFO
+		       "Legacy %s driver for max. %d devices registered\n",
+		       DRV_NAME, MAXDEV);
+	return err;
+}
+
+static void __exit sja1000_isa_exit(void)
+{
+	isa_unregister_driver(&sja1000_isa_driver);
+}
+
+module_init(sja1000_isa_init);
+module_exit(sja1000_isa_exit);
diff --exclude CVS --exclude .git -uNr linux-2.6.27.8/drivers/net/can/sja1000/sja1000_of_platform.c linux-2.6.27.8.modified/drivers/net/can/sja1000/sja1000_of_platform.c
--- linux-2.6.27.8/drivers/net/can/sja1000/sja1000_of_platform.c	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.27.8.modified/drivers/net/can/sja1000/sja1000_of_platform.c	2013-05-30 03:44:18.000000000 -0400
@@ -0,0 +1,260 @@
+/*
+ * Driver for SJA1000 CAN controllers on the OpenFirmware platform bus
+ *
+ * Copyright (C) 2008-2009 Wolfgang Grandegger <wg@grandegger.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the version 2 of the GNU General Public License
+ * as published by the Free Software Foundation
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+/* This is a generic driver for SJA1000 chips on the OpenFirmware platform
+ * bus found on embedded PowerPC systems. You need a SJA1000 CAN node
+ * definition in your flattened device tree source (DTS) file similar to:
+ *
+ *   can@3,100 {
+ *           compatible = "nxp,sja1000";
+ *           reg = <3 0x100 0x80>;
+ *           interrupts = <2 0>;
+ *           interrupt-parent = <&mpic>;
+ *           nxp,external-clock-frequency = <16000000>;
+ *   };
+ *
+ * See "Documentation/powerpc/dts-bindings/can/sja1000.txt" for further
+ * information.
+ */
+
+#include <linux/kernel.h>
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/interrupt.h>
+#include <linux/netdevice.h>
+#include <linux/delay.h>
+#include <socketcan/can.h>
+#include <socketcan/can/dev.h>
+
+#include <linux/of_platform.h>
+#include <asm/prom.h>
+
+#include "sja1000.h"
+
+#define DRV_NAME "sja1000_of_platform"
+
+MODULE_AUTHOR("Wolfgang Grandegger <wg@grandegger.com>");
+MODULE_DESCRIPTION("Socket-CAN driver for SJA1000 on the OF platform bus");
+MODULE_LICENSE("GPL v2");
+
+#define SJA1000_OFP_CAN_CLOCK  (16000000 / 2)
+
+#define SJA1000_OFP_OCR        OCR_TX0_PULLDOWN
+#define SJA1000_OFP_CDR        (CDR_CBP | CDR_CLK_OFF)
+
+static u8 sja1000_ofp_read_reg(const struct sja1000_priv *priv, int reg)
+{
+	return in_8(priv->reg_base + reg);
+}
+
+static void sja1000_ofp_write_reg(const struct sja1000_priv *priv,
+				  int reg, u8 val)
+{
+	out_8(priv->reg_base + reg, val);
+}
+
+static int __devexit sja1000_ofp_remove(struct of_device *ofdev)
+{
+	struct net_device *dev = dev_get_drvdata(&ofdev->dev);
+	struct sja1000_priv *priv = netdev_priv(dev);
+	struct device_node *np = ofdev->node;
+	struct resource res;
+
+	dev_set_drvdata(&ofdev->dev, NULL);
+
+	unregister_sja1000dev(dev);
+	free_sja1000dev(dev);
+	iounmap(priv->reg_base);
+	irq_dispose_mapping(dev->irq);
+
+	of_address_to_resource(np, 0, &res);
+	release_mem_region(res.start, resource_size(&res));
+
+	return 0;
+}
+
+static int __devinit sja1000_ofp_probe(struct of_device *ofdev,
+				       const struct of_device_id *id)
+{
+	struct device_node *np = ofdev->node;
+	struct net_device *dev;
+	struct sja1000_priv *priv;
+	struct resource res;
+	const u32 *prop;
+	int err, irq, res_size, prop_size;
+	void __iomem *base;
+
+	err = of_address_to_resource(np, 0, &res);
+	if (err) {
+		dev_err(&ofdev->dev, "invalid address\n");
+		return err;
+	}
+
+	res_size = resource_size(&res);
+
+	if (!request_mem_region(res.start, res_size, DRV_NAME)) {
+		dev_err(&ofdev->dev, "couldn't request %#llx..%#llx\n",
+			(unsigned long long)res.start,
+			(unsigned long long)res.end);
+		return -EBUSY;
+	}
+
+	base = ioremap_nocache(res.start, res_size);
+	if (!base) {
+		dev_err(&ofdev->dev, "couldn't ioremap %#llx..%#llx\n",
+			(unsigned long long)res.start,
+			(unsigned long long)res.end);
+		err = -ENOMEM;
+		goto exit_release_mem;
+	}
+
+	irq = irq_of_parse_and_map(np, 0);
+	if (irq == NO_IRQ) {
+		dev_err(&ofdev->dev, "no irq found\n");
+		err = -ENODEV;
+		goto exit_unmap_mem;
+	}
+
+	dev = alloc_sja1000dev(0);
+	if (!dev) {
+		err = -ENOMEM;
+		goto exit_dispose_irq;
+	}
+
+	priv = netdev_priv(dev);
+
+	priv->read_reg = sja1000_ofp_read_reg;
+	priv->write_reg = sja1000_ofp_write_reg;
+
+	/* backward compatibility */
+	prop = of_get_property(np, "clock-frequency", &prop_size);
+	if (!prop)
+		prop = of_get_property(np, "nxp,external-clock-frequency",
+				       &prop_size);
+
+	if (prop && (prop_size ==  sizeof(u32)))
+		priv->can.clock.freq = *prop / 2;
+	else
+		priv->can.clock.freq = SJA1000_OFP_CAN_CLOCK; /* default */
+
+	/* backward compatibility */
+	prop = of_get_property(np, "ocr-reg", &prop_size);
+	if (prop && (prop_size == sizeof(u32))) {
+		priv->ocr = (u8)*prop;
+	} else {
+
+		prop = of_get_property(np, "nxp,tx-output-mode", &prop_size);
+		if (prop && (prop_size == sizeof(u32)))
+			priv->ocr |= *prop & OCR_MODE_MASK;
+		else
+			priv->ocr |= OCR_MODE_NORMAL; /* default */
+
+		prop = of_get_property(np, "nxp,tx-output-config", &prop_size);
+		if (prop && (prop_size == sizeof(u32)))
+			priv->ocr |= (*prop << OCR_TX_SHIFT) & OCR_TX_MASK;
+		else
+			priv->ocr |= OCR_TX0_PULLDOWN; /* default */
+	}
+
+	/* backward compatibility */
+	prop = of_get_property(np, "cdr-reg", &prop_size);
+	if (prop && (prop_size == sizeof(u32))) {
+		priv->cdr = (u8)*prop;
+	} else {
+		prop = of_get_property(np, "nxp,clock-out-frequency",
+				       &prop_size);
+		if (prop && (prop_size == sizeof(u32)) && *prop) {
+			u32 divider = priv->can.clock.freq * 2 / *prop;
+
+			if (divider > 1)
+				priv->cdr |= divider / 2 - 1;
+			else
+				priv->cdr |= CDR_CLKOUT_MASK;
+		} else {
+			priv->cdr |= CDR_CLK_OFF; /* default */
+		}
+
+		prop = of_get_property(np, "nxp,no-comparator-bypass", NULL);
+		if (!prop)
+			priv->cdr |= CDR_CBP; /* default */
+	}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,18)
+	priv->irq_flags = SA_SHIRQ;
+#else
+	priv->irq_flags = IRQF_SHARED;
+#endif
+	priv->reg_base = base;
+
+	dev->irq = irq;
+
+	dev_info(&ofdev->dev,
+		 "reg_base=0x%p irq=%d clock=%d ocr=0x%02x cdr=0x%02x\n",
+		 priv->reg_base, dev->irq, priv->can.clock.freq,
+		 priv->ocr, priv->cdr);
+
+	dev_set_drvdata(&ofdev->dev, dev);
+	SET_NETDEV_DEV(dev, &ofdev->dev);
+
+	err = register_sja1000dev(dev);
+	if (err) {
+		dev_err(&ofdev->dev, "registering %s failed (err=%d)\n",
+			DRV_NAME, err);
+		goto exit_free_sja1000;
+	}
+
+	return 0;
+
+exit_free_sja1000:
+	free_sja1000dev(dev);
+exit_dispose_irq:
+	irq_dispose_mapping(irq);
+exit_unmap_mem:
+	iounmap(base);
+exit_release_mem:
+	release_mem_region(res.start, res_size);
+
+	return err;
+}
+
+static struct of_device_id __devinitdata sja1000_ofp_table[] = {
+	{.compatible = "philips,sja1000"},
+	{.compatible = "nxp,sja1000"},
+	{},
+};
+
+static struct of_platform_driver sja1000_ofp_driver = {
+	.owner = THIS_MODULE,
+	.name = DRV_NAME,
+	.probe = sja1000_ofp_probe,
+	.remove = __devexit_p(sja1000_ofp_remove),
+	.match_table = sja1000_ofp_table,
+};
+
+static int __init sja1000_ofp_init(void)
+{
+	return of_register_platform_driver(&sja1000_ofp_driver);
+}
+module_init(sja1000_ofp_init);
+
+static void __exit sja1000_ofp_exit(void)
+{
+	return of_unregister_platform_driver(&sja1000_ofp_driver);
+};
+module_exit(sja1000_ofp_exit);
diff --exclude CVS --exclude .git -uNr linux-2.6.27.8/drivers/net/can/sja1000/sja1000_platform.c linux-2.6.27.8.modified/drivers/net/can/sja1000/sja1000_platform.c
--- linux-2.6.27.8/drivers/net/can/sja1000/sja1000_platform.c	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.27.8.modified/drivers/net/can/sja1000/sja1000_platform.c	2013-05-30 03:44:18.000000000 -0400
@@ -0,0 +1,170 @@
+/*
+ * Copyright (C) 2005 Sascha Hauer, Pengutronix
+ * Copyright (C) 2007 Wolfgang Grandegger <wg@grandegger.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the version 2 of the GNU General Public License
+ * as published by the Free Software Foundation
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/kernel.h>
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/interrupt.h>
+#include <linux/netdevice.h>
+#include <linux/delay.h>
+#include <linux/pci.h>
+#include <linux/platform_device.h>
+#include <linux/irq.h>
+#include <socketcan/can.h>
+#include <socketcan/can/dev.h>
+#include <socketcan/can/platform/sja1000.h>
+#include <linux/io.h>
+
+#include "sja1000.h"
+
+#define DRV_NAME "sja1000_platform"
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,27)
+#error This driver does not support Kernel versions < 2.6.27
+#endif
+
+MODULE_AUTHOR("Sascha Hauer <s.hauer@pengutronix.de>");
+MODULE_DESCRIPTION("Socket-CAN driver for SJA1000 on the platform bus");
+MODULE_LICENSE("GPL v2");
+
+static u8 sp_read_reg(const struct sja1000_priv *priv, int reg)
+{
+	return ioread8(priv->reg_base + reg);
+}
+
+static void sp_write_reg(const struct sja1000_priv *priv, int reg, u8 val)
+{
+	iowrite8(val, priv->reg_base + reg);
+}
+
+static int sp_probe(struct platform_device *pdev)
+{
+	int err;
+	void __iomem *addr;
+	struct net_device *dev;
+	struct sja1000_priv *priv;
+	struct resource *res_mem, *res_irq;
+	struct sja1000_platform_data *pdata;
+
+	pdata = pdev->dev.platform_data;
+	if (!pdata) {
+		dev_err(&pdev->dev, "No platform data provided!\n");
+		err = -ENODEV;
+		goto exit;
+	}
+
+	res_mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	res_irq = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
+	if (!res_mem || !res_irq) {
+		err = -ENODEV;
+		goto exit;
+	}
+
+	if (!request_mem_region(res_mem->start, resource_size(res_mem),
+				DRV_NAME)) {
+		err = -EBUSY;
+		goto exit;
+	}
+
+	addr = ioremap_nocache(res_mem->start, resource_size(res_mem));
+	if (!addr) {
+		err = -ENOMEM;
+		goto exit_release;
+	}
+
+	dev = alloc_sja1000dev(0);
+	if (!dev) {
+		err = -ENOMEM;
+		goto exit_iounmap;
+	}
+	priv = netdev_priv(dev);
+
+	dev->irq = res_irq->start;
+	priv->irq_flags = res_irq->flags & IRQF_TRIGGER_MASK;
+	priv->reg_base = addr;
+	priv->read_reg = sp_read_reg;
+	priv->write_reg = sp_write_reg;
+	priv->can.clock.freq = pdata->clock;
+	priv->ocr = pdata->ocr;
+	priv->cdr = pdata->cdr;
+
+	dev_set_drvdata(&pdev->dev, dev);
+	SET_NETDEV_DEV(dev, &pdev->dev);
+
+	err = register_sja1000dev(dev);
+	if (err) {
+		dev_err(&pdev->dev, "registering %s failed (err=%d)\n",
+			DRV_NAME, err);
+		goto exit_free;
+	}
+
+	dev_info(&pdev->dev, "%s device registered (reg_base=%p, irq=%d)\n",
+		 DRV_NAME, priv->reg_base, dev->irq);
+	return 0;
+
+ exit_free:
+	free_sja1000dev(dev);
+ exit_iounmap:
+	iounmap(addr);
+ exit_release:
+	release_mem_region(res_mem->start, resource_size(res_mem));
+ exit:
+	return err;
+}
+
+static int sp_remove(struct platform_device *pdev)
+{
+	struct net_device *dev = dev_get_drvdata(&pdev->dev);
+	struct sja1000_priv *priv = netdev_priv(dev);
+	struct resource *res;
+
+	unregister_sja1000dev(dev);
+	dev_set_drvdata(&pdev->dev, NULL);
+
+	if (priv->reg_base)
+		iounmap(priv->reg_base);
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	release_mem_region(res->start, resource_size(res));
+
+	free_sja1000dev(dev);
+
+	return 0;
+}
+
+static struct platform_driver sp_driver = {
+	.probe = sp_probe,
+	.remove = sp_remove,
+	.driver = {
+		.name = DRV_NAME,
+		.owner = THIS_MODULE,
+	},
+};
+
+static int __init sp_init(void)
+{
+	return platform_driver_register(&sp_driver);
+}
+
+static void __exit sp_exit(void)
+{
+	platform_driver_unregister(&sp_driver);
+}
+
+module_init(sp_init);
+module_exit(sp_exit);
diff --exclude CVS --exclude .git -uNr linux-2.6.27.8/drivers/net/can/slcan.c linux-2.6.27.8.modified/drivers/net/can/slcan.c
--- linux-2.6.27.8/drivers/net/can/slcan.c	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.27.8.modified/drivers/net/can/slcan.c	2013-05-30 03:44:17.000000000 -0400
@@ -0,0 +1,986 @@
+/*
+ * slcan.c - serial line CAN interface driver (using tty line discipline)
+ *
+ * This file is derived from linux/drivers/net/slip.c
+ *
+ * slip.c Authors  : Laurence Culhane <loz@holmes.demon.co.uk>
+ *                   Fred N. van Kempen <waltje@uwalt.nl.mugnet.org>
+ * slcan.c Author  : Oliver Hartkopp <socketcan@hartkopp.net>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 59 Temple Place, Suite 330, Boston, MA 02111-1307. You can also get it
+ * at http://www.gnu.org/licenses/gpl.html
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * Send feedback to <socketcan-users@lists.berlios.de>
+ *
+ */
+
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+
+#include <asm/system.h>
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,17)
+#include <linux/uaccess.h>
+#else
+#include <asm/uaccess.h>
+#endif
+#include <linux/bitops.h>
+#include <linux/string.h>
+#include <linux/tty.h>
+#include <linux/errno.h>
+#include <linux/netdevice.h>
+#include <linux/skbuff.h>
+#include <linux/rtnetlink.h>
+#include <linux/if_arp.h>
+#include <linux/if_ether.h>
+#include <linux/sched.h>
+#include <linux/delay.h>
+#include <linux/init.h>
+#include <socketcan/can.h>
+
+#include <socketcan/can/version.h> /* for RCSID. Removed by mkpatch script */
+RCSID("$Id: slcan.c 1224 2010-12-09 18:03:47Z hartkopp $");
+
+static __initdata const char banner[] =
+	KERN_INFO "slcan: serial line CAN interface driver\n";
+
+MODULE_ALIAS_LDISC(N_SLCAN);
+MODULE_DESCRIPTION("serial line CAN interface");
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Oliver Hartkopp <socketcan@hartkopp.net>");
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,14)
+static inline void *kzalloc(size_t size, unsigned int __nocast flags)
+{
+	void *ret = kmalloc(size, flags);
+	if (ret)
+		memset(ret, 0, size);
+	return ret;
+}
+#endif
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,25)
+#ifndef N_SLCAN
+#error Your kernel does not support tty line discipline N_SLCAN
+#endif
+/*
+ * As there is currently no line discipline N_SLCAN in the mainstream kernel
+ * you will have to modify two kernel includes & recompile the kernel.
+ *
+ * Add this in include/asm/termios.h after the definition of N_HCI:
+ *        #define N_SLCAN         16
+ *
+ * Increment NR_LDICS in include/linux/tty.h from 16 to 17
+ *
+ * NEW: Since Kernel 2.6.21 you only have to change include/linux/tty.h
+ *
+ * HACK for precompiled Kernels:
+ *
+ * In order to use the slcan driver without rebuilding the kernel, the slcan
+ * driver must be compiled to use an existing line discipline.
+ * The N_MOUSE line discipline is documented to be free for custom use and
+ * using it *should* not cause any side effect.
+ *
+ * Then, before compiling the slcan driver, add a -DN_SLCAN=N_MOUSE  
+ * compilation option in its Makefile. The slcan_attach tool must(!!) also be
+ * rebuild to use the right value for N_SLCAN. This workaround will allow  
+ * to use the slcan driver with an existing kernel.
+ */
+#endif
+
+#define SLCAN_MAGIC 0x53CA
+
+static int maxdev = 10;		/* MAX number of SLCAN channels;
+				   This can be overridden with
+				   insmod slcan.ko maxdev=nnn	*/
+module_param(maxdev, int, 0);
+MODULE_PARM_DESC(maxdev, "Maximum number of slcan interfaces");
+
+/* maximum rx buffer len: extended CAN frame with timestamp */
+#define SLC_MTU (sizeof("T1111222281122334455667788EA5F\r")+1)
+
+struct slcan {
+	int			magic;
+
+	/* Various fields. */
+	struct tty_struct	*tty;		/* ptr to TTY structure	     */
+	struct net_device	*dev;		/* easy for intr handling    */
+	spinlock_t		lock;
+
+	/* These are pointers to the malloc()ed frame buffers. */
+	unsigned char		rbuff[SLC_MTU];	/* receiver buffer	     */
+	int			rcount;         /* received chars counter    */
+	unsigned char		xbuff[SLC_MTU];	/* transmitter buffer	     */
+	unsigned char		*xhead;         /* pointer to next XMIT byte */
+	int			xleft;          /* bytes left in XMIT queue  */
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,23)
+	/* SLCAN interface statistics. */
+	struct net_device_stats stats;
+#endif
+
+	unsigned long		flags;		/* Flag values/ mode etc     */
+#define SLF_INUSE		0		/* Channel in use            */
+#define SLF_ERROR		1               /* Parity, etc. error        */
+
+	unsigned char		leased;
+	dev_t			line;
+	pid_t			pid;
+};
+
+static struct net_device **slcan_devs;
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,23)
+/* Netdevice get statistics request */
+static struct net_device_stats *slc_get_stats(struct net_device *dev)
+{
+	struct slcan *sl = netdev_priv(dev);
+
+	return &sl->stats;
+}
+#endif
+
+ /************************************************************************
+  *			SLCAN ENCAPSULATION FORMAT			 *
+  ************************************************************************/
+
+/*
+ * A CAN frame has a can_id (11 bit standard frame format OR 29 bit extended
+ * frame format) a data length code (can_dlc) which can be from 0 to 8
+ * and up to <can_dlc> data bytes as payload.
+ * Additionally a CAN frame may become a remote transmission frame if the
+ * RTR-bit is set. This causes another ECU to send a CAN frame with the
+ * given can_id.
+ *
+ * The SLCAN ASCII representation of these different frame types is:
+ * <type> <id> <dlc> <data>*
+ *
+ * Extended frames (29 bit) are defined by capital characters in the type.
+ * RTR frames are defined as 'r' types - normal frames have 't' type:
+ * t => 11 bit data frame
+ * r => 11 bit RTR frame
+ * T => 29 bit data frame
+ * R => 29 bit RTR frame
+ *
+ * The <id> is 3 (standard) or 8 (extended) bytes in ASCII Hex (base64).
+ * The <dlc> is a one byte ASCII number ('0' - '8')
+ * The <data> section has at much ASCII Hex bytes as defined by the <dlc>
+ *
+ * Examples:
+ *
+ * t1230 : can_id 0x123, can_dlc 0, no data
+ * t4563112233 : can_id 0x456, can_dlc 3, data 0x11 0x22 0x33
+ * T12ABCDEF2AA55 : extended can_id 0x12ABCDEF, can_dlc 2, data 0xAA 0x55
+ * r1230 : can_id 0x123, can_dlc 0, no data, remote transmission request
+ *
+ */
+
+ /************************************************************************
+  *			STANDARD SLCAN DECAPSULATION			 *
+  ************************************************************************/
+
+static int asc2nibble(char c)
+{
+
+	if ((c >= '0') && (c <= '9'))
+		return c - '0';
+
+	if ((c >= 'A') && (c <= 'F'))
+		return c - 'A' + 10;
+
+	if ((c >= 'a') && (c <= 'f'))
+		return c - 'a' + 10;
+
+	return 16; /* error */
+}
+
+/* Send one completely decapsulated can_frame to the network layer */
+static void slc_bump(struct slcan *sl)
+{
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,23)
+	struct net_device_stats *stats = slc_get_stats(sl->dev);
+#endif
+	struct sk_buff *skb;
+	struct can_frame cf;
+	int i, dlc_pos, tmp;
+	unsigned long ultmp;
+	char cmd = sl->rbuff[0];
+
+	if ((cmd != 't') && (cmd != 'T') && (cmd != 'r') && (cmd != 'R'))
+		return;
+
+	if (cmd & 0x20) /* tiny chars 'r' 't' => standard frame format */
+		dlc_pos = 4; /* dlc position tiiid */
+	else
+		dlc_pos = 9; /* dlc position Tiiiiiiiid */
+
+	if (!((sl->rbuff[dlc_pos] >= '0') && (sl->rbuff[dlc_pos] < '9')))
+		return;
+
+	cf.can_dlc = sl->rbuff[dlc_pos] - '0'; /* get can_dlc from ASCII val */
+
+	sl->rbuff[dlc_pos] = 0; /* terminate can_id string */
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,25)
+	ultmp = simple_strtoul(sl->rbuff+1, NULL, 16);
+#else
+	if (strict_strtoul(sl->rbuff+1, 16, &ultmp))
+		return;
+#endif
+
+	cf.can_id = ultmp;
+
+	if (!(cmd & 0x20)) /* NO tiny chars => extended frame format */
+		cf.can_id |= CAN_EFF_FLAG;
+
+	if ((cmd | 0x20) == 'r') /* RTR frame */
+		cf.can_id |= CAN_RTR_FLAG;
+
+	*(u64 *) (&cf.data) = 0; /* clear payload */
+
+	for (i = 0, dlc_pos++; i < cf.can_dlc; i++) {
+
+		tmp = asc2nibble(sl->rbuff[dlc_pos++]);
+		if (tmp > 0x0F)
+			return;
+		cf.data[i] = (tmp << 4);
+		tmp = asc2nibble(sl->rbuff[dlc_pos++]);
+		if (tmp > 0x0F)
+			return;
+		cf.data[i] |= tmp;
+	}
+
+
+	skb = dev_alloc_skb(sizeof(struct can_frame));
+	if (!skb)
+		return;
+
+	skb->dev = sl->dev;
+	skb->protocol = htons(ETH_P_CAN);
+	skb->pkt_type = PACKET_BROADCAST;
+	skb->ip_summed = CHECKSUM_UNNECESSARY;
+	memcpy(skb_put(skb, sizeof(struct can_frame)),
+	       &cf, sizeof(struct can_frame));
+	netif_rx(skb);
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,32)
+	sl->dev->last_rx = jiffies;
+#endif
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,23)
+	stats->rx_packets++;
+	stats->rx_bytes += cf.can_dlc;
+#else
+	sl->dev->stats.rx_packets++;
+	sl->dev->stats.rx_bytes += cf.can_dlc;
+#endif
+}
+
+/* parse tty input stream */
+static void slcan_unesc(struct slcan *sl, unsigned char s)
+{
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,23)
+	struct net_device_stats *stats = slc_get_stats(sl->dev);
+#endif
+
+	if ((s == '\r') || (s == '\a')) { /* CR or BEL ends the pdu */
+		if (!test_and_clear_bit(SLF_ERROR, &sl->flags) &&
+		    (sl->rcount > 4))  {
+			slc_bump(sl);
+		}
+		sl->rcount = 0;
+	} else {
+		if (!test_bit(SLF_ERROR, &sl->flags))  {
+			if (sl->rcount < SLC_MTU)  {
+				sl->rbuff[sl->rcount++] = s;
+				return;
+			} else {
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,23)
+				stats->rx_over_errors++;
+#else
+				sl->dev->stats.rx_over_errors++;
+#endif
+				set_bit(SLF_ERROR, &sl->flags);
+			}
+		}
+	}
+}
+
+ /************************************************************************
+  *			STANDARD SLCAN ENCAPSULATION			 *
+  ************************************************************************/
+
+/* Encapsulate one can_frame and stuff into a TTY queue. */
+static void slc_encaps(struct slcan *sl, struct can_frame *cf)
+{
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,23)
+	struct net_device_stats *stats = slc_get_stats(sl->dev);
+#endif
+	int actual, idx, i;
+	char cmd;
+
+	if (cf->can_id & CAN_RTR_FLAG)
+		cmd = 'R'; /* becomes 'r' in standard frame format */
+	else
+		cmd = 'T'; /* becomes 't' in standard frame format */
+
+	if (cf->can_id & CAN_EFF_FLAG)
+		sprintf(sl->xbuff, "%c%08X%d", cmd,
+			cf->can_id & CAN_EFF_MASK, cf->can_dlc);
+	else
+		sprintf(sl->xbuff, "%c%03X%d", cmd | 0x20,
+			cf->can_id & CAN_SFF_MASK, cf->can_dlc);
+
+	idx = strlen(sl->xbuff);
+
+	for (i = 0; i < cf->can_dlc; i++)
+		sprintf(&sl->xbuff[idx + 2*i], "%02X", cf->data[i]);
+
+	strcat(sl->xbuff, "\r"); /* add terminating character */
+
+	/* Order of next two lines is *very* important.
+	 * When we are sending a little amount of data,
+	 * the transfer may be completed inside the ops->write()
+	 * routine, because it's running with interrupts enabled.
+	 * In this case we *never* got WRITE_WAKEUP event,
+	 * if we did not request it before write operation.
+	 *       14 Oct 1994  Dmitry Gorodchanin.
+	 */
+	set_bit(TTY_DO_WRITE_WAKEUP, &sl->tty->flags);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,26)
+	actual = sl->tty->driver->write(sl->tty, sl->xbuff, strlen(sl->xbuff));
+#else
+	actual = sl->tty->ops->write(sl->tty, sl->xbuff, strlen(sl->xbuff));
+#endif
+	sl->xleft = strlen(sl->xbuff) - actual;
+	sl->xhead = sl->xbuff + actual;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,23)
+	stats->tx_bytes += cf->can_dlc;
+#else
+	sl->dev->stats.tx_bytes += cf->can_dlc;
+#endif
+}
+
+/*
+ * Called by the driver when there's room for more data.  If we have
+ * more packets to send, we send them here.
+ */
+static void slcan_write_wakeup(struct tty_struct *tty)
+{
+	int actual;
+	struct slcan *sl = (struct slcan *) tty->disc_data;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,23)
+	struct net_device_stats *stats = slc_get_stats(sl->dev);
+#endif
+
+	/* First make sure we're connected. */
+	if (!sl || sl->magic != SLCAN_MAGIC || !netif_running(sl->dev))
+		return;
+
+	if (sl->xleft <= 0)  {
+		/* Now serial buffer is almost free & we can start
+		 * transmission of another packet */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,23)
+		stats->tx_packets++;
+#else
+		sl->dev->stats.tx_packets++;
+#endif
+		clear_bit(TTY_DO_WRITE_WAKEUP, &tty->flags);
+		netif_wake_queue(sl->dev);
+		return;
+	}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,26)
+	actual = tty->driver->write(tty, sl->xhead, sl->xleft);
+#else
+	actual = tty->ops->write(tty, sl->xhead, sl->xleft);
+#endif
+	sl->xleft -= actual;
+	sl->xhead += actual;
+}
+
+/* Send a can_frame to a TTY queue. */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,32)
+static int slc_xmit(struct sk_buff *skb, struct net_device *dev)
+#else
+static netdev_tx_t slc_xmit(struct sk_buff *skb, struct net_device *dev)
+#endif
+{
+	struct slcan *sl = netdev_priv(dev);
+
+	if (skb->len != sizeof(struct can_frame))
+		goto out;
+
+	spin_lock(&sl->lock);
+	if (!netif_running(dev))  {
+		spin_unlock(&sl->lock);
+		printk(KERN_WARNING "%s: xmit: iface is down\n", dev->name);
+		goto out;
+	}
+	if (sl->tty == NULL) {
+		spin_unlock(&sl->lock);
+		goto out;
+	}
+
+	netif_stop_queue(sl->dev);
+	slc_encaps(sl, (struct can_frame *) skb->data); /* encaps & send */
+	spin_unlock(&sl->lock);
+
+out:
+	kfree_skb(skb);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,32)
+	return 0;
+#else
+	return NETDEV_TX_OK;
+#endif
+}
+
+
+/******************************************
+ *   Routines looking at netdevice side.
+ ******************************************/
+
+/* Netdevice UP -> DOWN routine */
+static int slc_close(struct net_device *dev)
+{
+	struct slcan *sl = netdev_priv(dev);
+
+	spin_lock_bh(&sl->lock);
+	if (sl->tty) {
+		/* TTY discipline is running. */
+		clear_bit(TTY_DO_WRITE_WAKEUP, &sl->tty->flags);
+	}
+	netif_stop_queue(dev);
+	sl->rcount   = 0;
+	sl->xleft    = 0;
+	spin_unlock_bh(&sl->lock);
+
+	return 0;
+}
+
+/* Netdevice DOWN -> UP routine */
+static int slc_open(struct net_device *dev)
+{
+	struct slcan *sl = netdev_priv(dev);
+
+	if (sl->tty == NULL)
+		return -ENODEV;
+
+	sl->flags &= (1 << SLF_INUSE);
+	netif_start_queue(dev);
+	return 0;
+}
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,31)
+/* Hook the destructor so we can free slcan devs at the right point in time */
+static void slc_free_netdev(struct net_device *dev)
+{
+	int i = dev->base_addr;
+	free_netdev(dev);
+	slcan_devs[i] = NULL;
+}
+#endif
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,28)
+static const struct net_device_ops slc_netdev_ops = {
+	.ndo_open               = slc_open,
+	.ndo_stop               = slc_close,
+	.ndo_start_xmit         = slc_xmit,
+};
+#endif
+
+static void slc_setup(struct net_device *dev)
+{
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,28)
+	dev->netdev_ops		= &slc_netdev_ops;
+#else
+	dev->open		= slc_open;
+	dev->stop		= slc_close;
+	dev->hard_start_xmit	= slc_xmit;
+#endif
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,31)
+	dev->destructor		= slc_free_netdev;
+#else
+	dev->destructor		= free_netdev;
+#endif
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,23)
+	dev->get_stats		= slc_get_stats;
+#endif
+
+	dev->hard_header_len	= 0;
+	dev->addr_len		= 0;
+	dev->tx_queue_len	= 10;
+
+	dev->mtu		= sizeof(struct can_frame);
+	dev->type		= ARPHRD_CAN;
+
+	/* New-style flags. */
+	dev->flags		= IFF_NOARP;
+	dev->features           = NETIF_F_NO_CSUM;
+}
+
+/******************************************
+  Routines looking at TTY side.
+ ******************************************/
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,16)
+static int slcan_receive_room(struct tty_struct *tty)
+{
+	return 65536;  /* We can handle an infinite amount of data. :-) */
+}
+#endif
+
+/*
+ * Handle the 'receiver data ready' interrupt.
+ * This function is called by the 'tty_io' module in the kernel when
+ * a block of SLCAN data has been received, which can now be decapsulated
+ * and sent on to some IP layer for further processing. This will not
+ * be re-entered while running but other ldisc functions may be called
+ * in parallel
+ */
+
+static void slcan_receive_buf(struct tty_struct *tty,
+			      const unsigned char *cp, char *fp, int count)
+{
+	struct slcan *sl = (struct slcan *) tty->disc_data;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,23)
+	struct net_device_stats *stats = slc_get_stats(sl->dev);
+#endif
+
+	if (!sl || sl->magic != SLCAN_MAGIC || !netif_running(sl->dev))
+		return;
+
+	/* Read the characters out of the buffer */
+	while (count--) {
+		if (fp && *fp++) {
+			if (!test_and_set_bit(SLF_ERROR, &sl->flags))
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,23)
+				stats->rx_errors++;
+#else
+				sl->dev->stats.rx_errors++;
+#endif
+			cp++;
+			continue;
+		}
+		slcan_unesc(sl, *cp++);
+	}
+}
+
+/************************************
+ *  slcan_open helper routines.
+ ************************************/
+
+/* Collect hanged up channels */
+static void slc_sync(void)
+{
+	int i;
+	struct net_device *dev;
+	struct slcan	  *sl;
+
+	for (i = 0; i < maxdev; i++) {
+		dev = slcan_devs[i];
+		if (dev == NULL)
+			break;
+
+		sl = netdev_priv(dev);
+		if (sl->tty || sl->leased)
+			continue;
+		if (dev->flags & IFF_UP)
+			dev_close(dev);
+	}
+}
+
+/* Find a free SLCAN channel, and link in this `tty' line. */
+static struct slcan *slc_alloc(dev_t line)
+{
+	int i;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,32)
+	int sel = -1;
+	int score = -1;
+#endif
+	struct net_device *dev = NULL;
+	struct slcan       *sl;
+
+	if (slcan_devs == NULL)
+		return NULL;	/* Master array missing ! */
+
+	for (i = 0; i < maxdev; i++) {
+		dev = slcan_devs[i];
+		if (dev == NULL)
+			break;
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,32)
+		sl = netdev_priv(dev);
+		if (sl->leased) {
+			if (sl->line != line)
+				continue;
+			if (sl->tty)
+				return NULL;
+
+			/* Clear ESCAPE & ERROR flags */
+			sl->flags &= (1 << SLF_INUSE);
+			return sl;
+		}
+
+		if (sl->tty)
+			continue;
+
+		if (current->pid == sl->pid) {
+			if (sl->line == line && score < 3) {
+				sel = i;
+				score = 3;
+				continue;
+			}
+			if (score < 2) {
+				sel = i;
+				score = 2;
+			}
+			continue;
+		}
+		if (sl->line == line && score < 1) {
+			sel = i;
+			score = 1;
+			continue;
+		}
+		if (score < 0) {
+			sel = i;
+			score = 0;
+		}
+	}
+
+	if (sel >= 0) {
+		i = sel;
+		dev = slcan_devs[i];
+		if (score > 1) {
+			sl = netdev_priv(dev);
+			sl->flags &= (1 << SLF_INUSE);
+			return sl;
+		}
+#endif
+	}
+
+	/* Sorry, too many, all slots in use */
+	if (i >= maxdev)
+		return NULL;
+
+	if (dev) {
+		sl = netdev_priv(dev);
+		if (test_bit(SLF_INUSE, &sl->flags)) {
+			unregister_netdevice(dev);
+			dev = NULL;
+			slcan_devs[i] = NULL;
+		}
+	}
+
+	if (!dev) {
+		char name[IFNAMSIZ];
+		sprintf(name, "slcan%d", i);
+
+		dev = alloc_netdev(sizeof(*sl), name, slc_setup);
+		if (!dev)
+			return NULL;
+		dev->base_addr  = i;
+	}
+
+	sl = netdev_priv(dev);
+
+	/* Initialize channel control data */
+	sl->magic = SLCAN_MAGIC;
+	sl->dev	= dev;
+	spin_lock_init(&sl->lock);
+	slcan_devs[i] = dev;
+
+	return sl;
+}
+
+/*
+ * Open the high-level part of the SLCAN channel.
+ * This function is called by the TTY module when the
+ * SLCAN line discipline is called for.  Because we are
+ * sure the tty line exists, we only have to link it to
+ * a free SLCAN channel...
+ *
+ * Called in process context serialized from other ldisc calls.
+ */
+
+static int slcan_open(struct tty_struct *tty)
+{
+	struct slcan *sl;
+	int err;
+
+	if (!capable(CAP_NET_ADMIN))
+		return -EPERM;
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,25)
+	if (tty->ops->write == NULL)
+		return -EOPNOTSUPP;
+#endif
+
+	/* RTnetlink lock is misused here to serialize concurrent
+	   opens of slcan channels. There are better ways, but it is
+	   the simplest one.
+	 */
+	rtnl_lock();
+
+	/* Collect hanged up channels. */
+	slc_sync();
+
+	sl = tty->disc_data;
+
+	err = -EEXIST;
+	/* First make sure we're not already connected. */
+	if (sl && sl->magic == SLCAN_MAGIC)
+		goto err_exit;
+
+	/* OK.  Find a free SLCAN channel to use. */
+	err = -ENFILE;
+	sl = slc_alloc(tty_devnum(tty));
+	if (sl == NULL)
+		goto err_exit;
+
+	sl->tty = tty;
+	tty->disc_data = sl;
+	sl->line = tty_devnum(tty);
+	sl->pid = current->pid;
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,16)
+	/* FIXME: already done before we were called - seems this can go */
+	if (tty->driver->flush_buffer)
+		tty->driver->flush_buffer(tty);
+#endif
+
+	if (!test_bit(SLF_INUSE, &sl->flags)) {
+		/* Perform the low-level SLCAN initialization. */
+		sl->rcount   = 0;
+		sl->xleft    = 0;
+
+		set_bit(SLF_INUSE, &sl->flags);
+
+		err = register_netdevice(sl->dev);
+		if (err)
+			goto err_free_chan;
+	}
+
+	/* Done.  We have linked the TTY line to a channel. */
+	rtnl_unlock();
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,16)
+	tty->receive_room = 65536;	/* We don't flow control */
+#endif
+	return sl->dev->base_addr;
+
+err_free_chan:
+	sl->tty = NULL;
+	tty->disc_data = NULL;
+	clear_bit(SLF_INUSE, &sl->flags);
+
+err_exit:
+	rtnl_unlock();
+
+	/* Count references from TTY module */
+	return err;
+}
+
+/*
+ * Close down a SLCAN channel.
+ * This means flushing out any pending queues, and then returning. This
+ * call is serialized against other ldisc functions.
+ *
+ * We also use this method for a hangup event.
+ */
+
+static void slcan_close(struct tty_struct *tty)
+{
+	struct slcan *sl = (struct slcan *) tty->disc_data;
+
+	/* First make sure we're connected. */
+	if (!sl || sl->magic != SLCAN_MAGIC || sl->tty != tty)
+		return;
+
+	tty->disc_data = NULL;
+	sl->tty = NULL;
+	if (!sl->leased)
+		sl->line = 0;
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,31)
+	/* Flush network side */
+	unregister_netdev(sl->dev);
+	/* This will complete via sl_free_netdev */
+#else
+	/* Count references from TTY module */
+#endif
+}
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,31)
+static int slcan_hangup(struct tty_struct *tty)
+{
+	slcan_close(tty);
+	return 0;
+}
+#endif
+
+/* Perform I/O control on an active SLCAN channel. */
+static int slcan_ioctl(struct tty_struct *tty, struct file *file,
+		       unsigned int cmd, unsigned long arg)
+{
+	struct slcan *sl = (struct slcan *) tty->disc_data;
+	unsigned int tmp;
+
+	/* First make sure we're connected. */
+	if (!sl || sl->magic != SLCAN_MAGIC)
+		return -EINVAL;
+
+	switch (cmd) {
+	case SIOCGIFNAME:
+		tmp = strlen(sl->dev->name) + 1;
+		if (copy_to_user((void __user *)arg, sl->dev->name, tmp))
+			return -EFAULT;
+		return 0;
+
+	case SIOCSIFHWADDR:
+		return -EINVAL;
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,27)
+	/* Allow stty to read, but not set, the serial port */
+	case TCGETS:
+	case TCGETA:
+		return n_tty_ioctl(tty, file, cmd, arg);
+
+	default:
+		return -ENOIOCTLCMD;
+#else
+	default:
+		return tty_mode_ioctl(tty, file, cmd, arg);
+#endif
+	}
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,27)
+static struct tty_ldisc	slc_ldisc = {
+#else
+static struct tty_ldisc_ops slc_ldisc = {
+#endif
+	.owner		= THIS_MODULE,
+	.magic		= TTY_LDISC_MAGIC,
+	.name		= "slcan",
+	.open		= slcan_open,
+	.close		= slcan_close,
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,31)
+	.hangup		= slcan_hangup,
+#endif
+	.ioctl		= slcan_ioctl,
+	.receive_buf	= slcan_receive_buf,
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,16)
+	.receive_room	= slcan_receive_room,
+#endif
+	.write_wakeup	= slcan_write_wakeup,
+};
+
+static int __init slcan_init(void)
+{
+	int status;
+
+	if (maxdev < 4)
+		maxdev = 4; /* Sanity */
+
+	printk(banner);
+	printk(KERN_INFO "slcan: %d dynamic interface channels.\n", maxdev);
+
+	slcan_devs = kzalloc(sizeof(struct net_device *)*maxdev, GFP_KERNEL);
+	if (!slcan_devs) {
+		printk(KERN_ERR "slcan: can't allocate slcan device array!\n");
+		return -ENOMEM;
+	}
+
+	/* Fill in our line protocol discipline, and register it */
+	status = tty_register_ldisc(N_SLCAN, &slc_ldisc);
+	if (status)  {
+		printk(KERN_ERR "slcan: can't register line discipline\n");
+		kfree(slcan_devs);
+	}
+	return status;
+}
+
+static void __exit slcan_exit(void)
+{
+	int i;
+	struct net_device *dev;
+	struct slcan *sl;
+	unsigned long timeout = jiffies + HZ;
+	int busy = 0;
+
+	if (slcan_devs == NULL)
+		return;
+
+	/* First of all: check for active disciplines and hangup them.
+	 */
+	do {
+		if (busy)
+			msleep_interruptible(100);
+
+		busy = 0;
+		for (i = 0; i < maxdev; i++) {
+			dev = slcan_devs[i];
+			if (!dev)
+				continue;
+			sl = netdev_priv(dev);
+			spin_lock_bh(&sl->lock);
+			if (sl->tty) {
+				busy++;
+				tty_hangup(sl->tty);
+			}
+			spin_unlock_bh(&sl->lock);
+		}
+	} while (busy && time_before(jiffies, timeout));
+
+	/* FIXME: hangup is async so we should wait when doing this second
+	   phase */
+
+	for (i = 0; i < maxdev; i++) {
+		dev = slcan_devs[i];
+		if (!dev)
+			continue;
+		slcan_devs[i] = NULL;
+
+		sl = netdev_priv(dev);
+		if (sl->tty) {
+			printk(KERN_ERR "%s: tty discipline still running\n",
+			       dev->name);
+			/* Intentionally leak the control block. */
+			dev->destructor = NULL;
+		}
+
+		unregister_netdev(dev);
+	}
+
+	kfree(slcan_devs);
+	slcan_devs = NULL;
+
+	i = tty_unregister_ldisc(N_SLCAN);
+	if (i)
+		printk(KERN_ERR "slcan: can't unregister ldisc (err %d)\n", i);
+}
+
+module_init(slcan_init);
+module_exit(slcan_exit);
diff --exclude CVS --exclude .git -uNr linux-2.6.27.8/drivers/net/can/softing/Makefile linux-2.6.27.8.modified/drivers/net/can/softing/Makefile
--- linux-2.6.27.8/drivers/net/can/softing/Makefile	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.27.8.modified/drivers/net/can/softing/Makefile	2013-05-30 03:44:18.000000000 -0400
@@ -0,0 +1,20 @@
+# Makefile for softing CAN driver
+
+ifeq ($(KERNELRELEASE),)
+# necessary when used outside kernel
+KERNELDIR := /lib/modules/$(shell uname -r)/build
+PWD       := $(shell pwd)
+TOPDIR    := $(PWD)/../../../..
+
+modules modules_install clean:
+	$(MAKE) -C $(KERNELDIR) M=$(PWD) $@ TOPDIR=$(TOPDIR)
+
+else
+
+-include $(TOPDIR)/Makefile.common
+
+softing-y := softing_main.o softing_fw.o softing_sysfs.o
+obj-$(CONFIG_CAN_SOFTING)        += softing.o
+obj-$(CONFIG_CAN_SOFTING_CS)     += softing_cs.o
+
+endif
diff --exclude CVS --exclude .git -uNr linux-2.6.27.8/drivers/net/can/softing/softing.h linux-2.6.27.8.modified/drivers/net/can/softing/softing.h
--- linux-2.6.27.8/drivers/net/can/softing/softing.h	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.27.8.modified/drivers/net/can/softing/softing.h	2013-05-30 03:44:18.000000000 -0400
@@ -0,0 +1,256 @@
+/*
+ * softing common interfaces
+ *
+ * by Kurt Van Dijck, 06-2008
+ */
+
+#include <linux/interrupt.h>
+#include <linux/netdevice.h>
+#include <linux/ktime.h>
+#include <socketcan/can.h>
+#include <socketcan/can/dev.h>
+
+struct softing;
+struct sofing_desc;
+
+/* softing firmware directory prefix */
+#define fw_dir "softing-4.6/"
+
+/* special attribute, so we should not rely on the ->priv pointers
+ * before knowing how to interpret these
+ */
+struct softing_attribute;
+
+struct softing_priv {
+	struct can_priv can;	/* must be the first member! */
+	struct net_device *netdev;
+	struct softing *card;
+	struct {
+		int pending;
+		/* variables which hold the circular buffer */
+		int echo_put;
+		int echo_get;
+	} tx;
+	struct can_bittiming_const btr_const;
+	int index;
+	u8 output;
+	u16 chip;
+	struct attribute_group sysfs;
+};
+#define netdev2softing(netdev)	((struct softing_priv *)netdev_priv(netdev))
+
+struct softing_desc {
+	unsigned int manf;
+	unsigned int prod;
+	/* generation
+	 * 1st with NEC or SJA1000
+	 * 8bit, exclusive interrupt, ...
+	 * 2nd only SJA11000
+	 * 16bit, shared interrupt
+	 */
+	int generation;
+	unsigned int freq;	/*crystal in MHz */
+	unsigned int max_brp;
+	unsigned int max_sjw;
+	unsigned long dpram_size;
+	char name[32];
+	struct {
+		unsigned long offs;
+		unsigned long addr;
+		char fw[32];
+	} boot, load, app;
+};
+
+struct softing {
+	int nbus;
+	struct softing_priv *bus[2];
+	spinlock_t	 spin; /* protect this structure & DPRAM access */
+	ktime_t ts_ref;
+	ktime_t ts_overflow; /* timestamp overflow value, in ktime */
+
+	struct {
+		/* indication of firmware status */
+		int up;
+		int failed; /* firmware has failed */
+		/* protection of the 'up' variable */
+		struct mutex lock;
+	} fw;
+	struct {
+		int nr;
+		int requested;
+		struct tasklet_struct bh;
+		int svc_count;
+	} irq;
+	struct {
+		int pending;
+		int last_bus;
+		/* keep the bus that last tx'd a message,
+		 * in order to let every netdev queue resume
+		 */
+	} tx;
+	struct {
+		unsigned long phys;
+		unsigned long size;
+		unsigned char *virt;
+		unsigned char *end;
+		struct softing_fct  *fct;
+		struct softing_info *info;
+		struct softing_rx  *rx;
+		struct softing_tx  *tx;
+		struct softing_irq *irq;
+		unsigned short *command;
+		unsigned short *receipt;
+	} dpram;
+	struct {
+		unsigned short manf;
+		unsigned short prod;
+		u32  serial, fw, hw, lic;
+		u16  chip[2];
+		u32  freq;
+		const char *name;
+	} id;
+	const struct softing_desc		*desc;
+	struct {
+		int (*reset)	 (struct softing *, int);
+		int (*enable_irq)(struct softing *, int);
+	} fn;
+	struct device *dev;
+	/* sysfs */
+	struct attribute_group sysfs;
+	struct softing_attribute *attr;
+	struct attribute **grp;
+};
+
+extern int	mk_softing(struct softing *);
+/* fields that must be set already are :
+ * ncan
+ * id.manf
+ * id.prod
+ * fn.reset
+ * fn.enable_irq
+ */
+extern void rm_softing(struct softing *);
+/* usefull functions during operation */
+
+extern int softing_default_output(struct softing *card
+			, struct softing_priv *priv);
+extern ktime_t softing_raw2ktime(struct softing *card, u32 raw);
+
+extern int softing_fct_cmd(struct softing *card
+			, int cmd, int vector, const char *msg);
+
+extern int softing_bootloader_command(struct softing *card
+			, int command, const char *msg);
+
+/* Load firmware after reset */
+extern int softing_load_fw(const char *file, struct softing *card,
+			unsigned char *virt, unsigned int size, int offset);
+
+/* Load final application firmware after bootloader */
+extern int softing_load_app_fw(const char *file, struct softing *card);
+
+extern int softing_reset_chip(struct softing *card);
+
+/* enable or disable irq
+ * only called with fw.lock locked
+ */
+extern int softing_card_irq(struct softing *card, int enable);
+
+/* start/stop 1 bus on cardr*/
+extern int softing_cycle(
+	struct softing *card, struct softing_priv *priv, int up);
+
+/* netif_rx() */
+extern int softing_rx(struct net_device *netdev, const struct can_frame *msg,
+	ktime_t ktime);
+
+/* create/remove the per-card associated sysfs entries */
+extern int softing_card_sysfs_create(struct softing *card);
+extern void softing_card_sysfs_remove(struct softing *card);
+/* create/remove the per-bus associated sysfs entries */
+extern int softing_bus_sysfs_create(struct softing_priv *bus);
+extern void softing_bus_sysfs_remove(struct softing_priv *bus);
+
+/* SOFTING DPRAM mappings */
+struct softing_rx {
+	u8  fifo[16][32];
+	u8  dummy1;
+	u16 rd;
+	u16 dummy2;
+	u16 wr;
+	u16  dummy3;
+	u16 lost_msg;
+} __attribute__((packed));
+
+#define TXMAX	31
+struct softing_tx {
+	u8  fifo[32][16];
+	u8  dummy1;
+	u16 rd;
+	u16 dummy2;
+	u16 wr;
+	u8  dummy3;
+} __attribute__((packed));
+
+struct softing_irq {
+	u8 to_host;
+	u8 to_card;
+} __attribute__((packed));
+
+struct softing_fct {
+	s16 param[20]; /* 0 is index */
+	s16 returned;
+	u8  dummy;
+	u16 host_access;
+} __attribute__((packed));
+
+struct softing_info {
+	u8  dummy1;
+	u16 bus_state;
+	u16 dummy2;
+	u16 bus_state2;
+	u16 dummy3;
+	u16 error_state;
+	u16 dummy4;
+	u16 error_state2;
+	u16 dummy5;
+	u16 reset;
+	u16 dummy6;
+	u16 clear_rcv_fifo;
+	u16 dummy7;
+	u16 dummyxx;
+	u16 dummy8;
+	u16 time_reset;
+	u8  dummy9;
+	u32 time;
+	u32 time_wrap;
+	u8  wr_start;
+	u8  wr_end;
+	u8  dummy10;
+	u16 dummy12;
+	u16 dummy12x;
+	u16 dummy13;
+	u16 reset_rcv_fifo;
+	u8  dummy14;
+	u8  reset_xmt_fifo;
+	u8  read_fifo_levels;
+	u16 rcv_fifo_level;
+	u16 xmt_fifo_level;
+} __attribute__((packed));
+
+/* DPRAM return codes */
+#define RES_NONE 0
+#define RES_OK	 1
+#define RES_NOK  2
+#define RES_UNKNOWN 3
+/* DPRAM flags */
+#define CMD_TX		0x01
+#define CMD_ACK 0x02
+#define CMD_XTD 0x04
+#define CMD_RTR 0x08
+#define CMD_ERR 0x10
+#define CMD_BUS2	0x80
+
+/* debug */
+extern int softing_debug;
+
diff --exclude CVS --exclude .git -uNr linux-2.6.27.8/drivers/net/can/softing/softing_cs.c linux-2.6.27.8.modified/drivers/net/can/softing/softing_cs.c
--- linux-2.6.27.8/drivers/net/can/softing/softing_cs.c	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.27.8.modified/drivers/net/can/softing/softing_cs.c	2013-05-30 03:44:18.000000000 -0400
@@ -0,0 +1,562 @@
+/*
+* drivers/net/can/softing/softing_cs.c
+*
+* Copyright (C) 2008
+*
+* - Kurt Van Dijck, EIA Electronics
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the version 2 of the GNU General Public License
+* as published by the Free Software Foundation
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+*/
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/version.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/sched.h>
+#include <linux/ptrace.h>
+#include <linux/slab.h>
+#include <linux/string.h>
+#include <linux/timer.h>
+#include <linux/major.h>
+#include <linux/io.h>
+
+#include <pcmcia/cs_types.h>
+#include <pcmcia/cs.h>
+#include <pcmcia/cistpl.h>
+#include <pcmcia/ciscode.h>
+#include <pcmcia/ds.h>
+#include <pcmcia/cisreg.h>
+
+#include <asm/system.h>
+
+#include "softing.h"
+
+struct softing_cs {
+	struct softing	 softing;
+	win_req_t win;
+};
+#define softing2cs(x) container_of((x), struct softing_cs, softing)
+
+/* card descriptions */
+static const struct softing_desc carddescs[] = {
+{
+	.name = "CANcard",
+	.manf = 0x0168, .prod = 0x001,
+	.generation = 1,
+	.freq = 16, .max_brp = 32, .max_sjw = 4,
+	.dpram_size = 0x0800,
+	.boot = {0x0000, 0x000000, fw_dir "bcard.bin",},
+	.load = {0x0120, 0x00f600, fw_dir "ldcard.bin",},
+	.app = {0x0010, 0x0d0000, fw_dir "cancard.bin",},
+}, {
+	.name = "CANcard-NEC",
+	.manf = 0x0168, .prod = 0x002,
+	.generation = 1,
+	.freq = 16, .max_brp = 32, .max_sjw = 4,
+	.dpram_size = 0x0800,
+	.boot = {0x0000, 0x000000, fw_dir "bcard.bin",},
+	.load = {0x0120, 0x00f600, fw_dir "ldcard.bin",},
+	.app = {0x0010, 0x0d0000, fw_dir "cancard.bin",},
+}, {
+	.name = "CANcard-SJA",
+	.manf = 0x0168, .prod = 0x004,
+	.generation = 1,
+	.freq = 20, .max_brp = 32, .max_sjw = 4,
+	.dpram_size = 0x0800,
+	.boot = {0x0000, 0x000000, fw_dir "bcard.bin",},
+	.load = {0x0120, 0x00f600, fw_dir "ldcard.bin",},
+	.app = {0x0010, 0x0d0000, fw_dir "cansja.bin",},
+}, {
+	.name = "CANcard-2",
+	.manf = 0x0168, .prod = 0x005,
+	.generation = 2,
+	.freq = 24, .max_brp = 64, .max_sjw = 4,
+	.dpram_size = 0x0800,
+	.boot = {0x0000, 0x000000, fw_dir "bcard2.bin",},
+	.load = {0x0120, 0x00f600, fw_dir "ldcard2.bin",},
+	.app = {0x0010, 0x0d0000, fw_dir "cancrd2.bin",},
+}, {
+	.name = "Vector-CANcard",
+	.manf = 0x0168, .prod = 0x081,
+	.generation = 1,
+	.freq = 16, .max_brp = 64, .max_sjw = 4,
+	.dpram_size = 0x0800,
+	.boot = {0x0000, 0x000000, fw_dir "bcard.bin",},
+	.load = {0x0120, 0x00f600, fw_dir "ldcard.bin",},
+	.app = {0x0010, 0x0d0000, fw_dir "cancard.bin",},
+}, {
+	.name = "Vector-CANcard-SJA",
+	.manf = 0x0168, .prod = 0x084,
+	.generation = 1,
+	.freq = 20, .max_brp = 32, .max_sjw = 4,
+	.dpram_size = 0x0800,
+	.boot = {0x0000, 0x000000, fw_dir "bcard.bin",},
+	.load = {0x0120, 0x00f600, fw_dir "ldcard.bin",},
+	.app = {0x0010, 0x0d0000, fw_dir "cansja.bin",},
+}, {
+	.name = "Vector-CANcard-2",
+	.manf = 0x0168, .prod = 0x085,
+	.generation = 2,
+	.freq = 24, .max_brp = 64, .max_sjw = 4,
+	.dpram_size = 0x0800,
+	.boot = {0x0000, 0x000000, fw_dir "bcard2.bin",},
+	.load = {0x0120, 0x00f600, fw_dir "ldcard2.bin",},
+	.app = {0x0010, 0x0d0000, fw_dir "cancrd2.bin",},
+}, {
+	.name = "EDICcard-NEC",
+	.manf = 0x0168, .prod = 0x102,
+	.generation = 1,
+	.freq = 16, .max_brp = 64, .max_sjw = 4,
+	.dpram_size = 0x0800,
+	.boot = {0x0000, 0x000000, fw_dir "bcard.bin",},
+	.load = {0x0120, 0x00f600, fw_dir "ldcard.bin",},
+	.app = {0x0010, 0x0d0000, fw_dir "cancard.bin",},
+}, {
+	.name = "EDICcard-2",
+	.manf = 0x0168, .prod = 0x105,
+	.generation = 2,
+	.freq = 24, .max_brp = 64, .max_sjw = 4,
+	.dpram_size = 0x0800,
+	.boot = {0x0000, 0x000000, fw_dir "bcard2.bin",},
+	.load = {0x0120, 0x00f600, fw_dir "ldcard2.bin",},
+	.app = {0x0010, 0x0d0000, fw_dir "cancrd2.bin",},
+	},
+{0, 0,},
+};
+
+MODULE_FIRMWARE(fw_dir "bcard.bin");
+MODULE_FIRMWARE(fw_dir "ldcard.bin");
+MODULE_FIRMWARE(fw_dir "cancard.bin");
+MODULE_FIRMWARE(fw_dir "cansja.bin");
+
+MODULE_FIRMWARE(fw_dir "bcard2.bin");
+MODULE_FIRMWARE(fw_dir "ldcard2.bin");
+MODULE_FIRMWARE(fw_dir "cancrd2.bin");
+
+static const struct softing_desc *softing_cs_lookup_desc
+					(unsigned int manf, unsigned int prod)
+{
+	const struct softing_desc *lp = carddescs;
+	for (; lp->name; ++lp) {
+		if ((lp->manf == manf) && (lp->prod == prod))
+			return lp;
+	}
+	return 0;
+}
+
+
+struct lookup {
+	int i;
+	const char *a;
+};
+
+static const char __devinit *lookup_mask(const struct lookup *lp, int *i)
+{
+	for (; lp->a; ++lp) {
+		if (lp->i & *i) {
+			*i &= ~lp->i;
+			return lp->a;
+		}
+	}
+	return 0;
+}
+
+static int card_reset_via_pcmcia(struct softing *sdev, int v)
+{
+	struct pcmcia_device *pcmcia = to_pcmcia_dev(sdev->dev);
+	conf_reg_t reg;
+	reg.Function = 0; /* socket */
+	reg.Action	 = CS_WRITE;
+	reg.Offset	 = 2;
+	reg.Value	 = v ? 0 : 0x20;
+	return pcmcia_access_configuration_register(pcmcia, &reg);
+}
+
+static int card_reset_via_dpram(struct softing *sdev, int v)
+{
+	if (v) {
+		spin_lock_bh(&sdev->spin);
+		sdev->dpram.virt[0xe00] &= ~1;
+		spin_unlock_bh(&sdev->spin);
+		card_reset_via_pcmcia(sdev, v);
+	} else {
+		card_reset_via_pcmcia(sdev, v);
+		spin_lock_bh(&sdev->spin);
+		sdev->dpram.virt[0xe00] |=  1;
+		spin_unlock_bh(&sdev->spin);
+	}
+	return 0;
+}
+
+static int card_enable_irq_via_pcmcia(struct softing *sdev, int v)
+{
+	int ret;
+	struct pcmcia_device *pcmcia = to_pcmcia_dev(sdev->dev);
+	conf_reg_t reg;
+	memset(&reg, 0, sizeof(reg));
+	reg.Function = 0; /* socket */
+	reg.Action	 = CS_WRITE;
+	reg.Offset	 = 0;
+	reg.Value	 = v ? 0x60 : 0;
+	ret = pcmcia_access_configuration_register(pcmcia, &reg);
+	if (ret)
+		dev_alert(&pcmcia->dev, "failed %u\n", ret);
+	return ret;
+}
+
+/* TODO: in 2.6.26, __devinitconst works*/
+static const __devinitdata struct lookup pcmcia_io_attr[] = {
+	{ IO_DATA_PATH_WIDTH_AUTO	, "[auto]"	, },
+	{ IO_DATA_PATH_WIDTH_8		, "8bit"	, },
+	{ IO_DATA_PATH_WIDTH_16		, "16bit"	, },
+	{ 0, 0, },
+};
+
+static const __devinitdata struct lookup pcmcia_mem_attr[] = {
+	{ WIN_ADDR_SPACE_IO	, "IO"		, },
+	{ WIN_MEMORY_TYPE_AM	, "typeAM"	, },
+	{ WIN_ENABLE		, "enable"	, },
+	{ WIN_DATA_WIDTH_8	, "8bit"	, },
+	{ WIN_DATA_WIDTH_16	, "16bit"	, },
+	{ WIN_DATA_WIDTH_32	, "32bit"	, },
+	{ WIN_PAGED		, "paged"	, },
+	{ WIN_SHARED		, "shared"	, },
+	{ WIN_FIRST_SHARED	, "first_shared", },
+	{ WIN_USE_WAIT		, "wait"	, },
+	{ WIN_STRICT_ALIGN	, "strict_align", },
+	{ WIN_MAP_BELOW_1MB	, "below_1MB"	, },
+	{ WIN_PREFETCH		, "prefetch"	, },
+	{ WIN_CACHEABLE		, "cacheable"	, },
+	{ 0, 0, },
+};
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 28)
+/* backported */
+struct pcmcia_cfg_mem {
+	tuple_t tuple;
+	cisparse_t parse;
+	u8 buf[256];
+	cistpl_cftable_entry_t dflt;
+};
+static int pcmcia_loop_config(struct pcmcia_device *p_dev,
+		       int	(*conf_check)	(struct pcmcia_device *p_dev,
+						 cistpl_cftable_entry_t *cfg,
+						 cistpl_cftable_entry_t *dflt,
+						 unsigned int vcc,
+						 void *priv_data),
+		       void *priv_data)
+{
+	struct pcmcia_cfg_mem *cfg_mem;
+
+	tuple_t *tuple;
+	int ret = -ENODEV;
+	unsigned int vcc;
+
+	cfg_mem = kzalloc(sizeof(*cfg_mem), GFP_KERNEL);
+	if (cfg_mem == NULL)
+		return -ENOMEM;
+
+	/* get the current Vcc setting */
+	vcc = p_dev->socket->socket.Vcc;
+
+	tuple = &cfg_mem->tuple;
+	tuple->TupleData = cfg_mem->buf;
+	tuple->TupleDataMax = sizeof(cfg_mem->buf)-1;
+	tuple->TupleOffset = 0;
+	tuple->DesiredTuple = CISTPL_CFTABLE_ENTRY;
+	tuple->Attributes = 0;
+
+	ret = pcmcia_get_first_tuple(p_dev, tuple);
+	while (!ret) {
+		cistpl_cftable_entry_t *cfg = &cfg_mem->parse.cftable_entry;
+
+		if (pcmcia_get_tuple_data(p_dev, tuple))
+			goto next_entry;
+
+		if (pcmcia_parse_tuple(p_dev, tuple, &cfg_mem->parse))
+			goto next_entry;
+
+		/* default values */
+		p_dev->conf.ConfigIndex = cfg->index;
+		if (cfg->flags & CISTPL_CFTABLE_DEFAULT)
+			cfg_mem->dflt = *cfg;
+
+		ret = conf_check(p_dev, cfg, &cfg_mem->dflt, vcc, priv_data);
+		if (!ret)
+			break;
+
+next_entry:
+		ret = pcmcia_get_next_tuple(p_dev, tuple);
+	}
+	kfree(cfg_mem);
+	return ret;
+}
+#endif
+
+static int dev_conf_check(struct pcmcia_device *pdev,
+	cistpl_cftable_entry_t *cf, cistpl_cftable_entry_t *def_cf,
+	unsigned int vcc, void *priv_data)
+{
+	struct softing_cs *csdev = priv_data;
+	struct softing *sdev = &csdev->softing;
+	int ret;
+
+	if (!cf->index)
+		goto do_next;
+	/* power settings (Vcc & Vpp) */
+	if (cf->vcc.present & (1 << CISTPL_POWER_VNOM)) {
+		if (vcc != cf->vcc.param[CISTPL_POWER_VNOM]/10000) {
+			dev_alert(&pdev->dev, "cf->Vcc mismatch\n");
+			goto do_next;
+		}
+	} else if (def_cf->vcc.present & (1 << CISTPL_POWER_VNOM)) {
+		if (vcc != def_cf->vcc.param[CISTPL_POWER_VNOM]/10000) {
+			dev_alert(&pdev->dev, "cf->Vcc mismatch\n");
+			goto do_next;
+		}
+	}
+	if (cf->vpp1.present & (1 << CISTPL_POWER_VNOM))
+		pdev->conf.Vpp
+			= cf->vpp1.param[CISTPL_POWER_VNOM] / 10000;
+
+	else if (def_cf->vpp1.present & (1 << CISTPL_POWER_VNOM))
+		pdev->conf.Vpp
+			= def_cf->vpp1.param[CISTPL_POWER_VNOM] / 10000;
+
+	/* interrupt ? */
+	if (cf->irq.IRQInfo1 || def_cf->irq.IRQInfo1)
+		pdev->conf.Attributes |= CONF_ENABLE_IRQ;
+
+	/* IO window */
+	pdev->io.NumPorts1
+		= pdev->io.NumPorts2
+		= 0;
+	/* Memory window */
+	if ((cf->mem.nwin > 0) || (def_cf->mem.nwin > 0)) {
+		memreq_t map;
+		cistpl_mem_t *mem
+			= (cf->mem.nwin) ? &cf->mem : &def_cf->mem;
+		/* softing specific: choose 8 or 16bit access */
+		csdev->win.Attributes = ((sdev->desc->generation >= 2)
+				? WIN_DATA_WIDTH_16 : WIN_DATA_WIDTH_8)
+			| WIN_MEMORY_TYPE_CM
+			| WIN_ENABLE;
+		csdev->win.Base = mem->win[0].host_addr;
+		csdev->win.Size = mem->win[0].len;
+		csdev->win.AccessSpeed = 0;
+		/* softing specific: choose slower access for old cards */
+		if (sdev->desc->generation < 2) {
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 33)
+			pdev->win->ctl.flags
+				= MAP_ACTIVE | MAP_USE_WAIT;
+			pdev->win->ctl.speed = 3;
+#else
+			csdev->win.Attributes |= WIN_USE_WAIT;
+			csdev->win.AccessSpeed = 3;
+#endif
+		}
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 33)
+		ret = pcmcia_request_window(&pdev, &csdev->win, &pdev->win);
+#else
+		ret = pcmcia_request_window(pdev, &csdev->win, &pdev->win);
+#endif
+		if (ret) {
+			dev_alert(&pdev->dev,
+				"pcmcia_request_window() mismatch\n");
+			goto do_next;
+		}
+		map.Page = 0;
+		map.CardOffset = mem->win[0].card_addr;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 33)
+		if (pcmcia_map_mem_page(pdev->win, &map)) {
+#else
+		if (pcmcia_map_mem_page(pdev, pdev->win, &map)) {
+#endif
+			dev_alert(&pdev->dev,
+				"pcmcia_map_mem_page() mismatch\n");
+			goto do_next_win;
+		}
+	} else {
+		dev_info(&pdev->dev, "no memory window in tuple %u\n",
+			cf->index);
+		goto do_next;
+	}
+	return 0;
+do_next_win:
+do_next:
+	pcmcia_disable_device(pdev);
+	return -ENODEV;
+}
+
+static void driver_remove(struct pcmcia_device *pcmcia)
+{
+	struct softing *card = (struct softing *)pcmcia->priv;
+	struct softing_cs *cs = softing2cs(card);
+	dev_dbg(&pcmcia->dev, "%s, device '%s'\n"
+		, card->id.name, pcmcia->devname);
+	rm_softing(card);
+	/* release pcmcia stuff */
+	pcmcia_disable_device(pcmcia);
+	/* free bits */
+	kfree(cs);
+}
+
+static int __devinit driver_probe(struct pcmcia_device *pcmcia)
+{
+	struct softing_cs *cs;
+	struct softing *card;
+	char *str;
+	char line[1024]; /* possible memory corruption */
+
+	dev_dbg(&pcmcia->dev, "on %s\n", pcmcia->devname);
+
+	/* Create new softing device */
+	cs = kzalloc(sizeof(*cs), GFP_KERNEL);
+	if (!cs)
+		goto no_mem;
+	/* setup links */
+	card = &cs->softing;
+	pcmcia->priv = card;
+	card->dev = &pcmcia->dev;
+	/* properties */
+	card->id.manf = pcmcia->manf_id;
+	card->id.prod = pcmcia->card_id;
+	card->desc = softing_cs_lookup_desc(card->id.manf, card->id.prod);
+	if (!card->desc) {
+		dev_alert(&pcmcia->dev, "unknown card\n");
+		goto description_failed;
+	}
+	if (card->desc->generation >= 2) {
+		card->fn.reset = card_reset_via_dpram;
+	} else {
+		card->fn.reset = card_reset_via_pcmcia;
+		card->fn.enable_irq = card_enable_irq_via_pcmcia;
+	}
+
+	card->nbus = 2;
+	/* pcmcia presets */
+	pcmcia->irq.Attributes = IRQ_TYPE_DYNAMIC_SHARING;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 33)
+	pcmcia->irq.IRQInfo1 = IRQ_LEVEL_ID;
+#endif
+	pcmcia->irq.Handler	= 0;
+	pcmcia->conf.Attributes = 0;
+	pcmcia->conf.IntType = INT_MEMORY_AND_IO;
+
+	if (pcmcia_loop_config(pcmcia, dev_conf_check, cs))
+		goto config_failed;
+
+	if (pcmcia_request_irq(pcmcia, &pcmcia->irq))
+		goto config_failed;
+
+	if (pcmcia_request_configuration(pcmcia, &pcmcia->conf))
+		goto config_failed;
+
+	card->dpram.phys = cs->win.Base;
+	card->dpram.size = cs->win.Size;
+
+	if (card->dpram.size != 0x1000) {
+		dev_alert(&pcmcia->dev, "dpram size 0x%lx mismatch\n",
+			card->dpram.size);
+		goto wrong_dpram;
+	}
+
+	/* Finally, report what we've done */
+	str = line;
+	str += sprintf(str, "config index %u", pcmcia->conf.ConfigIndex);
+	if (pcmcia->conf.Vpp)
+		str += sprintf(str, ", Vpp %d.%d",
+			pcmcia->conf.Vpp/10, pcmcia->conf.Vpp%10);
+	if (pcmcia->conf.Attributes & CONF_ENABLE_IRQ) {
+		str += sprintf(str, ", irq %d", pcmcia->irq.AssignedIRQ);
+		card->irq.nr = pcmcia->irq.AssignedIRQ;
+	}
+
+	if (pcmcia->win) {
+		int tmp;
+		const char *p;
+		str += sprintf(str, ", mem 0x%08lx-0x%08lx"
+			, card->dpram.phys
+			, card->dpram.phys + card->dpram.size-1);
+		tmp = cs->win.Attributes;
+		while (tmp) {
+			p = lookup_mask(pcmcia_mem_attr, &tmp);
+			if (!p)
+				continue;
+			str += sprintf(str, " %s", p);
+		}
+	}
+	dev_info(&pcmcia->dev, "%s\n", line);
+
+	if (mk_softing(card))
+		goto softing_failed;
+	return 0;
+
+softing_failed:
+wrong_dpram:
+config_failed:
+description_failed:
+	kfree(cs);
+no_mem:
+	pcmcia_disable_device(pcmcia);
+	return -ENODEV;
+}
+
+static struct pcmcia_device_id driver_ids[] = {
+	/* softing */
+	PCMCIA_DEVICE_MANF_CARD(0x0168, 0x0001),
+	PCMCIA_DEVICE_MANF_CARD(0x0168, 0x0002),
+	PCMCIA_DEVICE_MANF_CARD(0x0168, 0x0004),
+	PCMCIA_DEVICE_MANF_CARD(0x0168, 0x0005),
+	/* vector , manufacturer? */
+	PCMCIA_DEVICE_MANF_CARD(0x0168, 0x0081),
+	PCMCIA_DEVICE_MANF_CARD(0x0168, 0x0084),
+	PCMCIA_DEVICE_MANF_CARD(0x0168, 0x0085),
+	/* EDIC */
+	PCMCIA_DEVICE_MANF_CARD(0x0168, 0x0102),
+	PCMCIA_DEVICE_MANF_CARD(0x0168, 0x0105),
+	PCMCIA_DEVICE_NULL,
+};
+
+MODULE_DEVICE_TABLE(pcmcia, driver_ids);
+
+static struct pcmcia_driver softing_cs_driver = {
+	.owner		= THIS_MODULE,
+	.drv			= {
+	.name		= "softing_cs",
+	},
+	.probe		= driver_probe,
+	.remove		= driver_remove,
+	.id_table	= driver_ids,
+};
+
+static int __init mod_start(void)
+{
+	return pcmcia_register_driver(&softing_cs_driver);
+}
+
+static void __exit mod_stop(void)
+{
+	pcmcia_unregister_driver(&softing_cs_driver);
+}
+
+module_init(mod_start);
+module_exit(mod_stop);
+
+MODULE_DESCRIPTION("softing CANcard driver"
+		", links PCMCIA card to softing driver");
+MODULE_LICENSE("GPL");
+MODULE_SUPPORTED_DEVICE("softing CANcard2");
+
diff --exclude CVS --exclude .git -uNr linux-2.6.27.8/drivers/net/can/softing/softing_fw.c linux-2.6.27.8.modified/drivers/net/can/softing/softing_fw.c
--- linux-2.6.27.8/drivers/net/can/softing/softing_fw.c	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.27.8.modified/drivers/net/can/softing/softing_fw.c	2013-05-30 03:44:18.000000000 -0400
@@ -0,0 +1,664 @@
+/*
+* drivers/net/can/softing/softing_fw.c
+*
+* Copyright (C) 2008
+*
+* - Kurt Van Dijck, EIA Electronics
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the version 2 of the GNU General Public License
+* as published by the Free Software Foundation
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+*/
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/device.h>
+#include <linux/firmware.h>
+#include <linux/interrupt.h>
+#include <linux/sched.h>
+#include <linux/mutex.h>
+#include <linux/io.h>
+#include <asm/div64.h>
+
+#include "softing.h"
+
+static const struct softing_desc carddescs[] = {
+/* never tested, but taken from original softing */
+{	.name = "CAN-AC2-104",
+	.manf = 0x0000, .prod = 0x009,
+	.generation = 1,
+	.freq = 25, .max_brp = 64, .max_sjw = 4,
+	.dpram_size = 0x1000,
+	.boot = {0x0000, 0x000000, fw_dir "boot104.bin",},
+	.load = {0x0800, 0x035000, fw_dir "ld104.bin",},
+	.app = {0x0010, 0x120000, fw_dir "canpc104.bin",},
+	},
+{0, 0,},
+};
+
+MODULE_FIRMWARE(fw_dir "boot104.bin");
+MODULE_FIRMWARE(fw_dir "ld104.bin");
+MODULE_FIRMWARE(fw_dir "canpc104.bin");
+
+int softing_fct_cmd(struct softing *card, int cmd, int vector, const char *msg)
+{
+	int ret;
+	unsigned long stamp;
+	if (vector == RES_OK)
+		vector = RES_NONE;
+	card->dpram.fct->param[0] = cmd;
+	card->dpram.fct->host_access = vector;
+	/* be sure to flush this to the card */
+	wmb();
+	stamp = jiffies;
+	/*wait for card */
+	do {
+		ret = card->dpram.fct->host_access;
+		/* don't have any cached variables */
+		rmb();
+		if (ret == RES_OK) {
+			/*don't read return-value now */
+			ret = card->dpram.fct->returned;
+			if (ret)
+				dev_alert(card->dev,
+					"%s returned %u\n", msg, ret);
+			return 0;
+		}
+		if ((jiffies - stamp) >= 1 * HZ)
+			break;
+		if (in_interrupt())
+			/* go as fast as possible */
+			continue;
+		/* process context => relax */
+		schedule();
+	} while (!signal_pending(current));
+
+	if (ret == RES_NONE) {
+		dev_alert(card->dev,
+			"%s, no response from card on %u/0x%02x\n",
+			msg, cmd, vector);
+		return 1;
+	} else {
+		dev_alert(card->dev,
+			"%s, bad response from card on %u/0x%02x, 0x%04x\n",
+			msg, cmd, vector, ret);
+		/*make sure to return something not 0 */
+		return ret ? ret : 1;
+	}
+}
+
+int softing_bootloader_command(struct softing *card
+		, int command, const char *msg)
+{
+	int ret;
+	unsigned long stamp;
+	card->dpram.receipt[0] = RES_NONE;
+	card->dpram.command[0] = command;
+	/* be sure to flush this to the card */
+	wmb();
+	stamp = jiffies;
+	/*wait for card */
+	do {
+		ret = card->dpram.receipt[0];
+		/* don't have any cached variables */
+		rmb();
+		if (ret == RES_OK)
+			return 0;
+		if ((jiffies - stamp) >= (3 * HZ))
+			break;
+		schedule();
+	} while (!signal_pending(current));
+
+	switch (ret) {
+	case RES_NONE:
+		dev_alert(card->dev, "%s: no response from card\n", msg);
+		break;
+	case RES_NOK:
+		dev_alert(card->dev, "%s: response from card nok\n", msg);
+		break;
+	case RES_UNKNOWN:
+		dev_alert(card->dev, "%s: command 0x%04x unknown\n",
+			msg, command);
+		break;
+	default:
+		dev_alert(card->dev, "%s: bad response from card (%u)]\n",
+			msg, ret);
+		break;
+	}
+	return ret ? ret : 1;
+}
+
+struct fw_hdr {
+	u16 type;
+	u32 addr;
+	u16 len;
+	u16 checksum;
+	const unsigned char *base;
+} __attribute__ ((packed));
+
+static int fw_parse(const unsigned char **pmem, struct fw_hdr *hdr)
+{
+	u16 tmp;
+	const unsigned char *mem;
+	const unsigned char *end;
+	mem = *pmem;
+	hdr->type = (mem[0] << 0) | (mem[1] << 8);
+	hdr->addr = (mem[2] << 0) | (mem[3] << 8)
+		 | (mem[4] << 16) | (mem[5] << 24);
+	hdr->len = (mem[6] << 0) | (mem[7] << 8);
+	hdr->base = &mem[8];
+	hdr->checksum =
+		 (hdr->base[hdr->len] << 0) | (hdr->base[hdr->len + 1] << 8);
+	for (tmp = 0, mem = *pmem, end = &hdr->base[hdr->len]; mem < end; ++mem)
+		tmp += *mem;
+	if (tmp != hdr->checksum)
+		return EINVAL;
+	*pmem += 10 + hdr->len;
+	return 0;
+}
+
+int softing_load_fw(const char *file, struct softing *card,
+			unsigned char *virt, unsigned int size, int offset)
+{
+	const struct firmware *fw;
+	const unsigned char *mem;
+	const unsigned char *end;
+	int ret;
+	u32 start_addr;
+	struct fw_hdr rec;
+	int ok = 0;
+	unsigned char buf[1024];
+
+	ret = request_firmware(&fw, file, card->dev);
+	if (ret) {
+		dev_alert(card->dev, "request_firmware(%s) got %i\n",
+			file, ret);
+		return ret;
+	}
+	dev_dbg(card->dev, "%s, firmware(%s) got %u bytes"
+		", offset %c0x%04x\n",
+		card->id.name, file, (unsigned int)fw->size,
+		(offset >= 0) ? '+' : '-', (unsigned int)abs(offset));
+	/* parse the firmware */
+	mem = fw->data;
+	end = &mem[fw->size];
+	/* look for header record */
+	if (fw_parse(&mem, &rec))
+		goto fw_end;
+	if (rec.type != 0xffff) {
+		dev_alert(card->dev, "firware starts with type 0x%04x\n",
+			rec.type);
+		goto fw_end;
+	}
+	if (strncmp("Structured Binary Format, Softing GmbH"
+			, rec.base, rec.len)) {
+		dev_info(card->dev, "firware string '%.*s'\n",
+			rec.len, rec.base);
+		goto fw_end;
+	}
+	ok |= 1;
+	/* ok, we had a header */
+	while (mem < end) {
+		if (fw_parse(&mem, &rec))
+			break;
+		if (rec.type == 3) {
+			/*start address */
+			start_addr = rec.addr;
+			ok |= 2;
+			continue;
+		} else if (rec.type == 1) {
+			/*eof */
+			ok |= 4;
+			goto fw_end;
+		} else if (rec.type != 0) {
+			dev_alert(card->dev, "unknown record type 0x%04x\n",
+				rec.type);
+			break;
+		}
+
+		if ((rec.addr + rec.len + offset) > size) {
+			dev_alert(card->dev,
+				"firmware out of range (0x%08x / 0x%08x)\n",
+				(rec.addr + rec.len + offset), size);
+			goto fw_end;
+		}
+		memcpy_toio(&virt[rec.addr + offset],
+				 rec.base, rec.len);
+		/* be sure to flush caches from IO space */
+		mb();
+		if (rec.len > sizeof(buf)) {
+			dev_info(card->dev,
+				"record is big (%u bytes), not verifying\n",
+				rec.len);
+			continue;
+		}
+		/* verify record data */
+		memcpy_fromio(buf, &virt[rec.addr + offset], rec.len);
+		if (!memcmp(buf, rec.base, rec.len))
+			/* is ok */
+			continue;
+		dev_alert(card->dev, "0x%08x:0x%03x at 0x%p failed\n",
+			rec.addr, rec.len, &virt[rec.addr + offset]);
+		goto fw_end;
+	}
+fw_end:
+	release_firmware(fw);
+	if (0x5 == (ok & 0x5)) {
+		/*got eof & start */
+		return 0;
+	}
+	dev_info(card->dev, "firmware %s failed\n", file);
+	return EINVAL;
+}
+
+int softing_load_app_fw(const char *file, struct softing *card)
+{
+	const struct firmware *fw;
+	const unsigned char *mem;
+	const unsigned char *end;
+	int ret;
+	struct fw_hdr rec;
+	int ok = 0;
+	u32 start_addr = 0;
+	u16 rx_sum;
+	unsigned int sum;
+	const unsigned char *mem_lp;
+	const unsigned char *mem_end;
+	struct cpy {
+		u32 src;
+		u32 dst;
+		u16 len;
+		u8 do_cs;
+	} __attribute__((packed)) *pcpy =
+		 (struct cpy *)&card->dpram.command[1];
+	struct cmd {
+		u32 start;
+		u8 autorestart;
+	} __attribute__((packed)) *pcmdstart =
+		(struct cmd *)&card->dpram.command[1];
+
+	ret = request_firmware(&fw, file, card->dev);
+	if (ret) {
+		dev_alert(card->dev, "request_firmware(%s) got %i\n",
+			file, ret);
+		return ret;
+	}
+	dev_dbg(card->dev, "%s, firmware(%s) got %lu bytes\n",
+		card->id.name, file, (unsigned long)fw->size);
+	/* parse the firmware */
+	mem = fw->data;
+	end = &mem[fw->size];
+	/* look for header record */
+	if (fw_parse(&mem, &rec))
+		goto fw_end;
+	if (rec.type != 0xffff) {
+		dev_alert(card->dev, "firware starts with type 0x%04x\n",
+			rec.type);
+		goto fw_end;
+	}
+	if (strncmp("Structured Binary Format, Softing GmbH"
+		, rec.base, rec.len)) {
+		dev_alert(card->dev, "firware string '%.*s' fault\n",
+			rec.len, rec.base);
+		goto fw_end;
+	}
+	ok |= 1;
+	/* ok, we had a header */
+	while (mem < end) {
+		if (fw_parse(&mem, &rec))
+			break;
+
+		if (rec.type == 3) {
+			/*start address */
+			start_addr = rec.addr;
+			ok |= 2;
+			continue;
+		} else if (rec.type == 1) {
+			/*eof */
+			ok |= 4;
+			goto fw_end;
+		} else if (rec.type != 0) {
+			dev_alert(card->dev, "unknown record type 0x%04x\n",
+				rec.type);
+			break;
+		}
+		/* regualar data */
+		for (sum = 0, mem_lp = rec.base, mem_end = &mem_lp[rec.len];
+			mem_lp < mem_end; ++mem_lp)
+			sum += *mem_lp;
+
+		memcpy_toio(&card->dpram. virt[card->desc->app.offs],
+				 rec.base, rec.len);
+		pcpy->src = card->desc->app.offs + card->desc->app.addr;
+		pcpy->dst = rec.addr;
+		pcpy->len = rec.len;
+		pcpy->do_cs = 1;
+		if (softing_bootloader_command(card, 1, "loading app."))
+			goto fw_end;
+		/*verify checksum */
+		rx_sum = card->dpram.receipt[1];
+		if (rx_sum != (sum & 0xffff)) {
+			dev_alert(card->dev, "SRAM seems to be damaged"
+				", wanted 0x%04x, got 0x%04x\n", sum, rx_sum);
+			goto fw_end;
+		}
+	}
+fw_end:
+	release_firmware(fw);
+	if (ok != 7)
+		goto fw_failed;
+	/*got start, start_addr, & eof */
+	pcmdstart->start = start_addr;
+	pcmdstart->autorestart = 1;
+	if (softing_bootloader_command(card, 3, "start app."))
+		goto fw_failed;
+	dev_info(card->dev, "firmware %s up\n", file);
+	return 0;
+fw_failed:
+	dev_info(card->dev, "firmware %s failed\n", file);
+	return EINVAL;
+}
+
+int softing_reset_chip(struct softing *card)
+{
+	do {
+		/*reset chip */
+		card->dpram.info->reset_rcv_fifo = 0;
+		card->dpram.info->reset = 1;
+		if (!softing_fct_cmd(card, 0, 0, "reset_chip"))
+			break;
+		if (signal_pending(current))
+			goto failed;
+		/*sync */
+		if (softing_fct_cmd(card, 99, 0x55, "sync-a"))
+			goto failed;
+		if (softing_fct_cmd(card, 99, 0xaa, "sync-a"))
+			goto failed;
+	} while (1);
+	card->tx.pending = 0;
+	return 0;
+failed:
+	return -EIO;
+}
+
+static void softing_initialize_timestamp(struct softing *card)
+{
+	uint64_t ovf;
+
+	card->ts_ref = ktime_get();
+
+	/* 16MHz is the reference */
+	ovf = 0x100000000ULL * 16;
+	do_div(ovf, card->desc->freq ?: 16);
+
+	card->ts_overflow = ktime_add_us(ktime_set(0, 0), ovf);
+}
+
+ktime_t softing_raw2ktime(struct softing *card, u32 raw)
+{
+	uint64_t rawl;
+	ktime_t now, real_offset;
+	ktime_t target;
+	ktime_t tmp;
+
+	now = ktime_get();
+	real_offset = ktime_sub(ktime_get_real(), now);
+
+	/* find nsec from card */
+	rawl = raw * 16;
+	do_div(rawl, card->desc->freq ?: 16);
+	target = ktime_add_us(card->ts_ref, rawl);
+	/* test for overflows */
+	tmp = ktime_add(target, card->ts_overflow);
+	while (unlikely(ktime_to_ns(tmp) > ktime_to_ns(now))) {
+		card->ts_ref = ktime_add(card->ts_ref, card->ts_overflow);
+		target = tmp;
+		tmp = ktime_add(target, card->ts_overflow);
+	}
+	return ktime_add(target, real_offset);
+}
+
+int softing_cycle(struct softing *card, struct softing_priv *bus, int up)
+{
+	int ret;
+	struct softing_priv *pbus;
+	int mask_start;
+	int j;
+	struct can_frame msg;
+
+	if (!card->fw.up)
+		return -EIO;
+
+	ret = mutex_lock_interruptible(&card->fw.lock);
+	if (ret)
+		return ret;
+	if (card->fw.failed)
+		goto failed_already;
+
+	mask_start = 0;
+	/* bring netdevs down */
+	for (j = 0; j < card->nbus; ++j) {
+		pbus = card->bus[j];
+		if (!pbus)
+			continue;
+
+		if (bus != pbus)
+			netif_stop_queue(pbus->netdev);
+
+		if ((bus != pbus) && netif_running(pbus->netdev))
+			mask_start |= (1 << j);
+		if (netif_running(pbus->netdev)) {
+			pbus->tx.pending = 0;
+			pbus->tx.echo_put = 0;
+			pbus->tx.echo_get = 0;
+			/* this bus' may just have called open_candev()
+			 * which is rather stupid to call close_candev()
+			 * already
+			 * but we may come here from busoff recovery too
+			 * in which case the echo_skb _needs_ flushing too.
+			 * just be sure to call open_candev() again
+			 */
+			close_candev(pbus->netdev);
+		}
+		pbus->can.state = CAN_STATE_STOPPED;
+	}
+	card->tx.pending = 0;
+	if (bus && up)
+		/* prepare to start this bus as well */
+		mask_start |= (1 << bus->index);
+
+	softing_card_irq(card, 0);
+	ret = softing_reset_chip(card);
+	if (ret)
+		goto failed;
+	if (!mask_start)
+		/* no busses to be brought up */
+		goto card_done;
+
+	/* from here, we must jump to failed: */
+
+	if (mask_start & 1) {
+		pbus = card->bus[0];
+		/*init chip 1 */
+		card->dpram.fct->param[1] = pbus->can.bittiming.brp;
+		card->dpram.fct->param[2] = pbus->can.bittiming.sjw;
+		card->dpram.fct->param[3] =
+			pbus->can.bittiming.phase_seg1 +
+			pbus->can.bittiming.prop_seg;
+		card->dpram.fct->param[4] =
+			pbus->can.bittiming.phase_seg2;
+		card->dpram.fct->param[5] = (pbus->can.ctrlmode &
+			CAN_CTRLMODE_3_SAMPLES) ? 1 : 0;
+		if (softing_fct_cmd(card, 1, 0, "initialize_chip[0]"))
+			goto failed;
+		/*set mode */
+		card->dpram.fct->param[1] = 0;
+		card->dpram.fct->param[2] = 0;
+		if (softing_fct_cmd(card, 3, 0, "set_mode[0]"))
+			goto failed;
+		/*set filter */
+		card->dpram.fct->param[1] = 0x0000;/*card->bus[0].s.msg; */
+		card->dpram.fct->param[2] = 0x07ff;/*card->bus[0].s.msk; */
+		card->dpram.fct->param[3] = 0x0000;/*card->bus[0].l.msg; */
+		card->dpram.fct->param[4] = 0xffff;/*card->bus[0].l.msk; */
+		card->dpram.fct->param[5] = 0x0000;/*card->bus[0].l.msg >> 16;*/
+		card->dpram.fct->param[6] = 0x1fff;/*card->bus[0].l.msk >> 16;*/
+		if (softing_fct_cmd(card, 7, 0, "set_filter[0]"))
+			goto failed;
+		/*set output control */
+		card->dpram.fct->param[1] = pbus->output;
+		if (softing_fct_cmd(card, 5, 0, "set_output[0]"))
+			goto failed;
+	}
+	if (mask_start & 2) {
+		pbus = card->bus[1];
+		/*init chip2 */
+		card->dpram.fct->param[1] = pbus->can.bittiming.brp;
+		card->dpram.fct->param[2] = pbus->can.bittiming.sjw;
+		card->dpram.fct->param[3] =
+			pbus->can.bittiming.phase_seg1 +
+			pbus->can.bittiming.prop_seg;
+		card->dpram.fct->param[4] =
+			pbus->can.bittiming.phase_seg2;
+		card->dpram.fct->param[5] = (pbus->can.ctrlmode &
+			CAN_CTRLMODE_3_SAMPLES) ? 1 : 0;
+		if (softing_fct_cmd(card, 2, 0, "initialize_chip[1]"))
+			goto failed;
+		/*set mode2 */
+		card->dpram.fct->param[1] = 0;
+		card->dpram.fct->param[2] = 0;
+		if (softing_fct_cmd(card, 4, 0, "set_mode[1]"))
+			goto failed;
+		/*set filter2 */
+		card->dpram.fct->param[1] = 0x0000;/*card->bus[1].s.msg; */
+		card->dpram.fct->param[2] = 0x07ff;/*card->bus[1].s.msk; */
+		card->dpram.fct->param[3] = 0x0000;/*card->bus[1].l.msg; */
+		card->dpram.fct->param[4] = 0xffff;/*card->bus[1].l.msk; */
+		card->dpram.fct->param[5] = 0x0000;/*card->bus[1].l.msg >> 16;*/
+		card->dpram.fct->param[6] = 0x1fff;/*card->bus[1].l.msk >> 16;*/
+		if (softing_fct_cmd(card, 8, 0, "set_filter[1]"))
+			goto failed;
+		/*set output control2 */
+		card->dpram.fct->param[1] = pbus->output;
+		if (softing_fct_cmd(card, 6, 0, "set_output[1]"))
+			goto failed;
+	}
+	/*enable_error_frame */
+	/*
+	if (softing_fct_cmd(card, 51, 0, "enable_error_frame"))
+		goto failed;
+	*/
+	/*initialize interface */
+	card->dpram.fct->param[1] = 1;
+	card->dpram.fct->param[2] = 1;
+	card->dpram.fct->param[3] = 1;
+	card->dpram.fct->param[4] = 1;
+	card->dpram.fct->param[5] = 1;
+	card->dpram.fct->param[6] = 1;
+	card->dpram.fct->param[7] = 1;
+	card->dpram.fct->param[8] = 1;
+	card->dpram.fct->param[9] = 1;
+	card->dpram.fct->param[10] = 1;
+	if (softing_fct_cmd(card, 17, 0, "initialize_interface"))
+		goto failed;
+	/*enable_fifo */
+	if (softing_fct_cmd(card, 36, 0, "enable_fifo"))
+		goto failed;
+	/*enable fifo tx ack */
+	if (softing_fct_cmd(card, 13, 0, "fifo_tx_ack[0]"))
+		goto failed;
+	/*enable fifo tx ack2 */
+	if (softing_fct_cmd(card, 14, 0, "fifo_tx_ack[1]"))
+		goto failed;
+	/*enable timestamps */
+	/*is default, no code found */
+	/*start_chip */
+	if (softing_fct_cmd(card, 11, 0, "start_chip"))
+		goto failed;
+	card->dpram.info->bus_state = 0;
+	card->dpram.info->bus_state2 = 0;
+	dev_info(card->dev, "ok for %s, %s/%s\n",
+		card->bus[0]->netdev->name, card->bus[1]->netdev->name,
+		card->id.name);
+	if (card->desc->generation < 2) {
+		card->dpram.irq->to_host = 0;
+		/* flush the DPRAM caches */
+		wmb();
+	}
+
+	softing_initialize_timestamp(card);
+
+	/*
+	 * do socketcan notifications/status changes
+	 * from here, no errors should occur, or the failed: part
+	 * must be reviewed
+	 */
+	memset(&msg, 0, sizeof(msg));
+	msg.can_id = CAN_ERR_FLAG | CAN_ERR_RESTARTED;
+	msg.can_dlc = CAN_ERR_DLC;
+	for (j = 0; j < card->nbus; ++j) {
+		pbus = card->bus[j];
+		if (!pbus)
+			continue;
+		if (!(mask_start & (1 << j)))
+			continue;
+		pbus->can.state = CAN_STATE_ERROR_ACTIVE;
+		open_candev(pbus->netdev);
+		if (bus != pbus) {
+			/* notify other busses on the restart */
+			softing_rx(pbus->netdev, &msg, ktime_set(0, 0));
+			++pbus->can.can_stats.restarts;
+		}
+		netif_wake_queue(pbus->netdev);
+	}
+
+	/* enable interrupts */
+	ret = softing_card_irq(card, 1);
+	if (ret)
+		goto failed;
+card_done:
+	mutex_unlock(&card->fw.lock);
+	return 0;
+failed:
+	dev_alert(card->dev, "firmware failed, going idle\n");
+	softing_card_irq(card, 0);
+	softing_reset_chip(card);
+	card->fw.failed = 1;
+	mutex_unlock(&card->fw.lock);
+	/* bring all other interfaces down */
+	for (j = 0; j < card->nbus; ++j) {
+		pbus = card->bus[j];
+		if (!pbus)
+			continue;
+		dev_close(pbus->netdev);
+	}
+	return -EIO;
+
+failed_already:
+	mutex_unlock(&card->fw.lock);
+	return -EIO;
+}
+
+int softing_default_output(struct softing *card, struct softing_priv *priv)
+{
+	switch (priv->chip) {
+	case 1000:
+		if (card->desc->generation < 2)
+			return 0xfb;
+		return 0xfa;
+	case 5:
+		return 0x60;
+	default:
+		return 0x40;
+	}
+}
+
diff --exclude CVS --exclude .git -uNr linux-2.6.27.8/drivers/net/can/softing/softing_main.c linux-2.6.27.8.modified/drivers/net/can/softing/softing_main.c
--- linux-2.6.27.8/drivers/net/can/softing/softing_main.c	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.27.8.modified/drivers/net/can/softing/softing_main.c	2013-05-30 03:44:18.000000000 -0400
@@ -0,0 +1,841 @@
+/*
+* drivers/net/can/softing/softing_main.c
+*
+* Copyright (C) 2008
+*
+* - Kurt Van Dijck, EIA Electronics
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the version 2 of the GNU General Public License
+* as published by the Free Software Foundation
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+*/
+
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/device.h>
+#include <linux/interrupt.h>
+#include <linux/mutex.h>
+#include <linux/io.h>
+
+#include "softing.h"
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,23)
+#error This driver does not support Kernel versions < 2.6.23
+#endif
+
+#define TX_ECHO_SKB_MAX 4
+
+/*
+ * test is a specific CAN netdev
+ * is online (ie. up 'n running, not sleeping, not busoff
+ */
+static inline int canif_is_active(struct net_device *netdev)
+{
+	struct can_priv *can = netdev_priv(netdev);
+	if (!netif_running(netdev))
+		return 0;
+	return (can->state <= CAN_STATE_ERROR_PASSIVE);
+}
+
+/* trigger the tx queue-ing */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,32)
+static int netdev_start_xmit(struct sk_buff *skb, struct net_device *dev)
+#else
+static netdev_tx_t netdev_start_xmit(struct sk_buff *skb,
+			struct net_device *dev)
+#endif
+{
+	struct softing_priv *priv = netdev_priv(dev);
+	struct softing *card = priv->card;
+	int ret;
+	int bhlock;
+	u8 *ptr;
+	u8 cmd;
+	unsigned int fifo_wr;
+	struct can_frame msg;
+
+	if (can_dropped_invalid_skb(dev, skb))
+		return NETDEV_TX_OK;
+
+	if (in_interrupt()) {
+		bhlock = 0;
+		spin_lock(&card->spin);
+	} else {
+		bhlock = 1;
+		spin_lock_bh(&card->spin);
+	}
+	ret = NETDEV_TX_BUSY;
+	if (!card->fw.up)
+		goto xmit_done;
+	if (card->tx.pending >= TXMAX)
+		goto xmit_done;
+	if (priv->tx.pending >= TX_ECHO_SKB_MAX)
+		goto xmit_done;
+	fifo_wr = card->dpram.tx->wr;
+	if (fifo_wr == card->dpram.tx->rd)
+		/*fifo full */
+		goto xmit_done;
+	memcpy(&msg, skb->data, sizeof(msg));
+	ptr = &card->dpram.tx->fifo[fifo_wr][0];
+	cmd = CMD_TX;
+	if (msg.can_id & CAN_RTR_FLAG)
+		cmd |= CMD_RTR;
+	if (msg.can_id & CAN_EFF_FLAG)
+		cmd |= CMD_XTD;
+	if (priv->index)
+		cmd |= CMD_BUS2;
+	*ptr++ = cmd;
+	*ptr++ = msg.can_dlc;
+	*ptr++ = (msg.can_id >> 0);
+	*ptr++ = (msg.can_id >> 8);
+	if (msg.can_id & CAN_EFF_FLAG) {
+		*ptr++ = (msg.can_id >> 16);
+		*ptr++ = (msg.can_id >> 24);
+	} else {
+		/*increment 1, not 2 as you might think */
+		ptr += 1;
+	}
+	if (!(msg.can_id & CAN_RTR_FLAG))
+		memcpy_toio(ptr, &msg.data[0], msg.can_dlc);
+	if (++fifo_wr >=
+		 sizeof(card->dpram.tx->fifo) /
+		 sizeof(card->dpram.tx->fifo[0]))
+		fifo_wr = 0;
+	card->dpram.tx->wr = fifo_wr;
+	card->tx.last_bus = priv->index;
+	++card->tx.pending;
+	++priv->tx.pending;
+	can_put_echo_skb(skb, dev, priv->tx.echo_put);
+	++priv->tx.echo_put;
+	if (priv->tx.echo_put >= TX_ECHO_SKB_MAX)
+		priv->tx.echo_put = 0;
+	/* can_put_echo_skb() saves the skb, safe to return TX_OK */
+	ret = NETDEV_TX_OK;
+xmit_done:
+	if (bhlock)
+		spin_unlock_bh(&card->spin);
+	else
+		spin_unlock(&card->spin);
+	if (card->tx.pending >= TXMAX) {
+		struct softing_priv *bus;
+		int j;
+		for (j = 0; j < card->nbus; ++j) {
+			bus = card->bus[j];
+			if (!bus)
+				continue;
+			netif_stop_queue(bus->netdev);
+		}
+	}
+	if (ret != NETDEV_TX_OK)
+		netif_stop_queue(dev);
+
+	return ret;
+}
+
+int softing_rx(struct net_device *netdev, const struct can_frame *msg,
+	ktime_t ktime)
+{
+	struct sk_buff *skb;
+	struct can_frame *cf;
+	int ret;
+	struct net_device_stats *stats;
+
+	skb = alloc_can_skb(netdev, &cf);
+	if (!skb)
+		return -ENOMEM;
+	memcpy(cf, msg, sizeof(*msg));
+	skb->tstamp = ktime;
+	ret = netif_rx(skb);
+	if (ret == NET_RX_DROP) {
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,23)
+		stats = can_get_stats(netdev);
+#else
+		stats = &netdev->stats;
+#endif
+		++stats->rx_dropped;
+	}
+	return ret;
+}
+
+static int softing_dev_svc_once(struct softing *card)
+{
+	int j;
+	struct softing_priv *bus;
+	ktime_t ktime;
+	struct can_frame msg;
+
+	unsigned int fifo_rd;
+	unsigned int cnt = 0;
+	struct net_device_stats *stats;
+	u8 *ptr;
+	u32 tmp;
+	u8 cmd;
+
+	memset(&msg, 0, sizeof(msg));
+	if (card->dpram.rx->lost_msg) {
+		/*reset condition */
+		card->dpram.rx->lost_msg = 0;
+		/* prepare msg */
+		msg.can_id = CAN_ERR_FLAG | CAN_ERR_CRTL;
+		msg.can_dlc = CAN_ERR_DLC;
+		msg.data[1] = CAN_ERR_CRTL_RX_OVERFLOW;
+		/*
+		 * service to all busses, we don't know which it was applicable
+		 * but only service busses that are online
+		 */
+		for (j = 0; j < card->nbus; ++j) {
+			bus = card->bus[j];
+			if (!bus)
+				continue;
+			if (!canif_is_active(bus->netdev))
+				/* a dead bus has no overflows */
+				continue;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,23)
+			stats = can_get_stats(bus->netdev);
+#else
+			stats = &bus->netdev->stats;
+#endif
+			++stats->rx_over_errors;
+			softing_rx(bus->netdev, &msg, ktime_set(0, 0));
+		}
+		/* prepare for other use */
+		memset(&msg, 0, sizeof(msg));
+		++cnt;
+	}
+
+	fifo_rd = card->dpram.rx->rd;
+	if (++fifo_rd >= ARRAY_SIZE(card->dpram.rx->fifo))
+		fifo_rd = 0;
+
+	if (card->dpram.rx->wr == fifo_rd)
+		return cnt;
+
+	ptr = &card->dpram.rx->fifo[fifo_rd][0];
+
+	cmd = *ptr++;
+	if (cmd == 0xff) {
+		/*not quite useful, probably the card has got out */
+		dev_alert(card->dev, "got cmd 0x%02x,"
+			" I suspect the card is lost\n", cmd);
+	}
+	/*mod_trace("0x%02x", cmd);*/
+	bus = card->bus[0];
+	if (cmd & CMD_BUS2)
+		bus = card->bus[1];
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,23)
+	stats = can_get_stats(bus->netdev);
+#else
+	stats = &bus->netdev->stats;
+#endif
+	if (cmd & CMD_ERR) {
+		u8 can_state;
+		u8 state;
+		state = *ptr++;
+
+		msg.can_id = CAN_ERR_FLAG;
+		msg.can_dlc = CAN_ERR_DLC;
+
+		if (state & 0x80) {
+			can_state = CAN_STATE_BUS_OFF;
+			msg.can_id |= CAN_ERR_BUSOFF;
+			state = 2;
+		} else if (state & 0x60) {
+			can_state = CAN_STATE_ERROR_PASSIVE;
+			msg.can_id |= CAN_ERR_BUSERROR;
+			msg.data[1] = CAN_ERR_CRTL_TX_PASSIVE;
+			state = 1;
+		} else {
+			can_state = CAN_STATE_ERROR_ACTIVE;
+			state = 0;
+			msg.can_id |= CAN_ERR_BUSERROR;
+		}
+		/*update DPRAM */
+		if (!bus->index)
+			card->dpram.info->bus_state = state;
+		else
+			card->dpram.info->bus_state2 = state;
+		/*timestamp */
+		tmp = (ptr[0] <<  0) | (ptr[1] <<  8)
+		    | (ptr[2] << 16) | (ptr[3] << 24);
+		ptr += 4;
+		ktime = softing_raw2ktime(card, tmp);
+		/*trigger dual port RAM */
+		mb();
+		card->dpram.rx->rd = fifo_rd;
+
+		++bus->can.can_stats.bus_error;
+		++stats->rx_errors;
+		/*update internal status */
+		if (can_state != bus->can.state) {
+			bus->can.state = can_state;
+			if (can_state == CAN_STATE_ERROR_PASSIVE)
+				++bus->can.can_stats.error_passive;
+			if (can_state == CAN_STATE_BUS_OFF) {
+				/* this calls can_close_cleanup() */
+				can_bus_off(bus->netdev);
+				netif_stop_queue(bus->netdev);
+			}
+			/*trigger socketcan */
+			softing_rx(bus->netdev, &msg, ktime);
+		}
+
+	} else {
+		if (cmd & CMD_RTR)
+			msg.can_id |= CAN_RTR_FLAG;
+		/* acknowledge, was tx msg
+		 * no real tx flag to set
+		if (cmd & CMD_ACK) {
+		}
+		 */
+		msg.can_dlc = get_can_dlc(*ptr++);
+		if (cmd & CMD_XTD) {
+			msg.can_id |= CAN_EFF_FLAG;
+			msg.can_id |= (ptr[0] <<  0) | (ptr[1] <<  8)
+				    | (ptr[2] << 16) | (ptr[3] << 24);
+			ptr += 4;
+		} else {
+			msg.can_id |= (ptr[0] << 0) | (ptr[1] << 8);
+			ptr += 2;
+		}
+		tmp = (ptr[0] <<  0) | (ptr[1] <<  8)
+		    | (ptr[2] << 16) | (ptr[3] << 24);
+		ptr += 4;
+		ktime = softing_raw2ktime(card, tmp);
+		memcpy_fromio(&msg.data[0], ptr, 8);
+		ptr += 8;
+		/*trigger dual port RAM */
+		mb();
+		card->dpram.rx->rd = fifo_rd;
+		/*update socket */
+		if (cmd & CMD_ACK) {
+			struct sk_buff *skb;
+			skb = bus->can.echo_skb[bus->tx.echo_get];
+			if (skb)
+				skb->tstamp = ktime;
+			can_get_echo_skb(bus->netdev, bus->tx.echo_get);
+			++bus->tx.echo_get;
+			if (bus->tx.echo_get >= TX_ECHO_SKB_MAX)
+				bus->tx.echo_get = 0;
+			if (bus->tx.pending)
+				--bus->tx.pending;
+			if (card->tx.pending)
+				--card->tx.pending;
+			++stats->tx_packets;
+			stats->tx_bytes += msg.can_dlc;
+		} else {
+			++stats->rx_packets;
+			stats->rx_bytes += msg.can_dlc;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,32)
+			bus->netdev->last_rx = jiffies;
+#endif
+			softing_rx(bus->netdev, &msg, ktime);
+		}
+	}
+	++cnt;
+	return cnt;
+}
+
+static void softing_dev_svc(unsigned long param)
+{
+	struct softing *card = (struct softing *)param;
+	struct softing_priv *bus;
+	int j;
+	int offset;
+
+	spin_lock(&card->spin);
+	while (softing_dev_svc_once(card) > 0)
+		++card->irq.svc_count;
+	spin_unlock(&card->spin);
+	/*resume tx queue's */
+	offset = card->tx.last_bus;
+	for (j = 0; j < card->nbus; ++j) {
+		if (card->tx.pending >= TXMAX)
+			break;
+		bus = card->bus[(j + offset + 1) % card->nbus];
+		if (!bus)
+			continue;
+		if (!canif_is_active(bus->netdev))
+			/* it makes no sense to wake dead busses */
+			continue;
+		if (bus->tx.pending >= TX_ECHO_SKB_MAX)
+			continue;
+		netif_wake_queue(bus->netdev);
+	}
+}
+
+static
+irqreturn_t dev_interrupt_shared(int irq, void *dev_id)
+{
+	struct softing *card = (struct softing *)dev_id;
+	unsigned char ir;
+	ir = card->dpram.virt[0xe02];
+	card->dpram.virt[0xe02] = 0;
+	if (card->dpram.rx->rd == 0xffff) {
+		dev_alert(card->dev, "I think the card is gone\n");
+		return IRQ_NONE;
+	}
+	if (ir == 1) {
+		tasklet_schedule(&card->irq.bh);
+		return IRQ_HANDLED;
+	} else if (ir == 0x10) {
+		return IRQ_NONE;
+	} else {
+		return IRQ_NONE;
+	}
+}
+
+static
+irqreturn_t dev_interrupt_nshared(int irq, void *dev_id)
+{
+	struct softing *card = (struct softing *)dev_id;
+	unsigned char irq_host;
+	irq_host = card->dpram.irq->to_host;
+	/* make sure we have a copy, before clearing the variable in DPRAM */
+	rmb();
+	card->dpram.irq->to_host = 0;
+	/* make sure we cleared it */
+	wmb();
+	if (card->dpram.rx->rd == 0xffff) {
+		dev_alert(card->dev, "I think the card is gone\n");
+		return IRQ_NONE;
+	}
+	tasklet_schedule(&card->irq.bh);
+	return IRQ_HANDLED;
+}
+
+static int netdev_open(struct net_device *ndev)
+{
+	struct softing_priv *priv = netdev_priv(ndev);
+	struct softing *card = priv->card;
+	int ret;
+
+	/* check or determine and set bittime */
+	ret = open_candev(ndev);
+	if (ret)
+		goto failed;
+	ret = softing_cycle(card, priv, 1);
+	if (ret)
+		goto failed;
+	return 0;
+failed:
+	return ret;
+}
+
+static int netdev_stop(struct net_device *ndev)
+{
+	struct softing_priv *priv = netdev_priv(ndev);
+	struct softing *card = priv->card;
+	int ret;
+
+	netif_stop_queue(ndev);
+
+	/* softing cycle does close_candev() */
+	ret = softing_cycle(card, priv, 0);
+	return ret;
+}
+
+static int candev_set_mode(struct net_device *ndev, enum can_mode mode)
+{
+	struct softing_priv *priv = netdev_priv(ndev);
+	struct softing *card = priv->card;
+	int ret;
+
+	switch (mode) {
+	case CAN_MODE_START:
+		/* softing cycle does close_candev() */
+		ret = softing_cycle(card, priv, 1);
+		return ret;
+	case CAN_MODE_STOP:
+	case CAN_MODE_SLEEP:
+		return -EOPNOTSUPP;
+	}
+	return 0;
+}
+
+/*assume the card->lock is held*/
+
+int softing_card_irq(struct softing *card, int enable)
+{
+	int ret;
+	if (!enable) {
+		if (card->irq.requested && card->irq.nr) {
+			free_irq(card->irq.nr, card);
+			card->irq.requested = 0;
+		}
+		return 0;
+	}
+	if (!card->irq.requested && (card->irq.nr)) {
+		irqreturn_t(*fn) (int, void *);
+		fn = dev_interrupt_nshared;
+		if (card->desc->generation >= 2)
+			fn = dev_interrupt_shared;
+		ret = request_irq(card->irq.nr, fn, IRQF_SHARED,
+				card->id.name, card);
+		if (ret) {
+			dev_alert(card->dev, "%s, request_irq(%u) failed\n",
+				card->id.name, card->irq.nr);
+			return ret;
+		}
+		card->irq.requested = 1;
+	}
+	return 0;
+}
+
+static void shutdown_card(struct softing *card)
+{
+	int fw_up = 0;
+	dev_dbg(card->dev, "%s()\n", __func__);
+	if (mutex_lock_interruptible(&card->fw.lock))
+		/* return -ERESTARTSYS*/;
+	fw_up = card->fw.up;
+	card->fw.up = 0;
+
+	if (card->irq.requested && card->irq.nr) {
+		free_irq(card->irq.nr, card);
+		card->irq.requested = 0;
+	}
+	if (fw_up) {
+		if (card->fn.enable_irq)
+			card->fn.enable_irq(card, 0);
+		if (card->fn.reset)
+			card->fn.reset(card, 1);
+	}
+	mutex_unlock(&card->fw.lock);
+	tasklet_kill(&card->irq.bh);
+}
+
+static int boot_card(struct softing *card)
+{
+	unsigned char *lp;
+	static const unsigned char stream[] =
+		{ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, };
+	unsigned char back[sizeof(stream)];
+	dev_dbg(card->dev, "%s()\n", __func__);
+
+	if (mutex_lock_interruptible(&card->fw.lock))
+		return -ERESTARTSYS;
+	if (card->fw.up) {
+		mutex_unlock(&card->fw.lock);
+		return 0;
+	}
+	/*reset board */
+
+	if (card->fn.enable_irq)
+		card->fn.enable_irq(card, 1);
+	/*boot card */
+	if (card->fn.reset)
+		card->fn.reset(card, 1);
+	/*test dp ram */
+	if (!card->dpram.virt)
+		goto open_failed;
+	for (lp = card->dpram.virt; &lp[sizeof(stream)] <= card->dpram.end;
+		lp += sizeof(stream)) {
+
+		memcpy_toio(lp, stream, sizeof(stream));
+		/* flush IO cache */
+		mb();
+		memcpy_fromio(back, lp, sizeof(stream));
+
+		if (!memcmp(back, stream, sizeof(stream)))
+			continue;
+		/* memory is not equal */
+		dev_alert(card->dev, "write to dpram failed at 0x%04lx\n",
+			(unsigned long)(lp - card->dpram.virt));
+		goto open_failed;
+	}
+	wmb();
+	/*load boot firmware */
+	if (softing_load_fw(card->desc->boot.fw, card, card->dpram.virt,
+				 card->dpram.size,
+				 card->desc->boot.offs -
+				 card->desc->boot.addr))
+		goto open_failed;
+	/*load load firmware */
+	if (softing_load_fw(card->desc->load.fw, card, card->dpram.virt,
+				 card->dpram.size,
+				 card->desc->load.offs -
+				 card->desc->load.addr))
+		goto open_failed;
+
+	if (card->fn.reset)
+		card->fn.reset(card, 0);
+	if (softing_bootloader_command(card, 0, "card boot"))
+		goto open_failed;
+	if (softing_load_app_fw(card->desc->app.fw, card))
+		goto open_failed;
+	/*reset chip */
+	card->dpram.info->reset_rcv_fifo = 0;
+	card->dpram.info->reset = 1;
+	/*sync */
+	if (softing_fct_cmd(card, 99, 0x55, "sync-a"))
+		goto open_failed;
+	if (softing_fct_cmd(card, 99, 0xaa, "sync-a"))
+		goto open_failed;
+	/*reset chip */
+	if (softing_fct_cmd(card, 0, 0, "reset_chip"))
+		goto open_failed;
+	/*get_serial */
+	if (softing_fct_cmd(card, 43, 0, "get_serial_number"))
+		goto open_failed;
+	card->id.serial =
+		 (u16) card->dpram.fct->param[1] +
+		 (((u16) card->dpram.fct->param[2]) << 16);
+	/*get_version */
+	if (softing_fct_cmd(card, 12, 0, "get_version"))
+		goto open_failed;
+	card->id.fw = (u16) card->dpram.fct->param[1];
+	card->id.hw = (u16) card->dpram.fct->param[2];
+	card->id.lic = (u16) card->dpram.fct->param[3];
+	card->id.chip[0] = (u16) card->dpram.fct->param[4];
+	card->id.chip[1] = (u16) card->dpram.fct->param[5];
+
+	dev_info(card->dev, "card booted, type %s, "
+			"serial %u, fw %u, hw %u, lic %u, chip (%u,%u)\n",
+		  card->id.name, card->id.serial, card->id.fw, card->id.hw,
+		  card->id.lic, card->id.chip[0], card->id.chip[1]);
+
+	card->fw.up = 1;
+	mutex_unlock(&card->fw.lock);
+	return 0;
+open_failed:
+	card->fw.up = 0;
+	if (card->fn.enable_irq)
+		card->fn.enable_irq(card, 0);
+	if (card->fn.reset)
+		card->fn.reset(card, 1);
+	mutex_unlock(&card->fw.lock);
+	return EINVAL;
+}
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,28)
+static const struct net_device_ops softing_netdev_ops = {
+	.ndo_open 	= netdev_open,
+	.ndo_stop	= netdev_stop,
+	.ndo_start_xmit	= netdev_start_xmit,
+};
+#endif
+
+static const struct can_bittiming_const softing_btr_const = {
+	.tseg1_min = 1,
+	.tseg1_max = 16,
+	.tseg2_min = 1,
+	.tseg2_max = 8,
+	.sjw_max = 4, /* overruled */
+	.brp_min = 1,
+	.brp_max = 32, /* overruled */
+	.brp_inc = 1,
+};
+
+
+static struct softing_priv *mk_netdev(struct softing *card, u16 chip_id)
+{
+	struct net_device *ndev;
+	struct softing_priv *priv;
+
+	ndev = alloc_candev(sizeof(*priv), TX_ECHO_SKB_MAX);
+	if (!ndev) {
+		dev_alert(card->dev, "alloc_candev failed\n");
+		return 0;
+	}
+	priv = netdev_priv(ndev);
+	priv->netdev		= ndev;
+	priv->card		= card;
+	memcpy(&priv->btr_const, &softing_btr_const, sizeof(priv->btr_const));
+	priv->btr_const.brp_max = card->desc->max_brp;
+	priv->btr_const.sjw_max = card->desc->max_sjw;
+	priv->can.bittiming_const = &priv->btr_const;
+	priv->can.clock.freq	= 8000000;
+	priv->chip 		= chip_id;
+	priv->output = softing_default_output(card, priv);
+	SET_NETDEV_DEV(ndev, card->dev);
+
+	ndev->flags |= IFF_ECHO;
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,28)
+	ndev->netdev_ops	= &softing_netdev_ops;
+#else
+	ndev->open		= netdev_open;
+	ndev->stop		= netdev_stop;
+	ndev->hard_start_xmit	= netdev_start_xmit;
+#endif
+	priv->can.do_set_mode	= candev_set_mode;
+	priv->can.ctrlmode_supported = CAN_CTRLMODE_3_SAMPLES;
+
+	return priv;
+}
+
+static int reg_netdev(struct softing_priv *priv)
+{
+	int ret;
+	ret = register_candev(priv->netdev);
+	if (ret) {
+		dev_alert(priv->card->dev, "%s, register failed\n",
+			priv->card->id.name);
+		goto reg_failed;
+	}
+	ret = softing_bus_sysfs_create(priv);
+	if (ret) {
+		dev_alert(priv->card->dev, "%s, sysfs failed\n",
+			priv->card->id.name);
+		goto sysfs_failed;
+	}
+	return 0;
+sysfs_failed:
+	unregister_candev(priv->netdev);
+reg_failed:
+	return EINVAL;
+}
+
+void rm_softing(struct softing *card)
+{
+	int j;
+
+	/*first, disable card*/
+	shutdown_card(card);
+
+	for (j = 0; j < card->nbus; ++j) {
+		if (!card->bus[j])
+			continue;
+		softing_bus_sysfs_remove(card->bus[j]);
+		unregister_candev(card->bus[j]->netdev);
+		free_candev(card->bus[j]->netdev);
+		card->bus[j] = 0;
+	}
+
+	softing_card_sysfs_remove(card);
+
+	iounmap(card->dpram.virt);
+}
+EXPORT_SYMBOL(rm_softing);
+
+int mk_softing(struct softing *card)
+{
+	int j;
+
+	/* try_module_get(THIS_MODULE); */
+	mutex_init(&card->fw.lock);
+	spin_lock_init(&card->spin);
+	tasklet_init(&card->irq.bh, softing_dev_svc, (unsigned long)card);
+
+	if (!card->desc) {
+		dev_alert(card->dev, "no card description\n");
+		goto lookup_failed;
+	}
+	card->id.name = card->desc->name;
+
+	card->dpram.virt = ioremap(card->dpram.phys, card->dpram.size);
+	if (!card->dpram.virt) {
+		dev_alert(card->dev, "dpram ioremap failed\n");
+		goto ioremap_failed;
+	}
+
+	card->dpram.size = card->desc->dpram_size;
+	card->dpram.end = &card->dpram.virt[card->dpram.size];
+	/*initialize_board */
+	card->dpram.rx = (struct softing_rx *)&card->dpram.virt[0x0000];
+	card->dpram.tx = (struct softing_tx *)&card->dpram.virt[0x0400];
+	card->dpram.fct = (struct softing_fct *)&card->dpram.virt[0x0300];
+	card->dpram.info = (struct softing_info *)&card->dpram.virt[0x0330];
+	card->dpram.command = (unsigned short *)&card->dpram.virt[0x07e0];
+	card->dpram.receipt = (unsigned short *)&card->dpram.virt[0x07f0];
+	card->dpram.irq = (struct softing_irq *)&card->dpram.virt[0x07fe];
+
+	/*reset card */
+	if (card->fn.reset)
+		card->fn.reset(card, 1);
+	if (boot_card(card)) {
+		dev_alert(card->dev, "failed to boot\n");
+		goto boot_failed;
+	}
+
+	/*only now, the chip's are known */
+	card->id.freq = card->desc->freq * 1000000UL;
+
+	if (softing_card_sysfs_create(card)) {
+		dev_alert(card->dev, "sysfs failed\n");
+		goto sysfs_failed;
+	}
+
+	if (card->nbus > (sizeof(card->bus) / sizeof(card->bus[0]))) {
+		card->nbus = sizeof(card->bus) / sizeof(card->bus[0]);
+		dev_alert(card->dev, "have %u busses\n", card->nbus);
+	}
+
+	for (j = 0; j < card->nbus; ++j) {
+		card->bus[j] = mk_netdev(card, card->id.chip[j]);
+		if (!card->bus[j]) {
+			dev_alert(card->dev, "failed to make can[%i]", j);
+			goto netdev_failed;
+		}
+		card->bus[j]->index = j;
+	}
+	for (j = 0; j < card->nbus; ++j) {
+		if (reg_netdev(card->bus[j])) {
+			dev_alert(card->dev,
+				"failed to register can[%i]\n", j);
+			goto reg_failed;
+		}
+	}
+	dev_info(card->dev, "card initialised\n");
+	return 0;
+
+reg_failed:
+	for (j = 0; j < card->nbus; ++j) {
+		if (!card->bus[j])
+			continue;
+		softing_bus_sysfs_remove(card->bus[j]);
+		unregister_candev(card->bus[j]->netdev);
+	}
+netdev_failed:
+	for (j = 0; j < card->nbus; ++j) {
+		if (!card->bus[j])
+			continue;
+		free_candev(card->bus[j]->netdev);
+		card->bus[j] = 0;
+	}
+	softing_card_sysfs_remove(card);
+sysfs_failed:
+	shutdown_card(card);
+boot_failed:
+	iounmap(card->dpram.virt);
+	card->dpram.virt = 0;
+	card->dpram.end = 0;
+ioremap_failed:
+lookup_failed:
+	tasklet_kill(&card->irq.bh);
+	return EINVAL;
+}
+EXPORT_SYMBOL(mk_softing);
+
+static int __init mod_start(void)
+{
+	printk(KERN_INFO "[%s] start\n", THIS_MODULE->name);
+	return 0;
+}
+
+static void __exit mod_stop(void)
+{
+	printk(KERN_INFO "[%s] stop\n", THIS_MODULE->name);
+}
+
+module_init(mod_start);
+module_exit(mod_stop);
+
+MODULE_DESCRIPTION("socketcan softing driver");
+MODULE_AUTHOR("Kurt Van Dijck <kurt.van.dijck@eia.be>");
+MODULE_LICENSE("GPL");
+
+int softing_debug = 1;
+EXPORT_SYMBOL(softing_debug);
+module_param(softing_debug, int , S_IRUGO | S_IWUSR | S_IWGRP);
+MODULE_PARM_DESC(softing_debug, "trace softing functions");
diff --exclude CVS --exclude .git -uNr linux-2.6.27.8/drivers/net/can/softing/softing_sysfs.c linux-2.6.27.8.modified/drivers/net/can/softing/softing_sysfs.c
--- linux-2.6.27.8/drivers/net/can/softing/softing_sysfs.c	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.27.8.modified/drivers/net/can/softing/softing_sysfs.c	2013-05-30 03:44:18.000000000 -0400
@@ -0,0 +1,222 @@
+/*
+* drivers/net/can/softing/softing_sysfs.c
+*
+* Copyright (C) 2009
+*
+* - Kurt Van Dijck, EIA Electronics
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the version 2 of the GNU General Public License
+* as published by the Free Software Foundation
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+*/
+
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/device.h>
+#include <linux/mutex.h>
+
+#include "softing.h"
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,23)
+#error This driver does not support Kernel versions < 2.6.23
+#endif
+
+/*sysfs stuff*/
+
+/* Because the struct softing may be used by pcmcia devices
+ * as well as pci devices, * we have no clue how to get
+ * from a struct device * towards the struct softing *.
+ * It may go over a pci_device->priv or over a pcmcia_device->priv.
+ * Therefore, provide the struct softing pointer within the attribute.
+ * Then we don't need driver/bus specific things in these attributes
+ */
+struct softing_attribute {
+	struct device_attribute dev;
+	ssize_t (*show) (struct softing *card, char *buf);
+	ssize_t (*store)(struct softing *card, const char *buf, size_t count);
+	struct softing *card;
+};
+
+static ssize_t rd_card_attr(struct device *dev, struct device_attribute *attr
+		, char *buf) {
+	struct softing_attribute *cattr
+		= container_of(attr, struct softing_attribute, dev);
+	return cattr->show ? cattr->show(cattr->card, buf) : 0;
+}
+static ssize_t wr_card_attr(struct device *dev, struct device_attribute *attr
+		, const char *buf, size_t count) {
+	struct softing_attribute *cattr
+		= container_of(attr, struct softing_attribute, dev);
+	return cattr->store ? cattr->store(cattr->card, buf, count) : 0;
+}
+
+#define declare_attr(_name, _mode, _show, _store) { \
+	.dev = { \
+		.attr = { \
+			.name = __stringify(_name), \
+			.mode = _mode, \
+		}, \
+		.show = rd_card_attr, \
+		.store = wr_card_attr, \
+	}, \
+	.show =	_show, \
+	.store = _store, \
+}
+
+#define CARD_SHOW(name, member) \
+static ssize_t show_##name(struct softing *card, char *buf) { \
+	return sprintf(buf, "%u\n", card->member); \
+}
+CARD_SHOW(serial	, id.serial);
+CARD_SHOW(firmware	, id.fw);
+CARD_SHOW(hardware	, id.hw);
+CARD_SHOW(license	, id.lic);
+CARD_SHOW(freq		, id.freq);
+CARD_SHOW(txpending	, tx.pending);
+
+static const struct softing_attribute card_attr_proto[] = {
+	declare_attr(serial	, 0444, show_serial	, 0),
+	declare_attr(firmware	, 0444, show_firmware	, 0),
+	declare_attr(hardware	, 0444, show_hardware	, 0),
+	declare_attr(license	, 0444, show_license	, 0),
+	declare_attr(freq	, 0444, show_freq	, 0),
+	declare_attr(txpending	, 0644, show_txpending	, 0),
+};
+
+int softing_card_sysfs_create(struct softing *card)
+{
+	int size;
+	int j;
+
+	size = sizeof(card_attr_proto)/sizeof(card_attr_proto[0]);
+	card->attr = kmalloc((size+1)*sizeof(card->attr[0]), GFP_KERNEL);
+	if (!card->attr)
+		goto attr_mem_failed;
+	memcpy(card->attr, card_attr_proto, size * sizeof(card->attr[0]));
+	memset(&card->attr[size], 0, sizeof(card->attr[0]));
+
+	card->grp  = kmalloc((size+1)*sizeof(card->grp[0]), GFP_KERNEL);
+	if (!card->grp)
+		goto grp_mem_failed;
+
+	for (j = 0; j < size; ++j) {
+		card->attr[j].card = card;
+		card->grp[j] = &card->attr[j].dev.attr;
+		if (!card->attr[j].show)
+			card->attr[j].dev.attr.mode &= ~(S_IRUGO);
+		if (!card->attr[j].store)
+			card->attr[j].dev.attr.mode &= ~(S_IWUGO);
+	}
+	card->grp[size] = 0;
+	card->sysfs.name	= "softing";
+	card->sysfs.attrs = card->grp;
+	if (sysfs_create_group(&card->dev->kobj, &card->sysfs) < 0)
+		goto sysfs_failed;
+
+	return 0;
+
+sysfs_failed:
+	kfree(card->grp);
+grp_mem_failed:
+	kfree(card->attr);
+attr_mem_failed:
+	return -1;
+}
+void softing_card_sysfs_remove(struct softing *card)
+{
+	sysfs_remove_group(&card->dev->kobj, &card->sysfs);
+	kfree(card->grp);
+	kfree(card->attr);
+}
+
+static ssize_t show_channel(struct device *dev
+		, struct device_attribute *attr, char *buf)
+{
+	struct net_device *ndev = to_net_dev(dev);
+	struct softing_priv *priv = netdev2softing(ndev);
+	return sprintf(buf, "%i\n", priv->index);
+}
+
+static ssize_t show_chip(struct device *dev
+		, struct device_attribute *attr, char *buf)
+{
+	struct net_device *ndev = to_net_dev(dev);
+	struct softing_priv *priv = netdev2softing(ndev);
+	return sprintf(buf, "%i\n", priv->chip);
+}
+
+static ssize_t show_output(struct device *dev
+		, struct device_attribute *attr, char *buf)
+{
+	struct net_device *ndev = to_net_dev(dev);
+	struct softing_priv *priv = netdev2softing(ndev);
+	return sprintf(buf, "0x%02x\n", priv->output);
+}
+
+static ssize_t store_output(struct device *dev
+		, struct device_attribute *attr
+		, const char *buf, size_t count)
+{
+	struct net_device *ndev = to_net_dev(dev);
+	struct softing_priv *priv = netdev2softing(ndev);
+	struct softing *card = priv->card;
+	unsigned long val;
+	int ret;
+
+	ret = strict_strtoul(buf, 0, &val);
+	if (ret < 0)
+		return ret;
+	val &= 0xFF;
+
+	ret = mutex_lock_interruptible(&card->fw.lock);
+	if (ret)
+		return -ERESTARTSYS;
+	if (netif_running(ndev)) {
+		mutex_unlock(&card->fw.lock);
+		return -EBUSY;
+	}
+	priv->output = val;
+	mutex_unlock(&card->fw.lock);
+	return count;
+}
+/* TODO
+ * the latest softing cards support sleep mode too
+ */
+
+static const DEVICE_ATTR(channel, S_IRUGO, show_channel, 0);
+static const DEVICE_ATTR(chip, S_IRUGO, show_chip, 0);
+static const DEVICE_ATTR(output, S_IRUGO | S_IWUSR, show_output, store_output);
+
+static const struct attribute *const netdev_sysfs_entries[] = {
+	&dev_attr_channel	.attr,
+	&dev_attr_chip		.attr,
+	&dev_attr_output	.attr,
+	0,
+};
+static const struct attribute_group netdev_sysfs = {
+	.name  = 0,
+	.attrs = (struct attribute **)netdev_sysfs_entries,
+};
+
+int softing_bus_sysfs_create(struct softing_priv *priv)
+{
+	if (!priv->netdev->dev.kobj.sd) {
+		dev_alert(priv->card->dev, "sysfs_create_group would fail\n");
+		return ENODEV;
+	}
+	return sysfs_create_group(&priv->netdev->dev.kobj, &netdev_sysfs);
+}
+void softing_bus_sysfs_remove(struct softing_priv *priv)
+{
+	sysfs_remove_group(&priv->netdev->dev.kobj, &netdev_sysfs);
+}
+
diff --exclude CVS --exclude .git -uNr linux-2.6.27.8/drivers/net/can/sysfs.c linux-2.6.27.8.modified/drivers/net/can/sysfs.c
--- linux-2.6.27.8/drivers/net/can/sysfs.c	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.27.8.modified/drivers/net/can/sysfs.c	2013-05-30 03:44:17.000000000 -0400
@@ -0,0 +1,539 @@
+/*
+ * $Id: dev.c 542 2007-11-07 13:57:16Z thuermann $
+ *
+ * Copyright (C) 2007-2008 Wolfgang Grandegger <wg@grandegger.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the version 2 of the GNU General Public License
+ * as published by the Free Software Foundation
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/capability.h>
+#include <linux/kernel.h>
+#include <linux/version.h>
+#include <linux/netdevice.h>
+#include <linux/if_arp.h>
+#include <net/sock.h>
+#include <linux/rtnetlink.h>
+
+#include <socketcan/can.h>
+#include <socketcan/can/dev.h>
+
+#include "sysfs.h"
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,25)
+int strict_strtoul(const char *cp, unsigned int base, unsigned long *res)
+{
+	char *tail;
+	unsigned long val;
+	size_t len;
+
+	*res = 0;
+	len = strlen(cp);
+	if (len == 0)
+		return -EINVAL;
+
+	val = simple_strtoul(cp, &tail, base);
+	if ((*tail == '\0') ||
+		((len == (size_t)(tail - cp) + 1) && (*tail == '\n'))) {
+		*res = val;
+		return 0;
+	}
+
+	return -EINVAL;
+}
+#endif
+
+#ifdef CONFIG_SYSFS
+
+/*
+ * SYSFS access functions and attributes. Use same locking as
+ * net/core/net-sysfs.c does.
+ */
+static inline int dev_isalive(const struct net_device *dev)
+{
+	return dev->reg_state <= NETREG_REGISTERED;
+}
+
+/* use same locking rules as GIF* ioctl's */
+static ssize_t can_dev_show(struct device *d,
+			    struct device_attribute *attr, char *buf,
+			    ssize_t (*fmt)(struct net_device *, char *))
+{
+	struct net_device *dev = to_net_dev(d);
+	ssize_t ret = -EINVAL;
+
+	read_lock(&dev_base_lock);
+	if (dev_isalive(dev))
+		ret = (*fmt)(dev, buf);
+	read_unlock(&dev_base_lock);
+
+	return ret;
+}
+
+/* generate a show function for simple field */
+#define CAN_DEV_SHOW(field, fmt_string)					\
+static ssize_t fmt_can_##field(struct net_device *dev, char *buf)	\
+{									\
+	struct can_priv *priv = netdev_priv(dev);			\
+	return sprintf(buf, fmt_string, priv->field);			\
+}									\
+static ssize_t show_can_##field(struct device *d,			\
+				struct device_attribute *attr,		\
+				char *buf)				\
+{									\
+	return can_dev_show(d, attr, buf, fmt_can_##field);		\
+}
+
+/* use same locking and permission rules as SIF* ioctl's */
+static ssize_t can_dev_store(struct device *d, struct device_attribute *attr,
+			     const char *buf, size_t len,
+			     int (*set)(struct net_device *, unsigned long))
+{
+	struct net_device *dev = to_net_dev(d);
+	unsigned long new;
+	int ret = -EINVAL;
+
+	if (!capable(CAP_NET_ADMIN))
+		return -EPERM;
+
+	ret = strict_strtoul(buf, 0, &new);
+	if (ret)
+		goto out;
+
+	rtnl_lock();
+	if (dev_isalive(dev)) {
+		ret = (*set)(dev, new);
+		if (!ret)
+			ret = len;
+	}
+	rtnl_unlock();
+out:
+	return ret;
+}
+
+#define CAN_CREATE_FILE(_dev, _name)					\
+	if (device_create_file(&_dev->dev, &dev_attr_##_name))		\
+		dev_err(ND2D(_dev),					\
+			"Couldn't create device file for ##_name\n")
+
+#define CAN_REMOVE_FILE(_dev, _name)					\
+	device_remove_file(&_dev->dev, &dev_attr_##_name)		\
+
+CAN_DEV_SHOW(ctrlmode, "0x%x\n");
+
+static int change_can_ctrlmode(struct net_device *dev, unsigned long ctrlmode)
+{
+	struct can_priv *priv = netdev_priv(dev);
+
+	if (priv->state != CAN_STATE_STOPPED)
+		return -EBUSY;
+
+	priv->ctrlmode = ctrlmode;
+
+	return 0;
+}
+
+static ssize_t store_can_ctrlmode(struct device *dev,
+				  struct device_attribute *attr,
+				  const char *buf, size_t len)
+{
+	return can_dev_store(dev, attr, buf, len, change_can_ctrlmode);
+}
+
+static DEVICE_ATTR(can_ctrlmode, S_IRUGO | S_IWUSR,
+		   show_can_ctrlmode, store_can_ctrlmode);
+
+static const char *can_state_names[] = {
+	"active", "bus-warn", "bus-pass" , "bus-off",
+	"stopped", "sleeping", "unkown"
+};
+
+static ssize_t printf_can_state(struct net_device *dev, char *buf)
+{
+	struct can_priv *priv = netdev_priv(dev);
+	enum can_state state;
+	int err = 0;
+
+	if (priv->do_get_state) {
+		err = priv->do_get_state(dev, &state);
+		if (err)
+			goto out;
+		priv->state = state;
+	} else
+		state = priv->state;
+
+	if (state >= ARRAY_SIZE(can_state_names))
+		state = ARRAY_SIZE(can_state_names) - 1;
+	err = sprintf(buf, "%s\n", can_state_names[state]);
+out:
+	return err;
+}
+
+static ssize_t show_can_state(struct device *d,
+			      struct device_attribute *attr, char *buf)
+{
+	return can_dev_show(d, attr, buf, printf_can_state);
+}
+
+static DEVICE_ATTR(can_state, S_IRUGO, show_can_state, NULL);
+
+CAN_DEV_SHOW(restart_ms, "%d\n");
+
+static int change_can_restart_ms(struct net_device *dev, unsigned long ms)
+{
+	struct can_priv *priv = netdev_priv(dev);
+
+	if (priv->restart_ms < 0)
+		return -EOPNOTSUPP;
+	if (priv->state != CAN_STATE_STOPPED)
+		return -EBUSY;
+	priv->restart_ms = ms;
+	return 0;
+}
+
+static ssize_t store_can_restart_ms(struct device *dev,
+				    struct device_attribute *attr,
+				    const char *buf, size_t len)
+{
+	return can_dev_store(dev, attr, buf, len, change_can_restart_ms);
+}
+
+static DEVICE_ATTR(can_restart_ms, S_IRUGO | S_IWUSR,
+		   show_can_restart_ms, store_can_restart_ms);
+
+static ssize_t printf_can_echo(struct net_device *dev, char *buf)
+{
+	return sprintf(buf, "%d\n", dev->flags & IFF_ECHO ? 1 : 0);
+}
+
+static ssize_t show_can_echo(struct device *d,
+			  struct device_attribute *attr, char *buf)
+{
+	return can_dev_show(d, attr, buf, printf_can_echo);
+}
+
+static int change_can_echo(struct net_device *dev, unsigned long on)
+{
+	if (on)
+		dev->flags |= IFF_ECHO;
+	else
+		dev->flags &= ~IFF_ECHO;
+	return 0;
+}
+
+static ssize_t store_can_echo(struct device *dev,
+			      struct device_attribute *attr,
+			      const char *buf, size_t len)
+{
+	return can_dev_store(dev, attr, buf, len, change_can_echo);
+}
+
+static DEVICE_ATTR(can_echo, S_IRUGO | S_IWUSR, show_can_echo, store_can_echo);
+
+static int change_can_restart(struct net_device *dev, unsigned long on)
+{
+	return can_restart_now(dev);
+}
+
+static ssize_t store_can_restart(struct device *dev,
+				 struct device_attribute *attr,
+				 const char *buf, size_t len)
+{
+	return can_dev_store(dev, attr, buf, len, change_can_restart);
+}
+
+static DEVICE_ATTR(can_restart, S_IWUSR, NULL, store_can_restart);
+
+/* Show a given attribute if the CAN bittiming group */
+static ssize_t can_btc_show(const struct device *d,
+			    struct device_attribute *attr, char *buf,
+			    unsigned long offset)
+{
+	struct net_device *dev = to_net_dev(d);
+	struct can_priv *priv = netdev_priv(dev);
+	struct can_bittiming_const *btc = priv->bittiming_const;
+	ssize_t ret = -EINVAL;
+
+	WARN_ON(offset >= sizeof(struct can_bittiming_const) ||
+		offset % sizeof(u32) != 0);
+
+	read_lock(&dev_base_lock);
+	if (dev_isalive(dev) && btc)
+		ret = sprintf(buf, "%d\n",
+			      *(u32 *)(((u8 *)btc) + offset));
+
+	read_unlock(&dev_base_lock);
+	return ret;
+}
+
+/* Generate a read-only bittiming const attribute */
+#define CAN_BT_CONST_ENTRY(name)					\
+static ssize_t show_##name(struct device *d,				\
+			   struct device_attribute *attr, char *buf) 	\
+{									\
+	return can_btc_show(d, attr, buf,				\
+			    offsetof(struct can_bittiming_const, name));\
+}									\
+static DEVICE_ATTR(hw_##name, S_IRUGO, show_##name, NULL)
+
+CAN_BT_CONST_ENTRY(tseg1_min);
+CAN_BT_CONST_ENTRY(tseg1_max);
+CAN_BT_CONST_ENTRY(tseg2_min);
+CAN_BT_CONST_ENTRY(tseg2_max);
+CAN_BT_CONST_ENTRY(sjw_max);
+CAN_BT_CONST_ENTRY(brp_min);
+CAN_BT_CONST_ENTRY(brp_max);
+CAN_BT_CONST_ENTRY(brp_inc);
+
+static ssize_t can_bt_show(const struct device *d,
+			   struct device_attribute *attr, char *buf,
+			   unsigned long offset)
+{
+	struct net_device *dev = to_net_dev(d);
+	struct can_priv *priv = netdev_priv(dev);
+	struct can_bittiming *bt = &priv->bittiming;
+	ssize_t ret = -EINVAL;
+	u32 *ptr, val;
+
+	WARN_ON(offset >= sizeof(struct can_bittiming) ||
+		offset % sizeof(u32) != 0);
+
+	read_lock(&dev_base_lock);
+	if (dev_isalive(dev)) {
+		ptr = (u32 *)(((u8 *)bt) + offset);
+		if (ptr == &bt->sample_point &&
+		    priv->state != CAN_STATE_STOPPED)
+			val = can_sample_point(bt);
+		else
+			val = *ptr;
+		ret = sprintf(buf, "%d\n", val);
+	}
+	read_unlock(&dev_base_lock);
+	return ret;
+}
+
+static ssize_t can_bt_store(const struct device *d,
+			    struct device_attribute *attr,
+			    const char *buf, size_t count,
+			    unsigned long offset)
+{
+	struct net_device *dev = to_net_dev(d);
+	struct can_priv *priv = netdev_priv(dev);
+	struct can_bittiming *bt = &priv->bittiming;
+	unsigned long new;
+	ssize_t ret = -EINVAL;
+	u32 *ptr;
+
+	if (priv->state != CAN_STATE_STOPPED)
+		return -EBUSY;
+
+	WARN_ON(offset >= sizeof(struct can_bittiming) ||
+		offset % sizeof(u32) != 0);
+
+	ret = strict_strtoul(buf, 0, &new);
+	if (ret)
+		goto out;
+
+	ptr = (u32 *)(((u8 *)bt) + offset);
+	rtnl_lock();
+	if (dev_isalive(dev)) {
+		*ptr = (u32)new;
+
+		if ((ptr == &bt->bitrate) || (ptr == &bt->sample_point)) {
+			bt->tq = 0;
+			bt->brp = 0;
+			bt->sjw = 0;
+			bt->prop_seg = 0;
+			bt->phase_seg1 = 0;
+			bt->phase_seg2 = 0;
+		} else {
+			bt->bitrate = 0;
+			bt->sample_point = 0;
+		}
+		ret = count;
+	}
+	rtnl_unlock();
+out:
+	return ret;
+}
+
+static ssize_t fmt_can_clock(struct net_device *dev, char *buf)
+{
+	struct can_priv *priv = netdev_priv(dev);
+
+	return sprintf(buf, "%d\n", priv->clock.freq);
+}
+
+static ssize_t show_can_clock(struct device *d,
+			      struct device_attribute *attr,
+			      char *buf)
+{
+	return can_dev_show(d, attr, buf, fmt_can_clock);
+}
+static DEVICE_ATTR(hw_clock, S_IRUGO, show_can_clock, NULL);
+
+#define CAN_BT_ENTRY(name)						\
+static ssize_t show_##name(struct device *d,				\
+			   struct device_attribute *attr, char *buf) 	\
+{									\
+	return can_bt_show(d, attr, buf,				\
+			   offsetof(struct can_bittiming, name));	\
+}									\
+static ssize_t store_##name(struct device *d,				\
+			    struct device_attribute *attr,		\
+			    const char *buf, size_t count)		\
+{									\
+	return can_bt_store(d, attr, buf, count,			\
+			    offsetof(struct can_bittiming, name));	\
+}									\
+static DEVICE_ATTR(name, S_IRUGO | S_IWUSR, show_##name, store_##name)
+
+CAN_BT_ENTRY(bitrate);
+CAN_BT_ENTRY(sample_point);
+CAN_BT_ENTRY(tq);
+CAN_BT_ENTRY(prop_seg);
+CAN_BT_ENTRY(phase_seg1);
+CAN_BT_ENTRY(phase_seg2);
+CAN_BT_ENTRY(sjw);
+
+static struct attribute *can_bittiming_attrs[] = {
+	&dev_attr_hw_tseg1_min.attr,
+	&dev_attr_hw_tseg1_max.attr,
+	&dev_attr_hw_tseg2_max.attr,
+	&dev_attr_hw_tseg2_min.attr,
+	&dev_attr_hw_sjw_max.attr,
+	&dev_attr_hw_brp_min.attr,
+	&dev_attr_hw_brp_max.attr,
+	&dev_attr_hw_brp_inc.attr,
+	&dev_attr_hw_clock.attr,
+	&dev_attr_bitrate.attr,
+	&dev_attr_sample_point.attr,
+	&dev_attr_tq.attr,
+	&dev_attr_prop_seg.attr,
+	&dev_attr_phase_seg1.attr,
+	&dev_attr_phase_seg2.attr,
+	&dev_attr_sjw.attr,
+	NULL
+};
+
+/* Minimal number of attributes to support intelligent CAN controllers */
+static struct attribute *can_bittiming_min_attrs[] = {
+	&dev_attr_bitrate.attr,
+	NULL
+};
+
+static struct attribute_group can_bittiming_group = {
+	.name = "can_bittiming",
+	.attrs = can_bittiming_attrs,
+};
+
+/* Show a given attribute in the CAN statistics group */
+static ssize_t can_stat_show(const struct device *d,
+			     struct device_attribute *attr, char *buf,
+			     unsigned long offset)
+{
+	struct net_device *dev = to_net_dev(d);
+	struct can_priv *priv = netdev_priv(dev);
+	struct can_device_stats *stats = &priv->can_stats;
+	ssize_t ret = -EINVAL;
+
+	WARN_ON(offset >= sizeof(struct can_device_stats) ||
+		offset % sizeof(unsigned long) != 0);
+
+	read_lock(&dev_base_lock);
+	if (dev_isalive(dev))
+		ret = sprintf(buf, "%d\n",
+			      *(u32 *)(((u8 *)stats) + offset));
+
+	read_unlock(&dev_base_lock);
+	return ret;
+}
+
+/* Generate a read-only CAN statistics attribute */
+#define CAN_STAT_ENTRY(name)						\
+static ssize_t show_##name(struct device *d,				\
+			   struct device_attribute *attr, char *buf) 	\
+{									\
+	return can_stat_show(d, attr, buf,				\
+			     offsetof(struct can_device_stats, name));	\
+}									\
+static DEVICE_ATTR(name, S_IRUGO, show_##name, NULL)
+
+CAN_STAT_ENTRY(error_warning);
+CAN_STAT_ENTRY(error_passive);
+CAN_STAT_ENTRY(bus_off);
+CAN_STAT_ENTRY(bus_error);
+CAN_STAT_ENTRY(arbitration_lost);
+CAN_STAT_ENTRY(restarts);
+
+static struct attribute *can_statistics_attrs[] = {
+	&dev_attr_error_warning.attr,
+	&dev_attr_error_passive.attr,
+	&dev_attr_bus_off.attr,
+	&dev_attr_bus_error.attr,
+	&dev_attr_arbitration_lost.attr,
+	&dev_attr_restarts.attr,
+	NULL
+};
+
+static struct attribute_group can_statistics_group = {
+	.name = "can_statistics",
+	.attrs = can_statistics_attrs,
+};
+
+void can_create_sysfs(struct net_device *dev)
+{
+	struct can_priv *priv = netdev_priv(dev);
+	int err;
+
+	CAN_CREATE_FILE(dev, can_ctrlmode);
+	CAN_CREATE_FILE(dev, can_echo);
+	CAN_CREATE_FILE(dev, can_restart);
+	CAN_CREATE_FILE(dev, can_state);
+	CAN_CREATE_FILE(dev, can_restart_ms);
+
+	err = sysfs_create_group(&(dev->dev.kobj),
+				 &can_statistics_group);
+	if (err) {
+		printk(KERN_EMERG
+		       "couldn't create sysfs group for CAN statistics\n");
+	}
+
+	if (!priv->bittiming_const)
+		can_bittiming_group.attrs = can_bittiming_min_attrs;
+	err = sysfs_create_group(&(dev->dev.kobj), &can_bittiming_group);
+	if (err) {
+		printk(KERN_EMERG "couldn't create sysfs "
+		       "group for CAN bittiming\n");
+	}
+}
+
+void can_remove_sysfs(struct net_device *dev)
+{
+	struct can_priv *priv = netdev_priv(dev);
+
+	CAN_REMOVE_FILE(dev, can_ctrlmode);
+	CAN_REMOVE_FILE(dev, can_echo);
+	CAN_REMOVE_FILE(dev, can_state);
+	CAN_REMOVE_FILE(dev, can_restart);
+	CAN_REMOVE_FILE(dev, can_restart_ms);
+
+	sysfs_remove_group(&(dev->dev.kobj), &can_statistics_group);
+	if (priv->bittiming_const)
+		sysfs_remove_group(&(dev->dev.kobj), &can_bittiming_group);
+}
+
+#endif /* CONFIG_SYSFS */
+
+
+
diff --exclude CVS --exclude .git -uNr linux-2.6.27.8/drivers/net/can/sysfs.h linux-2.6.27.8.modified/drivers/net/can/sysfs.h
--- linux-2.6.27.8/drivers/net/can/sysfs.h	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.27.8.modified/drivers/net/can/sysfs.h	2013-05-30 03:44:17.000000000 -0400
@@ -0,0 +1,27 @@
+/*
+ * $Id: dev.c 542 2007-11-07 13:57:16Z thuermann $
+ *
+ * Copyright (C) 2007 Wolfgang Grandegger <wg@grandegger.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the version 2 of the GNU General Public License
+ * as published by the Free Software Foundation
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef CAN_SYSFS_H
+#define CAN_SYSFS_H
+
+void can_create_sysfs(struct net_device *dev);
+void can_remove_sysfs(struct net_device *dev);
+int can_sample_point(struct can_bittiming *bt);
+
+#endif /* CAN_SYSFS_H */
diff --exclude CVS --exclude .git -uNr linux-2.6.27.8/drivers/net/can/usb/Kconfig linux-2.6.27.8.modified/drivers/net/can/usb/Kconfig
--- linux-2.6.27.8/drivers/net/can/usb/Kconfig	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.27.8.modified/drivers/net/can/usb/Kconfig	2013-05-30 03:44:17.000000000 -0400
@@ -0,0 +1,16 @@
+menu "CAN USB interfaces"
+	depends on USB && CAN_DEV
+
+config CAN_EMS_USB
+	tristate "EMS CPC-USB/ARM7 CAN/USB interface"
+	---help---
+	  This driver is for the one channel CPC-USB/ARM7 CAN/USB interface
+	  from from EMS Dr. Thomas Wuensche (http://www.ems-wuensche.de).
+
+config CAN_ESD_USB2
+	tristate "ESD USB/2 CAN/USB interface"
+	---help---
+	  This driver supports the CAN-USB/2 interface
+	  from esd electronic system design gmbh (http://www.esd.eu).
+
+endmenu
diff --exclude CVS --exclude .git -uNr linux-2.6.27.8/drivers/net/can/usb/Makefile linux-2.6.27.8.modified/drivers/net/can/usb/Makefile
--- linux-2.6.27.8/drivers/net/can/usb/Makefile	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.27.8.modified/drivers/net/can/usb/Makefile	2013-05-30 03:44:17.000000000 -0400
@@ -0,0 +1,25 @@
+#
+#  Makefile for the Linux Controller Area Network USB drivers.
+#
+
+ifeq ($(KERNELRELEASE),)
+
+KERNELDIR := /lib/modules/$(shell uname -r)/build
+PWD       := $(shell pwd)
+TOPDIR    := $(PWD)/../../../..
+
+modules modules_install clean:
+	$(MAKE) -C $(KERNELDIR) M=$(PWD) $@ TOPDIR=$(TOPDIR)
+
+else
+
+-include $(TOPDIR)/Makefile.common
+
+obj-$(CONFIG_CAN_EMS_USB) += ems_usb.o
+obj-$(CONFIG_CAN_ESD_USB2) += esd_usb2.o
+
+ifeq ($(CONFIG_CAN_DEBUG_DEVICES),y)
+	EXTRA_CFLAGS += -DDEBUG
+endif
+
+endif
diff --exclude CVS --exclude .git -uNr linux-2.6.27.8/drivers/net/can/usb/ems_usb.c linux-2.6.27.8.modified/drivers/net/can/usb/ems_usb.c
--- linux-2.6.27.8/drivers/net/can/usb/ems_usb.c	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.27.8.modified/drivers/net/can/usb/ems_usb.c	2013-05-30 03:44:17.000000000 -0400
@@ -0,0 +1,1165 @@
+/*
+ * CAN driver for EMS Dr. Thomas Wuensche CPC-USB/ARM7
+ *
+ * Copyright (C) 2004-2009 EMS Dr. Thomas Wuensche
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; version 2 of the License.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+#include <linux/init.h>
+#include <linux/signal.h>
+#include <linux/slab.h>
+#include <linux/module.h>
+#include <linux/netdevice.h>
+#include <linux/usb.h>
+
+#include <socketcan/can.h>
+#include <socketcan/can/dev.h>
+#include <socketcan/can/error.h>
+
+MODULE_AUTHOR("Sebastian Haas <haas@ems-wuensche.com>");
+MODULE_DESCRIPTION("CAN driver for EMS Dr. Thomas Wuensche CAN/USB interfaces");
+MODULE_LICENSE("GPL v2");
+
+/* Control-Values for CPC_Control() Command Subject Selection */
+#define CONTR_CAN_MESSAGE 0x04
+#define CONTR_CAN_STATE   0x0C
+#define CONTR_BUS_ERROR   0x1C
+
+/* Control Command Actions */
+#define CONTR_CONT_OFF 0
+#define CONTR_CONT_ON  1
+#define CONTR_ONCE     2
+
+/* Messages from CPC to PC */
+#define CPC_MSG_TYPE_CAN_FRAME       1  /* CAN data frame */
+#define CPC_MSG_TYPE_RTR_FRAME       8  /* CAN remote frame */
+#define CPC_MSG_TYPE_CAN_PARAMS      12 /* Actual CAN parameters */
+#define CPC_MSG_TYPE_CAN_STATE       14 /* CAN state message */
+#define CPC_MSG_TYPE_EXT_CAN_FRAME   16 /* Extended CAN data frame */
+#define CPC_MSG_TYPE_EXT_RTR_FRAME   17 /* Extended remote frame */
+#define CPC_MSG_TYPE_CONTROL         19 /* change interface behavior */
+#define CPC_MSG_TYPE_CONFIRM         20 /* command processed confirmation */
+#define CPC_MSG_TYPE_OVERRUN         21 /* overrun events */
+#define CPC_MSG_TYPE_CAN_FRAME_ERROR 23 /* detected bus errors */
+#define CPC_MSG_TYPE_ERR_COUNTER     25 /* RX/TX error counter */
+
+/* Messages from the PC to the CPC interface  */
+#define CPC_CMD_TYPE_CAN_FRAME     1   /* CAN data frame */
+#define CPC_CMD_TYPE_CONTROL       3   /* control of interface behavior */
+#define CPC_CMD_TYPE_CAN_PARAMS    6   /* set CAN parameters */
+#define CPC_CMD_TYPE_RTR_FRAME     13  /* CAN remote frame */
+#define CPC_CMD_TYPE_CAN_STATE     14  /* CAN state message */
+#define CPC_CMD_TYPE_EXT_CAN_FRAME 15  /* Extended CAN data frame */
+#define CPC_CMD_TYPE_EXT_RTR_FRAME 16  /* Extended CAN remote frame */
+#define CPC_CMD_TYPE_CAN_EXIT      200 /* exit the CAN */
+
+#define CPC_CMD_TYPE_INQ_ERR_COUNTER 25 /* request the CAN error counters */
+#define CPC_CMD_TYPE_CLEAR_MSG_QUEUE 8  /* clear CPC_MSG queue */
+#define CPC_CMD_TYPE_CLEAR_CMD_QUEUE 28 /* clear CPC_CMD queue */
+
+#define CPC_CC_TYPE_SJA1000 2 /* Philips basic CAN controller */
+
+#define CPC_CAN_ECODE_ERRFRAME 0x01 /* Ecode type */
+
+/* Overrun types */
+#define CPC_OVR_EVENT_CAN       0x01
+#define CPC_OVR_EVENT_CANSTATE  0x02
+#define CPC_OVR_EVENT_BUSERROR  0x04
+
+/*
+ * If the CAN controller lost a message we indicate it with the highest bit
+ * set in the count field.
+ */
+#define CPC_OVR_HW 0x80
+
+/* Size of the "struct ems_cpc_msg" without the union */
+#define CPC_MSG_HEADER_LEN   11
+#define CPC_CAN_MSG_MIN_SIZE 5
+
+/* Define these values to match your devices */
+#define USB_CPCUSB_VENDOR_ID 0x12D6
+
+#define USB_CPCUSB_ARM7_PRODUCT_ID 0x0444
+
+/* Mode register NXP LPC2119/SJA1000 CAN Controller */
+#define SJA1000_MOD_NORMAL 0x00
+#define SJA1000_MOD_RM     0x01
+
+/* ECC register NXP LPC2119/SJA1000 CAN Controller */
+#define SJA1000_ECC_SEG   0x1F
+#define SJA1000_ECC_DIR   0x20
+#define SJA1000_ECC_ERR   0x06
+#define SJA1000_ECC_BIT   0x00
+#define SJA1000_ECC_FORM  0x40
+#define SJA1000_ECC_STUFF 0x80
+#define SJA1000_ECC_MASK  0xc0
+
+/* Status register content */
+#define SJA1000_SR_BS 0x80
+#define SJA1000_SR_ES 0x40
+
+#define SJA1000_DEFAULT_OUTPUT_CONTROL 0xDA
+
+/*
+ * The device actually uses a 16MHz clock to generate the CAN clock
+ * but it expects SJA1000 bit settings based on 8MHz (is internally
+ * converted).
+ */
+#define EMS_USB_ARM7_CLOCK 8000000
+
+/*
+ * CAN-Message representation in a CPC_MSG. Message object type is
+ * CPC_MSG_TYPE_CAN_FRAME or CPC_MSG_TYPE_RTR_FRAME or
+ * CPC_MSG_TYPE_EXT_CAN_FRAME or CPC_MSG_TYPE_EXT_RTR_FRAME.
+ */
+struct cpc_can_msg {
+	u32 id;
+	u8 length;
+	u8 msg[8];
+};
+
+/* Representation of the CAN parameters for the SJA1000 controller */
+struct cpc_sja1000_params {
+	u8 mode;
+	u8 acc_code0;
+	u8 acc_code1;
+	u8 acc_code2;
+	u8 acc_code3;
+	u8 acc_mask0;
+	u8 acc_mask1;
+	u8 acc_mask2;
+	u8 acc_mask3;
+	u8 btr0;
+	u8 btr1;
+	u8 outp_contr;
+};
+
+/* CAN params message representation */
+struct cpc_can_params {
+	u8 cc_type;
+
+	/* Will support M16C CAN controller in the future */
+	union {
+		struct cpc_sja1000_params sja1000;
+	} cc_params;
+};
+
+/* Structure for confirmed message handling */
+struct cpc_confirm {
+	u8 error; /* error code */
+};
+
+/* Structure for overrun conditions */
+struct cpc_overrun {
+	u8 event;
+	u8 count;
+};
+
+/* SJA1000 CAN errors (compatible to NXP LPC2119) */
+struct cpc_sja1000_can_error {
+	u8 ecc;
+	u8 rxerr;
+	u8 txerr;
+};
+
+/* structure for CAN error conditions */
+struct cpc_can_error {
+	u8 ecode;
+
+	struct {
+		u8 cc_type;
+
+		/* Other controllers may also provide error code capture regs */
+		union {
+			struct cpc_sja1000_can_error sja1000;
+		} regs;
+	} cc;
+};
+
+/*
+ * Structure containing RX/TX error counter. This structure is used to request
+ * the values of the CAN controllers TX and RX error counter.
+ */
+struct cpc_can_err_counter {
+	u8 rx;
+	u8 tx;
+};
+
+/* Main message type used between library and application */
+struct __attribute__ ((packed)) ems_cpc_msg {
+	u8 type;	/* type of message */
+	u8 length;	/* length of data within union 'msg' */
+	u8 msgid;	/* confirmation handle */
+	u32 ts_sec;	/* timestamp in seconds */
+	u32 ts_nsec;	/* timestamp in nano seconds */
+
+	union {
+		u8 generic[64];
+		struct cpc_can_msg can_msg;
+		struct cpc_can_params can_params;
+		struct cpc_confirm confirmation;
+		struct cpc_overrun overrun;
+		struct cpc_can_error error;
+		struct cpc_can_err_counter err_counter;
+		u8 can_state;
+	} msg;
+};
+
+/*
+ * Table of devices that work with this driver
+ * NOTE: This driver supports only CPC-USB/ARM7 (LPC2119) yet.
+ */
+static struct usb_device_id ems_usb_table[] = {
+	{USB_DEVICE(USB_CPCUSB_VENDOR_ID, USB_CPCUSB_ARM7_PRODUCT_ID)},
+	{} /* Terminating entry */
+};
+
+MODULE_DEVICE_TABLE(usb, ems_usb_table);
+
+#define RX_BUFFER_SIZE      64
+#define CPC_HEADER_SIZE     4
+#define INTR_IN_BUFFER_SIZE 4
+
+#define MAX_RX_URBS 10
+#define MAX_TX_URBS 10
+
+struct ems_usb;
+
+struct ems_tx_urb_context {
+	struct ems_usb *dev;
+
+	u32 echo_index;
+	u8 dlc;
+};
+
+struct ems_usb {
+	struct can_priv can; /* must be the first member */
+	int open_time;
+
+	struct sk_buff *echo_skb[MAX_TX_URBS];
+
+	struct usb_device *udev;
+	struct net_device *netdev;
+
+	atomic_t active_tx_urbs;
+	struct usb_anchor tx_submitted;
+	struct ems_tx_urb_context tx_contexts[MAX_TX_URBS];
+
+	struct usb_anchor rx_submitted;
+
+	struct urb *intr_urb;
+
+	u8 *tx_msg_buffer;
+
+	u8 *intr_in_buffer;
+	unsigned int free_slots; /* remember number of available slots */
+
+	struct ems_cpc_msg active_params; /* active controller parameters */
+};
+
+static void ems_usb_read_interrupt_callback(struct urb *urb)
+{
+	struct ems_usb *dev = urb->context;
+	struct net_device *netdev = dev->netdev;
+	int err;
+
+	if (!netif_device_present(netdev))
+		return;
+
+	switch (urb->status) {
+	case 0:
+		dev->free_slots = dev->intr_in_buffer[1];
+		break;
+
+	case -ECONNRESET: /* unlink */
+	case -ENOENT:
+	case -ESHUTDOWN:
+		return;
+
+	default:
+		dev_info(ND2D(netdev), "Rx interrupt aborted %d\n",
+			 urb->status);
+		break;
+	}
+
+	err = usb_submit_urb(urb, GFP_ATOMIC);
+
+	if (err == -ENODEV)
+		netif_device_detach(netdev);
+	else if (err)
+		dev_err(ND2D(netdev),
+			"failed resubmitting intr urb: %d\n", err);
+
+	return;
+}
+
+static void ems_usb_rx_can_msg(struct ems_usb *dev, struct ems_cpc_msg *msg)
+{
+	struct can_frame *cf;
+	struct sk_buff *skb;
+	int i;
+	struct net_device_stats *stats = &dev->netdev->stats;
+
+	skb = alloc_can_skb(dev->netdev, &cf);
+	if (skb == NULL)
+		return;
+
+	cf->can_id = msg->msg.can_msg.id;
+	cf->can_dlc = get_can_dlc(msg->msg.can_msg.length);
+
+	if (msg->type == CPC_MSG_TYPE_EXT_CAN_FRAME
+	    || msg->type == CPC_MSG_TYPE_EXT_RTR_FRAME)
+		cf->can_id |= CAN_EFF_FLAG;
+
+	if (msg->type == CPC_MSG_TYPE_RTR_FRAME
+	    || msg->type == CPC_MSG_TYPE_EXT_RTR_FRAME) {
+		cf->can_id |= CAN_RTR_FLAG;
+	} else {
+		for (i = 0; i < cf->can_dlc; i++)
+			cf->data[i] = msg->msg.can_msg.msg[i];
+	}
+
+	netif_rx(skb);
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,32)
+	dev->netdev->last_rx = jiffies;
+#endif
+	stats->rx_packets++;
+	stats->rx_bytes += cf->can_dlc;
+}
+
+static void ems_usb_rx_err(struct ems_usb *dev, struct ems_cpc_msg *msg)
+{
+	struct can_frame *cf;
+	struct sk_buff *skb;
+	struct net_device_stats *stats = &dev->netdev->stats;
+
+	skb = alloc_can_err_skb(dev->netdev, &cf);
+	if (skb == NULL)
+		return;
+
+	if (msg->type == CPC_MSG_TYPE_CAN_STATE) {
+		u8 state = msg->msg.can_state;
+
+		if (state & SJA1000_SR_BS) {
+			dev->can.state = CAN_STATE_BUS_OFF;
+			cf->can_id |= CAN_ERR_BUSOFF;
+
+			can_bus_off(dev->netdev);
+		} else if (state & SJA1000_SR_ES) {
+			dev->can.state = CAN_STATE_ERROR_WARNING;
+			dev->can.can_stats.error_warning++;
+		} else {
+			dev->can.state = CAN_STATE_ERROR_ACTIVE;
+			dev->can.can_stats.error_passive++;
+		}
+	} else if (msg->type == CPC_MSG_TYPE_CAN_FRAME_ERROR) {
+		u8 ecc = msg->msg.error.cc.regs.sja1000.ecc;
+		u8 txerr = msg->msg.error.cc.regs.sja1000.txerr;
+		u8 rxerr = msg->msg.error.cc.regs.sja1000.rxerr;
+
+		/* bus error interrupt */
+		dev->can.can_stats.bus_error++;
+		stats->rx_errors++;
+
+		cf->can_id |= CAN_ERR_PROT | CAN_ERR_BUSERROR;
+
+		switch (ecc & SJA1000_ECC_MASK) {
+		case SJA1000_ECC_BIT:
+			cf->data[2] |= CAN_ERR_PROT_BIT;
+			break;
+		case SJA1000_ECC_FORM:
+			cf->data[2] |= CAN_ERR_PROT_FORM;
+			break;
+		case SJA1000_ECC_STUFF:
+			cf->data[2] |= CAN_ERR_PROT_STUFF;
+			break;
+		default:
+			cf->data[2] |= CAN_ERR_PROT_UNSPEC;
+			cf->data[3] = ecc & SJA1000_ECC_SEG;
+			break;
+		}
+
+		/* Error occurred during transmission? */
+		if ((ecc & SJA1000_ECC_DIR) == 0)
+			cf->data[2] |= CAN_ERR_PROT_TX;
+
+		if (dev->can.state == CAN_STATE_ERROR_WARNING ||
+		    dev->can.state == CAN_STATE_ERROR_PASSIVE) {
+			cf->data[1] = (txerr > rxerr) ?
+			    CAN_ERR_CRTL_TX_PASSIVE : CAN_ERR_CRTL_RX_PASSIVE;
+		}
+	} else if (msg->type == CPC_MSG_TYPE_OVERRUN) {
+		cf->can_id |= CAN_ERR_CRTL;
+		cf->data[1] = CAN_ERR_CRTL_RX_OVERFLOW;
+
+		stats->rx_over_errors++;
+		stats->rx_errors++;
+	}
+
+	netif_rx(skb);
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,32)
+	dev->netdev->last_rx = jiffies;
+#endif
+	stats->rx_packets++;
+	stats->rx_bytes += cf->can_dlc;
+}
+
+/*
+ * callback for bulk IN urb
+ */
+static void ems_usb_read_bulk_callback(struct urb *urb)
+{
+	struct ems_usb *dev = urb->context;
+	struct net_device *netdev;
+	int retval;
+
+	netdev = dev->netdev;
+
+	if (!netif_device_present(netdev))
+		return;
+
+	switch (urb->status) {
+	case 0: /* success */
+		break;
+
+	case -ENOENT:
+		return;
+
+	default:
+		dev_info(ND2D(netdev), "Rx URB aborted (%d)\n",
+			 urb->status);
+		goto resubmit_urb;
+	}
+
+	if (urb->actual_length > CPC_HEADER_SIZE) {
+		struct ems_cpc_msg *msg;
+		u8 *ibuf = urb->transfer_buffer;
+		u8 msg_count, again, start;
+
+		msg_count = ibuf[0] & ~0x80;
+		again = ibuf[0] & 0x80;
+
+		start = CPC_HEADER_SIZE;
+
+		while (msg_count) {
+			msg = (struct ems_cpc_msg *)&ibuf[start];
+
+			switch (msg->type) {
+			case CPC_MSG_TYPE_CAN_STATE:
+				/* Process CAN state changes */
+				ems_usb_rx_err(dev, msg);
+				break;
+
+			case CPC_MSG_TYPE_CAN_FRAME:
+			case CPC_MSG_TYPE_EXT_CAN_FRAME:
+			case CPC_MSG_TYPE_RTR_FRAME:
+			case CPC_MSG_TYPE_EXT_RTR_FRAME:
+				ems_usb_rx_can_msg(dev, msg);
+				break;
+
+			case CPC_MSG_TYPE_CAN_FRAME_ERROR:
+				/* Process errorframe */
+				ems_usb_rx_err(dev, msg);
+				break;
+
+			case CPC_MSG_TYPE_OVERRUN:
+				/* Message lost while receiving */
+				ems_usb_rx_err(dev, msg);
+				break;
+			}
+
+			start += CPC_MSG_HEADER_LEN + msg->length;
+			msg_count--;
+
+			if (start > urb->transfer_buffer_length) {
+				dev_err(ND2D(netdev), "format error\n");
+				break;
+			}
+		}
+	}
+
+resubmit_urb:
+	usb_fill_bulk_urb(urb, dev->udev, usb_rcvbulkpipe(dev->udev, 2),
+			  urb->transfer_buffer, RX_BUFFER_SIZE,
+			  ems_usb_read_bulk_callback, dev);
+
+	retval = usb_submit_urb(urb, GFP_ATOMIC);
+
+	if (retval == -ENODEV)
+		netif_device_detach(netdev);
+	else if (retval)
+		dev_err(ND2D(netdev),
+			"failed resubmitting read bulk urb: %d\n", retval);
+
+	return;
+}
+
+/*
+ * callback for bulk IN urb
+ */
+static void ems_usb_write_bulk_callback(struct urb *urb)
+{
+	struct ems_tx_urb_context *context = urb->context;
+	struct ems_usb *dev;
+	struct net_device *netdev;
+
+	BUG_ON(!context);
+
+	dev = context->dev;
+	netdev = dev->netdev;
+
+	/* free up our allocated buffer */
+	usb_buffer_free(urb->dev, urb->transfer_buffer_length,
+			urb->transfer_buffer, urb->transfer_dma);
+
+	atomic_dec(&dev->active_tx_urbs);
+
+	if (!netif_device_present(netdev))
+		return;
+
+	if (urb->status)
+		dev_info(ND2D(netdev), "Tx URB aborted (%d)\n",
+			 urb->status);
+
+	netdev->trans_start = jiffies;
+
+	/* transmission complete interrupt */
+	netdev->stats.tx_packets++;
+	netdev->stats.tx_bytes += context->dlc;
+
+	can_get_echo_skb(netdev, context->echo_index);
+
+	/* Release context */
+	context->echo_index = MAX_TX_URBS;
+
+	if (netif_queue_stopped(netdev))
+		netif_wake_queue(netdev);
+}
+
+/*
+ * Send the given CPC command synchronously
+ */
+static int ems_usb_command_msg(struct ems_usb *dev, struct ems_cpc_msg *msg)
+{
+	int actual_length;
+
+	/* Copy payload */
+	memcpy(&dev->tx_msg_buffer[CPC_HEADER_SIZE], msg,
+	       msg->length + CPC_MSG_HEADER_LEN);
+
+	/* Clear header */
+	memset(&dev->tx_msg_buffer[0], 0, CPC_HEADER_SIZE);
+
+	return usb_bulk_msg(dev->udev, usb_sndbulkpipe(dev->udev, 2),
+			    &dev->tx_msg_buffer[0],
+			    msg->length + CPC_MSG_HEADER_LEN + CPC_HEADER_SIZE,
+			    &actual_length, 1000);
+}
+
+/*
+ * Change CAN controllers' mode register
+ */
+static int ems_usb_write_mode(struct ems_usb *dev, u8 mode)
+{
+	dev->active_params.msg.can_params.cc_params.sja1000.mode = mode;
+
+	return ems_usb_command_msg(dev, &dev->active_params);
+}
+
+/*
+ * Send a CPC_Control command to change behaviour when interface receives a CAN
+ * message, bus error or CAN state changed notifications.
+ */
+static int ems_usb_control_cmd(struct ems_usb *dev, u8 val)
+{
+	struct ems_cpc_msg cmd;
+
+	cmd.type = CPC_CMD_TYPE_CONTROL;
+	cmd.length = CPC_MSG_HEADER_LEN + 1;
+
+	cmd.msgid = 0;
+
+	cmd.msg.generic[0] = val;
+
+	return ems_usb_command_msg(dev, &cmd);
+}
+
+/*
+ * Start interface
+ */
+static int ems_usb_start(struct ems_usb *dev)
+{
+	struct net_device *netdev = dev->netdev;
+	int err, i;
+
+	dev->intr_in_buffer[0] = 0;
+	dev->free_slots = 15; /* initial size */
+
+	for (i = 0; i < MAX_RX_URBS; i++) {
+		struct urb *urb = NULL;
+		u8 *buf = NULL;
+
+		/* create a URB, and a buffer for it */
+		urb = usb_alloc_urb(0, GFP_KERNEL);
+		if (!urb) {
+			dev_err(ND2D(netdev),
+				"No memory left for URBs\n");
+			return -ENOMEM;
+		}
+
+		buf = usb_buffer_alloc(dev->udev, RX_BUFFER_SIZE, GFP_KERNEL,
+				       &urb->transfer_dma);
+		if (!buf) {
+			dev_err(ND2D(netdev),
+				"No memory left for USB buffer\n");
+			usb_free_urb(urb);
+			return -ENOMEM;
+		}
+
+		usb_fill_bulk_urb(urb, dev->udev, usb_rcvbulkpipe(dev->udev, 2),
+				  buf, RX_BUFFER_SIZE,
+				  ems_usb_read_bulk_callback, dev);
+		urb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;
+		usb_anchor_urb(urb, &dev->rx_submitted);
+
+		err = usb_submit_urb(urb, GFP_KERNEL);
+		if (err) {
+			if (err == -ENODEV)
+				netif_device_detach(dev->netdev);
+
+			usb_unanchor_urb(urb);
+			usb_buffer_free(dev->udev, RX_BUFFER_SIZE, buf,
+					urb->transfer_dma);
+			break;
+		}
+
+		/* Drop reference, USB core will take care of freeing it */
+		usb_free_urb(urb);
+	}
+
+	/* Did we submit any URBs */
+	if (i == 0) {
+		dev_warn(ND2D(netdev), "couldn't setup read URBs\n");
+		return err;
+	}
+
+	/* Warn if we've couldn't transmit all the URBs */
+	if (i < MAX_RX_URBS)
+		dev_warn(ND2D(netdev), "rx performance may be slow\n");
+
+	/* Setup and start interrupt URB */
+	usb_fill_int_urb(dev->intr_urb, dev->udev,
+			 usb_rcvintpipe(dev->udev, 1),
+			 dev->intr_in_buffer,
+			 INTR_IN_BUFFER_SIZE,
+			 ems_usb_read_interrupt_callback, dev, 1);
+
+	err = usb_submit_urb(dev->intr_urb, GFP_KERNEL);
+	if (err) {
+		if (err == -ENODEV)
+			netif_device_detach(dev->netdev);
+
+		dev_warn(ND2D(netdev), "intr URB submit failed: %d\n",
+			 err);
+
+		return err;
+	}
+
+	/* CPC-USB will transfer received message to host */
+	err = ems_usb_control_cmd(dev, CONTR_CAN_MESSAGE | CONTR_CONT_ON);
+	if (err)
+		goto failed;
+
+	/* CPC-USB will transfer CAN state changes to host */
+	err = ems_usb_control_cmd(dev, CONTR_CAN_STATE | CONTR_CONT_ON);
+	if (err)
+		goto failed;
+
+	/* CPC-USB will transfer bus errors to host */
+	err = ems_usb_control_cmd(dev, CONTR_BUS_ERROR | CONTR_CONT_ON);
+	if (err)
+		goto failed;
+
+	err = ems_usb_write_mode(dev, SJA1000_MOD_NORMAL);
+	if (err)
+		goto failed;
+
+	dev->can.state = CAN_STATE_ERROR_ACTIVE;
+
+	return 0;
+
+failed:
+	if (err == -ENODEV)
+		netif_device_detach(dev->netdev);
+
+	dev_warn(ND2D(netdev), "couldn't submit control: %d\n", err);
+
+	return err;
+}
+
+static void unlink_all_urbs(struct ems_usb *dev)
+{
+	int i;
+
+	usb_unlink_urb(dev->intr_urb);
+
+	usb_kill_anchored_urbs(&dev->rx_submitted);
+
+	usb_kill_anchored_urbs(&dev->tx_submitted);
+	atomic_set(&dev->active_tx_urbs, 0);
+
+	for (i = 0; i < MAX_TX_URBS; i++)
+		dev->tx_contexts[i].echo_index = MAX_TX_URBS;
+}
+
+static int ems_usb_open(struct net_device *netdev)
+{
+	struct ems_usb *dev = netdev_priv(netdev);
+	int err;
+
+	err = ems_usb_write_mode(dev, SJA1000_MOD_RM);
+	if (err)
+		return err;
+
+	/* common open */
+	err = open_candev(netdev);
+	if (err)
+		return err;
+
+	/* finally start device */
+	err = ems_usb_start(dev);
+	if (err) {
+		if (err == -ENODEV)
+			netif_device_detach(dev->netdev);
+
+		dev_warn(ND2D(netdev), "couldn't start device: %d\n",
+			 err);
+
+		close_candev(netdev);
+
+		return err;
+	}
+
+	dev->open_time = jiffies;
+
+	netif_start_queue(netdev);
+
+	return 0;
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,32)
+static int ems_usb_start_xmit(struct sk_buff *skb, struct net_device *netdev)
+#else
+static netdev_tx_t ems_usb_start_xmit(struct sk_buff *skb, struct net_device *netdev)
+#endif
+{
+	struct ems_usb *dev = netdev_priv(netdev);
+	struct ems_tx_urb_context *context = NULL;
+	struct net_device_stats *stats = &netdev->stats;
+	struct can_frame *cf = (struct can_frame *)skb->data;
+	struct ems_cpc_msg *msg;
+	struct urb *urb;
+	u8 *buf;
+	int i, err;
+	size_t size = CPC_HEADER_SIZE + CPC_MSG_HEADER_LEN
+			+ sizeof(struct cpc_can_msg);
+
+	if (can_dropped_invalid_skb(netdev, skb))
+		return NETDEV_TX_OK;
+
+	/* create a URB, and a buffer for it, and copy the data to the URB */
+	urb = usb_alloc_urb(0, GFP_ATOMIC);
+	if (!urb) {
+		dev_err(ND2D(netdev), "No memory left for URBs\n");
+		goto nomem;
+	}
+
+	buf = usb_buffer_alloc(dev->udev, size, GFP_ATOMIC, &urb->transfer_dma);
+	if (!buf) {
+		dev_err(ND2D(netdev), "No memory left for USB buffer\n");
+		usb_free_urb(urb);
+		goto nomem;
+	}
+
+	msg = (struct ems_cpc_msg *)&buf[CPC_HEADER_SIZE];
+
+	msg->msg.can_msg.id = cf->can_id & CAN_ERR_MASK;
+	msg->msg.can_msg.length = cf->can_dlc;
+
+	if (cf->can_id & CAN_RTR_FLAG) {
+		msg->type = cf->can_id & CAN_EFF_FLAG ?
+			CPC_CMD_TYPE_EXT_RTR_FRAME : CPC_CMD_TYPE_RTR_FRAME;
+
+		msg->length = CPC_CAN_MSG_MIN_SIZE;
+	} else {
+		msg->type = cf->can_id & CAN_EFF_FLAG ?
+			CPC_CMD_TYPE_EXT_CAN_FRAME : CPC_CMD_TYPE_CAN_FRAME;
+
+		for (i = 0; i < cf->can_dlc; i++)
+			msg->msg.can_msg.msg[i] = cf->data[i];
+
+		msg->length = CPC_CAN_MSG_MIN_SIZE + cf->can_dlc;
+	}
+
+	for (i = 0; i < MAX_TX_URBS; i++) {
+		if (dev->tx_contexts[i].echo_index == MAX_TX_URBS) {
+			context = &dev->tx_contexts[i];
+			break;
+		}
+	}
+
+	/*
+	 * May never happen! When this happens we'd more URBs in flight as
+	 * allowed (MAX_TX_URBS).
+	 */
+	if (!context) {
+		usb_unanchor_urb(urb);
+		usb_buffer_free(dev->udev, size, buf, urb->transfer_dma);
+
+		dev_warn(ND2D(netdev), "couldn't find free context\n");
+
+		return NETDEV_TX_BUSY;
+	}
+
+	context->dev = dev;
+	context->echo_index = i;
+	context->dlc = cf->can_dlc;
+
+	usb_fill_bulk_urb(urb, dev->udev, usb_sndbulkpipe(dev->udev, 2), buf,
+			  size, ems_usb_write_bulk_callback, context);
+	urb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;
+	usb_anchor_urb(urb, &dev->tx_submitted);
+
+	can_put_echo_skb(skb, netdev, context->echo_index);
+
+	atomic_inc(&dev->active_tx_urbs);
+
+	err = usb_submit_urb(urb, GFP_ATOMIC);
+	if (unlikely(err)) {
+		can_free_echo_skb(netdev, context->echo_index);
+
+		usb_unanchor_urb(urb);
+		usb_buffer_free(dev->udev, size, buf, urb->transfer_dma);
+		dev_kfree_skb(skb);
+
+		atomic_dec(&dev->active_tx_urbs);
+
+		if (err == -ENODEV) {
+			netif_device_detach(netdev);
+		} else {
+			dev_warn(ND2D(netdev), "failed tx_urb %d\n", err);
+
+			stats->tx_dropped++;
+		}
+	} else {
+		netdev->trans_start = jiffies;
+
+		/* Slow down tx path */
+		if (atomic_read(&dev->active_tx_urbs) >= MAX_TX_URBS ||
+		    dev->free_slots < 5) {
+			netif_stop_queue(netdev);
+		}
+	}
+
+	/*
+	 * Release our reference to this URB, the USB core will eventually free
+	 * it entirely.
+	 */
+	usb_free_urb(urb);
+
+	return NETDEV_TX_OK;
+
+nomem:
+	if (skb)
+		dev_kfree_skb(skb);
+
+	stats->tx_dropped++;
+
+	return NETDEV_TX_OK;
+}
+
+static int ems_usb_close(struct net_device *netdev)
+{
+	struct ems_usb *dev = netdev_priv(netdev);
+
+	/* Stop polling */
+	unlink_all_urbs(dev);
+
+	netif_stop_queue(netdev);
+
+	/* Set CAN controller to reset mode */
+	if (ems_usb_write_mode(dev, SJA1000_MOD_RM))
+		dev_warn(ND2D(netdev), "couldn't stop device");
+
+	close_candev(netdev);
+
+	dev->open_time = 0;
+
+	return 0;
+}
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,28)
+static const struct net_device_ops ems_usb_netdev_ops = {
+	.ndo_open = ems_usb_open,
+	.ndo_stop = ems_usb_close,
+	.ndo_start_xmit = ems_usb_start_xmit,
+};
+#endif
+
+static struct can_bittiming_const ems_usb_bittiming_const = {
+	.name = "ems_usb",
+	.tseg1_min = 1,
+	.tseg1_max = 16,
+	.tseg2_min = 1,
+	.tseg2_max = 8,
+	.sjw_max = 4,
+	.brp_min = 1,
+	.brp_max = 64,
+	.brp_inc = 1,
+};
+
+static int ems_usb_set_mode(struct net_device *netdev, enum can_mode mode)
+{
+	struct ems_usb *dev = netdev_priv(netdev);
+
+	if (!dev->open_time)
+		return -EINVAL;
+
+	switch (mode) {
+	case CAN_MODE_START:
+		if (ems_usb_write_mode(dev, SJA1000_MOD_NORMAL))
+			dev_warn(ND2D(netdev), "couldn't start device");
+
+		if (netif_queue_stopped(netdev))
+			netif_wake_queue(netdev);
+		break;
+
+	default:
+		return -EOPNOTSUPP;
+	}
+
+	return 0;
+}
+
+static int ems_usb_set_bittiming(struct net_device *netdev)
+{
+	struct ems_usb *dev = netdev_priv(netdev);
+	struct can_bittiming *bt = &dev->can.bittiming;
+	u8 btr0, btr1;
+
+	btr0 = ((bt->brp - 1) & 0x3f) | (((bt->sjw - 1) & 0x3) << 6);
+	btr1 = ((bt->prop_seg + bt->phase_seg1 - 1) & 0xf) |
+		(((bt->phase_seg2 - 1) & 0x7) << 4);
+	if (dev->can.ctrlmode & CAN_CTRLMODE_3_SAMPLES)
+		btr1 |= 0x80;
+
+	dev_info(ND2D(netdev), "setting BTR0=0x%02x BTR1=0x%02x\n",
+		 btr0, btr1);
+
+	dev->active_params.msg.can_params.cc_params.sja1000.btr0 = btr0;
+	dev->active_params.msg.can_params.cc_params.sja1000.btr1 = btr1;
+
+	return ems_usb_command_msg(dev, &dev->active_params);
+}
+
+static void init_params_sja1000(struct ems_cpc_msg *msg)
+{
+	struct cpc_sja1000_params *sja1000 =
+		&msg->msg.can_params.cc_params.sja1000;
+
+	msg->type = CPC_CMD_TYPE_CAN_PARAMS;
+	msg->length = sizeof(struct cpc_can_params);
+	msg->msgid = 0;
+
+	msg->msg.can_params.cc_type = CPC_CC_TYPE_SJA1000;
+
+	/* Acceptance filter open */
+	sja1000->acc_code0 = 0x00;
+	sja1000->acc_code1 = 0x00;
+	sja1000->acc_code2 = 0x00;
+	sja1000->acc_code3 = 0x00;
+
+	/* Acceptance filter open */
+	sja1000->acc_mask0 = 0xFF;
+	sja1000->acc_mask1 = 0xFF;
+	sja1000->acc_mask2 = 0xFF;
+	sja1000->acc_mask3 = 0xFF;
+
+	sja1000->btr0 = 0;
+	sja1000->btr1 = 0;
+
+	sja1000->outp_contr = SJA1000_DEFAULT_OUTPUT_CONTROL;
+	sja1000->mode = SJA1000_MOD_RM;
+}
+
+/*
+ * probe function for new CPC-USB devices
+ */
+static int ems_usb_probe(struct usb_interface *intf,
+			 const struct usb_device_id *id)
+{
+	struct net_device *netdev;
+	struct ems_usb *dev;
+	int i, err = -ENOMEM;
+
+	netdev = alloc_candev(sizeof(struct ems_usb), MAX_TX_URBS);
+	if (!netdev) {
+		dev_err(ND2D(netdev), "Couldn't alloc candev\n");
+		return -ENOMEM;
+	}
+
+	dev = netdev_priv(netdev);
+
+	dev->udev = interface_to_usbdev(intf);
+	dev->netdev = netdev;
+
+	dev->can.state = CAN_STATE_STOPPED;
+	dev->can.clock.freq = EMS_USB_ARM7_CLOCK;
+	dev->can.bittiming_const = &ems_usb_bittiming_const;
+	dev->can.do_set_bittiming = ems_usb_set_bittiming;
+	dev->can.do_set_mode = ems_usb_set_mode;
+	dev->can.ctrlmode_supported = CAN_CTRLMODE_3_SAMPLES;
+
+	netdev->flags |= IFF_ECHO; /* we support local echo */
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,28)
+	netdev->netdev_ops = &ems_usb_netdev_ops;
+#else
+	netdev->open = ems_usb_open;
+	netdev->stop = ems_usb_close;
+	netdev->hard_start_xmit = ems_usb_start_xmit;
+#endif
+
+	netdev->flags |= IFF_ECHO; /* we support local echo */
+
+	init_usb_anchor(&dev->rx_submitted);
+
+	init_usb_anchor(&dev->tx_submitted);
+	atomic_set(&dev->active_tx_urbs, 0);
+
+	for (i = 0; i < MAX_TX_URBS; i++)
+		dev->tx_contexts[i].echo_index = MAX_TX_URBS;
+
+	dev->intr_urb = usb_alloc_urb(0, GFP_KERNEL);
+	if (!dev->intr_urb) {
+		dev_err(ND2D(netdev), "Couldn't alloc intr URB\n");
+		goto cleanup_candev;
+	}
+
+	dev->intr_in_buffer = kzalloc(INTR_IN_BUFFER_SIZE, GFP_KERNEL);
+	if (!dev->intr_in_buffer) {
+		dev_err(netdev->dev.parent, "Couldn't alloc Intr buffer\n");
+		goto cleanup_intr_urb;
+	}
+
+	dev->tx_msg_buffer = kzalloc(CPC_HEADER_SIZE +
+				     sizeof(struct ems_cpc_msg), GFP_KERNEL);
+	if (!dev->tx_msg_buffer) {
+		dev_err(ND2D(netdev), "Couldn't alloc Tx buffer\n");
+		goto cleanup_intr_in_buffer;
+	}
+
+	usb_set_intfdata(intf, dev);
+
+	SET_NETDEV_DEV(netdev, &intf->dev);
+
+	init_params_sja1000(&dev->active_params);
+
+	err = ems_usb_command_msg(dev, &dev->active_params);
+	if (err) {
+		dev_err(netdev->dev.parent,
+			"couldn't initialize controller: %d\n", err);
+		goto cleanup_tx_msg_buffer;
+	}
+
+	err = register_candev(netdev);
+	if (err) {
+		dev_err(netdev->dev.parent,
+			"couldn't register CAN device: %d\n", err);
+		goto cleanup_tx_msg_buffer;
+	}
+
+	return 0;
+
+cleanup_tx_msg_buffer:
+	kfree(dev->tx_msg_buffer);
+
+cleanup_intr_in_buffer:
+	kfree(dev->intr_in_buffer);
+
+cleanup_intr_urb:
+	usb_free_urb(dev->intr_urb);
+
+cleanup_candev:
+	free_candev(netdev);
+
+	return err;
+}
+
+/*
+ * called by the usb core when the device is removed from the system
+ */
+static void ems_usb_disconnect(struct usb_interface *intf)
+{
+	struct ems_usb *dev = usb_get_intfdata(intf);
+
+	usb_set_intfdata(intf, NULL);
+
+	if (dev) {
+		unregister_netdev(dev->netdev);
+		free_candev(dev->netdev);
+
+		unlink_all_urbs(dev);
+
+		usb_free_urb(dev->intr_urb);
+
+		kfree(dev->intr_in_buffer);
+	}
+}
+
+/* usb specific object needed to register this driver with the usb subsystem */
+static struct usb_driver ems_usb_driver = {
+	.name = "ems_usb",
+	.probe = ems_usb_probe,
+	.disconnect = ems_usb_disconnect,
+	.id_table = ems_usb_table,
+};
+
+static int __init ems_usb_init(void)
+{
+	int err;
+
+	printk(KERN_INFO "CPC-USB kernel driver loaded\n");
+
+	/* register this driver with the USB subsystem */
+	err = usb_register(&ems_usb_driver);
+
+	if (err) {
+		err("usb_register failed. Error number %d\n", err);
+		return err;
+	}
+
+	return 0;
+}
+
+static void __exit ems_usb_exit(void)
+{
+	/* deregister this driver with the USB subsystem */
+	usb_deregister(&ems_usb_driver);
+}
+
+module_init(ems_usb_init);
+module_exit(ems_usb_exit);
diff --exclude CVS --exclude .git -uNr linux-2.6.27.8/drivers/net/can/usb/esd_usb2.c linux-2.6.27.8.modified/drivers/net/can/usb/esd_usb2.c
--- linux-2.6.27.8/drivers/net/can/usb/esd_usb2.c	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.27.8.modified/drivers/net/can/usb/esd_usb2.c	2013-05-30 03:44:17.000000000 -0400
@@ -0,0 +1,1122 @@
+/*
+ * CAN driver for esd CAN-USB/2
+ *
+ * Copyright (C) 2010 Matthias Fuchs <matthias.fuchs@esd.eu>, esd gmbh
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; version 2 of the License.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+#include <linux/init.h>
+#include <linux/signal.h>
+#include <linux/slab.h>
+#include <linux/module.h>
+#include <linux/netdevice.h>
+#include <linux/usb.h>
+
+#include <socketcan/can.h>
+#include <socketcan/can/dev.h>
+#include <socketcan/can/error.h>
+
+MODULE_AUTHOR("Matthias Fuchs <matthias.fuchs@esd.eu>");
+MODULE_DESCRIPTION("CAN driver for esd CAN-USB/2 interfaces");
+MODULE_LICENSE("GPL v2");
+
+/* Define these values to match your devices */
+#define USB_ESDGMBH_VENDOR_ID	0x0ab4
+#define USB_CANUSB2_PRODUCT_ID	0x0010
+
+#define ESD_USB2_CAN_CLOCK	60000000
+#define ESD_USB2_MAX_NETS	2
+
+/* USB2 commands */
+#define CMD_VERSION		1 /* also used for VERSION_REPLY */
+#define CMD_CAN_RX		2 /* device to host only */
+#define CMD_CAN_TX		3 /* also used for TX_DONE */
+#define CMD_SETBAUD		4 /* also used for SETBAUD_REPLY */
+#define CMD_TS			5 /* also used for TS_REPLY */
+#define CMD_IDADD		6 /* also used for IDADD_REPLY */
+
+/* esd CAN message flags - dlc field */
+#define ESD_RTR			0x10
+
+/* esd CAN message flags - id field */
+#define ESD_EXTID		0x20000000
+#define ESD_EVENT		0x40000000
+#define ESD_IDMASK		0x1fffffff
+
+/* esd CAN event ids used by this driver */
+#define ESD_EV_CAN_ERROR_EXT	2
+
+/* baudrate message flags */
+#define ESD_USB2_UBR		0x80000000
+#define ESD_USB2_LOM		0x40000000
+#define ESD_USB2_NO_BAUDRATE	0x7fffffff
+#define ESD_USB2_TSEG1_MIN	1
+#define ESD_USB2_TSEG1_MAX	16
+#define ESD_USB2_TSEG1_SHIFT	16
+#define ESD_USB2_TSEG2_MIN	1
+#define ESD_USB2_TSEG2_MAX	8
+#define ESD_USB2_TSEG2_SHIFT	20
+#define ESD_USB2_SJW_MAX	4
+#define ESD_USB2_SJW_SHIFT	14
+#define ESD_USB2_BRP_MIN	1
+#define ESD_USB2_BRP_MAX	1024
+#define ESD_USB2_BRP_INC	1
+#define ESD_USB2_3_SAMPLES	0x00800000
+
+/* esd IDADD message */
+#define ESD_ID_ENABLE		0x80
+#define ESD_MAX_ID_SEGMENT	64
+
+/* SJA1000 ECC register (emulated by usb2 firmware) */
+#define SJA1000_ECC_SEG		0x1F
+#define SJA1000_ECC_DIR		0x20
+#define SJA1000_ECC_ERR		0x06
+#define SJA1000_ECC_BIT		0x00
+#define SJA1000_ECC_FORM	0x40
+#define SJA1000_ECC_STUFF	0x80
+#define SJA1000_ECC_MASK	0xc0
+
+/* esd bus state event codes */
+#define ESD_BUSSTATE_MASK	0xc0
+#define ESD_BUSSTATE_WARN	0x40
+#define ESD_BUSSTATE_ERRPASSIVE	0x80
+#define ESD_BUSSTATE_BUSOFF	0xc0
+
+#define RX_BUFFER_SIZE		1024
+#define MAX_RX_URBS		4
+#define MAX_TX_URBS		16 /* must be power of 2 */
+
+struct header_msg {
+	u8 len; /* len is always the total message length in 32bit words */
+	u8 cmd;
+	u8 rsvd[2];
+};
+
+struct version_msg {
+	u8 len;
+	u8 cmd;
+	u8 rsvd;
+	u8 flags;
+	__le32 drv_version;
+};
+
+struct version_reply_msg {
+	u8 len;
+	u8 cmd;
+	u8 nets;
+	u8 features;
+	__le32 version;
+	u8 name[16];
+	__le32 rsvd;
+	__le32 ts;
+};
+
+struct rx_msg {
+	u8 len;
+	u8 cmd;
+	u8 net;
+	u8 dlc;
+	__le32 ts;
+	__le32 id; /* upper 3 bits contain flags */
+	u8 data[8];
+};
+
+struct tx_msg {
+	u8 len;
+	u8 cmd;
+	u8 net;
+	u8 dlc;
+	__le32 hnd;
+	__le32 id; /* upper 3 bits contain flags */
+	u8 data[8];
+};
+
+struct tx_done_msg {
+	u8 len;
+	u8 cmd;
+	u8 net;
+	u8 status;
+	__le32 hnd;
+	__le32 ts;
+};
+
+struct id_filter_msg {
+	u8 len;
+	u8 cmd;
+	u8 net;
+	u8 option;
+	__le32 mask[65];
+};
+
+struct set_baudrate_msg {
+	u8 len;
+	u8 cmd;
+	u8 net;
+	u8 rsvd;
+	__le32 baud;
+};
+
+/* Main message type used between library and application */
+struct __attribute__ ((packed)) esd_usb2_msg {
+	union {
+		struct header_msg hdr;
+		struct version_msg version;
+		struct version_reply_msg version_reply;
+		struct rx_msg rx;
+		struct tx_msg tx;
+		struct tx_done_msg txdone;
+		struct set_baudrate_msg setbaud;
+		struct id_filter_msg filter;
+	} msg;
+};
+
+static struct usb_device_id esd_usb2_table[] = {
+	{USB_DEVICE(USB_ESDGMBH_VENDOR_ID, USB_CANUSB2_PRODUCT_ID)},
+	{}
+};
+MODULE_DEVICE_TABLE(usb, esd_usb2_table);
+
+struct esd_usb2_net_priv;
+
+struct esd_tx_urb_context {
+	struct esd_usb2_net_priv *priv;
+	u32 echo_index;
+	int dlc;
+};
+
+struct esd_usb2 {
+	struct usb_device *udev;
+	struct esd_usb2_net_priv *nets[ESD_USB2_MAX_NETS];
+
+	struct usb_anchor rx_submitted;
+
+	int net_count;
+	u32 version;
+	int rxinitdone;
+};
+
+struct esd_usb2_net_priv {
+	struct can_priv can; /* must be the first member */
+
+	atomic_t active_tx_jobs;
+	struct usb_anchor tx_submitted;
+	struct esd_tx_urb_context tx_contexts[MAX_TX_URBS];
+
+	int open_time;
+	struct esd_usb2 *usb2;
+	struct net_device *netdev;
+	int index;
+	u8 old_state;
+};
+
+static void esd_usb2_rx_event(struct esd_usb2_net_priv *priv,
+			      struct esd_usb2_msg *msg)
+{
+	struct net_device_stats *stats = &priv->netdev->stats;
+	struct can_frame *cf;
+	struct sk_buff *skb;
+	u32 id = le32_to_cpu(msg->msg.rx.id) & ESD_IDMASK;
+
+	if (id == ESD_EV_CAN_ERROR_EXT) {
+		u8 state = msg->msg.rx.data[0];
+		u8 ecc = msg->msg.rx.data[1];
+		u8 txerr = msg->msg.rx.data[2];
+		u8 rxerr = msg->msg.rx.data[3];
+
+		skb = alloc_can_err_skb(priv->netdev, &cf);
+		if (skb == NULL) {
+			stats->rx_dropped++;
+			return;
+		}
+
+		if (state != priv->old_state) {
+			priv->old_state = state;
+
+			switch (state & ESD_BUSSTATE_MASK) {
+			case ESD_BUSSTATE_BUSOFF:
+				priv->can.state = CAN_STATE_BUS_OFF;
+				cf->can_id |= CAN_ERR_BUSOFF;
+				can_bus_off(priv->netdev);
+				break;
+			case ESD_BUSSTATE_WARN:
+				priv->can.state = CAN_STATE_ERROR_WARNING;
+				priv->can.can_stats.error_warning++;
+				break;
+			case ESD_BUSSTATE_ERRPASSIVE:
+				priv->can.state = CAN_STATE_ERROR_PASSIVE;
+				priv->can.can_stats.error_passive++;
+				break;
+			default:
+				priv->can.state = CAN_STATE_ERROR_ACTIVE;
+				break;
+			}
+		} else {
+			priv->can.can_stats.bus_error++;
+			stats->rx_errors++;
+
+			cf->can_id |= CAN_ERR_PROT | CAN_ERR_BUSERROR;
+
+			switch (ecc & SJA1000_ECC_MASK) {
+			case SJA1000_ECC_BIT:
+				cf->data[2] |= CAN_ERR_PROT_BIT;
+				break;
+			case SJA1000_ECC_FORM:
+				cf->data[2] |= CAN_ERR_PROT_FORM;
+				break;
+			case SJA1000_ECC_STUFF:
+				cf->data[2] |= CAN_ERR_PROT_STUFF;
+				break;
+			default:
+				cf->data[2] |= CAN_ERR_PROT_UNSPEC;
+				cf->data[3] = ecc & SJA1000_ECC_SEG;
+				break;
+			}
+
+			/* Error occurred during transmission? */
+			if (!(ecc & SJA1000_ECC_DIR))
+				cf->data[2] |= CAN_ERR_PROT_TX;
+
+			if (priv->can.state == CAN_STATE_ERROR_WARNING ||
+			    priv->can.state == CAN_STATE_ERROR_PASSIVE) {
+				cf->data[1] = (txerr > rxerr) ?
+					CAN_ERR_CRTL_TX_PASSIVE :
+					CAN_ERR_CRTL_RX_PASSIVE;
+			}
+		}
+
+		netif_rx(skb);
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,32)
+		priv->netdev->last_rx = jiffies;
+#endif
+		stats->rx_packets++;
+		stats->rx_bytes += cf->can_dlc;
+	}
+}
+
+static void esd_usb2_rx_can_msg(struct esd_usb2_net_priv *priv,
+				struct esd_usb2_msg *msg)
+{
+	struct net_device_stats *stats = &priv->netdev->stats;
+	struct can_frame *cf;
+	struct sk_buff *skb;
+	int i;
+	u32 id;
+
+	if (!netif_device_present(priv->netdev))
+		return;
+
+	id = le32_to_cpu(msg->msg.rx.id);
+
+	if (id & ESD_EVENT) {
+		esd_usb2_rx_event(priv, msg);
+	} else {
+		skb = alloc_can_skb(priv->netdev, &cf);
+		if (skb == NULL) {
+			stats->rx_dropped++;
+			return;
+		}
+
+		cf->can_id = id & ESD_IDMASK;
+		cf->can_dlc = get_can_dlc(msg->msg.rx.dlc);
+
+		if (id & ESD_EXTID)
+			cf->can_id |= CAN_EFF_FLAG;
+
+		if (msg->msg.rx.dlc & ESD_RTR) {
+			cf->can_id |= CAN_RTR_FLAG;
+		} else {
+			for (i = 0; i < cf->can_dlc; i++)
+				cf->data[i] = msg->msg.rx.data[i];
+		}
+
+		netif_rx(skb);
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,32)
+		priv->netdev->last_rx = jiffies;
+#endif
+		stats->rx_packets++;
+		stats->rx_bytes += cf->can_dlc;
+	}
+
+	return;
+}
+
+static void esd_usb2_tx_done_msg(struct esd_usb2_net_priv *priv,
+				 struct esd_usb2_msg *msg)
+{
+	struct net_device_stats *stats = &priv->netdev->stats;
+	struct net_device *netdev = priv->netdev;
+	struct esd_tx_urb_context *context;
+
+	if (!netif_device_present(netdev))
+		return;
+
+	context = &priv->tx_contexts[msg->msg.txdone.hnd & (MAX_TX_URBS - 1)];
+
+	if (!msg->msg.txdone.status) {
+		stats->tx_packets++;
+		stats->tx_bytes += context->dlc;
+		can_get_echo_skb(netdev, context->echo_index);
+	} else {
+		stats->tx_errors++;
+		can_free_echo_skb(netdev, context->echo_index);
+	}
+
+	/* Release context */
+	context->echo_index = MAX_TX_URBS;
+	atomic_dec(&priv->active_tx_jobs);
+
+	netif_wake_queue(netdev);
+}
+
+static void esd_usb2_read_bulk_callback(struct urb *urb)
+{
+	struct esd_usb2 *dev = urb->context;
+	int retval;
+	int pos = 0;
+	int i;
+
+	switch (urb->status) {
+	case 0: /* success */
+		break;
+
+	case -ENOENT:
+	case -ESHUTDOWN:
+		return;
+
+	default:
+		dev_info(dev->udev->dev.parent,
+			 "Rx URB aborted (%d)\n", urb->status);
+		goto resubmit_urb;
+	}
+
+	while (pos < urb->actual_length) {
+		struct esd_usb2_msg *msg;
+
+		msg = (struct esd_usb2_msg *)(urb->transfer_buffer + pos);
+
+		switch (msg->msg.hdr.cmd) {
+		case CMD_CAN_RX:
+			esd_usb2_rx_can_msg(dev->nets[msg->msg.rx.net], msg);
+			break;
+
+		case CMD_CAN_TX:
+			esd_usb2_tx_done_msg(dev->nets[msg->msg.txdone.net],
+					     msg);
+			break;
+		}
+
+		pos += msg->msg.hdr.len << 2;
+
+		if (pos > urb->actual_length) {
+			dev_err(dev->udev->dev.parent, "format error\n");
+			break;
+		}
+	}
+
+resubmit_urb:
+	usb_fill_bulk_urb(urb, dev->udev, usb_rcvbulkpipe(dev->udev, 1),
+			  urb->transfer_buffer, RX_BUFFER_SIZE,
+			  esd_usb2_read_bulk_callback, dev);
+
+	retval = usb_submit_urb(urb, GFP_ATOMIC);
+	if (retval == -ENODEV) {
+		for (i = 0; i < dev->net_count; i++) {
+			if (dev->nets[i])
+				netif_device_detach(dev->nets[i]->netdev);
+		}
+	} else if (retval) {
+		dev_err(dev->udev->dev.parent,
+			"failed resubmitting read bulk urb: %d\n", retval);
+	}
+
+	return;
+}
+
+/*
+ * callback for bulk IN urb
+ */
+static void esd_usb2_write_bulk_callback(struct urb *urb)
+{
+	struct esd_tx_urb_context *context = urb->context;
+	struct esd_usb2_net_priv *priv;
+	struct esd_usb2 *dev;
+	struct net_device *netdev;
+	size_t size = sizeof(struct esd_usb2_msg);
+
+	BUG_ON(!context);
+
+	priv = context->priv;
+	netdev = priv->netdev;
+	dev = priv->usb2;
+
+	/* free up our allocated buffer */
+	usb_buffer_free(urb->dev, size,
+			urb->transfer_buffer, urb->transfer_dma);
+
+	if (!netif_device_present(netdev))
+		return;
+
+	if (urb->status)
+		dev_info(ND2D(netdev), "Tx URB aborted (%d)\n",
+			 urb->status);
+
+	netdev->trans_start = jiffies;
+}
+
+#ifdef CONFIG_SYSFS
+static ssize_t show_firmware(struct device *d,
+			     struct device_attribute *attr, char *buf)
+{
+	struct usb_interface *intf = to_usb_interface(d);
+	struct esd_usb2 *dev = usb_get_intfdata(intf);
+
+	return sprintf(buf, "%d.%d.%d\n",
+		       (dev->version >> 12) & 0xf,
+		       (dev->version >> 8) & 0xf,
+		       dev->version & 0xff);
+}
+static DEVICE_ATTR(firmware, S_IRUGO, show_firmware, NULL);
+
+static ssize_t show_hardware(struct device *d,
+			     struct device_attribute *attr, char *buf)
+{
+	struct usb_interface *intf = to_usb_interface(d);
+	struct esd_usb2 *dev = usb_get_intfdata(intf);
+
+	return sprintf(buf, "%d.%d.%d\n",
+		       (dev->version >> 28) & 0xf,
+		       (dev->version >> 24) & 0xf,
+		       (dev->version >> 16) & 0xff);
+}
+static DEVICE_ATTR(hardware, S_IRUGO, show_hardware, NULL);
+
+static ssize_t show_nets(struct device *d,
+			 struct device_attribute *attr, char *buf)
+{
+	struct usb_interface *intf = to_usb_interface(d);
+	struct esd_usb2 *dev = usb_get_intfdata(intf);
+
+	return sprintf(buf, "%d", dev->net_count);
+}
+static DEVICE_ATTR(nets, S_IRUGO, show_nets, NULL);
+#endif
+
+static int esd_usb2_send_msg(struct esd_usb2 *dev, struct esd_usb2_msg *msg)
+{
+	int actual_length;
+
+	return usb_bulk_msg(dev->udev,
+			    usb_sndbulkpipe(dev->udev, 2),
+			    msg,
+			    msg->msg.hdr.len << 2,
+			    &actual_length,
+			    1000);
+}
+
+static int esd_usb2_wait_msg(struct esd_usb2 *dev,
+			     struct esd_usb2_msg *msg)
+{
+	int actual_length;
+
+	return usb_bulk_msg(dev->udev,
+			    usb_rcvbulkpipe(dev->udev, 1),
+			    msg,
+			    sizeof(*msg),
+			    &actual_length,
+			    1000);
+}
+
+static int esd_usb2_setup_rx_urbs(struct esd_usb2 *dev)
+{
+	int i, err = 0;
+
+	if (dev->rxinitdone)
+		return 0;
+
+	for (i = 0; i < MAX_RX_URBS; i++) {
+		struct urb *urb = NULL;
+		u8 *buf = NULL;
+
+		/* create a URB, and a buffer for it */
+		urb = usb_alloc_urb(0, GFP_KERNEL);
+		if (!urb) {
+			dev_warn(dev->udev->dev.parent,
+				 "No memory left for URBs\n");
+			err = -ENOMEM;
+			break;
+		}
+
+		buf = usb_buffer_alloc(dev->udev, RX_BUFFER_SIZE, GFP_KERNEL,
+				       &urb->transfer_dma);
+		if (!buf) {
+			dev_warn(dev->udev->dev.parent,
+				 "No memory left for USB buffer\n");
+			err = -ENOMEM;
+			goto freeurb;
+		}
+
+		usb_fill_bulk_urb(urb, dev->udev,
+				  usb_rcvbulkpipe(dev->udev, 1),
+				  buf, RX_BUFFER_SIZE,
+				  esd_usb2_read_bulk_callback, dev);
+		urb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;
+		usb_anchor_urb(urb, &dev->rx_submitted);
+
+		err = usb_submit_urb(urb, GFP_KERNEL);
+		if (err) {
+			usb_unanchor_urb(urb);
+			usb_buffer_free(dev->udev, RX_BUFFER_SIZE, buf,
+					urb->transfer_dma);
+		}
+
+freeurb:
+		/* Drop reference, USB core will take care of freeing it */
+		usb_free_urb(urb);
+		if (err)
+			break;
+	}
+
+	/* Did we submit any URBs */
+	if (i == 0) {
+		dev_err(dev->udev->dev.parent, "couldn't setup read URBs\n");
+		return err;
+	}
+
+	/* Warn if we've couldn't transmit all the URBs */
+	if (i < MAX_RX_URBS) {
+		dev_warn(dev->udev->dev.parent,
+			 "rx performance may be slow\n");
+	}
+
+	dev->rxinitdone = 1;
+	return 0;
+}
+
+/*
+ * Start interface
+ */
+static int esd_usb2_start(struct esd_usb2_net_priv *priv)
+{
+	struct esd_usb2 *dev = priv->usb2;
+	struct net_device *netdev = priv->netdev;
+	struct esd_usb2_msg msg;
+	int err, i;
+
+	/*
+	 * Enable all IDs
+	 * The IDADD message takes up to 64 32 bit bitmasks (2048 bits).
+	 * Each bit represents one 11 bit CAN identifier. A set bit
+	 * enables reception of the corresponding CAN identifier. A cleared
+	 * bit disabled this identifier. An additional bitmask value
+	 * following the CAN 2.0A bits is used to enable reception of
+	 * extended CAN frames. Only the LSB of this final mask is checked
+	 * for the complete 29 bit ID range. The IDADD message also allows
+	 * filter configuration for an ID subset. In this case you can add
+	 * the number of the starting bitmask (0..64) to the filter.option
+	 * field followed by only some bitmasks.
+	 */
+	msg.msg.hdr.cmd = CMD_IDADD;
+	msg.msg.hdr.len = 2 + ESD_MAX_ID_SEGMENT;
+	msg.msg.filter.net = priv->index;
+	msg.msg.filter.option = ESD_ID_ENABLE; /* start with segment 0 */
+	for (i = 0; i < ESD_MAX_ID_SEGMENT; i++)
+		msg.msg.filter.mask[i] = cpu_to_le32(0xffffffff);
+	/* enable 29bit extended IDs */
+	msg.msg.filter.mask[ESD_MAX_ID_SEGMENT] = cpu_to_le32(0x00000001);
+
+	err = esd_usb2_send_msg(dev, &msg);
+	if (err)
+		goto failed;
+
+	err = esd_usb2_setup_rx_urbs(dev);
+	if (err)
+		goto failed;
+
+	priv->can.state = CAN_STATE_ERROR_ACTIVE;
+
+	return 0;
+
+failed:
+	if (err == -ENODEV)
+		netif_device_detach(netdev);
+
+	dev_err(ND2D(netdev), "couldn't start device: %d\n", err);
+
+	return err;
+}
+
+static void unlink_all_urbs(struct esd_usb2 *dev)
+{
+	struct esd_usb2_net_priv *priv;
+	int i;
+
+	usb_kill_anchored_urbs(&dev->rx_submitted);
+	for (i = 0; i < dev->net_count; i++) {
+		priv = dev->nets[i];
+		if (priv) {
+			usb_kill_anchored_urbs(&priv->tx_submitted);
+			atomic_set(&priv->active_tx_jobs, 0);
+
+			for (i = 0; i < MAX_TX_URBS; i++)
+				priv->tx_contexts[i].echo_index = MAX_TX_URBS;
+		}
+	}
+}
+
+static int esd_usb2_open(struct net_device *netdev)
+{
+	struct esd_usb2_net_priv *priv = netdev_priv(netdev);
+	int err;
+
+	/* common open */
+	err = open_candev(netdev);
+	if (err)
+		return err;
+
+	/* finally start device */
+	err = esd_usb2_start(priv);
+	if (err) {
+		dev_warn(ND2D(netdev), "couldn't start device: %d\n", err);
+
+		close_candev(netdev);
+
+		return err;
+	}
+
+	priv->open_time = jiffies;
+
+	netif_start_queue(netdev);
+
+	return 0;
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,32)
+static int esd_usb2_start_xmit(struct sk_buff *skb, struct net_device *netdev)
+#else
+static netdev_tx_t esd_usb2_start_xmit(struct sk_buff *skb,
+				      struct net_device *netdev)
+#endif
+{
+	struct esd_usb2_net_priv *priv = netdev_priv(netdev);
+	struct esd_usb2 *dev = priv->usb2;
+	struct esd_tx_urb_context *context = NULL;
+	struct net_device_stats *stats = &netdev->stats;
+	struct can_frame *cf = (struct can_frame *)skb->data;
+	struct esd_usb2_msg *msg;
+	struct urb *urb;
+	u8 *buf;
+	int i, err;
+	int ret = NETDEV_TX_OK;
+	size_t size = sizeof(struct esd_usb2_msg);
+
+	/* create a URB, and a buffer for it, and copy the data to the URB */
+	urb = usb_alloc_urb(0, GFP_ATOMIC);
+	if (!urb) {
+		dev_err(ND2D(netdev), "No memory left for URBs\n");
+		stats->tx_dropped++;
+		kfree_skb(skb);
+		goto nourbmem;
+	}
+
+	buf = usb_buffer_alloc(dev->udev, size, GFP_ATOMIC, &urb->transfer_dma);
+	if (!buf) {
+		dev_err(ND2D(netdev), "No memory left for USB buffer\n");
+		stats->tx_dropped++;
+		kfree_skb(skb);
+		goto nobufmem;
+	}
+
+	msg = (struct esd_usb2_msg *)buf;
+
+	msg->msg.hdr.len = 3; /* minimal length */
+	msg->msg.hdr.cmd = CMD_CAN_TX;
+	msg->msg.tx.net = priv->index;
+	msg->msg.tx.dlc = cf->can_dlc;
+	msg->msg.tx.id = cpu_to_le32(cf->can_id & CAN_ERR_MASK);
+
+	if (cf->can_id & CAN_RTR_FLAG)
+		msg->msg.tx.dlc |= ESD_RTR;
+
+	if (cf->can_id & CAN_EFF_FLAG)
+		msg->msg.tx.id |= cpu_to_le32(ESD_EXTID);
+
+	for (i = 0; i < cf->can_dlc; i++)
+		msg->msg.tx.data[i] = cf->data[i];
+
+	msg->msg.hdr.len += (cf->can_dlc + 3) >> 2;
+
+	for (i = 0; i < MAX_TX_URBS; i++) {
+		if (priv->tx_contexts[i].echo_index == MAX_TX_URBS) {
+			context = &priv->tx_contexts[i];
+			break;
+		}
+	}
+
+	/*
+	 * This may never happen.
+	 */
+	if (!context) {
+		dev_warn(ND2D(netdev), "couldn't find free context\n");
+		ret = NETDEV_TX_BUSY;
+		goto releasebuf;
+	}
+
+	context->priv = priv;
+	context->echo_index = i;
+	context->dlc = cf->can_dlc;
+
+	/* hnd must not be 0 */
+	msg->msg.tx.hnd = 0x80000000 | i; /* returned in TX done message */
+
+	usb_fill_bulk_urb(urb, dev->udev, usb_sndbulkpipe(dev->udev, 2), buf,
+			  msg->msg.hdr.len << 2,
+			  esd_usb2_write_bulk_callback, context);
+
+	urb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;
+
+	usb_anchor_urb(urb, &priv->tx_submitted);
+
+	can_put_echo_skb(skb, netdev, context->echo_index);
+
+	atomic_inc(&priv->active_tx_jobs);
+
+	err = usb_submit_urb(urb, GFP_ATOMIC);
+	if (err) {
+		can_free_echo_skb(netdev, context->echo_index);
+
+		atomic_dec(&priv->active_tx_jobs);
+		usb_unanchor_urb(urb);
+
+		stats->tx_dropped++;
+
+		if (err == -ENODEV)
+			netif_device_detach(netdev);
+		else
+			dev_warn(ND2D(netdev), "failed tx_urb %d\n", err);
+
+		goto releasebuf;
+	}
+
+	netdev->trans_start = jiffies;
+
+	/* Slow down tx path */
+	if (atomic_read(&priv->active_tx_jobs) >= MAX_TX_URBS)
+		netif_stop_queue(netdev);
+
+	/*
+	 * Release our reference to this URB, the USB core will eventually free
+	 * it entirely.
+	 */
+	usb_free_urb(urb);
+
+	return NETDEV_TX_OK;
+
+releasebuf:
+	usb_buffer_free(dev->udev, size, buf, urb->transfer_dma);
+
+nobufmem:
+	usb_free_urb(urb);
+
+nourbmem:
+	return ret;
+}
+
+static int esd_usb2_close(struct net_device *netdev)
+{
+	struct esd_usb2_net_priv *priv = netdev_priv(netdev);
+	struct esd_usb2_msg msg;
+	int i;
+
+	/* Disable all IDs (see esd_usb2_start()) */
+	msg.msg.hdr.cmd = CMD_IDADD;
+	msg.msg.hdr.len = 2 + ESD_MAX_ID_SEGMENT;
+	msg.msg.filter.net = priv->index;
+	msg.msg.filter.option = ESD_ID_ENABLE; /* start with segment 0 */
+	for (i = 0; i <= ESD_MAX_ID_SEGMENT; i++)
+		msg.msg.filter.mask[i] = 0;
+	esd_usb2_send_msg(priv->usb2, &msg);
+
+	/* set CAN controller to reset mode */
+	msg.msg.hdr.len = 2;
+	msg.msg.hdr.cmd = CMD_SETBAUD;
+	msg.msg.setbaud.net = priv->index;
+	msg.msg.setbaud.rsvd = 0;
+	msg.msg.setbaud.baud = cpu_to_le32(ESD_USB2_NO_BAUDRATE);
+	esd_usb2_send_msg(priv->usb2, &msg);
+
+	priv->can.state = CAN_STATE_STOPPED;
+
+	netif_stop_queue(netdev);
+
+	close_candev(netdev);
+
+	priv->open_time = 0;
+
+	return 0;
+}
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,28)
+static const struct net_device_ops esd_usb2_netdev_ops = {
+	.ndo_open = esd_usb2_open,
+	.ndo_stop = esd_usb2_close,
+	.ndo_start_xmit = esd_usb2_start_xmit,
+};
+#endif
+
+static struct can_bittiming_const esd_usb2_bittiming_const = {
+	.name = "esd_usb2",
+	.tseg1_min = ESD_USB2_TSEG1_MIN,
+	.tseg1_max = ESD_USB2_TSEG1_MAX,
+	.tseg2_min = ESD_USB2_TSEG2_MIN,
+	.tseg2_max = ESD_USB2_TSEG2_MAX,
+	.sjw_max = ESD_USB2_SJW_MAX,
+	.brp_min = ESD_USB2_BRP_MIN,
+	.brp_max = ESD_USB2_BRP_MAX,
+	.brp_inc = ESD_USB2_BRP_INC,
+};
+
+static int esd_usb2_set_bittiming(struct net_device *netdev)
+{
+	struct esd_usb2_net_priv *priv = netdev_priv(netdev);
+	struct can_bittiming *bt = &priv->can.bittiming;
+	struct esd_usb2_msg msg;
+	u32 canbtr;
+
+	canbtr = ESD_USB2_UBR;
+	canbtr |= (bt->brp - 1) & (ESD_USB2_BRP_MAX - 1);
+	canbtr |= ((bt->sjw - 1) & (ESD_USB2_SJW_MAX - 1))
+		<< ESD_USB2_SJW_SHIFT;
+	canbtr |= ((bt->prop_seg + bt->phase_seg1 - 1)
+		   & (ESD_USB2_TSEG1_MAX - 1))
+		<< ESD_USB2_TSEG1_SHIFT;
+	canbtr |= ((bt->phase_seg2 - 1) & (ESD_USB2_TSEG2_MAX - 1))
+		<< ESD_USB2_TSEG2_SHIFT;
+	if (priv->can.ctrlmode & CAN_CTRLMODE_3_SAMPLES)
+		canbtr |= ESD_USB2_3_SAMPLES;
+
+	msg.msg.hdr.len = 2;
+	msg.msg.hdr.cmd = CMD_SETBAUD;
+	msg.msg.setbaud.net = priv->index;
+	msg.msg.setbaud.rsvd = 0;
+	msg.msg.setbaud.baud = cpu_to_le32(canbtr);
+
+	dev_info(ND2D(netdev), "setting BTR=%#x\n", canbtr);
+
+	return esd_usb2_send_msg(priv->usb2, &msg);
+}
+
+static int esd_usb2_set_mode(struct net_device *netdev, enum can_mode mode)
+{
+	struct esd_usb2_net_priv *priv = netdev_priv(netdev);
+
+	if (!priv->open_time)
+		return -EINVAL;
+
+	switch (mode) {
+	case CAN_MODE_START:
+		netif_wake_queue(netdev);
+		break;
+
+	default:
+		return -EOPNOTSUPP;
+	}
+
+	return 0;
+}
+
+static int esd_usb2_probe_one_net(struct usb_interface *intf, int index)
+{
+	struct esd_usb2 *dev = usb_get_intfdata(intf);
+	struct net_device *netdev;
+	struct esd_usb2_net_priv *priv;
+	int err;
+	int i;
+
+	netdev = alloc_candev(sizeof(*priv), MAX_TX_URBS);
+	if (!netdev) {
+		dev_err(&intf->dev, "couldn't alloc candev\n");
+		return -ENOMEM;
+	}
+
+	priv = netdev_priv(netdev);
+
+	init_usb_anchor(&priv->tx_submitted);
+	atomic_set(&priv->active_tx_jobs, 0);
+
+	for (i = 0; i < MAX_TX_URBS; i++)
+		priv->tx_contexts[i].echo_index = MAX_TX_URBS;
+
+	priv->usb2 = dev;
+	priv->netdev = netdev;
+	priv->index = index;
+
+	priv->can.state = CAN_STATE_STOPPED;
+	priv->can.clock.freq = ESD_USB2_CAN_CLOCK;
+	priv->can.bittiming_const = &esd_usb2_bittiming_const;
+	priv->can.do_set_bittiming = esd_usb2_set_bittiming;
+	priv->can.do_set_mode = esd_usb2_set_mode;
+
+	netdev->flags |= IFF_ECHO; /* we support local echo */
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,28)
+	netdev->netdev_ops = &esd_usb2_netdev_ops;
+#else
+	netdev->open = esd_usb2_open;
+	netdev->stop = esd_usb2_close;
+	netdev->hard_start_xmit = esd_usb2_start_xmit;
+#endif
+
+	SET_NETDEV_DEV(netdev, &intf->dev);
+
+	err = register_candev(netdev);
+	if (err) {
+		dev_err(&intf->dev,
+			"couldn't register CAN device: %d\n", err);
+		free_candev(netdev);
+		return -ENOMEM;
+	}
+
+	dev->nets[index] = priv;
+	dev_info(ND2D(netdev), "device %s registered\n", netdev->name);
+	return 0;
+}
+
+/*
+ * probe function for new USB2 devices
+ *
+ * check version information and number of available
+ * CAN interfaces
+ */
+static int esd_usb2_probe(struct usb_interface *intf,
+			 const struct usb_device_id *id)
+{
+	struct esd_usb2 *dev;
+	struct esd_usb2_msg msg;
+	int i, err = -ENOMEM;
+
+	dev = kzalloc(sizeof(*dev), GFP_KERNEL);
+	if (!dev)
+		return -ENOMEM;
+
+	dev->udev = interface_to_usbdev(intf);
+
+	init_usb_anchor(&dev->rx_submitted);
+
+	usb_set_intfdata(intf, dev);
+
+	/* query number of CAN interfaces (nets) */
+	msg.msg.hdr.cmd = CMD_VERSION;
+	msg.msg.hdr.len = 2;
+	msg.msg.version.rsvd = 0;
+	msg.msg.version.flags = 0;
+	msg.msg.version.drv_version = 0;
+
+	if (esd_usb2_send_msg(dev, &msg) < 0) {
+		dev_err(&intf->dev, "sending version message failed\n");
+		goto free_dev;
+	}
+
+	if (esd_usb2_wait_msg(dev, &msg) < 0) {
+		dev_err(&intf->dev, "no version message answer\n");
+		goto free_dev;
+	}
+
+	dev->net_count = (int)msg.msg.version_reply.nets;
+	dev->version = le32_to_cpu(msg.msg.version_reply.version);
+
+#ifdef CONFIG_SYSFS
+	if (device_create_file(&intf->dev, &dev_attr_firmware))
+		dev_err(&intf->dev,
+			"Couldn't create device file for firmware\n");
+
+	if (device_create_file(&intf->dev, &dev_attr_hardware))
+		dev_err(&intf->dev,
+			"Couldn't create device file for hardware\n");
+
+	if (device_create_file(&intf->dev, &dev_attr_nets))
+		dev_err(&intf->dev,
+			"Couldn't create device file for nets\n");
+#endif
+
+	/* do per device probing */
+	for (i = 0; i < dev->net_count; i++)
+		esd_usb2_probe_one_net(intf, i);
+
+	return 0;
+
+free_dev:
+	kfree(dev);
+	return err;
+}
+
+/*
+ * called by the usb core when the device is removed from the system
+ */
+static void esd_usb2_disconnect(struct usb_interface *intf)
+{
+	struct esd_usb2 *dev = usb_get_intfdata(intf);
+	struct net_device *netdev;
+	int i;
+
+#ifdef CONFIG_SYSFS
+	device_remove_file(&intf->dev, &dev_attr_firmware);
+	device_remove_file(&intf->dev, &dev_attr_hardware);
+	device_remove_file(&intf->dev, &dev_attr_nets);
+#endif
+	usb_set_intfdata(intf, NULL);
+
+	if (dev) {
+		for (i = 0; i < dev->net_count; i++) {
+			if (dev->nets[i]) {
+				netdev = dev->nets[i]->netdev;
+				unregister_netdev(netdev);
+				free_candev(netdev);
+			}
+		}
+		unlink_all_urbs(dev);
+	}
+}
+
+/* usb specific object needed to register this driver with the usb subsystem */
+static struct usb_driver esd_usb2_driver = {
+	.name = "esd_usb2",
+	.probe = esd_usb2_probe,
+	.disconnect = esd_usb2_disconnect,
+	.id_table = esd_usb2_table,
+};
+
+static int __init esd_usb2_init(void)
+{
+	int err;
+
+	/* register this driver with the USB subsystem */
+	err = usb_register(&esd_usb2_driver);
+
+	if (err) {
+		err("usb_register failed. Error number %d\n", err);
+		return err;
+	}
+
+	return 0;
+}
+module_init(esd_usb2_init);
+
+static void __exit esd_usb2_exit(void)
+{
+	/* deregister this driver with the USB subsystem */
+	usb_deregister(&esd_usb2_driver);
+}
+module_exit(esd_usb2_exit);
diff --exclude CVS --exclude .git -uNr linux-2.6.27.8/drivers/net/can/vcan.c linux-2.6.27.8.modified/drivers/net/can/vcan.c
--- linux-2.6.27.8/drivers/net/can/vcan.c	2008-12-05 15:03:02.000000000 -0500
+++ linux-2.6.27.8.modified/drivers/net/can/vcan.c	2013-05-30 03:44:17.000000000 -0400
@@ -43,11 +43,18 @@
 
 #include <linux/module.h>
 #include <linux/init.h>
+#include <linux/version.h>
 #include <linux/netdevice.h>
 #include <linux/if_arp.h>
 #include <linux/if_ether.h>
-#include <linux/can.h>
+#include <socketcan/can.h>
+#include <socketcan/can/dev.h>
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,23)
 #include <net/rtnetlink.h>
+#endif
+
+#include <socketcan/can/version.h> /* for RCSID. Removed by mkpatch script */
+RCSID("$Id: vcan.c 1109 2010-01-12 11:06:55Z hartkopp $");
 
 static __initdata const char banner[] =
 	KERN_INFO "vcan: Virtual CAN interface driver\n";
@@ -56,6 +63,23 @@
 MODULE_LICENSE("Dual BSD/GPL");
 MODULE_AUTHOR("Urs Thuermann <urs.thuermann@volkswagen.de>");
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,14)
+static void *kzalloc(size_t size, unsigned int __nocast flags)
+{
+	void *ret = kmalloc(size, flags);
+
+	if (ret)
+		memset(ret, 0, size);
+
+	return ret;
+}
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,24)
+static int numdev = 4; /* default number of virtual CAN interfaces */
+module_param(numdev, int, S_IRUGO);
+MODULE_PARM_DESC(numdev, "Number of virtual CAN devices");
+#endif
 
 /*
  * CAN test feature:
@@ -67,29 +91,51 @@
 module_param(echo, bool, S_IRUGO);
 MODULE_PARM_DESC(echo, "Echo sent frames (for testing). Default: 0 (Off)");
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,24)
+static struct net_device **vcan_devs; /* root pointer to netdevice structs */
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,23)
+#define PRIVSIZE sizeof(struct net_device_stats)
+#elif LINUX_VERSION_CODE < KERNEL_VERSION(2,6,24)
+#define PRIVSIZE 0
+#endif
 
 static void vcan_rx(struct sk_buff *skb, struct net_device *dev)
 {
+	struct can_frame *cf = (struct can_frame *)skb->data;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,23)
 	struct net_device_stats *stats = &dev->stats;
+#else
+	struct net_device_stats *stats = netdev_priv(dev);
+#endif
 
 	stats->rx_packets++;
-	stats->rx_bytes += skb->len;
+	stats->rx_bytes += cf->can_dlc;
 
 	skb->protocol  = htons(ETH_P_CAN);
 	skb->pkt_type  = PACKET_BROADCAST;
 	skb->dev       = dev;
 	skb->ip_summed = CHECKSUM_UNNECESSARY;
 
-	netif_rx(skb);
+	netif_rx_ni(skb);
 }
 
 static int vcan_tx(struct sk_buff *skb, struct net_device *dev)
 {
+	struct can_frame *cf = (struct can_frame *)skb->data;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,23)
 	struct net_device_stats *stats = &dev->stats;
+#else
+	struct net_device_stats *stats = netdev_priv(dev);
+#endif
 	int loop;
 
+	if (can_dropped_invalid_skb(dev, skb))
+		return NETDEV_TX_OK;
+
 	stats->tx_packets++;
-	stats->tx_bytes += skb->len;
+	stats->tx_bytes += cf->can_dlc;
 
 	/* set flag whether this packet has to be looped back */
 	loop = skb->pkt_type == PACKET_LOOPBACK;
@@ -103,7 +149,7 @@
 			 * CAN core already did the echo for us
 			 */
 			stats->rx_packets++;
-			stats->rx_bytes += skb->len;
+			stats->rx_bytes += cf->can_dlc;
 		}
 		kfree_skb(skb);
 		return NETDEV_TX_OK;
@@ -128,26 +174,53 @@
 	return NETDEV_TX_OK;
 }
 
-static void vcan_setup(struct net_device *dev)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,23)
+static struct net_device_stats *vcan_get_stats(struct net_device *dev)
 {
-	dev->type              = ARPHRD_CAN;
-	dev->mtu               = sizeof(struct can_frame);
-	dev->hard_header_len   = 0;
-	dev->addr_len          = 0;
-	dev->tx_queue_len      = 0;
-	dev->flags             = IFF_NOARP;
+	struct net_device_stats *stats = netdev_priv(dev);
+
+	return stats;
+}
+#endif
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,29)
+static const struct net_device_ops vcan_netdev_ops = {
+	.ndo_start_xmit = vcan_tx,
+};
+#endif
 
+static void vcan_setup(struct net_device *dev)
+{
+	dev->type		= ARPHRD_CAN;
+	dev->mtu		= sizeof(struct can_frame);
+	dev->hard_header_len	= 0;
+	dev->addr_len		= 0;
+	dev->tx_queue_len	= 0;
+	dev->flags		= IFF_NOARP;
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,25)
+#define IFF_ECHO IFF_LOOPBACK
+#endif
 	/* set flags according to driver capabilities */
 	if (echo)
 		dev->flags |= IFF_ECHO;
 
-	dev->hard_start_xmit   = vcan_tx;
-	dev->destructor        = free_netdev;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,29)
+	dev->netdev_ops		= &vcan_netdev_ops;
+#else
+	dev->hard_start_xmit	= vcan_tx;
+#endif
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,24)
+	dev->destructor		= free_netdev;
+#endif
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,23)
+	dev->get_stats		= vcan_get_stats;
+#endif
 }
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,24)
 static struct rtnl_link_ops vcan_link_ops __read_mostly = {
-       .kind           = "vcan",
-       .setup          = vcan_setup,
+	.kind	= "vcan",
+	.setup	= vcan_setup,
 };
 
 static __init int vcan_init_module(void)
@@ -164,6 +237,75 @@
 {
 	rtnl_link_unregister(&vcan_link_ops);
 }
+#else
+static __init int vcan_init_module(void)
+{
+	int i, result;
+
+	printk(banner);
+
+	/* register at least one interface */
+	if (numdev < 1)
+		numdev = 1;
+
+	printk(KERN_INFO
+	       "vcan: registering %d virtual CAN interfaces. (echo %s)\n",
+	       numdev, echo ? "enabled" : "disabled");
+
+	vcan_devs = kzalloc(numdev * sizeof(struct net_device *), GFP_KERNEL);
+	if (!vcan_devs) {
+		printk(KERN_ERR "vcan: Can't allocate vcan devices array!\n");
+		return -ENOMEM;
+	}
+
+	for (i = 0; i < numdev; i++) {
+		vcan_devs[i] = alloc_netdev(PRIVSIZE, "vcan%d", vcan_setup);
+		if (!vcan_devs[i]) {
+			printk(KERN_ERR "vcan: error allocating net_device\n");
+			result = -ENOMEM;
+			goto out;
+		}
+
+		result = register_netdev(vcan_devs[i]);
+		if (result < 0) {
+			printk(KERN_ERR
+			       "vcan: error %d registering interface %s\n",
+			       result, vcan_devs[i]->name);
+			free_netdev(vcan_devs[i]);
+			vcan_devs[i] = NULL;
+			goto out;
+		}
+	}
+
+	return 0;
+
+ out:
+	for (i = 0; i < numdev; i++) {
+		if (vcan_devs[i]) {
+			unregister_netdev(vcan_devs[i]);
+			free_netdev(vcan_devs[i]);
+		}
+	}
+
+	kfree(vcan_devs);
+
+	return result;
+}
+
+static __exit void vcan_cleanup_module(void)
+{
+	int i;
+
+	for (i = 0; i < numdev; i++) {
+		if (vcan_devs[i]) {
+			unregister_netdev(vcan_devs[i]);
+			free_netdev(vcan_devs[i]);
+		}
+	}
+
+	kfree(vcan_devs);
+}
+#endif
 
 module_init(vcan_init_module);
 module_exit(vcan_cleanup_module);
diff --exclude CVS --exclude .git -uNr linux-2.6.27.8/drivers/net/lpc32xx_mii.c linux-2.6.27.8.modified/drivers/net/lpc32xx_mii.c
--- linux-2.6.27.8/drivers/net/lpc32xx_mii.c	2014-06-15 10:04:08.000000000 -0400
+++ linux-2.6.27.8.modified/drivers/net/lpc32xx_mii.c	2013-05-15 01:40:53.000000000 -0400
@@ -52,7 +52,7 @@
 
 #define MODNAME "lpc32xx-net"
 #define DRV_VERSION "$Revision: 1.00 $"
-#define PHYDEF_ADDR 0x00
+#define PHYDEF_ADDR 0x1f
 
 #define ENET_MAXF_SIZE 1536
 #define ENET_RX_DESC 128 /* Number of receive descriptors/buffers */
Binary files linux-2.6.27.8/drivers/serial/.hs_serial_lpc32xx.c.swp and linux-2.6.27.8.modified/drivers/serial/.hs_serial_lpc32xx.c.swp differ
diff --exclude CVS --exclude .git -uNr linux-2.6.27.8/drivers/serial/hs_serial_lpc32xx.c linux-2.6.27.8.modified/drivers/serial/hs_serial_lpc32xx.c
--- linux-2.6.27.8/drivers/serial/hs_serial_lpc32xx.c	2014-06-15 10:04:08.000000000 -0400
+++ linux-2.6.27.8.modified/drivers/serial/hs_serial_lpc32xx.c	2013-05-23 05:12:32.000000000 -0400
@@ -33,9 +33,11 @@
 #include <asm/io.h>
 #include <asm/irq.h>
 #include <mach/lpc32xx_hsuart.h>
+#include <mach/lpc32xx_gpio.h>
 
 #define MODNAME "lpc32xx_hsuart"
 #define REVISION "$Revision: 0.90 $"
+#define GPIO_IOBASE io_p2v(GPIO_BASE)
 
 struct lpc32xx_hsuart_port
 {
@@ -233,8 +235,12 @@
 	/* Transmit data request? */
 	if ((status & HSU_TX_INT) && (!uart_tx_stopped(port)))
 	{
+		printk(KERN_INFO "1serial_lpc32xx_interrupt\n");
+		__raw_writel(OUTP_STATE_GPO(17), GPIO_P3_OUTP_SET(GPIO_IOBASE));
 		__raw_writel(HSU_TX_INT, HSUART_IIR(port->membase));
 		__serial_lpc32xx_tx(port);
+		__raw_writel(OUTP_STATE_GPO(17), GPIO_P3_OUTP_CLR(GPIO_IOBASE));
+		printk(KERN_INFO "2serial_lpc32xx_interrupt\n");
 	}
 
 	spin_unlock(&port->lock);
@@ -246,9 +252,11 @@
 {
 	unsigned int ret = 0;
 
+	printk(KERN_INFO "*serial_lpc32xx_empty\n");
 	if (HSU_TX_LEV(__raw_readl(HSUART_LEVEL(port->membase))) == 0)
 	{
 		/* TX FIFO is empty */
+		__raw_writel(OUTP_STATE_GPO(17), GPIO_P3_OUTP_CLR(GPIO_IOBASE));
 		ret = TIOCSER_TEMT;
 	}
 
@@ -271,6 +279,7 @@
 	unsigned long flags;
 	u32 tmp;
 
+	printk(KERN_INFO "-serial_lpc32xx_stop_tx\n");
 	spin_lock_irqsave(&port->lock, flags);
 
 	/* Stop TX interrrupt */
@@ -286,8 +295,10 @@
 	unsigned long flags;
 	u32 tmp;
 
+	printk(KERN_INFO "+serial_lpc32xx_start_tx\n");
 	spin_lock_irqsave(&port->lock, flags);
 
+	__raw_writel(OUTP_STATE_GPO(17), GPIO_P3_OUTP_SET(GPIO_IOBASE));
 	/* Start TX interrrupt */
 	__serial_lpc32xx_tx(port);
 	tmp = __raw_readl(HSUART_CTRL(port->membase));
diff --exclude CVS --exclude .git -uNr linux-2.6.27.8/drivers/spi/spi_lpc32xx.c linux-2.6.27.8.modified/drivers/spi/spi_lpc32xx.c
--- linux-2.6.27.8/drivers/spi/spi_lpc32xx.c	2014-06-15 10:04:06.000000000 -0400
+++ linux-2.6.27.8.modified/drivers/spi/spi_lpc32xx.c	2013-05-30 22:09:57.000000000 -0400
@@ -55,10 +55,13 @@
 
 /*
  * Default configuration for boards without specific setup
+ * 目前存在两个SPI设备,SPI E2P和SPI CAN MCP2515
+ * SPI E2P 通过GPIO5/SSEL0 选择
+ * SPI CAN MCP2515通过GPIO0选择
  */
 static struct lpc32xx_spi_cfg lpc32xx_stdspi_cfg =
 {
-	.num_cs = 1,
+	.num_cs = 2,
 };
 
 static void lpc32xx_spi_prep(struct lpc32xxspi *spidat)
diff --exclude CVS --exclude .git -uNr linux-2.6.27.8/include/linux/can/Kbuild linux-2.6.27.8.modified/include/linux/can/Kbuild
--- linux-2.6.27.8/include/linux/can/Kbuild	2008-12-05 15:03:02.000000000 -0500
+++ linux-2.6.27.8.modified/include/linux/can/Kbuild	1969-12-31 19:00:00.000000000 -0500
@@ -1,3 +0,0 @@
-header-y += raw.h
-header-y += bcm.h
-header-y += error.h
diff --exclude CVS --exclude .git -uNr linux-2.6.27.8/include/linux/can/bcm.h linux-2.6.27.8.modified/include/linux/can/bcm.h
--- linux-2.6.27.8/include/linux/can/bcm.h	2008-12-05 15:03:02.000000000 -0500
+++ linux-2.6.27.8.modified/include/linux/can/bcm.h	2013-05-30 03:44:12.000000000 -0400
@@ -1,65 +1 @@
-/*
- * linux/can/bcm.h
- *
- * Definitions for CAN Broadcast Manager (BCM)
- *
- * Author: Oliver Hartkopp <oliver.hartkopp@volkswagen.de>
- * Copyright (c) 2002-2007 Volkswagen Group Electronic Research
- * All rights reserved.
- *
- * Send feedback to <socketcan-users@lists.berlios.de>
- *
- */
-
-#ifndef CAN_BCM_H
-#define CAN_BCM_H
-
-/**
- * struct bcm_msg_head - head of messages to/from the broadcast manager
- * @opcode:    opcode, see enum below.
- * @flags:     special flags, see below.
- * @count:     number of frames to send before changing interval.
- * @ival1:     interval for the first @count frames.
- * @ival2:     interval for the following frames.
- * @can_id:    CAN ID of frames to be sent or received.
- * @nframes:   number of frames appended to the message head.
- * @frames:    array of CAN frames.
- */
-struct bcm_msg_head {
-	__u32 opcode;
-	__u32 flags;
-	__u32 count;
-	struct timeval ival1, ival2;
-	canid_t can_id;
-	__u32 nframes;
-	struct can_frame frames[0];
-};
-
-enum {
-	TX_SETUP = 1,	/* create (cyclic) transmission task */
-	TX_DELETE,	/* remove (cyclic) transmission task */
-	TX_READ,	/* read properties of (cyclic) transmission task */
-	TX_SEND,	/* send one CAN frame */
-	RX_SETUP,	/* create RX content filter subscription */
-	RX_DELETE,	/* remove RX content filter subscription */
-	RX_READ,	/* read properties of RX content filter subscription */
-	TX_STATUS,	/* reply to TX_READ request */
-	TX_EXPIRED,	/* notification on performed transmissions (count=0) */
-	RX_STATUS,	/* reply to RX_READ request */
-	RX_TIMEOUT,	/* cyclic message is absent */
-	RX_CHANGED	/* updated CAN frame (detected content change) */
-};
-
-#define SETTIMER            0x0001
-#define STARTTIMER          0x0002
-#define TX_COUNTEVT         0x0004
-#define TX_ANNOUNCE         0x0008
-#define TX_CP_CAN_ID        0x0010
-#define RX_FILTER_ID        0x0020
-#define RX_CHECK_DLC        0x0040
-#define RX_NO_AUTOTIMER     0x0080
-#define RX_ANNOUNCE_RESUME  0x0100
-#define TX_RESET_MULTI_IDX  0x0200
-#define RX_RTR_FRAME        0x0400
-
-#endif /* CAN_BCM_H */
+#include <socketcan/can/bcm.h>
diff --exclude CVS --exclude .git -uNr linux-2.6.27.8/include/linux/can/core.h linux-2.6.27.8.modified/include/linux/can/core.h
--- linux-2.6.27.8/include/linux/can/core.h	2008-12-05 15:03:02.000000000 -0500
+++ linux-2.6.27.8.modified/include/linux/can/core.h	2013-05-30 03:44:12.000000000 -0400
@@ -1,64 +1 @@
-/*
- * linux/can/core.h
- *
- * Protoypes and definitions for CAN protocol modules using the PF_CAN core
- *
- * Authors: Oliver Hartkopp <oliver.hartkopp@volkswagen.de>
- *          Urs Thuermann   <urs.thuermann@volkswagen.de>
- * Copyright (c) 2002-2007 Volkswagen Group Electronic Research
- * All rights reserved.
- *
- * Send feedback to <socketcan-users@lists.berlios.de>
- *
- */
-
-#ifndef CAN_CORE_H
-#define CAN_CORE_H
-
-#include <linux/can.h>
-#include <linux/skbuff.h>
-#include <linux/netdevice.h>
-
-#define CAN_VERSION "20071116"
-
-/* increment this number each time you change some user-space interface */
-#define CAN_ABI_VERSION "8"
-
-#define CAN_VERSION_STRING "rev " CAN_VERSION " abi " CAN_ABI_VERSION
-
-#define DNAME(dev) ((dev) ? (dev)->name : "any")
-
-/**
- * struct can_proto - CAN protocol structure
- * @type:       type argument in socket() syscall, e.g. SOCK_DGRAM.
- * @protocol:   protocol number in socket() syscall.
- * @capability: capability needed to open the socket, or -1 for no restriction.
- * @ops:        pointer to struct proto_ops for sock->ops.
- * @prot:       pointer to struct proto structure.
- */
-struct can_proto {
-	int              type;
-	int              protocol;
-	int              capability;
-	struct proto_ops *ops;
-	struct proto     *prot;
-};
-
-/* function prototypes for the CAN networklayer core (af_can.c) */
-
-extern int  can_proto_register(struct can_proto *cp);
-extern void can_proto_unregister(struct can_proto *cp);
-
-extern int  can_rx_register(struct net_device *dev, canid_t can_id,
-			    canid_t mask,
-			    void (*func)(struct sk_buff *, void *),
-			    void *data, char *ident);
-
-extern void can_rx_unregister(struct net_device *dev, canid_t can_id,
-			      canid_t mask,
-			      void (*func)(struct sk_buff *, void *),
-			      void *data);
-
-extern int can_send(struct sk_buff *skb, int loop);
-
-#endif /* CAN_CORE_H */
+#include <socketcan/can/core.h>
diff --exclude CVS --exclude .git -uNr linux-2.6.27.8/include/linux/can/dev.h linux-2.6.27.8.modified/include/linux/can/dev.h
--- linux-2.6.27.8/include/linux/can/dev.h	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.27.8.modified/include/linux/can/dev.h	2013-05-30 03:44:12.000000000 -0400
@@ -0,0 +1 @@
+#include <socketcan/can/dev.h>
diff --exclude CVS --exclude .git -uNr linux-2.6.27.8/include/linux/can/error.h linux-2.6.27.8.modified/include/linux/can/error.h
--- linux-2.6.27.8/include/linux/can/error.h	2008-12-05 15:03:02.000000000 -0500
+++ linux-2.6.27.8.modified/include/linux/can/error.h	2013-05-30 03:44:12.000000000 -0400
@@ -1,93 +1 @@
-/*
- * linux/can/error.h
- *
- * Definitions of the CAN error frame to be filtered and passed to the user.
- *
- * Author: Oliver Hartkopp <oliver.hartkopp@volkswagen.de>
- * Copyright (c) 2002-2007 Volkswagen Group Electronic Research
- * All rights reserved.
- *
- * Send feedback to <socketcan-users@lists.berlios.de>
- *
- */
-
-#ifndef CAN_ERROR_H
-#define CAN_ERROR_H
-
-#define CAN_ERR_DLC 8 /* dlc for error frames */
-
-/* error class (mask) in can_id */
-#define CAN_ERR_TX_TIMEOUT   0x00000001U /* TX timeout (by netdevice driver) */
-#define CAN_ERR_LOSTARB      0x00000002U /* lost arbitration    / data[0]    */
-#define CAN_ERR_CRTL         0x00000004U /* controller problems / data[1]    */
-#define CAN_ERR_PROT         0x00000008U /* protocol violations / data[2..3] */
-#define CAN_ERR_TRX          0x00000010U /* transceiver status  / data[4]    */
-#define CAN_ERR_ACK          0x00000020U /* received no ACK on transmission */
-#define CAN_ERR_BUSOFF       0x00000040U /* bus off */
-#define CAN_ERR_BUSERROR     0x00000080U /* bus error (may flood!) */
-#define CAN_ERR_RESTARTED    0x00000100U /* controller restarted */
-
-/* arbitration lost in bit ... / data[0] */
-#define CAN_ERR_LOSTARB_UNSPEC   0x00 /* unspecified */
-				      /* else bit number in bitstream */
-
-/* error status of CAN-controller / data[1] */
-#define CAN_ERR_CRTL_UNSPEC      0x00 /* unspecified */
-#define CAN_ERR_CRTL_RX_OVERFLOW 0x01 /* RX buffer overflow */
-#define CAN_ERR_CRTL_TX_OVERFLOW 0x02 /* TX buffer overflow */
-#define CAN_ERR_CRTL_RX_WARNING  0x04 /* reached warning level for RX errors */
-#define CAN_ERR_CRTL_TX_WARNING  0x08 /* reached warning level for TX errors */
-#define CAN_ERR_CRTL_RX_PASSIVE  0x10 /* reached error passive status RX */
-#define CAN_ERR_CRTL_TX_PASSIVE  0x20 /* reached error passive status TX */
-				      /* (at least one error counter exceeds */
-				      /* the protocol-defined level of 127)  */
-
-/* error in CAN protocol (type) / data[2] */
-#define CAN_ERR_PROT_UNSPEC      0x00 /* unspecified */
-#define CAN_ERR_PROT_BIT         0x01 /* single bit error */
-#define CAN_ERR_PROT_FORM        0x02 /* frame format error */
-#define CAN_ERR_PROT_STUFF       0x04 /* bit stuffing error */
-#define CAN_ERR_PROT_BIT0        0x08 /* unable to send dominant bit */
-#define CAN_ERR_PROT_BIT1        0x10 /* unable to send recessive bit */
-#define CAN_ERR_PROT_OVERLOAD    0x20 /* bus overload */
-#define CAN_ERR_PROT_ACTIVE      0x40 /* active error announcement */
-#define CAN_ERR_PROT_TX          0x80 /* error occured on transmission */
-
-/* error in CAN protocol (location) / data[3] */
-#define CAN_ERR_PROT_LOC_UNSPEC  0x00 /* unspecified */
-#define CAN_ERR_PROT_LOC_SOF     0x03 /* start of frame */
-#define CAN_ERR_PROT_LOC_ID28_21 0x02 /* ID bits 28 - 21 (SFF: 10 - 3) */
-#define CAN_ERR_PROT_LOC_ID20_18 0x06 /* ID bits 20 - 18 (SFF: 2 - 0 )*/
-#define CAN_ERR_PROT_LOC_SRTR    0x04 /* substitute RTR (SFF: RTR) */
-#define CAN_ERR_PROT_LOC_IDE     0x05 /* identifier extension */
-#define CAN_ERR_PROT_LOC_ID17_13 0x07 /* ID bits 17-13 */
-#define CAN_ERR_PROT_LOC_ID12_05 0x0F /* ID bits 12-5 */
-#define CAN_ERR_PROT_LOC_ID04_00 0x0E /* ID bits 4-0 */
-#define CAN_ERR_PROT_LOC_RTR     0x0C /* RTR */
-#define CAN_ERR_PROT_LOC_RES1    0x0D /* reserved bit 1 */
-#define CAN_ERR_PROT_LOC_RES0    0x09 /* reserved bit 0 */
-#define CAN_ERR_PROT_LOC_DLC     0x0B /* data length code */
-#define CAN_ERR_PROT_LOC_DATA    0x0A /* data section */
-#define CAN_ERR_PROT_LOC_CRC_SEQ 0x08 /* CRC sequence */
-#define CAN_ERR_PROT_LOC_CRC_DEL 0x18 /* CRC delimiter */
-#define CAN_ERR_PROT_LOC_ACK     0x19 /* ACK slot */
-#define CAN_ERR_PROT_LOC_ACK_DEL 0x1B /* ACK delimiter */
-#define CAN_ERR_PROT_LOC_EOF     0x1A /* end of frame */
-#define CAN_ERR_PROT_LOC_INTERM  0x12 /* intermission */
-
-/* error status of CAN-transceiver / data[4] */
-/*                                             CANH CANL */
-#define CAN_ERR_TRX_UNSPEC             0x00 /* 0000 0000 */
-#define CAN_ERR_TRX_CANH_NO_WIRE       0x04 /* 0000 0100 */
-#define CAN_ERR_TRX_CANH_SHORT_TO_BAT  0x05 /* 0000 0101 */
-#define CAN_ERR_TRX_CANH_SHORT_TO_VCC  0x06 /* 0000 0110 */
-#define CAN_ERR_TRX_CANH_SHORT_TO_GND  0x07 /* 0000 0111 */
-#define CAN_ERR_TRX_CANL_NO_WIRE       0x40 /* 0100 0000 */
-#define CAN_ERR_TRX_CANL_SHORT_TO_BAT  0x50 /* 0101 0000 */
-#define CAN_ERR_TRX_CANL_SHORT_TO_VCC  0x60 /* 0110 0000 */
-#define CAN_ERR_TRX_CANL_SHORT_TO_GND  0x70 /* 0111 0000 */
-#define CAN_ERR_TRX_CANL_SHORT_TO_CANH 0x80 /* 1000 0000 */
-
-/* controller specific additional information / data[5..7] */
-
-#endif /* CAN_ERROR_H */
+#include <socketcan/can/error.h>
diff --exclude CVS --exclude .git -uNr linux-2.6.27.8/include/linux/can/gw.h linux-2.6.27.8.modified/include/linux/can/gw.h
--- linux-2.6.27.8/include/linux/can/gw.h	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.27.8.modified/include/linux/can/gw.h	2013-05-30 03:44:12.000000000 -0400
@@ -0,0 +1 @@
+#include <socketcan/can/gw.h>
diff --exclude CVS --exclude .git -uNr linux-2.6.27.8/include/linux/can/isotp.h linux-2.6.27.8.modified/include/linux/can/isotp.h
--- linux-2.6.27.8/include/linux/can/isotp.h	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.27.8.modified/include/linux/can/isotp.h	2013-05-30 03:44:12.000000000 -0400
@@ -0,0 +1 @@
+#include <socketcan/can/isotp.h>
diff --exclude CVS --exclude .git -uNr linux-2.6.27.8/include/linux/can/j1939.h linux-2.6.27.8.modified/include/linux/can/j1939.h
--- linux-2.6.27.8/include/linux/can/j1939.h	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.27.8.modified/include/linux/can/j1939.h	2013-05-30 03:44:12.000000000 -0400
@@ -0,0 +1 @@
+#include <socketcan/can/j1939.h>
diff --exclude CVS --exclude .git -uNr linux-2.6.27.8/include/linux/can/netlink.h linux-2.6.27.8.modified/include/linux/can/netlink.h
--- linux-2.6.27.8/include/linux/can/netlink.h	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.27.8.modified/include/linux/can/netlink.h	2013-05-30 03:44:12.000000000 -0400
@@ -0,0 +1 @@
+#include <socketcan/can/netlink.h>
diff --exclude CVS --exclude .git -uNr linux-2.6.27.8/include/linux/can/raw.h linux-2.6.27.8.modified/include/linux/can/raw.h
--- linux-2.6.27.8/include/linux/can/raw.h	2008-12-05 15:03:02.000000000 -0500
+++ linux-2.6.27.8.modified/include/linux/can/raw.h	2013-05-30 03:44:12.000000000 -0400
@@ -1,31 +1 @@
-/*
- * linux/can/raw.h
- *
- * Definitions for raw CAN sockets
- *
- * Authors: Oliver Hartkopp <oliver.hartkopp@volkswagen.de>
- *          Urs Thuermann   <urs.thuermann@volkswagen.de>
- * Copyright (c) 2002-2007 Volkswagen Group Electronic Research
- * All rights reserved.
- *
- * Send feedback to <socketcan-users@lists.berlios.de>
- *
- */
-
-#ifndef CAN_RAW_H
-#define CAN_RAW_H
-
-#include <linux/can.h>
-
-#define SOL_CAN_RAW (SOL_CAN_BASE + CAN_RAW)
-
-/* for socket options affecting the socket (not the global system) */
-
-enum {
-	CAN_RAW_FILTER = 1,	/* set 0 .. n can_filter(s)          */
-	CAN_RAW_ERR_FILTER,	/* set filter for error frames       */
-	CAN_RAW_LOOPBACK,	/* local loopback (default:on)       */
-	CAN_RAW_RECV_OWN_MSGS	/* receive my own msgs (default:off) */
-};
-
-#endif
+#include <socketcan/can/raw.h>
diff --exclude CVS --exclude .git -uNr linux-2.6.27.8/include/linux/can.h linux-2.6.27.8.modified/include/linux/can.h
--- linux-2.6.27.8/include/linux/can.h	2008-12-05 15:03:02.000000000 -0500
+++ linux-2.6.27.8.modified/include/linux/can.h	2013-05-30 21:27:11.000000000 -0400
@@ -1,111 +1 @@
-/*
- * linux/can.h
- *
- * Definitions for CAN network layer (socket addr / CAN frame / CAN filter)
- *
- * Authors: Oliver Hartkopp <oliver.hartkopp@volkswagen.de>
- *          Urs Thuermann   <urs.thuermann@volkswagen.de>
- * Copyright (c) 2002-2007 Volkswagen Group Electronic Research
- * All rights reserved.
- *
- * Send feedback to <socketcan-users@lists.berlios.de>
- *
- */
-
-#ifndef CAN_H
-#define CAN_H
-
-#include <linux/types.h>
-#include <linux/socket.h>
-
-/* controller area network (CAN) kernel definitions */
-
-/* special address description flags for the CAN_ID */
-#define CAN_EFF_FLAG 0x80000000U /* EFF/SFF is set in the MSB */
-#define CAN_RTR_FLAG 0x40000000U /* remote transmission request */
-#define CAN_ERR_FLAG 0x20000000U /* error frame */
-
-/* valid bits in CAN ID for frame formats */
-#define CAN_SFF_MASK 0x000007FFU /* standard frame format (SFF) */
-#define CAN_EFF_MASK 0x1FFFFFFFU /* extended frame format (EFF) */
-#define CAN_ERR_MASK 0x1FFFFFFFU /* omit EFF, RTR, ERR flags */
-
-/*
- * Controller Area Network Identifier structure
- *
- * bit 0-28	: CAN identifier (11/29 bit)
- * bit 29	: error frame flag (0 = data frame, 1 = error frame)
- * bit 30	: remote transmission request flag (1 = rtr frame)
- * bit 31	: frame format flag (0 = standard 11 bit, 1 = extended 29 bit)
- */
-typedef __u32 canid_t;
-
-/*
- * Controller Area Network Error Frame Mask structure
- *
- * bit 0-28	: error class mask (see include/linux/can/error.h)
- * bit 29-31	: set to zero
- */
-typedef __u32 can_err_mask_t;
-
-/**
- * struct can_frame - basic CAN frame structure
- * @can_id:  the CAN ID of the frame and CAN_*_FLAG flags, see above.
- * @can_dlc: the data length field of the CAN frame
- * @data:    the CAN frame payload.
- */
-struct can_frame {
-	canid_t can_id;  /* 32 bit CAN_ID + EFF/RTR/ERR flags */
-	__u8    can_dlc; /* data length code: 0 .. 8 */
-	__u8    data[8] __attribute__((aligned(8)));
-};
-
-/* particular protocols of the protocol family PF_CAN */
-#define CAN_RAW		1 /* RAW sockets */
-#define CAN_BCM		2 /* Broadcast Manager */
-#define CAN_TP16	3 /* VAG Transport Protocol v1.6 */
-#define CAN_TP20	4 /* VAG Transport Protocol v2.0 */
-#define CAN_MCNET	5 /* Bosch MCNet */
-#define CAN_ISOTP	6 /* ISO 15765-2 Transport Protocol */
-#define CAN_NPROTO	7
-
-#define SOL_CAN_BASE 100
-
-/**
- * struct sockaddr_can - the sockaddr structure for CAN sockets
- * @can_family:  address family number AF_CAN.
- * @can_ifindex: CAN network interface index.
- * @can_addr:    protocol specific address information
- */
-struct sockaddr_can {
-	sa_family_t can_family;
-	int         can_ifindex;
-	union {
-		/* transport protocol class address information (e.g. ISOTP) */
-		struct { canid_t rx_id, tx_id; } tp;
-
-		/* reserved for future CAN protocols address information */
-	} can_addr;
-};
-
-/**
- * struct can_filter - CAN ID based filter in can_register().
- * @can_id:   relevant bits of CAN ID which are not masked out.
- * @can_mask: CAN mask (see description)
- *
- * Description:
- * A filter matches, when
- *
- *          <received_can_id> & mask == can_id & mask
- *
- * The filter can be inverted (CAN_INV_FILTER bit set in can_id) or it can
- * filter for error frames (CAN_ERR_FLAG bit set in mask).
- */
-struct can_filter {
-	canid_t can_id;
-	canid_t can_mask;
-};
-
-#define CAN_INV_FILTER 0x20000000U /* to be set in can_filter.can_id */
-
-#endif /* CAN_H */
+#include <socketcan/can.h>
diff --exclude CVS --exclude .git -uNr linux-2.6.27.8/include/socketcan/can/bcm.h linux-2.6.27.8.modified/include/socketcan/can/bcm.h
--- linux-2.6.27.8/include/socketcan/can/bcm.h	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.27.8.modified/include/socketcan/can/bcm.h	2013-05-30 03:44:13.000000000 -0400
@@ -0,0 +1,67 @@
+/*
+ * socketcan/can/bcm.h
+ *
+ * Definitions for CAN Broadcast Manager (BCM)
+ *
+ * $Id: bcm.h 1038 2009-08-21 10:00:21Z hartkopp $
+ *
+ * Author: Oliver Hartkopp <oliver.hartkopp@volkswagen.de>
+ * Copyright (c) 2002-2007 Volkswagen Group Electronic Research
+ * All rights reserved.
+ *
+ * Send feedback to <socketcan-users@lists.berlios.de>
+ *
+ */
+
+#ifndef CAN_BCM_H
+#define CAN_BCM_H
+
+/**
+ * struct bcm_msg_head - head of messages to/from the broadcast manager
+ * @opcode:    opcode, see enum below.
+ * @flags:     special flags, see below.
+ * @count:     number of frames to send before changing interval.
+ * @ival1:     interval for the first @count frames.
+ * @ival2:     interval for the following frames.
+ * @can_id:    CAN ID of frames to be sent or received.
+ * @nframes:   number of frames appended to the message head.
+ * @frames:    array of CAN frames.
+ */
+struct bcm_msg_head {
+	__u32 opcode;
+	__u32 flags;
+	__u32 count;
+	struct timeval ival1, ival2;
+	canid_t can_id;
+	__u32 nframes;
+	struct can_frame frames[0];
+};
+
+enum {
+	TX_SETUP = 1,	/* create (cyclic) transmission task */
+	TX_DELETE,	/* remove (cyclic) transmission task */
+	TX_READ,	/* read properties of (cyclic) transmission task */
+	TX_SEND,	/* send one CAN frame */
+	RX_SETUP,	/* create RX content filter subscription */
+	RX_DELETE,	/* remove RX content filter subscription */
+	RX_READ,	/* read properties of RX content filter subscription */
+	TX_STATUS,	/* reply to TX_READ request */
+	TX_EXPIRED,	/* notification on performed transmissions (count=0) */
+	RX_STATUS,	/* reply to RX_READ request */
+	RX_TIMEOUT,	/* cyclic message is absent */
+	RX_CHANGED	/* updated CAN frame (detected content change) */
+};
+
+#define SETTIMER            0x0001
+#define STARTTIMER          0x0002
+#define TX_COUNTEVT         0x0004
+#define TX_ANNOUNCE         0x0008
+#define TX_CP_CAN_ID        0x0010
+#define RX_FILTER_ID        0x0020
+#define RX_CHECK_DLC        0x0040
+#define RX_NO_AUTOTIMER     0x0080
+#define RX_ANNOUNCE_RESUME  0x0100
+#define TX_RESET_MULTI_IDX  0x0200
+#define RX_RTR_FRAME        0x0400
+
+#endif /* CAN_BCM_H */
diff --exclude CVS --exclude .git -uNr linux-2.6.27.8/include/socketcan/can/core.h linux-2.6.27.8.modified/include/socketcan/can/core.h
--- linux-2.6.27.8/include/socketcan/can/core.h	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.27.8.modified/include/socketcan/can/core.h	2013-05-30 03:44:13.000000000 -0400
@@ -0,0 +1,106 @@
+/*
+ * socketcan/can/core.h
+ *
+ * Protoypes and definitions for CAN protocol modules using the PF_CAN core
+ *
+ * $Id: core.h 1252 2011-05-05 14:42:58Z hartkopp $
+ *
+ * Authors: Oliver Hartkopp <oliver.hartkopp@volkswagen.de>
+ *          Urs Thuermann   <urs.thuermann@volkswagen.de>
+ * Copyright (c) 2002-2007 Volkswagen Group Electronic Research
+ * All rights reserved.
+ *
+ * Send feedback to <socketcan-users@lists.berlios.de>
+ *
+ */
+
+#ifndef CAN_CORE_H
+#define CAN_CORE_H
+
+#include <socketcan/can.h>
+#include <linux/skbuff.h>
+#include <linux/netdevice.h>
+#include <net/rtnetlink.h>
+
+#define CAN_VERSION "20090105"
+
+/* increment this number each time you change some user-space interface */
+#define CAN_ABI_VERSION "8"
+
+#define CAN_VERSION_STRING "rev " CAN_VERSION " abi " CAN_ABI_VERSION
+
+#define DNAME(dev) ((dev) ? (dev)->name : "any")
+
+/**
+ * struct can_proto - CAN protocol structure
+ * @type:       type argument in socket() syscall, e.g. SOCK_DGRAM.
+ * @protocol:   protocol number in socket() syscall.
+ * @capability: capability needed to open the socket, or -1 for no restriction.
+ * @ops:        pointer to struct proto_ops for sock->ops.
+ * @prot:       pointer to struct proto structure.
+ */
+struct can_proto {
+	int type;
+	int protocol;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,33)
+	int capability;
+#endif
+	const struct proto_ops *ops;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,12)
+	struct proto *prot;
+#else
+	struct module *owner;
+	int (*init)(struct sock *sk);
+	size_t obj_size;
+#endif
+	const struct rtnl_af_ops *rtnl_link_ops;
+	/*
+	 * hooks for rtnl hooks
+	 * for the *dump* functions, cb->args[0] is reserved
+	 * for use by af_can.c, so keep your fingers off.
+	 */
+	rtnl_doit_func rtnl_new_addr;
+	rtnl_doit_func rtnl_del_addr;
+	rtnl_dumpit_func rtnl_dump_addr;
+};
+
+/*
+ * this is quite a dirty hack:
+ * reuse the second byte of a rtnetlink msg
+ * to indicate the precise protocol.
+ * The major problem is that is may conflict
+ * with the prefixlen in struct ifaddrmsg.
+ */
+struct rtgencanmsg {
+	unsigned char rtgen_family;
+	unsigned char can_protocol;
+};
+
+/*
+ * required_size
+ * macro to find the minimum size of a struct
+ * that includes a requested member
+ */
+#define required_size(member, struct_type) \
+	(offsetof(typeof(struct_type), member) + \
+	 sizeof(((typeof(struct_type) *)(0))->member))
+
+/* function prototypes for the CAN networklayer core (af_can.c) */
+
+extern int  can_proto_register(const struct can_proto *cp);
+extern void can_proto_unregister(const struct can_proto *cp);
+
+extern int  can_rx_register(struct net_device *dev, canid_t can_id,
+			    canid_t mask,
+			    void (*func)(struct sk_buff *, void *),
+			    void *data, char *ident);
+
+extern void can_rx_unregister(struct net_device *dev, canid_t can_id,
+			      canid_t mask,
+			      void (*func)(struct sk_buff *, void *),
+			      void *data);
+
+extern int can_send(struct sk_buff *skb, int loop);
+extern int can_ioctl(struct socket *sock, unsigned int cmd, unsigned long arg);
+
+#endif /* CAN_CORE_H */
diff --exclude CVS --exclude .git -uNr linux-2.6.27.8/include/socketcan/can/dev.h linux-2.6.27.8.modified/include/socketcan/can/dev.h
--- linux-2.6.27.8/include/socketcan/can/dev.h	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.27.8.modified/include/socketcan/can/dev.h	2013-05-30 03:44:13.000000000 -0400
@@ -0,0 +1,122 @@
+/*
+ * socketcan/can/dev.h
+ *
+ * Definitions for the CAN network device driver interface
+ *
+ * $Id: dev.h 1153 2010-03-05 09:11:52Z wolf $
+ *
+ * Copyright (C) 2006 Andrey Volkov <avolkov@varma-el.com>
+ *               Varma Electronics Oy
+ *
+ * Copyright (C) 2008 Wolfgang Grandegger <wg@grandegger.com>
+ *
+ * Send feedback to <socketcan-users@lists.berlios.de>
+ */
+
+#ifndef CAN_DEV_H
+#define CAN_DEV_H
+
+#include <linux/version.h>
+#include <socketcan/can/netlink.h>
+#include <socketcan/can/error.h>
+
+/*
+ * CAN mode
+ */
+enum can_mode {
+	CAN_MODE_STOP = 0,
+	CAN_MODE_START,
+	CAN_MODE_SLEEP
+};
+
+/*
+ * CAN common private data
+ */
+struct can_priv {
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,23)
+	struct net_device_stats net_stats;
+#endif
+	struct can_device_stats can_stats;
+
+	struct can_bittiming bittiming;
+	struct can_bittiming_const *bittiming_const;
+	struct can_clock clock;
+
+	enum can_state state;
+	u32 ctrlmode;
+	u32 ctrlmode_supported;
+
+	int restart_ms;
+	struct timer_list restart_timer;
+
+	int (*do_set_bittiming)(struct net_device *dev);
+	int (*do_set_mode)(struct net_device *dev, enum can_mode mode);
+	int (*do_get_state)(const struct net_device *dev,
+			    enum can_state *state);
+	int (*do_get_berr_counter)(const struct net_device *dev,
+				   struct can_berr_counter *bec);
+
+	unsigned int echo_skb_max;
+	struct sk_buff **echo_skb;
+};
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,21)
+#define ND2D(_ndev)	(_ndev->class_dev.dev)
+#else
+#define ND2D(_ndev)	(_ndev->dev.parent)
+#endif
+
+/*
+ * get_can_dlc(value) - helper macro to cast a given data length code (dlc)
+ * to __u8 and ensure the dlc value to be max. 8 bytes.
+ *
+ * To be used in the CAN netdriver receive path to ensure conformance with
+ * ISO 11898-1 Chapter 8.4.2.3 (DLC field)
+ */
+#define get_can_dlc(i)	(min_t(__u8, (i), 8))
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,25)
+#define IFF_ECHO IFF_LOOPBACK
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,23)
+struct net_device_stats *can_get_stats(struct net_device *dev);
+#endif
+
+/* Drop a given socketbuffer if it does not contain a valid CAN frame. */
+static inline int can_dropped_invalid_skb(struct net_device *dev,
+					  struct sk_buff *skb)
+{
+	const struct can_frame *cf = (struct can_frame *)skb->data;
+
+	if (unlikely(skb->len != sizeof(*cf) || cf->can_dlc > 8)) {
+		kfree_skb(skb);
+		dev->stats.tx_dropped++;
+		return 1;
+	}
+
+	return 0;
+}
+
+struct net_device *alloc_candev(int sizeof_priv, unsigned int echo_skb_max);
+void free_candev(struct net_device *dev);
+
+int open_candev(struct net_device *dev);
+void close_candev(struct net_device *dev);
+
+int register_candev(struct net_device *dev);
+void unregister_candev(struct net_device *dev);
+
+int can_restart_now(struct net_device *dev);
+void can_bus_off(struct net_device *dev);
+
+void can_put_echo_skb(struct sk_buff *skb, struct net_device *dev,
+		      unsigned int idx);
+void can_get_echo_skb(struct net_device *dev, unsigned int idx);
+void can_free_echo_skb(struct net_device *dev, unsigned int idx);
+
+struct sk_buff *alloc_can_skb(struct net_device *dev, struct can_frame **cf);
+struct sk_buff *alloc_can_err_skb(struct net_device *dev,
+				  struct can_frame **cf);
+
+#endif /* CAN_DEV_H */
diff --exclude CVS --exclude .git -uNr linux-2.6.27.8/include/socketcan/can/error.h linux-2.6.27.8.modified/include/socketcan/can/error.h
--- linux-2.6.27.8/include/socketcan/can/error.h	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.27.8.modified/include/socketcan/can/error.h	2013-05-30 03:44:13.000000000 -0400
@@ -0,0 +1,95 @@
+/*
+ * socketcan/can/error.h
+ *
+ * Definitions of the CAN error frame to be filtered and passed to the user.
+ *
+ * $Id: error.h 1239 2011-04-19 14:15:21Z hartkopp $
+ *
+ * Author: Oliver Hartkopp <oliver.hartkopp@volkswagen.de>
+ * Copyright (c) 2002-2007 Volkswagen Group Electronic Research
+ * All rights reserved.
+ *
+ * Send feedback to <socketcan-users@lists.berlios.de>
+ *
+ */
+
+#ifndef CAN_ERROR_H
+#define CAN_ERROR_H
+
+#define CAN_ERR_DLC 8 /* dlc for error frames */
+
+/* error class (mask) in can_id */
+#define CAN_ERR_TX_TIMEOUT   0x00000001U /* TX timeout (by netdevice driver) */
+#define CAN_ERR_LOSTARB      0x00000002U /* lost arbitration    / data[0]    */
+#define CAN_ERR_CRTL         0x00000004U /* controller problems / data[1]    */
+#define CAN_ERR_PROT         0x00000008U /* protocol violations / data[2..3] */
+#define CAN_ERR_TRX          0x00000010U /* transceiver status  / data[4]    */
+#define CAN_ERR_ACK          0x00000020U /* received no ACK on transmission */
+#define CAN_ERR_BUSOFF       0x00000040U /* bus off */
+#define CAN_ERR_BUSERROR     0x00000080U /* bus error (may flood!) */
+#define CAN_ERR_RESTARTED    0x00000100U /* controller restarted */
+
+/* arbitration lost in bit ... / data[0] */
+#define CAN_ERR_LOSTARB_UNSPEC   0x00 /* unspecified */
+				      /* else bit number in bitstream */
+
+/* error status of CAN-controller / data[1] */
+#define CAN_ERR_CRTL_UNSPEC      0x00 /* unspecified */
+#define CAN_ERR_CRTL_RX_OVERFLOW 0x01 /* RX buffer overflow */
+#define CAN_ERR_CRTL_TX_OVERFLOW 0x02 /* TX buffer overflow */
+#define CAN_ERR_CRTL_RX_WARNING  0x04 /* reached warning level for RX errors */
+#define CAN_ERR_CRTL_TX_WARNING  0x08 /* reached warning level for TX errors */
+#define CAN_ERR_CRTL_RX_PASSIVE  0x10 /* reached error passive status RX */
+#define CAN_ERR_CRTL_TX_PASSIVE  0x20 /* reached error passive status TX */
+				      /* (at least one error counter exceeds */
+				      /* the protocol-defined level of 127)  */
+
+/* error in CAN protocol (type) / data[2] */
+#define CAN_ERR_PROT_UNSPEC      0x00 /* unspecified */
+#define CAN_ERR_PROT_BIT         0x01 /* single bit error */
+#define CAN_ERR_PROT_FORM        0x02 /* frame format error */
+#define CAN_ERR_PROT_STUFF       0x04 /* bit stuffing error */
+#define CAN_ERR_PROT_BIT0        0x08 /* unable to send dominant bit */
+#define CAN_ERR_PROT_BIT1        0x10 /* unable to send recessive bit */
+#define CAN_ERR_PROT_OVERLOAD    0x20 /* bus overload */
+#define CAN_ERR_PROT_ACTIVE      0x40 /* active error announcement */
+#define CAN_ERR_PROT_TX          0x80 /* error occurred on transmission */
+
+/* error in CAN protocol (location) / data[3] */
+#define CAN_ERR_PROT_LOC_UNSPEC  0x00 /* unspecified */
+#define CAN_ERR_PROT_LOC_SOF     0x03 /* start of frame */
+#define CAN_ERR_PROT_LOC_ID28_21 0x02 /* ID bits 28 - 21 (SFF: 10 - 3) */
+#define CAN_ERR_PROT_LOC_ID20_18 0x06 /* ID bits 20 - 18 (SFF: 2 - 0 )*/
+#define CAN_ERR_PROT_LOC_SRTR    0x04 /* substitute RTR (SFF: RTR) */
+#define CAN_ERR_PROT_LOC_IDE     0x05 /* identifier extension */
+#define CAN_ERR_PROT_LOC_ID17_13 0x07 /* ID bits 17-13 */
+#define CAN_ERR_PROT_LOC_ID12_05 0x0F /* ID bits 12-5 */
+#define CAN_ERR_PROT_LOC_ID04_00 0x0E /* ID bits 4-0 */
+#define CAN_ERR_PROT_LOC_RTR     0x0C /* RTR */
+#define CAN_ERR_PROT_LOC_RES1    0x0D /* reserved bit 1 */
+#define CAN_ERR_PROT_LOC_RES0    0x09 /* reserved bit 0 */
+#define CAN_ERR_PROT_LOC_DLC     0x0B /* data length code */
+#define CAN_ERR_PROT_LOC_DATA    0x0A /* data section */
+#define CAN_ERR_PROT_LOC_CRC_SEQ 0x08 /* CRC sequence */
+#define CAN_ERR_PROT_LOC_CRC_DEL 0x18 /* CRC delimiter */
+#define CAN_ERR_PROT_LOC_ACK     0x19 /* ACK slot */
+#define CAN_ERR_PROT_LOC_ACK_DEL 0x1B /* ACK delimiter */
+#define CAN_ERR_PROT_LOC_EOF     0x1A /* end of frame */
+#define CAN_ERR_PROT_LOC_INTERM  0x12 /* intermission */
+
+/* error status of CAN-transceiver / data[4] */
+/*                                             CANH CANL */
+#define CAN_ERR_TRX_UNSPEC             0x00 /* 0000 0000 */
+#define CAN_ERR_TRX_CANH_NO_WIRE       0x04 /* 0000 0100 */
+#define CAN_ERR_TRX_CANH_SHORT_TO_BAT  0x05 /* 0000 0101 */
+#define CAN_ERR_TRX_CANH_SHORT_TO_VCC  0x06 /* 0000 0110 */
+#define CAN_ERR_TRX_CANH_SHORT_TO_GND  0x07 /* 0000 0111 */
+#define CAN_ERR_TRX_CANL_NO_WIRE       0x40 /* 0100 0000 */
+#define CAN_ERR_TRX_CANL_SHORT_TO_BAT  0x50 /* 0101 0000 */
+#define CAN_ERR_TRX_CANL_SHORT_TO_VCC  0x60 /* 0110 0000 */
+#define CAN_ERR_TRX_CANL_SHORT_TO_GND  0x70 /* 0111 0000 */
+#define CAN_ERR_TRX_CANL_SHORT_TO_CANH 0x80 /* 1000 0000 */
+
+/* controller specific additional information / data[5..7] */
+
+#endif /* CAN_ERROR_H */
diff --exclude CVS --exclude .git -uNr linux-2.6.27.8/include/socketcan/can/gw.h linux-2.6.27.8.modified/include/socketcan/can/gw.h
--- linux-2.6.27.8/include/socketcan/can/gw.h	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.27.8.modified/include/socketcan/can/gw.h	2013-05-30 03:44:13.000000000 -0400
@@ -0,0 +1,165 @@
+/*
+ * socketcan/can/gw.h
+ *
+ * Definitions for CAN frame Gateway/Router/Bridge 
+ *
+ * $Id: gw.h 1167 2010-04-16 08:46:17Z hartkopp $
+ *
+ * Author: Oliver Hartkopp <oliver.hartkopp@volkswagen.de>
+ * Copyright (c) 2002-2010 Volkswagen Group Electronic Research
+ * All rights reserved.
+ *
+ * Send feedback to <socketcan-users@lists.berlios.de>
+ *
+ */
+
+#ifndef CAN_GW_H
+#define CAN_GW_H
+
+#include <socketcan/can.h>
+
+struct rtcanmsg {
+	__u8  can_family;
+	__u8  gwtype;
+	__u16 flags;
+};
+
+/* CAN gateway types */
+enum {
+	CGW_TYPE_UNSPEC,
+	CGW_TYPE_CAN_CAN,	/* CAN->CAN routing */
+	__CGW_TYPE_MAX
+};
+
+#define CGW_TYPE_MAX (__CGW_TYPE_MAX - 1)
+
+/* CAN rtnetlink attribute definitions */
+enum {
+	CGW_UNSPEC,
+	CGW_MOD_AND,	/* CAN frame modification binary AND */
+	CGW_MOD_OR,	/* CAN frame modification binary OR */
+	CGW_MOD_XOR,	/* CAN frame modification binary XOR */
+	CGW_MOD_SET,	/* CAN frame modification set alternate values */
+	CGW_CS_XOR,	/* set data[] XOR checksum into data[index] */
+	CGW_CS_CRC8,	/* set data[] CRC8 checksum into data[index] */
+	CGW_HANDLED,	/* number of handled CAN frames */
+	CGW_DROPPED,	/* number of dropped CAN frames */
+	CGW_SRC_IF,	/* ifindex of source network interface */
+	CGW_DST_IF,	/* ifindex of destination network interface */
+	CGW_FILTER,	/* specify struct can_filter on source CAN device */
+	__CGW_MAX
+};
+
+#define CGW_MAX (__CGW_MAX - 1)
+
+#define CGW_FLAGS_CAN_ECHO 0x01
+#define CGW_FLAGS_CAN_SRC_TSTAMP 0x02
+
+#define CGW_MOD_FUNCS 4 /* AND OR XOR SET */
+
+/* CAN frame elements that are affected by curr. 3 CAN frame modifications */
+#define CGW_MOD_ID	0x01
+#define CGW_MOD_DLC	0x02
+#define CGW_MOD_DATA	0x04
+
+#define CGW_FRAME_MODS 3 /* ID DLC DATA */
+
+#define MAX_MODFUNCTIONS (CGW_MOD_FUNCS * CGW_FRAME_MODS)
+
+struct cgw_frame_mod {
+	struct can_frame cf;
+	__u8 modtype;
+} __attribute__((packed));
+
+#define CGW_MODATTR_LEN sizeof(struct cgw_frame_mod)
+
+struct cgw_csum_xor {
+	__s8 from_idx;
+	__s8 to_idx;
+	__s8 result_idx;
+	__u8 init_xor_val;
+} __attribute__ ((packed));
+
+struct cgw_csum_crc8 {
+	__s8 from_idx;
+	__s8 to_idx;
+	__s8 result_idx;
+	__u8 init_crc_val;
+	__u8 final_xor_val;
+	__u8 crctab[256];
+	__u8 profile;
+	__u8 profile_data[20];
+} __attribute__ ((packed));
+
+/* length of checksum operation parameters. idx = index in CAN frame data[] */
+#define CGW_CS_XOR_LEN  sizeof(struct cgw_csum_xor)
+#define CGW_CS_CRC8_LEN  sizeof(struct cgw_csum_crc8)
+
+/* CRC8 profiles (compute CRC for additional data elements - see below) */
+enum {
+	CGW_CRC8PRF_UNSPEC,
+	CGW_CRC8PRF_1U8,	/* compute one additional u8 value */
+	CGW_CRC8PRF_16U8,	/* u8 value table indexed by data[1] & 0xF */
+	CGW_CRC8PRF_SFFID_XOR,	/* (can_id & 0xFF) ^ (can_id >> 8 & 0xFF) */
+	__CGW_CRC8PRF_MAX
+};
+
+#define CGW_CRC8PRF_MAX (__CGW_CRC8PRF_MAX - 1)
+
+/*
+ * CAN rtnetlink attribute contents in detail
+ *
+ * CGW_XXX_IF (length 4 bytes):
+ * Sets an interface index for source/destination network interfaces.
+ * For the CAN->CAN gwtype the indices of _two_ CAN interfaces are mandatory.
+ *
+ * CGW_FILTER (length 8 bytes):
+ * Sets a CAN receive filter for the gateway job specified by the
+ * struct can_filter described in include/linux/can.h
+ *
+ * CGW_MOD_XXX (length 17 bytes):
+ * Specifies a modification that's done to a received CAN frame before it is
+ * send out to the destination interface.
+ *
+ * <struct can_frame> data used as operator
+ * <u8> affected CAN frame elements
+ *
+ * CGW_CS_XOR (length 4 bytes):
+ * Set a simple XOR checksum starting with an initial value into
+ * data[result-idx] using data[start-idx] .. data[end-idx]
+ *
+ * The XOR checksum is calculated like this:
+ *
+ * xor = init_xor_val
+ * 
+ * for (i = from_idx .. to_idx)
+ *      xor ^= can_frame.data[i]
+ *
+ * can_frame.data[ result_idx ] = xor
+ *
+ * CGW_CS_CRC8 (length 282 bytes):
+ * Set a CRC8 value into data[result-idx] using a given 256 byte CRC8 table,
+ * a given initial value and a defined input data[start-idx] .. data[end-idx].
+ * Finally the result value is XOR'ed with the final_xor_val.
+ *
+ * The CRC8 checksum is calculated like this:
+ *
+ * crc = init_crc_val
+ * 
+ * for (i = from_idx .. to_idx)
+ *      crc = crctab[ crc ^ can_frame.data[i] ]
+ *
+ * can_frame.data[ result_idx ] = crc ^ final_xor_val
+ *
+ * The calculated CRC may contain additional source data elements that can be
+ * defined in the handling of 'checksum profiles' e.g. shown in AUTOSAR specs
+ * like http://www.autosar.org/download/R4.0/AUTOSAR_SWS_E2ELibrary.pdf
+ * E.g. the profile_data[] may contain additional u8 values (called DATA_IDs)
+ * that are used depending on counter values inside the CAN frame data[].
+ * So far only three profiles have been implemented for illustration.
+ *
+ * Remark: In general the attribute data is a linear buffer.
+ *         Beware of sending unpacked or aligned structs!
+ */
+
+#endif
diff --exclude CVS --exclude .git -uNr linux-2.6.27.8/include/socketcan/can/ioctl.h linux-2.6.27.8.modified/include/socketcan/can/ioctl.h
--- linux-2.6.27.8/include/socketcan/can/ioctl.h	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.27.8.modified/include/socketcan/can/ioctl.h	2013-05-30 03:44:13.000000000 -0400
@@ -0,0 +1,99 @@
+
+/*
+ * socketcan/can/ioctl.h
+ *
+ * Definitions for CAN controller setup (work in progress)
+ *
+ * $Id: ioctl.h 1038 2009-08-21 10:00:21Z hartkopp $
+ *
+ * Send feedback to <socketcan-users@lists.berlios.de>
+ *
+ */
+
+#ifndef CAN_IOCTL_H
+#define CAN_IOCTL_H
+
+#include <linux/sockios.h>
+
+/*
+ * CAN bitrate
+ */
+#define CAN_BITRATE_UNCONFIGURED	((__u32) 0xFFFFFFFFU)
+#define CAN_BITRATE_UNKNOWN		0
+#define CAN_BITRATE_DEFAULT		500000
+
+/*
+ * CAN custom bit time
+ */
+enum can_bittimes {
+	CAN_BITTIME_STD,
+	CAN_BITTIME_BTR
+};
+
+/* TSEG1 of controllers usually is a sum of synch_seg (always 1),
+ * prop_seg and phase_seg1, TSEG2 = phase_seg2 */
+
+struct can_bittime_std {
+	__u32 brp;        /* baud rate prescaler */
+	__u8  prop_seg;   /* from 1 to 8 */
+	__u8  phase_seg1; /* from 1 to 8 */
+	__u8  phase_seg2; /* from 1 to 8 */
+	__u8  sjw:7;      /* from 1 to 4 */
+	__u8  sam:1;      /* 1 - enable triple sampling */
+};
+
+struct can_bittime_btr {
+	__u8  btr0;
+	__u8  btr1;
+};
+
+struct can_bittime {
+	enum can_bittimes type;
+	union {
+		struct can_bittime_std std;
+		struct can_bittime_btr btr;
+	};
+};
+
+/*
+ * CAN mode
+ */
+enum can_mode {
+	CAN_MODE_STOP = 0,
+	CAN_MODE_START,
+	CAN_MODE_SLEEP
+};
+
+/*
+ * CAN controller mode
+ */
+#define CAN_CTRLMODE_LOOPBACK   0x1
+#define CAN_CTRLMODE_LISTENONLY 0x2
+
+/*
+ * CAN operational and error states
+ */
+enum can_state {
+	CAN_STATE_ACTIVE = 0,
+	CAN_STATE_BUS_WARNING,
+	CAN_STATE_BUS_PASSIVE,
+	CAN_STATE_BUS_OFF,
+	CAN_STATE_STOPPED,
+	CAN_STATE_SLEEPING
+};
+
+/*
+ * CAN device statistics
+ */
+struct can_device_stats {
+	int error_warning;
+	int data_overrun;
+	int wakeup;
+	int bus_error;
+	int error_passive;
+	int arbitration_lost;
+	int restarts;
+	int bus_error_at_init;
+};
+
+#endif /* CAN_IOCTL_H */
diff --exclude CVS --exclude .git -uNr linux-2.6.27.8/include/socketcan/can/isotp.h linux-2.6.27.8.modified/include/socketcan/can/isotp.h
--- linux-2.6.27.8/include/socketcan/can/isotp.h	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.27.8.modified/include/socketcan/can/isotp.h	2013-05-30 03:44:13.000000000 -0400
@@ -0,0 +1,110 @@
+/*
+ * socketcan/can/isotp.h
+ *
+ * Definitions for isotp CAN sockets
+ *
+ * $Id: isotp.h 1201 2010-11-14 08:55:06Z hartkopp $
+ *
+ * Author: Oliver Hartkopp <oliver.hartkopp@volkswagen.de>
+ * Copyright (c) 2008 Volkswagen Group Electronic Research
+ * All rights reserved.
+ *
+ * Send feedback to <socketcan-users@lists.berlios.de>
+ *
+ */
+
+#ifndef CAN_ISOTP_H
+#define CAN_ISOTP_H
+
+#include <socketcan/can.h>
+
+#define SOL_CAN_ISOTP (SOL_CAN_BASE + CAN_ISOTP)
+
+/* for socket options affecting the socket (not the global system) */
+
+#define CAN_ISOTP_OPTS		1	/* pass struct can_isotp_options */
+
+#define CAN_ISOTP_RECV_FC	2	/* pass struct can_isotp_fc_options */
+
+/* sockopts to force stmin timer values for protocol regression tests */
+
+#define CAN_ISOTP_TX_STMIN	3	/* pass __u32 value in nano secs    */
+					/* use this time instead of value   */
+					/* provided in FC from the receiver */
+
+#define CAN_ISOTP_RX_STMIN	4	/* pass __u32 value in nano secs   */
+					/* ignore received CF frames which */
+					/* timestamps differ less than val */
+
+struct can_isotp_options {
+
+	__u32 flags;		/* set flags for isotp behaviour.	*/
+				/* __u32 value : flags see below	*/
+
+	__u32 frame_txtime;	/* frame transmission time (N_As/N_Ar)	*/
+				/* __u32 value : time in nano secs	*/
+
+	__u8  ext_address;	/* set address for extended addressing	*/
+				/* __u8 value : extended address	*/
+
+	__u8  txpad_content;	/* set content of padding byte (tx)	*/
+				/* __u8 value : content	on tx path	*/
+
+	__u8  rxpad_content;	/* set content of padding byte (rx)	*/
+				/* __u8 value : content	on rx path	*/
+};
+
+struct can_isotp_fc_options {
+
+	__u8  bs;		/* blocksize provided in FC frame	*/
+				/* __u8 value : blocksize. 0 = off	*/
+
+	__u8  stmin;		/* separation time provided in FC frame	*/
+				/* __u8 value :				*/
+				/* 0x00 - 0x7F : 0 - 127 ms		*/
+				/* 0x80 - 0xF0 : reserved		*/
+				/* 0xF1 - 0xF9 : 100 us - 900 us	*/
+				/* 0xFA - 0xFF : reserved		*/
+
+	__u8  wftmax;		/* max. number of wait frame transmiss.	*/
+				/* __u8 value : 0 = omit FC N_PDU WT	*/
+};
+
+
+/* flags for isotp behaviour */
+
+#define CAN_ISOTP_LISTEN_MODE	0x001	/* listen only (do not send FC) */
+#define CAN_ISOTP_EXTEND_ADDR	0x002	/* enable extended addressing */
+#define CAN_ISOTP_TX_PADDING	0x004	/* enable CAN frame padding tx path */
+#define CAN_ISOTP_RX_PADDING	0x008	/* enable CAN frame padding rx path */
+#define CAN_ISOTP_CHK_PAD_LEN	0x010	/* check received CAN frame padding */
+#define CAN_ISOTP_CHK_PAD_DATA	0x020	/* check received CAN frame padding */
+#define CAN_ISOTP_HALF_DUPLEX	0x040	/* half duplex error state handling */
+#define CAN_ISOTP_FORCE_TXSTMIN	0x080	/* ignore stmin from received FC */
+#define CAN_ISOTP_FORCE_RXSTMIN	0x100	/* ignore CFs depending on rx stmin */
+
+
+/* default values */
+
+#define CAN_ISOTP_DEFAULT_FLAGS		0
+#define CAN_ISOTP_DEFAULT_EXT_ADDRESS	0x00
+#define CAN_ISOTP_DEFAULT_RXPAD_CONTENT	0x00
+#define CAN_ISOTP_DEFAULT_TXPAD_CONTENT	0x00
+#define CAN_ISOTP_DEFAULT_FRAME_TXTIME	0
+#define CAN_ISOTP_DEFAULT_RECV_BS	0
+#define CAN_ISOTP_DEFAULT_RECV_STMIN	0x00
+#define CAN_ISOTP_DEFAULT_RECV_WFTMAX	0
+
+/*
+ * Remark on CAN_ISOTP_DEFAULT_RECV_* values:
+ *
+ * We can strongly assume, that the Linux Kernel implementation of
+ * CAN_ISOTP is capable to run with BS=0, STmin=0 and WFTmax=0.
+ * But as we like to be able to behave as a commonly available ECU,
+ * these default settings can be changed via sockopts.
+ * For that reason the STmin value is intentionally _not_ checked for
+ * consistency and copied directly into the flow control (FC) frame.
+ *
+ */
+
+#endif
diff --exclude CVS --exclude .git -uNr linux-2.6.27.8/include/socketcan/can/j1939.h linux-2.6.27.8.modified/include/socketcan/can/j1939.h
--- linux-2.6.27.8/include/socketcan/can/j1939.h	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.27.8.modified/include/socketcan/can/j1939.h	2013-05-30 03:44:13.000000000 -0400
@@ -0,0 +1,99 @@
+/*
+ * j1939.h
+ *
+ * Copyright (c) 2010-2011 EIA Electronics
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef _J1939_H_
+#define _J1939_H_
+
+#include <linux/types.h>
+#include <linux/socket.h>
+#include <socketcan/can.h>
+
+#define J1939_IDLE_ADDR	0xfe
+#define J1939_NO_ADDR	0xff
+#define J1939_NO_NAME	0
+#define J1939_NO_PGN	0x40000
+/*
+ * J1939 Parameter Group Number
+ *
+ * bit 0-7	: PDU Specific (PS)
+ * bit 8-15	: PDU Format (PF)
+ * bit 16	: Data Page (DP)
+ * bit 17	: Reserved (R)
+ * bit 19-31	: set to zero
+ */
+typedef __u32 pgn_t;
+
+/*
+ * J1939 Priority
+ *
+ * bit 0-2	: Priority (P)
+ * bit 3-7	: set to zero
+ */
+typedef __u8 priority_t;
+
+/*
+ * J1939 NAME
+ *
+ * bit 0-20	: Identity Number
+ * bit 21-31	: Manufacturer Code
+ * bit 32-34	: ECU Instance
+ * bit 35-39	: Function Instance
+ * bit 40-47	: Function
+ * bit 48	: Reserved
+ * bit 49-55	: Vehicle System
+ * bit 56-59	: Vehicle System Instance
+ * bit 60-62	: Industry Group
+ * bit 63	: Arbitrary Address Capable
+ */
+typedef __u64 name_t;
+
+/*
+ * J1939 socket options
+ */
+#define SOL_CAN_J1939 (SOL_CAN_BASE + CAN_J1939)
+enum {
+	SO_J1939_FILTER = 1,	/* set filters */
+	SO_J1939_PROMISC = 2,	/* set/clr promiscuous mode */
+	SO_J1939_RECV_OWN = 3,
+	SO_J1939_SEND_PRIO = 4,
+};
+
+enum {
+	SCM_J1939_DEST_ADDR = 1,
+	SCM_J1939_DEST_NAME = 2,
+	SCM_J1939_PRIO = 3,
+};
+
+struct j1939_filter {
+	name_t name;
+	name_t name_mask;
+	__u8 addr;
+	__u8 addr_mask;
+	pgn_t pgn;
+	pgn_t pgn_mask;
+};
+
+/*
+ * RTNETLINK
+ */
+enum {
+	IFLA_J1939_UNSPEC,
+	IFLA_J1939_ENABLE,
+	IFLA_J1939_MAX,
+};
+
+enum {
+	IFA_J1939_UNSPEC,
+	IFA_J1939_ADDR,
+	IFA_J1939_NAME,
+	IFA_J1939_MAX,
+};
+
+#endif /* _J1939_H_ */
diff --exclude CVS --exclude .git -uNr linux-2.6.27.8/include/socketcan/can/netlink.h linux-2.6.27.8.modified/include/socketcan/can/netlink.h
--- linux-2.6.27.8/include/socketcan/can/netlink.h	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.27.8.modified/include/socketcan/can/netlink.h	2013-05-30 03:44:13.000000000 -0400
@@ -0,0 +1,126 @@
+/*
+ * socketcan/can/netlink.h
+ *
+ * Definitions for the CAN netlink interface
+ *
+ * $Id: dev.h 939 2009-02-14 14:30:19Z wolf $
+ *
+ * Copyright (c) 2009 Wolfgang Grandegger <wg@grandegger.com>
+ *
+ * Send feedback to <socketcan-users@lists.berlios.de>
+ *
+ */
+
+#ifndef CAN_NETLINK_H
+#define CAN_NETLINK_H
+
+#include <linux/types.h>
+
+/*
+ * CAN bit-timing parameters
+ *
+ * For further information, please read chapter "8 BIT TIMING
+ * REQUIREMENTS" of the "Bosch CAN Specification version 2.0"
+ * at http://www.semiconductors.bosch.de/pdf/can2spec.pdf.
+ */
+struct can_bittiming {
+	__u32 bitrate;		/* Bit-rate in bits/second */
+	__u32 sample_point;	/* Sample point in one-tenth of a percent */
+	__u32 tq;		/* Time quanta (TQ) in nanoseconds */
+	__u32 prop_seg;		/* Propagation segment in TQs */
+	__u32 phase_seg1;	/* Phase buffer segment 1 in TQs */
+	__u32 phase_seg2;	/* Phase buffer segment 2 in TQs */
+	__u32 sjw;		/* Synchronisation jump width in TQs */
+	__u32 brp;		/* Bit-rate prescaler */
+};
+
+/*
+ * CAN harware-dependent bit-timing constant
+ *
+ * Used for calculating and checking bit-timing parameters
+ */
+struct can_bittiming_const {
+	char name[16];		/* Name of the CAN controller hardware */
+	__u32 tseg1_min;	/* Time segement 1 = prop_seg + phase_seg1 */
+	__u32 tseg1_max;
+	__u32 tseg2_min;	/* Time segement 2 = phase_seg2 */
+	__u32 tseg2_max;
+	__u32 sjw_max;		/* Synchronisation jump width */
+	__u32 brp_min;		/* Bit-rate prescaler */
+	__u32 brp_max;
+	__u32 brp_inc;
+};
+
+/*
+ * CAN clock parameters
+ */
+struct can_clock {
+	__u32 freq;		/* CAN system clock frequency in Hz */
+};
+
+/*
+ * CAN operational and error states
+ */
+enum can_state {
+	CAN_STATE_ERROR_ACTIVE = 0,	/* RX/TX error count < 96 */
+	CAN_STATE_ERROR_WARNING,	/* RX/TX error count < 128 */
+	CAN_STATE_ERROR_PASSIVE,	/* RX/TX error count < 256 */
+	CAN_STATE_BUS_OFF,		/* RX/TX error count >= 256 */
+	CAN_STATE_STOPPED,		/* Device is stopped */
+	CAN_STATE_SLEEPING,		/* Device is sleeping */
+	CAN_STATE_MAX
+};
+
+/*
+ * CAN bus error counters
+ */
+struct can_berr_counter {
+	__u16 txerr;
+	__u16 rxerr;
+};
+
+/*
+ * CAN controller mode
+ */
+struct can_ctrlmode {
+	__u32 mask;
+	__u32 flags;
+};
+
+#define CAN_CTRLMODE_LOOPBACK		0x01	/* Loopback mode */
+#define CAN_CTRLMODE_LISTENONLY		0x02 	/* Listen-only mode */
+#define CAN_CTRLMODE_3_SAMPLES		0x04	/* Triple sampling mode */
+#define CAN_CTRLMODE_ONE_SHOT		0x08	/* One-Shot mode */
+#define CAN_CTRLMODE_BERR_REPORTING	0x10	/* Bus-error reporting */
+
+/*
+ * CAN device statistics
+ */
+struct can_device_stats {
+	__u32 bus_error;	/* Bus errors */
+	__u32 error_warning;	/* Changes to error warning state */
+	__u32 error_passive;	/* Changes to error passive state */
+	__u32 bus_off;		/* Changes to bus off state */
+	__u32 arbitration_lost; /* Arbitration lost errors */
+	__u32 restarts;		/* CAN controller re-starts */
+};
+
+/*
+ * CAN netlink interface
+ */
+enum {
+	IFLA_CAN_UNSPEC,
+	IFLA_CAN_BITTIMING,
+	IFLA_CAN_BITTIMING_CONST,
+	IFLA_CAN_CLOCK,
+	IFLA_CAN_STATE,
+	IFLA_CAN_CTRLMODE,
+	IFLA_CAN_RESTART_MS,
+	IFLA_CAN_RESTART,
+	IFLA_CAN_BERR_COUNTER,
+	__IFLA_CAN_MAX
+};
+
+#define IFLA_CAN_MAX	(__IFLA_CAN_MAX - 1)
+
+#endif /* CAN_NETLINK_H */
diff --exclude CVS --exclude .git -uNr linux-2.6.27.8/include/socketcan/can/platform/mcp251x.h linux-2.6.27.8.modified/include/socketcan/can/platform/mcp251x.h
--- linux-2.6.27.8/include/socketcan/can/platform/mcp251x.h	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.27.8.modified/include/socketcan/can/platform/mcp251x.h	2013-05-30 03:44:13.000000000 -0400
@@ -0,0 +1,36 @@
+#ifndef __CAN_PLATFORM_MCP251X_H__
+#define __CAN_PLATFORM_MCP251X_H__
+
+/*
+ *
+ * CAN bus driver for Microchip 251x CAN Controller with SPI Interface
+ *
+ */
+
+#include <linux/spi/spi.h>
+
+/**
+ * struct mcp251x_platform_data - MCP251X SPI CAN controller platform data
+ * @oscillator_frequency:       - oscillator frequency in Hz
+ * @model:                      - actual type of chip
+ * @board_specific_setup:       - called before probing the chip (power,reset)
+ * @transceiver_enable:         - called to power on/off the transceiver
+ * @power_enable:               - called to power on/off the mcp *and* the
+ *                                transceiver
+ *
+ * Please note that you should define power_enable or transceiver_enable or
+ * none of them. Defining both of them is no use.
+ *
+ */
+
+struct mcp251x_platform_data {
+	unsigned long oscillator_frequency;
+	int model;
+#define CAN_MCP251X_MCP2510 0
+#define CAN_MCP251X_MCP2515 1
+	int (*board_specific_setup)(struct spi_device *spi);
+	int (*transceiver_enable)(int enable);
+	int (*power_enable) (int enable);
+};
+
+#endif /* __CAN_PLATFORM_MCP251X_H__ */
diff --exclude CVS --exclude .git -uNr linux-2.6.27.8/include/socketcan/can/platform/sja1000.h linux-2.6.27.8.modified/include/socketcan/can/platform/sja1000.h
--- linux-2.6.27.8/include/socketcan/can/platform/sja1000.h	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.27.8.modified/include/socketcan/can/platform/sja1000.h	2013-05-30 03:44:13.000000000 -0400
@@ -0,0 +1,35 @@
+#ifndef _CAN_PLATFORM_SJA1000_H_
+#define _CAN_PLATFORM_SJA1000_H_
+
+/* clock divider register */
+#define CDR_CLKOUT_MASK 0x07
+#define CDR_CLK_OFF	0x08 /* Clock off (CLKOUT pin) */
+#define CDR_RXINPEN	0x20 /* TX1 output is RX irq output */
+#define CDR_CBP		0x40 /* CAN input comparator bypass */
+#define CDR_PELICAN	0x80 /* PeliCAN mode */
+
+/* output control register */
+#define OCR_MODE_BIPHASE  0x00
+#define OCR_MODE_TEST     0x01
+#define OCR_MODE_NORMAL   0x02
+#define OCR_MODE_CLOCK    0x03
+#define OCR_MODE_MASK     0x07
+#define OCR_TX0_INVERT    0x04
+#define OCR_TX0_PULLDOWN  0x08
+#define OCR_TX0_PULLUP    0x10
+#define OCR_TX0_PUSHPULL  0x18
+#define OCR_TX1_INVERT    0x20
+#define OCR_TX1_PULLDOWN  0x40
+#define OCR_TX1_PULLUP    0x80
+#define OCR_TX1_PUSHPULL  0xc0
+#define OCR_TX_MASK       0xfc
+#define OCR_TX_SHIFT      2
+
+struct sja1000_platform_data {
+	u32 clock;	/* CAN bus oscillator frequency in Hz */
+
+	u8 ocr;		/* output control register */
+	u8 cdr;		/* clock divider register */
+};
+
+#endif	/* !_CAN_PLATFORM_SJA1000_H_ */
diff --exclude CVS --exclude .git -uNr linux-2.6.27.8/include/socketcan/can/raw.h linux-2.6.27.8.modified/include/socketcan/can/raw.h
--- linux-2.6.27.8/include/socketcan/can/raw.h	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.27.8.modified/include/socketcan/can/raw.h	2013-05-30 03:44:13.000000000 -0400
@@ -0,0 +1,33 @@
+/*
+ * socketcan/can/raw.h
+ *
+ * Definitions for raw CAN sockets
+ *
+ * $Id: raw.h 1038 2009-08-21 10:00:21Z hartkopp $
+ *
+ * Authors: Oliver Hartkopp <oliver.hartkopp@volkswagen.de>
+ *          Urs Thuermann   <urs.thuermann@volkswagen.de>
+ * Copyright (c) 2002-2007 Volkswagen Group Electronic Research
+ * All rights reserved.
+ *
+ * Send feedback to <socketcan-users@lists.berlios.de>
+ *
+ */
+
+#ifndef CAN_RAW_H
+#define CAN_RAW_H
+
+#include <socketcan/can.h>
+
+#define SOL_CAN_RAW (SOL_CAN_BASE + CAN_RAW)
+
+/* for socket options affecting the socket (not the global system) */
+
+enum {
+	CAN_RAW_FILTER = 1,	/* set 0 .. n can_filter(s)          */
+	CAN_RAW_ERR_FILTER,	/* set filter for error frames       */
+	CAN_RAW_LOOPBACK,	/* local loopback (default:on)       */
+	CAN_RAW_RECV_OWN_MSGS	/* receive my own msgs (default:off) */
+};
+
+#endif
diff --exclude CVS --exclude .git -uNr linux-2.6.27.8/include/socketcan/can/version.h linux-2.6.27.8.modified/include/socketcan/can/version.h
--- linux-2.6.27.8/include/socketcan/can/version.h	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.27.8.modified/include/socketcan/can/version.h	2013-05-30 03:44:13.000000000 -0400
@@ -0,0 +1,22 @@
+/*
+ * socketcan/can/version.h
+ *
+ * Version information for the CAN network layer implementation
+
+ * Author: Urs Thuermann   <urs.thuermann@volkswagen.de>
+ * Copyright (c) 2002-2007 Volkswagen Group Electronic Research
+ * All rights reserved.
+ *
+ * Send feedback to <socketcan-users@lists.berlios.de>
+ *
+ */
+
+#ifndef CAN_VERSION_H
+#define CAN_VERSION_H
+
+#define RCSID(s) asm(".section .rodata.str1.1,\"aMS\",@progbits,1\n\t" \
+		     ".string \"" s "\"\n\t.previous\n")
+
+RCSID("$Id: version.h 1038 2009-08-21 10:00:21Z hartkopp $");
+
+#endif /* CAN_VERSION_H */
diff --exclude CVS --exclude .git -uNr linux-2.6.27.8/include/socketcan/can.h linux-2.6.27.8.modified/include/socketcan/can.h
--- linux-2.6.27.8/include/socketcan/can.h	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.27.8.modified/include/socketcan/can.h	2013-05-30 03:44:13.000000000 -0400
@@ -0,0 +1,132 @@
+/*
+ * socketcan/can.h
+ *
+ * Definitions for CAN network layer (socket addr / CAN frame / CAN filter)
+ *
+ * $Id: can.h 1244 2011-05-01 15:00:10Z hartkopp $
+ *
+ * Authors: Oliver Hartkopp <oliver.hartkopp@volkswagen.de>
+ *          Urs Thuermann   <urs.thuermann@volkswagen.de>
+ * Copyright (c) 2002-2007 Volkswagen Group Electronic Research
+ * All rights reserved.
+ *
+ * Send feedback to <socketcan-users@lists.berlios.de>
+ *
+ */
+
+#ifndef CAN_H
+#define CAN_H
+
+#include <linux/version.h>
+#include <linux/types.h>
+#include <linux/socket.h>
+
+/* controller area network (CAN) kernel definitions */
+
+/* special address description flags for the CAN_ID */
+#define CAN_EFF_FLAG 0x80000000U /* EFF/SFF is set in the MSB */
+#define CAN_RTR_FLAG 0x40000000U /* remote transmission request */
+#define CAN_ERR_FLAG 0x20000000U /* error frame */
+
+/* valid bits in CAN ID for frame formats */
+#define CAN_SFF_MASK 0x000007FFU /* standard frame format (SFF) */
+#define CAN_EFF_MASK 0x1FFFFFFFU /* extended frame format (EFF) */
+#define CAN_ERR_MASK 0x1FFFFFFFU /* omit EFF, RTR, ERR flags */
+
+/*
+ * Controller Area Network Identifier structure
+ *
+ * bit 0-28	: CAN identifier (11/29 bit)
+ * bit 29	: error frame flag (0 = data frame, 1 = error frame)
+ * bit 30	: remote transmission request flag (1 = rtr frame)
+ * bit 31	: frame format flag (0 = standard 11 bit, 1 = extended 29 bit)
+ */
+typedef __u32 canid_t;
+
+/*
+ * Controller Area Network Error Frame Mask structure
+ *
+ * bit 0-28	: error class mask (see include/socketcan/can/error.h)
+ * bit 29-31	: set to zero
+ */
+typedef __u32 can_err_mask_t;
+
+/**
+ * struct can_frame - basic CAN frame structure
+ * @can_id:  the CAN ID of the frame and CAN_*_FLAG flags, see above.
+ * @can_dlc: the data length field of the CAN frame
+ * @data:    the CAN frame payload.
+ */
+struct can_frame {
+	canid_t can_id;  /* 32 bit CAN_ID + EFF/RTR/ERR flags */
+	__u8    can_dlc; /* data length code: 0 .. 8 */
+	__u8    data[8] __attribute__((aligned(8)));
+};
+
+/* particular protocols of the protocol family PF_CAN */
+#define CAN_RAW		1 /* RAW sockets */
+#define CAN_BCM		2 /* Broadcast Manager */
+#define CAN_TP16	3 /* VAG Transport Protocol v1.6 */
+#define CAN_TP20	4 /* VAG Transport Protocol v2.0 */
+#define CAN_MCNET	5 /* Bosch MCNet */
+#define CAN_ISOTP	6 /* ISO 15765-2 Transport Protocol */
+#define CAN_J1939	7 /* SAE J1939 */
+#define CAN_NPROTO	8
+
+#define SOL_CAN_BASE 100
+
+/**
+ * struct sockaddr_can - the sockaddr structure for CAN sockets
+ * @can_family:  address family number AF_CAN.
+ * @can_ifindex: CAN network interface index.
+ * @can_addr:    protocol specific address information
+ */
+struct sockaddr_can {
+	sa_family_t can_family;
+	int         can_ifindex;
+	union {
+		/* transport protocol class address information (e.g. ISOTP) */
+		struct { canid_t rx_id, tx_id; } tp;
+
+		/* J1939 address information */
+		struct {
+			/* 8 byte name when using dynamic addressing */
+			__u64 name;
+			/*
+			 * pgn:
+			 * 8bit: PS in PDU2 case, else 0
+			 * 8bit: PF
+			 * 1bit: DP
+			 * 1bit: reserved
+			 */
+			__u32 pgn;
+
+			/* 1byte address */
+			__u8 addr;
+		} j1939;
+
+		/* reserved for future CAN protocols address information */
+	} can_addr;
+};
+
+/**
+ * struct can_filter - CAN ID based filter in can_register().
+ * @can_id:   relevant bits of CAN ID which are not masked out.
+ * @can_mask: CAN mask (see description)
+ *
+ * Description:
+ * A filter matches, when
+ *
+ *          <received_can_id> & mask == can_id & mask
+ *
+ * The filter can be inverted (CAN_INV_FILTER bit set in can_id) or it can
+ * filter for error frames (CAN_ERR_FLAG bit set in mask).
+ */
+struct can_filter {
+	canid_t can_id;
+	canid_t can_mask;
+};
+
+#define CAN_INV_FILTER 0x20000000U /* to be set in can_filter.can_id */
+
+#endif /* CAN_H */
diff --exclude CVS --exclude .git -uNr linux-2.6.27.8/net/can/Kconfig linux-2.6.27.8.modified/net/can/Kconfig
--- linux-2.6.27.8/net/can/Kconfig	2008-12-05 15:03:02.000000000 -0500
+++ linux-2.6.27.8.modified/net/can/Kconfig	2013-05-30 03:44:16.000000000 -0400
@@ -40,5 +40,35 @@
 	  CAN messages are used on the bus (e.g. in automotive environments).
 	  To use the Broadcast Manager, use AF_CAN with protocol CAN_BCM.
 
+config CAN_GW
+	tristate "CAN Gateway/Router (with netlink configuration)"
+	depends on CAN
+	default N
+	---help---
+	  The CAN Gateway/Router is used to route (and modify) CAN frames.
+	  It is based on the PF_CAN core infrastructure for msg filtering and
+	  msg sending and can optionally modify routed CAN frames on the fly.
+	  CAN frames can be routed between CAN network interfaces (one hop).
+	  They can be modified with AND/OR/XOR/SET operations as configured
+	  by the netlink configuration interface known e.g. from iptables.
+
+config CAN_ISOTP
+	tristate "ISO 15765-2 CAN transport protocol"
+	depends on CAN && EXPERIMENTAL
+	default N
+	---help---
+	  CAN Transport Protocols offer support for segmented Point-to-Point
+	  communication between CAN nodes via two defined CAN Identifiers.
+	  This protocol driver implements data transfers according ISO 15765-2.
+	  WARNING: This is ALPHA code for discussions and first tests that
+	  should not be used in production environments.
+	  In the discussion the Socket-API to the userspace or the ISO-TP
+	  socket options or the return values may change! Current behaviour:
+	  - no ISO-TP specific return values are provided to the userspace
+	  - no support for sending wait frames to the data source in rx path
+	  - when a transfer (tx) is on the run the next write() blocks
+	    until the running transfer is done
+
+source "net/can/j1939/Kconfig"
 
 source "drivers/net/can/Kconfig"
diff --exclude CVS --exclude .git -uNr linux-2.6.27.8/net/can/Makefile linux-2.6.27.8.modified/net/can/Makefile
--- linux-2.6.27.8/net/can/Makefile	2008-12-05 15:03:02.000000000 -0500
+++ linux-2.6.27.8.modified/net/can/Makefile	2013-05-30 03:44:16.000000000 -0400
@@ -1,7 +1,27 @@
 #
-#  Makefile for the Linux Controller Area Network core.
+#  $Id: Makefile 1247 2011-05-01 16:09:08Z hartkopp $
 #
 
+ifeq ($(KERNELRELEASE),)
+
+KERNELDIR := /lib/modules/$(shell uname -r)/build
+PWD       := $(shell pwd)
+TOPDIR    := $(PWD)/../..
+
+modules modules_install clean:
+	$(MAKE) -C $(KERNELDIR) M=$(PWD) $@ TOPDIR=$(TOPDIR)
+
+export CONFIG_CAN=m
+export CONFIG_CAN_RAW=m
+export CONFIG_CAN_BCM=m
+export CONFIG_CAN_ISOTP=m
+export CONFIG_CAN_GW=m
+export CONFIG_CAN_J1939=m
+
+else
+
+-include $(TOPDIR)/Makefile.common
+
 obj-$(CONFIG_CAN)	+= can.o
 can-objs		:= af_can.o proc.o
 
@@ -10,3 +30,13 @@
 
 obj-$(CONFIG_CAN_BCM)	+= can-bcm.o
 can-bcm-objs		:= bcm.o
+
+obj-$(CONFIG_CAN_ISOTP)	+= can-isotp.o
+can-isotp-objs		:= isotp.o
+
+obj-$(CONFIG_CAN_GW)	+= can-gw.o
+can-gw-objs		:= gw.o
+
+obj-$(CONFIG_CAN_J1939)	+= j1939/
+
+endif
diff --exclude CVS --exclude .git -uNr linux-2.6.27.8/net/can/Makefile.kernel linux-2.6.27.8.modified/net/can/Makefile.kernel
--- linux-2.6.27.8/net/can/Makefile.kernel	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.27.8.modified/net/can/Makefile.kernel	2013-05-30 03:44:16.000000000 -0400
@@ -0,0 +1,12 @@
+#
+#  Makefile for the Linux Controller Area Network core.
+#
+
+obj-$(CONFIG_CAN)	+= can.o
+can-objs		:= af_can.o proc.o
+
+obj-$(CONFIG_CAN_RAW)	+= can-raw.o
+can-raw-objs		:= raw.o
+
+obj-$(CONFIG_CAN_BCM)	+= can-bcm.o
+can-bcm-objs		:= bcm.o
diff --exclude CVS --exclude .git -uNr linux-2.6.27.8/net/can/af_can.c linux-2.6.27.8.modified/net/can/af_can.c
--- linux-2.6.27.8/net/can/af_can.c	2008-12-05 15:03:02.000000000 -0500
+++ linux-2.6.27.8.modified/net/can/af_can.c	2013-05-30 03:44:16.000000000 -0400
@@ -43,25 +43,38 @@
  */
 
 #include <linux/module.h>
+#include <linux/version.h>
 #include <linux/init.h>
 #include <linux/kmod.h>
 #include <linux/slab.h>
 #include <linux/list.h>
 #include <linux/spinlock.h>
 #include <linux/rcupdate.h>
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,18)
 #include <linux/uaccess.h>
+#else
+#include <asm/uaccess.h>
+#endif
 #include <linux/net.h>
 #include <linux/netdevice.h>
 #include <linux/socket.h>
 #include <linux/if_ether.h>
 #include <linux/if_arp.h>
 #include <linux/skbuff.h>
-#include <linux/can.h>
-#include <linux/can/core.h>
+#include <socketcan/can.h>
+#include <socketcan/can/core.h>
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,24)
 #include <net/net_namespace.h>
+#endif
 #include <net/sock.h>
 
 #include "af_can.h"
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,25)
+#include "compat.h"
+#endif
+
+#include <socketcan/can/version.h> /* for RCSID. Removed by mkpatch script */
+RCSID("$Id: af_can.c 1253 2011-05-05 14:55:40Z hartkopp $");
 
 static __initdata const char banner[] = KERN_INFO
 	"can: controller area network core (" CAN_VERSION_STRING ")\n";
@@ -81,11 +94,15 @@
 static struct dev_rcv_lists can_rx_alldev_list;
 static DEFINE_SPINLOCK(can_rcvlists_lock);
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,20)
 static struct kmem_cache *rcv_cache __read_mostly;
+#else
+static kmem_cache_t *rcv_cache;
+#endif
 
 /* table of registered CAN protocols */
-static struct can_proto *proto_tab[CAN_NPROTO] __read_mostly;
-static DEFINE_SPINLOCK(proto_tab_lock);
+static const struct can_proto *proto_tab[CAN_NPROTO] __read_mostly;
+static DEFINE_MUTEX(proto_tab_lock);
 
 struct timer_list can_stattimer;   /* timer for statistics update */
 struct s_stats    can_stats;       /* packet statistics */
@@ -95,7 +112,7 @@
  * af_can socket functions
  */
 
-static int can_ioctl(struct socket *sock, unsigned int cmd, unsigned long arg)
+int can_ioctl(struct socket *sock, unsigned int cmd, unsigned long arg)
 {
 	struct sock *sk = sock->sk;
 
@@ -105,19 +122,61 @@
 		return sock_get_timestamp(sk, (struct timeval __user *)arg);
 
 	default:
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,16)
 		return -ENOIOCTLCMD;
+#else
+		return dev_ioctl(cmd, (void __user *)arg);
+#endif
 	}
 }
+EXPORT_SYMBOL(can_ioctl);
 
 static void can_sock_destruct(struct sock *sk)
 {
 	skb_queue_purge(&sk->sk_receive_queue);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,12)
+	if (sk->sk_protinfo)
+		kfree(sk->sk_protinfo);
+#endif
+}
+
+static const struct can_proto *can_get_proto(int protocol)
+{
+	const struct can_proto *cp;
+
+	rcu_read_lock();
+	cp = rcu_dereference(proto_tab[protocol]);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,12)
+	if (cp && !try_module_get(cp->prot->owner))
+		cp = NULL;
+#else
+	if (cp && !try_module_get(cp->owner))
+		cp = NULL;
+#endif
+	rcu_read_unlock();
+
+	return cp;
+}
+
+static inline void can_put_proto(const struct can_proto *cp)
+{
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,12)
+	module_put(cp->prot->owner);
+#else
+	module_put(cp->owner);
+#endif
 }
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,33)
+static int can_create(struct net *net, struct socket *sock, int protocol, int kern)
+#elif LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,24)
 static int can_create(struct net *net, struct socket *sock, int protocol)
+#else
+static int can_create(struct socket *sock, int protocol)
+#endif
 {
 	struct sock *sk;
-	struct can_proto *cp;
+	const struct can_proto *cp;
 	int err = 0;
 
 	sock->state = SS_UNCONNECTED;
@@ -125,12 +184,17 @@
 	if (protocol < 0 || protocol >= CAN_NPROTO)
 		return -EINVAL;
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,24)
 	if (net != &init_net)
 		return -EAFNOSUPPORT;
+#endif
+
+	cp = can_get_proto(protocol);
+
+#ifdef CONFIG_MODULES
+	if (!cp) {
+		/* try to load protocol module if kernel is modular */
 
-#ifdef CONFIG_KMOD
-	/* try to load protocol module, when CONFIG_KMOD is defined */
-	if (!proto_tab[protocol]) {
 		err = request_module("can-proto-%d", protocol);
 
 		/*
@@ -141,43 +205,63 @@
 		if (err && printk_ratelimit())
 			printk(KERN_ERR "can: request_module "
 			       "(can-proto-%d) failed.\n", protocol);
+
+		cp = can_get_proto(protocol);
 	}
 #endif
 
-	spin_lock(&proto_tab_lock);
-	cp = proto_tab[protocol];
-	if (cp && !try_module_get(cp->prot->owner))
-		cp = NULL;
-	spin_unlock(&proto_tab_lock);
-
 	/* check for available protocol and correct usage */
 
 	if (!cp)
 		return -EPROTONOSUPPORT;
 
 	if (cp->type != sock->type) {
-		err = -EPROTONOSUPPORT;
+		err = -EPROTOTYPE;
 		goto errout;
 	}
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,33)
 	if (cp->capability >= 0 && !capable(cp->capability)) {
 		err = -EPERM;
 		goto errout;
 	}
-
+#endif
 	sock->ops = cp->ops;
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,24)
 	sk = sk_alloc(net, PF_CAN, GFP_KERNEL, cp->prot);
+#elif LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,12)
+	sk = sk_alloc(PF_CAN, GFP_KERNEL, cp->prot, 1);
+#else
+	sk = sk_alloc(PF_CAN, GFP_KERNEL, 1, 0);
+#endif
 	if (!sk) {
 		err = -ENOMEM;
 		goto errout;
 	}
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,12)
+	if (cp->obj_size) {
+		sk->sk_protinfo = kmalloc(cp->obj_size, GFP_KERNEL);
+		if (!sk->sk_protinfo) {
+			sk_free(sk);
+			err = -ENOMEM;
+			goto errout;
+		}
+	}
+	sk_set_owner(sk, proto_tab[protocol]->owner);
+#endif
+
 	sock_init_data(sock, sk);
 	sk->sk_destruct = can_sock_destruct;
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,12)
 	if (sk->sk_prot->init)
 		err = sk->sk_prot->init(sk);
+#else
+	if (cp->init)
+		err = cp->init(sk);
+#endif
 
 	if (err) {
 		/* release sk on errors */
@@ -186,7 +270,7 @@
 	}
 
  errout:
-	module_put(cp->prot->owner);
+	can_put_proto(cp);
 	return err;
 }
 
@@ -199,6 +283,8 @@
  * @skb: pointer to socket buffer with CAN frame in data section
  * @loop: loopback for listeners on local CAN sockets (recommended default!)
  *
+ * Due to the loopback this routine must not be called from hardirq context.
+ *
  * Return:
  *  0 on success
  *  -ENETDOWN when the selected interface is down
@@ -229,8 +315,13 @@
 	}
 
 	skb->protocol = htons(ETH_P_CAN);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,22)
 	skb_reset_network_header(skb);
 	skb_reset_transport_header(skb);
+#else
+	skb->nh.raw = skb->data;
+	skb->h.raw  = skb->data;
+#endif
 
 	if (loop) {
 		/* local loopback of sent CAN frames */
@@ -247,6 +338,9 @@
 		 * after each skb_clone() or skb_orphan() usage.
 		 */
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,25)
+#define IFF_ECHO IFF_LOOPBACK
+#endif
 		if (!(skb->dev->flags & IFF_ECHO)) {
 			/*
 			 * If the interface is not capable to do loopback
@@ -273,13 +367,18 @@
 		err = net_xmit_errno(err);
 
 	if (err) {
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,17)
+		/* kfree_skb() does not check for !NULL on older kernels */
 		if (newskb)
 			kfree_skb(newskb);
+#else
+		kfree_skb(newskb);
+#endif
 		return err;
 	}
 
 	if (newskb)
-		netif_rx(newskb);
+		netif_rx_ni(newskb);
 
 	/* update statistics */
 	can_stats.tx_frames++;
@@ -293,6 +392,26 @@
  * af_can rx path
  */
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,26)
+static struct dev_rcv_lists *find_dev_rcv_lists(struct net_device *dev)
+{
+	/*
+	 * find receive list for this device
+	 *
+	 * Since 2.6.26 a new "midlevel private" ml_priv pointer has been
+	 * introduced in struct net_device. We use this pointer to omit the
+	 * linear walk through the can_rx_dev_list. A similar speedup has been
+	 * queued for 2.6.34 mainline but using the new netdev_rcu lists.
+	 * Therefore the can_rx_dev_list is still needed (e.g. in proc.c)
+	 */
+
+	/* dev == NULL is the indicator for the 'all' filterlist */
+	if (!dev)
+		return &can_rx_alldev_list;
+	else
+		return (struct dev_rcv_lists *)dev->ml_priv;
+}
+#else
 static struct dev_rcv_lists *find_dev_rcv_lists(struct net_device *dev)
 {
 	struct dev_rcv_lists *d = NULL;
@@ -318,24 +437,54 @@
 
 	return n ? d : NULL;
 }
+#endif
 
+/**
+ * find_rcv_list - determine optimal filterlist inside device filter struct
+ * @can_id: pointer to CAN identifier of a given can_filter
+ * @mask: pointer to CAN mask of a given can_filter
+ * @d: pointer to the device filter struct
+ *
+ * Description:
+ *  Returns the optimal filterlist to reduce the filter handling in the
+ *  receive path. This function is called by service functions that need
+ *  to register or unregister a can_filter in the filter lists.
+ *
+ *  A filter matches in general, when
+ *
+ *          <received_can_id> & mask == can_id & mask
+ *
+ *  so every bit set in the mask (even CAN_EFF_FLAG, CAN_RTR_FLAG) describe
+ *  relevant bits for the filter.
+ *
+ *  The filter can be inverted (CAN_INV_FILTER bit set in can_id) or it can
+ *  filter for error frames (CAN_ERR_FLAG bit set in mask). For error frames
+ *  there is a special filterlist and a special rx path filter handling.
+ *
+ * Return:
+ *  Pointer to optimal filterlist for the given can_id/mask pair.
+ *  Constistency checked mask.
+ *  Reduced can_id to have a preprocessed filter compare value.
+ */
 static struct hlist_head *find_rcv_list(canid_t *can_id, canid_t *mask,
 					struct dev_rcv_lists *d)
 {
 	canid_t inv = *can_id & CAN_INV_FILTER; /* save flag before masking */
 
-	/* filter error frames */
+	/* filter for error frames in extra filterlist */
 	if (*mask & CAN_ERR_FLAG) {
-		/* clear CAN_ERR_FLAG in list entry */
+		/* clear CAN_ERR_FLAG in filter entry */
 		*mask &= CAN_ERR_MASK;
 		return &d->rx[RX_ERR];
 	}
 
-	/* ensure valid values in can_mask */
-	if (*mask & CAN_EFF_FLAG)
-		*mask &= (CAN_EFF_MASK | CAN_EFF_FLAG | CAN_RTR_FLAG);
-	else
-		*mask &= (CAN_SFF_MASK | CAN_RTR_FLAG);
+	/* with cleared CAN_ERR_FLAG we have a simple mask/value filterpair */
+
+#define CAN_EFF_RTR_FLAGS (CAN_EFF_FLAG | CAN_RTR_FLAG)
+
+	/* ensure valid values in can_mask for 'SFF only' frame filtering */
+	if ((*mask & CAN_EFF_FLAG) && !(*can_id & CAN_EFF_FLAG))
+		*mask &= (CAN_SFF_MASK | CAN_EFF_RTR_FLAGS);
 
 	/* reduce condition testing at receive time */
 	*can_id &= *mask;
@@ -348,15 +497,19 @@
 	if (!(*mask))
 		return &d->rx[RX_ALL];
 
-	/* use extra filterset for the subscription of exactly *ONE* can_id */
-	if (*can_id & CAN_EFF_FLAG) {
-		if (*mask == (CAN_EFF_MASK | CAN_EFF_FLAG)) {
-			/* RFC: a use-case for hash-tables in the future? */
-			return &d->rx[RX_EFF];
+	/* extra filterlists for the subscription of a single non-RTR can_id */
+	if (((*mask & CAN_EFF_RTR_FLAGS) == CAN_EFF_RTR_FLAGS)
+	    && !(*can_id & CAN_RTR_FLAG)) {
+
+		if (*can_id & CAN_EFF_FLAG) {
+			if (*mask == (CAN_EFF_MASK | CAN_EFF_RTR_FLAGS)) {
+				/* RFC: a future use-case for hash-tables? */
+				return &d->rx[RX_EFF];
+			}
+		} else {
+			if (*mask == (CAN_SFF_MASK | CAN_EFF_RTR_FLAGS))
+				return &d->rx_sff[*can_id];
 		}
-	} else {
-		if (*mask == CAN_SFF_MASK)
-			return &d->rx_sff[*can_id];
 	}
 
 	/* default: filter via can_id/can_mask */
@@ -381,6 +534,12 @@
  *  The filter can be inverted (CAN_INV_FILTER bit set in can_id) or it can
  *  filter for error frames (CAN_ERR_FLAG bit set in mask).
  *
+ *  The provided pointer to the sk_buff is guaranteed to be valid as long as
+ *  the callback function is running. The callback function must *not* free
+ *  the given sk_buff while processing it's task. When the given sk_buff is
+ *  needed after the end of the callback function it must be cloned inside
+ *  the callback function with skb_clone().
+ *
  * Return:
  *  0 on success
  *  -ENOMEM on missing cache mem to create subscription entry
@@ -397,6 +556,11 @@
 
 	/* insert new receiver  (dev,canid,mask) -> (func,data) */
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,26)
+	if (dev && dev->type != ARPHRD_CAN)
+		return -ENODEV;
+#endif
+
 	r = kmem_cache_alloc(rcv_cache, GFP_KERNEL);
 	if (!r)
 		return -ENOMEM;
@@ -470,6 +634,11 @@
 	struct hlist_node *next;
 	struct dev_rcv_lists *d;
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,26)
+	if (dev && dev->type != ARPHRD_CAN)
+		return;
+#endif
+
 	spin_lock(&can_rcvlists_lock);
 
 	d = find_dev_rcv_lists(dev);
@@ -516,9 +685,12 @@
 		can_pstats.rcv_entries--;
 
 	/* remove device structure requested by NETDEV_UNREGISTER */
-	if (d->remove_on_zero_entries && !d->entries)
+	if (d->remove_on_zero_entries && !d->entries) {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,26)
+		dev->ml_priv = NULL;
+#endif
 		hlist_del_rcu(&d->list);
-	else
+	} else
 		d = NULL;
 
  out:
@@ -536,13 +708,8 @@
 
 static inline void deliver(struct sk_buff *skb, struct receiver *r)
 {
-	struct sk_buff *clone = skb_clone(skb, GFP_ATOMIC);
-
-	if (clone) {
-		clone->sk = skb->sk;
-		r->func(clone, r->data);
-		r->matches++;
-	}
+	r->func(skb, r->data);
+	r->matches++;
 }
 
 static int can_rcv_filter(struct dev_rcv_lists *d, struct sk_buff *skb)
@@ -589,7 +756,10 @@
 		}
 	}
 
-	/* check CAN_ID specific entries */
+	/* check filterlists for single non-RTR can_ids */
+	if (can_id & CAN_RTR_FLAG)
+		return matches;
+
 	if (can_id & CAN_EFF_FLAG) {
 		hlist_for_each_entry_rcu(r, n, &d->rx[RX_EFF], list) {
 			if (r->can_id == can_id) {
@@ -608,19 +778,39 @@
 	return matches;
 }
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,14)
 static int can_rcv(struct sk_buff *skb, struct net_device *dev,
 		   struct packet_type *pt, struct net_device *orig_dev)
+#else
+static int can_rcv(struct sk_buff *skb, struct net_device *dev,
+		   struct packet_type *pt)
+#endif
 {
 	struct dev_rcv_lists *d;
 	struct can_frame *cf = (struct can_frame *)skb->data;
 	int matches;
 
-	if (dev->type != ARPHRD_CAN || !net_eq(dev_net(dev), &init_net)) {
-		kfree_skb(skb);
-		return 0;
-	}
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,26)
+	if (!net_eq(dev_net(dev), &init_net))
+		goto drop;
+#elif LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,24)
+	if (dev->nd_net != &init_net)
+		goto drop;
+#endif
 
-	BUG_ON(skb->len != sizeof(struct can_frame) || cf->can_dlc > 8);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,27)
+	if (WARN_ONCE(dev->type != ARPHRD_CAN ||
+		      skb->len != sizeof(struct can_frame) ||
+		      cf->can_dlc > 8,
+		      "PF_CAN: dropped non conform skbuf: "
+		      "dev type %d, len %d, can_dlc %d\n",
+		      dev->type, skb->len, cf->can_dlc))
+		goto drop;
+#else
+	BUG_ON(dev->type != ARPHRD_CAN ||
+	       skb->len != sizeof(struct can_frame) ||
+	       cf->can_dlc > 8);
+#endif
 
 	/* update statistics */
 	can_stats.rx_frames++;
@@ -638,15 +828,25 @@
 
 	rcu_read_unlock();
 
-	/* free the skbuff allocated by the netdevice driver */
+	/* consume the skbuff allocated by the netdevice driver */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,30)
+	consume_skb(skb);
+#else
 	kfree_skb(skb);
+#endif
 
 	if (matches > 0) {
 		can_stats.matches++;
 		can_stats.matches_delta++;
 	}
 
-	return 0;
+	return NET_RX_SUCCESS;
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,24)
+drop:
+	kfree_skb(skb);
+	return NET_RX_DROP;
+#endif
 }
 
 /*
@@ -663,7 +863,7 @@
  *  -EBUSY  protocol already in use
  *  -ENOBUF if proto_register() fails
  */
-int can_proto_register(struct can_proto *cp)
+int can_proto_register(const struct can_proto *cp)
 {
 	int proto = cp->protocol;
 	int err = 0;
@@ -674,26 +874,27 @@
 		return -EINVAL;
 	}
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,12)
 	err = proto_register(cp->prot, 0);
 	if (err < 0)
 		return err;
+#endif
+
+	mutex_lock(&proto_tab_lock);
 
-	spin_lock(&proto_tab_lock);
 	if (proto_tab[proto]) {
 		printk(KERN_ERR "can: protocol %d already registered\n",
 		       proto);
 		err = -EBUSY;
-	} else {
-		proto_tab[proto] = cp;
+	} else
+		rcu_assign_pointer(proto_tab[proto], cp);
 
-		/* use generic ioctl function if not defined by module */
-		if (!cp->ops->ioctl)
-			cp->ops->ioctl = can_ioctl;
-	}
-	spin_unlock(&proto_tab_lock);
+	mutex_unlock(&proto_tab_lock);
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,12)
 	if (err < 0)
 		proto_unregister(cp->prot);
+#endif
 
 	return err;
 }
@@ -703,19 +904,20 @@
  * can_proto_unregister - unregister CAN transport protocol
  * @cp: pointer to CAN protocol structure
  */
-void can_proto_unregister(struct can_proto *cp)
+void can_proto_unregister(const struct can_proto *cp)
 {
 	int proto = cp->protocol;
 
-	spin_lock(&proto_tab_lock);
-	if (!proto_tab[proto]) {
-		printk(KERN_ERR "BUG: can: protocol %d is not registered\n",
-		       proto);
-	}
-	proto_tab[proto] = NULL;
-	spin_unlock(&proto_tab_lock);
+	mutex_lock(&proto_tab_lock);
+	BUG_ON(proto_tab[proto] != cp);
+	rcu_assign_pointer(proto_tab[proto], NULL);
+	mutex_unlock(&proto_tab_lock);
+
+	synchronize_rcu();
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,12)
 	proto_unregister(cp->prot);
+#endif
 }
 EXPORT_SYMBOL(can_proto_unregister);
 
@@ -728,8 +930,13 @@
 	struct net_device *dev = (struct net_device *)data;
 	struct dev_rcv_lists *d;
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,26)
 	if (!net_eq(dev_net(dev), &init_net))
 		return NOTIFY_DONE;
+#elif LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,24)
+	if (dev->nd_net != &init_net)
+		return NOTIFY_DONE;
+#endif
 
 	if (dev->type != ARPHRD_CAN)
 		return NOTIFY_DONE;
@@ -756,6 +963,10 @@
 		d->dev = dev;
 
 		spin_lock(&can_rcvlists_lock);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,26)
+		BUG_ON(dev->ml_priv);
+		dev->ml_priv = d;
+#endif
 		hlist_add_head_rcu(&d->list, &can_rx_dev_list);
 		spin_unlock(&can_rcvlists_lock);
 
@@ -769,8 +980,12 @@
 			if (d->entries) {
 				d->remove_on_zero_entries = 1;
 				d = NULL;
-			} else
+			} else {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,26)
+				dev->ml_priv = NULL;
+#endif
 				hlist_del_rcu(&d->list);
+			}
 		} else
 			printk(KERN_ERR "can: notifier: receive list not "
 			       "found for dev %s\n", dev->name);
@@ -791,7 +1006,11 @@
  */
 
 static struct packet_type can_packet __read_mostly = {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,30)
+	.type = cpu_to_be16(ETH_P_CAN),
+#else
 	.type = __constant_htons(ETH_P_CAN),
+#endif
 	.dev  = NULL,
 	.func = can_rcv,
 };
@@ -807,12 +1026,219 @@
 	.notifier_call = can_notifier,
 };
 
+/*
+ * RTNETLINK
+ */
+static int can_rtnl_doit(struct sk_buff *skb, struct nlmsghdr *nlh, void *arg)
+{
+	int ret, protocol;
+	const struct can_proto *cp;
+	rtnl_doit_func fn;
+
+	protocol = ((struct rtgencanmsg *)NLMSG_DATA(nlh))->can_protocol;
+	/* since rtnl_lock is held, dont try to load protocol */
+	cp = can_get_proto(protocol);
+	if (!cp)
+		return -EPROTONOSUPPORT;
+
+	switch (nlh->nlmsg_type) {
+	case RTM_NEWADDR:
+		fn = cp->rtnl_new_addr;
+		break;
+	case RTM_DELADDR:
+		fn = cp->rtnl_del_addr;
+		break;
+	default:
+		fn = 0;
+		break;
+	}
+	if (fn)
+		ret = fn(skb, nlh, arg);
+	else
+		ret = -EPROTONOSUPPORT;
+	can_put_proto(cp);
+	return ret;
+}
+
+static int can_rtnl_dumpit(struct sk_buff *skb, struct netlink_callback *cb,
+		int offset)
+{
+	int ret, j;
+	const struct can_proto *cp;
+	rtnl_dumpit_func fn;
+
+	ret = 0;
+	for (j = cb->args[0]; j < CAN_NPROTO; ++j) {
+		/* save state */
+		cb->args[0] = j;
+		cp = can_get_proto(j);
+		if (!cp)
+			/* we are looping, any error is our own fault */
+			continue;
+		fn = *((rtnl_dumpit_func *)(&((const uint8_t *)cp)[offset]));
+		if (fn)
+			ret = fn(skb, cb);
+		can_put_proto(cp);
+		if (ret < 0)
+			/* suspend this skb */
+			return ret;
+	}
+	return ret;
+}
+
+static int can_rtnl_dump_addr(struct sk_buff *skb, struct netlink_callback *cb)
+{
+	return can_rtnl_dumpit(skb, cb,
+			offsetof(struct can_proto, rtnl_dump_addr));
+}
+
+/*
+ * LINK AF properties
+ */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,36)
+static size_t can_get_link_af_size(const struct net_device *dev)
+{
+	int ret, j, total;
+	const struct can_proto *cp;
+
+	if (!net_eq(dev_net(dev), &init_net) || (dev->type != ARPHRD_CAN))
+		return 0;
+
+	total = 0;
+	for (j = 0; j < CAN_NPROTO; ++j) {
+		cp = can_get_proto(j);
+		if (!cp)
+			/* no worry */
+			continue;
+		ret = 0;
+		if (cp->rtnl_link_ops && cp->rtnl_link_ops->get_link_af_size)
+			ret = cp->rtnl_link_ops->get_link_af_size(dev) +
+				nla_total_size(sizeof(struct nlattr));
+		can_put_proto(cp);
+		if (ret < 0)
+			return ret;
+		total += ret;
+	}
+	return nla_total_size(total);
+}
+
+static int can_fill_link_af(struct sk_buff *skb, const struct net_device *dev)
+{
+	int ret, j, n;
+	struct nlattr *nla;
+	const struct can_proto *cp;
+
+	if (!net_eq(dev_net(dev), &init_net) || (dev->type != ARPHRD_CAN))
+		return -ENODATA;
+
+	n = 0;
+	for (j = 0; j < CAN_NPROTO; ++j) {
+		cp = can_get_proto(j);
+		if (!cp)
+			/* no worry */
+			continue;
+		if (cp->rtnl_link_ops && cp->rtnl_link_ops->fill_link_af) {
+			nla = nla_nest_start(skb, j);
+			if (!nla)
+				goto nla_put_failure;
+
+			ret = cp->rtnl_link_ops->fill_link_af(skb, dev);
+			/*
+			 * Caller may return ENODATA to indicate that there
+			 * was no data to be dumped. This is not an error, it
+			 * means we should trim the attribute header and
+			 * continue.
+			 */
+			if (ret == -ENODATA)
+				nla_nest_cancel(skb, nla);
+			else if (ret < 0)
+				goto nla_put_failure;
+			nla_nest_end(skb, nla);
+			++n;
+		}
+		can_put_proto(cp);
+	}
+	return n ? 0 : -ENODATA;
+
+nla_put_failure:
+	nla_nest_cancel(skb, nla);
+	can_put_proto(cp);
+	return -EMSGSIZE;
+}
+
+static int can_validate_link_af(const struct net_device *dev,
+				 const struct nlattr *nla)
+{
+	int ret, rem;
+	const struct can_proto *cp;
+	struct nlattr *prot;
+
+	if (!net_eq(dev_net(dev), &init_net) || (dev->type != ARPHRD_CAN))
+		return -EPROTONOSUPPORT;
+
+	nla_for_each_nested(prot, nla, rem) {
+		cp = can_get_proto(nla_type(prot));
+		if (!cp)
+			return -EPROTONOSUPPORT;
+		if (!cp->rtnl_link_ops)
+			ret = -EPROTONOSUPPORT;
+		else if (!cp->rtnl_link_ops->validate_link_af)
+			ret = 0;
+		else
+			ret = cp->rtnl_link_ops->validate_link_af(dev, prot);
+		can_put_proto(cp);
+		if (ret < 0)
+			return ret;
+	}
+	return 0;
+}
+
+static int can_set_link_af(struct net_device *dev, const struct nlattr *nla)
+{
+	int ret, rem;
+	const struct can_proto *cp;
+	struct nlattr *prot;
+
+	if (!net_eq(dev_net(dev), &init_net) || (dev->type != ARPHRD_CAN))
+		return -EPROTONOSUPPORT;
+
+	nla_for_each_nested(prot, nla, rem) {
+		cp = can_get_proto(nla_type(prot));
+		if (!cp)
+			return -EPROTONOSUPPORT;
+		if (!cp->rtnl_link_ops || !cp->rtnl_link_ops->set_link_af)
+			ret = -EPROTONOSUPPORT;
+		else
+			ret = cp->rtnl_link_ops->set_link_af(dev, prot);
+		can_put_proto(cp);
+		if (ret < 0)
+			return ret;
+	}
+	return 0;
+}
+
+static struct rtnl_af_ops can_rtnl_af_ops = {
+	.family		  = AF_CAN,
+	.fill_link_af	  = can_fill_link_af,
+	.get_link_af_size = can_get_link_af_size,
+	.validate_link_af = can_validate_link_af,
+	.set_link_af	  = can_set_link_af,
+};
+#endif
+
+/* exported init */
+
 static __init int can_init(void)
 {
 	printk(banner);
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,23)
 	rcv_cache = kmem_cache_create("can_receiver", sizeof(struct receiver),
 				      0, 0, NULL);
+#else
+	rcv_cache = kmem_cache_create("can_receiver", sizeof(struct receiver),
+				      0, 0, NULL, NULL);
+#endif
 	if (!rcv_cache)
 		return -ENOMEM;
 
@@ -840,6 +1266,13 @@
 	register_netdevice_notifier(&can_netdev_notifier);
 	dev_add_pack(&can_packet);
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,36)
+	rtnl_af_register(&can_rtnl_af_ops);
+#endif
+	rtnl_register(PF_CAN, RTM_NEWADDR, can_rtnl_doit, NULL);
+	rtnl_register(PF_CAN, RTM_DELADDR, can_rtnl_doit, NULL);
+	rtnl_register(PF_CAN, RTM_GETADDR, NULL, can_rtnl_dump_addr);
+
 	return 0;
 }
 
@@ -851,6 +1284,13 @@
 	if (stats_timer)
 		del_timer(&can_stattimer);
 
+	rtnl_unregister(PF_CAN, RTM_NEWADDR);
+	rtnl_unregister(PF_CAN, RTM_DELADDR);
+	rtnl_unregister(PF_CAN, RTM_GETADDR);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,36)
+	rtnl_af_unregister(&can_rtnl_af_ops);
+#endif
+
 	can_remove_proc();
 
 	/* protocol unregister */
@@ -863,10 +1303,18 @@
 	hlist_del(&can_rx_alldev_list.list);
 	hlist_for_each_entry_safe(d, n, next, &can_rx_dev_list, list) {
 		hlist_del(&d->list);
+		BUG_ON(d->entries);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,26)
+		d->dev->ml_priv = NULL;
+#endif
 		kfree(d);
 	}
 	spin_unlock(&can_rcvlists_lock);
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,15)
+	rcu_barrier(); /* Wait for completion of call_rcu()'s */
+#endif
+
 	kmem_cache_destroy(rcv_cache);
 }
 
diff --exclude CVS --exclude .git -uNr linux-2.6.27.8/net/can/af_can.h linux-2.6.27.8.modified/net/can/af_can.h
--- linux-2.6.27.8/net/can/af_can.h	2008-12-05 15:03:02.000000000 -0500
+++ linux-2.6.27.8.modified/net/can/af_can.h	2013-05-30 03:44:16.000000000 -0400
@@ -1,4 +1,6 @@
 /*
+ * $Id: af_can.h 1038 2009-08-21 10:00:21Z hartkopp $
+ *
  * Copyright (c) 2002-2007 Volkswagen Group Electronic Research
  * All rights reserved.
  *
@@ -46,7 +48,7 @@
 #include <linux/netdevice.h>
 #include <linux/list.h>
 #include <linux/rcupdate.h>
-#include <linux/can.h>
+#include <socketcan/can.h>
 
 /* af_can rx dispatcher structures */
 
diff --exclude CVS --exclude .git -uNr linux-2.6.27.8/net/can/bcm-prior-2-6-22.c linux-2.6.27.8.modified/net/can/bcm-prior-2-6-22.c
--- linux-2.6.27.8/net/can/bcm-prior-2-6-22.c	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.27.8.modified/net/can/bcm-prior-2-6-22.c	2013-05-30 03:44:16.000000000 -0400
@@ -0,0 +1,1625 @@
+/*
+ * bcm.c - Broadcast Manager to filter/send (cyclic) CAN content
+ *
+ * Copyright (c) 2002-2007 Volkswagen Group Electronic Research
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of Volkswagen nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * Alternatively, provided that this notice is retained in full, this
+ * software may be distributed under the terms of the GNU General
+ * Public License ("GPL") version 2, in which case the provisions of the
+ * GPL apply INSTEAD OF those given above.
+ *
+ * The provided data structures and external interfaces from this code
+ * are not restricted to be used by modules with a GPL compatible license.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * Send feedback to <socketcan-users@lists.berlios.de>
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/version.h>
+#include <linux/init.h>
+#include <linux/list.h>
+#include <linux/proc_fs.h>
+#include <linux/uio.h>
+#include <linux/net.h>
+#include <linux/netdevice.h>
+#include <linux/socket.h>
+#include <linux/if_arp.h>
+#include <linux/skbuff.h>
+#include <socketcan/can.h>
+#include <socketcan/can/core.h>
+#include <socketcan/can/bcm.h>
+#include <net/sock.h>
+#include "compat.h"
+
+#include <socketcan/can/version.h> /* for RCSID. Removed by mkpatch script */
+RCSID("$Id: bcm-prior-2-6-22.c 1252 2011-05-05 14:42:58Z hartkopp $");
+
+/* use of last_frames[index].can_dlc */
+#define RX_RECV    0x40 /* received data for this element */
+#define RX_THR     0x80 /* element not been sent due to throttle feature */
+#define BCM_CAN_DLC_MASK 0x0F /* clean private flags in can_dlc by masking */
+
+/* get best masking value for can_rx_register() for a given single can_id */
+#define REGMASK(id) ((id & CAN_EFF_FLAG) ? \
+		     (CAN_EFF_MASK | CAN_EFF_FLAG | CAN_RTR_FLAG) : \
+		     (CAN_SFF_MASK | CAN_EFF_FLAG | CAN_RTR_FLAG))
+
+#define CAN_BCM_VERSION CAN_VERSION
+static __initdata const char banner[] = KERN_INFO
+	"can: broadcast manager protocol (rev " CAN_BCM_VERSION ")\n";
+
+MODULE_DESCRIPTION("PF_CAN broadcast manager protocol");
+MODULE_LICENSE("Dual BSD/GPL");
+MODULE_AUTHOR("Oliver Hartkopp <oliver.hartkopp@volkswagen.de>");
+MODULE_ALIAS("can-proto-2");
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,22)
+#error This code only supports Kernel versions _below_ 2.6.22
+#error For 2.6.22+ Kernels please use bcm.c instead of bcm-prior-2-6-22.c
+#endif
+
+/* easy access to can_frame payload */
+static inline u64 GET_U64(const struct can_frame *cp)
+{
+	return *(u64 *)cp->data;
+}
+
+struct bcm_op {
+	struct list_head list;
+	int ifindex;
+	canid_t can_id;
+	int flags;
+	unsigned long frames_abs, frames_filtered;
+	struct timeval ival1, ival2;
+	struct timer_list timer, thrtimer;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,14)
+	struct skb_timeval rx_stamp;
+#else
+	struct timeval rx_stamp;
+#endif
+	unsigned long j_ival1, j_ival2, j_lastmsg;
+	int rx_ifindex;
+	int count;
+	int nframes;
+	int currframe;
+	struct can_frame *frames;
+	struct can_frame *last_frames;
+	struct can_frame sframe;
+	struct can_frame last_sframe;
+	struct sock *sk;
+	struct net_device *rx_reg_dev;
+};
+
+static struct proc_dir_entry *proc_dir;
+
+struct bcm_sock {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,12)
+	struct sock sk;
+#else
+	struct sock *sk;
+#endif
+	int bound;
+	int ifindex;
+	struct notifier_block notifier;
+	struct list_head rx_ops;
+	struct list_head tx_ops;
+	unsigned long dropped_usr_msgs;
+	struct proc_dir_entry *bcm_proc_read;
+	char procname [9]; /* pointer printed in ASCII with \0 */
+};
+
+static inline struct bcm_sock *bcm_sk(const struct sock *sk)
+{
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,12)
+	return (struct bcm_sock *)sk;
+#else
+	return (struct bcm_sock *)sk->sk_protinfo;
+#endif
+}
+
+#define CFSIZ sizeof(struct can_frame)
+#define OPSIZ sizeof(struct bcm_op)
+#define MHSIZ sizeof(struct bcm_msg_head)
+
+/*
+ * rounded_tv2jif - calculate jiffies from timeval including optional up
+ * @tv: pointer to timeval
+ *
+ * Description:
+ * Unlike timeval_to_jiffies() provided in include/linux/jiffies.h, this
+ * function is intentionally more relaxed on precise timer ticks to get
+ * exact one jiffy for requested 1000us on a 1000HZ machine.
+ * This code is to be removed when upgrading to kernel hrtimer.
+ *
+ * Return:
+ *  calculated jiffies (max: ULONG_MAX)
+ */
+static unsigned long rounded_tv2jif(const struct timeval *tv)
+{
+	unsigned long sec  = tv->tv_sec;
+	unsigned long usec = tv->tv_usec;
+	unsigned long jif;
+
+	if (sec > ULONG_MAX / HZ)
+		return ULONG_MAX;
+
+	/* round up to get at least the requested time */
+	usec += 1000000 / HZ - 1;
+
+	jif  = usec / (1000000 / HZ);
+
+	if (sec * HZ > ULONG_MAX - jif)
+		return ULONG_MAX;
+
+	return jif + sec * HZ;
+}
+
+/*
+ * procfs functions
+ */
+static char *bcm_proc_getifname(int ifindex)
+{
+	struct net_device *dev;
+
+	if (!ifindex)
+		return "any";
+
+	/* no usage counting */
+	dev = __dev_get_by_index(&init_net, ifindex);
+	if (dev)
+		return dev->name;
+
+	return "???";
+}
+
+static int bcm_read_proc(char *page, char **start, off_t off,
+			 int count, int *eof, void *data)
+{
+	int len = 0;
+	struct sock *sk = (struct sock *)data;
+	struct bcm_sock *bo = bcm_sk(sk);
+	struct bcm_op *op;
+
+	len += snprintf(page + len, PAGE_SIZE - len, ">>> socket %p",
+			sk->sk_socket);
+	len += snprintf(page + len, PAGE_SIZE - len, " / sk %p", sk);
+	len += snprintf(page + len, PAGE_SIZE - len, " / bo %p", bo);
+	len += snprintf(page + len, PAGE_SIZE - len, " / dropped %lu",
+			bo->dropped_usr_msgs);
+	len += snprintf(page + len, PAGE_SIZE - len, " / bound %s",
+			bcm_proc_getifname(bo->ifindex));
+	len += snprintf(page + len, PAGE_SIZE - len, " <<<\n");
+
+	list_for_each_entry(op, &bo->rx_ops, list) {
+
+		unsigned long reduction;
+
+		/* print only active entries & prevent division by zero */
+		if (!op->frames_abs)
+			continue;
+
+		len += snprintf(page + len, PAGE_SIZE - len,
+				"rx_op: %03X %-5s ",
+				op->can_id, bcm_proc_getifname(op->ifindex));
+		len += snprintf(page + len, PAGE_SIZE - len, "[%d]%c ",
+				op->nframes,
+				(op->flags & RX_CHECK_DLC)?'d':' ');
+		if (op->j_ival1)
+			len += snprintf(page + len, PAGE_SIZE - len,
+					"timeo=%ld ", op->j_ival1);
+
+		if (op->j_ival2)
+			len += snprintf(page + len, PAGE_SIZE - len,
+					"thr=%ld ", op->j_ival2);
+
+		len += snprintf(page + len, PAGE_SIZE - len,
+				"# recv %ld (%ld) => reduction: ",
+				op->frames_filtered, op->frames_abs);
+
+		reduction = 100 - (op->frames_filtered * 100) / op->frames_abs;
+
+		len += snprintf(page + len, PAGE_SIZE - len, "%s%ld%%\n",
+				(reduction == 100)?"near ":"", reduction);
+
+		if (len > PAGE_SIZE - 200) {
+			/* mark output cut off */
+			len += snprintf(page + len, PAGE_SIZE - len, "(..)\n");
+			break;
+		}
+	}
+
+	list_for_each_entry(op, &bo->tx_ops, list) {
+
+		len += snprintf(page + len, PAGE_SIZE - len,
+				"tx_op: %03X %s [%d] ",
+				op->can_id, bcm_proc_getifname(op->ifindex),
+				op->nframes);
+
+		if (op->j_ival1)
+			len += snprintf(page + len, PAGE_SIZE - len, "t1=%ld ",
+					op->j_ival1);
+
+		if (op->j_ival2)
+			len += snprintf(page + len, PAGE_SIZE - len, "t2=%ld ",
+					op->j_ival2);
+
+		len += snprintf(page + len, PAGE_SIZE - len, "# sent %ld\n",
+				op->frames_abs);
+
+		if (len > PAGE_SIZE - 100) {
+			/* mark output cut off */
+			len += snprintf(page + len, PAGE_SIZE - len, "(..)\n");
+			break;
+		}
+	}
+
+	len += snprintf(page + len, PAGE_SIZE - len, "\n");
+
+	*eof = 1;
+	return len;
+}
+
+/*
+ * bcm_can_tx - send the (next) CAN frame to the appropriate CAN interface
+ *              of the given bcm tx op
+ */
+static void bcm_can_tx(struct bcm_op *op)
+{
+	struct sk_buff *skb;
+	struct net_device *dev;
+	struct can_frame *cf = &op->frames[op->currframe];
+
+	/* no target device? => exit */
+	if (!op->ifindex)
+		return;
+
+	dev = dev_get_by_index(&init_net, op->ifindex);
+	if (!dev) {
+		/* RFC: should this bcm_op remove itself here? */
+		return;
+	}
+
+	skb = alloc_skb(CFSIZ, gfp_any());
+	if (!skb)
+		goto out;
+
+	memcpy(skb_put(skb, CFSIZ), cf, CFSIZ);
+
+	/* send with loopback */
+	skb->dev = dev;
+	skb->sk = op->sk;
+	can_send(skb, 1);
+
+	/* update statistics */
+	op->currframe++;
+	op->frames_abs++;
+
+	/* reached last frame? */
+	if (op->currframe >= op->nframes)
+		op->currframe = 0;
+ out:
+	dev_put(dev);
+}
+
+/*
+ * bcm_send_to_user - send a BCM message to the userspace
+ *                    (consisting of bcm_msg_head + x CAN frames)
+ */
+static void bcm_send_to_user(struct bcm_op *op, struct bcm_msg_head *head,
+			     struct can_frame *frames, int has_timestamp)
+{
+	struct sk_buff *skb;
+	struct can_frame *firstframe;
+	struct sockaddr_can *addr;
+	struct sock *sk = op->sk;
+	int datalen = head->nframes * CFSIZ;
+	int err;
+
+	skb = alloc_skb(sizeof(*head) + datalen, gfp_any());
+	if (!skb)
+		return;
+
+	memcpy(skb_put(skb, sizeof(*head)), head, sizeof(*head));
+
+	if (head->nframes) {
+		/* can_frames starting here */
+		firstframe = (struct can_frame *)skb->tail;
+
+		memcpy(skb_put(skb, datalen), frames, datalen);
+
+		/*
+		 * the BCM uses the can_dlc-element of the can_frame
+		 * structure for internal purposes. This is only
+		 * relevant for updates that are generated by the
+		 * BCM, where nframes is 1
+		 */
+		if (head->nframes == 1)
+			firstframe->can_dlc &= BCM_CAN_DLC_MASK;
+	}
+
+	if (has_timestamp) {
+		/* restore rx timestamp */
+		skb->tstamp = op->rx_stamp;
+	}
+
+	/*
+	 *  Put the datagram to the queue so that bcm_recvmsg() can
+	 *  get it from there.  We need to pass the interface index to
+	 *  bcm_recvmsg().  We pass a whole struct sockaddr_can in skb->cb
+	 *  containing the interface index.
+	 */
+
+	BUILD_BUG_ON(sizeof(skb->cb) < sizeof(struct sockaddr_can));
+	addr = (struct sockaddr_can *)skb->cb;
+	memset(addr, 0, sizeof(*addr));
+	addr->can_family  = AF_CAN;
+	addr->can_ifindex = op->rx_ifindex;
+
+	err = sock_queue_rcv_skb(sk, skb);
+	if (err < 0) {
+		struct bcm_sock *bo = bcm_sk(sk);
+
+		kfree_skb(skb);
+		/* don't care about overflows in this statistic */
+		bo->dropped_usr_msgs++;
+	}
+}
+
+/*
+ * bcm_tx_timeout_handler - performes cyclic CAN frame transmissions
+ */
+static void bcm_tx_timeout_handler(unsigned long data)
+{
+	struct bcm_op *op = (struct bcm_op *)data;
+	struct bcm_msg_head msg_head;
+
+	if (op->j_ival1 && (op->count > 0)) {
+
+		op->count--;
+		if (!op->count && (op->flags & TX_COUNTEVT)) {
+
+			/* create notification to user */
+			msg_head.opcode  = TX_EXPIRED;
+			msg_head.flags   = op->flags;
+			msg_head.count   = op->count;
+			msg_head.ival1   = op->ival1;
+			msg_head.ival2   = op->ival2;
+			msg_head.can_id  = op->can_id;
+			msg_head.nframes = 0;
+
+			bcm_send_to_user(op, &msg_head, NULL, 0);
+		}
+	}
+
+	if (op->j_ival1 && (op->count > 0)) {
+
+		/* send (next) frame */
+		bcm_can_tx(op);
+		mod_timer(&op->timer, jiffies + op->j_ival1);
+
+	} else {
+		if (op->j_ival2) {
+
+			/* send (next) frame */
+			bcm_can_tx(op);
+			mod_timer(&op->timer, jiffies + op->j_ival2);
+		}
+	}
+}
+
+/*
+ * bcm_rx_changed - create a RX_CHANGED notification due to changed content
+ */
+static void bcm_rx_changed(struct bcm_op *op, struct can_frame *data)
+{
+	struct bcm_msg_head head;
+
+	op->j_lastmsg = jiffies;
+
+	/* update statistics */
+	op->frames_filtered++;
+
+	/* prevent statistics overflow */
+	if (op->frames_filtered > ULONG_MAX/100)
+		op->frames_filtered = op->frames_abs = 0;
+
+	/* this element is not throttled anymore */
+	data->can_dlc &= (BCM_CAN_DLC_MASK|RX_RECV);
+
+	head.opcode  = RX_CHANGED;
+	head.flags   = op->flags;
+	head.count   = op->count;
+	head.ival1   = op->ival1;
+	head.ival2   = op->ival2;
+	head.can_id  = op->can_id;
+	head.nframes = 1;
+
+	bcm_send_to_user(op, &head, data, 1);
+}
+
+/*
+ * bcm_rx_update_and_send - process a detected relevant receive content change
+ *                          1. update the last received data
+ *                          2. send a notification to the user (if possible)
+ */
+static void bcm_rx_update_and_send(struct bcm_op *op,
+				   struct can_frame *lastdata,
+				   const struct can_frame *rxdata)
+{
+	unsigned long nexttx = op->j_lastmsg + op->j_ival2;
+
+	memcpy(lastdata, rxdata, CFSIZ);
+
+	/* mark as used and throttled by default */
+	lastdata->can_dlc |= (RX_RECV|RX_THR);
+
+	/* throttle bcm_rx_changed ? */
+	if ((op->thrtimer.expires) ||
+	    ((op->j_ival2) && (nexttx > jiffies))) {
+		/* we are already waiting OR we have to start waiting */
+
+		if (!(op->thrtimer.expires)) {
+			/* start the timer only the first time */
+			mod_timer(&op->thrtimer, nexttx);
+		}
+
+	} else {
+		/* send RX_CHANGED to the user immediately */
+		bcm_rx_changed(op, lastdata);
+	}
+}
+
+/*
+ * bcm_rx_cmp_to_index - (bit)compares the currently received data to formerly
+ *                       received data stored in op->last_frames[]
+ */
+static void bcm_rx_cmp_to_index(struct bcm_op *op, int index,
+				const struct can_frame *rxdata)
+{
+	/*
+	 * no one uses the MSBs of can_dlc for comparation,
+	 * so we use it here to detect the first time of reception
+	 */
+
+	if (!(op->last_frames[index].can_dlc & RX_RECV)) {
+		/* received data for the first time => send update to user */
+		bcm_rx_update_and_send(op, &op->last_frames[index], rxdata);
+		return;
+	}
+
+	/* do a real check in can_frame data section */
+
+	if ((GET_U64(&op->frames[index]) & GET_U64(rxdata)) !=
+	    (GET_U64(&op->frames[index]) & GET_U64(&op->last_frames[index]))) {
+		bcm_rx_update_and_send(op, &op->last_frames[index], rxdata);
+		return;
+	}
+
+	if (op->flags & RX_CHECK_DLC) {
+		/* do a real check in can_frame dlc */
+		if (rxdata->can_dlc != (op->last_frames[index].can_dlc &
+					BCM_CAN_DLC_MASK)) {
+			bcm_rx_update_and_send(op, &op->last_frames[index],
+					       rxdata);
+			return;
+		}
+	}
+}
+
+/*
+ * bcm_rx_starttimer - enable timeout monitoring for CAN frame receiption
+ */
+static void bcm_rx_starttimer(struct bcm_op *op)
+{
+	if (op->flags & RX_NO_AUTOTIMER)
+		return;
+
+	if (op->j_ival1)
+		mod_timer(&op->timer, jiffies + op->j_ival1);
+}
+
+/*
+ * bcm_rx_timeout_handler - when the (cyclic) CAN frame receiption timed out
+ */
+static void bcm_rx_timeout_handler(unsigned long data)
+{
+	struct bcm_op *op = (struct bcm_op *)data;
+	struct bcm_msg_head msg_head;
+
+	/* create notification to user */
+	msg_head.opcode  = RX_TIMEOUT;
+	msg_head.flags   = op->flags;
+	msg_head.count   = op->count;
+	msg_head.ival1   = op->ival1;
+	msg_head.ival2   = op->ival2;
+	msg_head.can_id  = op->can_id;
+	msg_head.nframes = 0;
+
+	bcm_send_to_user(op, &msg_head, NULL, 0);
+
+	/* no restart of the timer is done here! */
+
+	/* if user wants to be informed, when cyclic CAN-Messages come back */
+	if ((op->flags & RX_ANNOUNCE_RESUME) && op->last_frames) {
+		/* clear received can_frames to indicate 'nothing received' */
+		memset(op->last_frames, 0, op->nframes * CFSIZ);
+	}
+}
+
+/*
+ * bcm_rx_do_flush - helper for bcm_rx_thr_flush
+ */
+static inline int bcm_rx_do_flush(struct bcm_op *op, int index)
+{
+	if ((op->last_frames) && (op->last_frames[index].can_dlc & RX_THR)) {
+		bcm_rx_changed(op, &op->last_frames[index]);
+		return 1;
+	}
+	return 0;
+}
+
+/*
+ * bcm_rx_thr_flush - Check for throttled data and send it to the userspace
+ */
+static int bcm_rx_thr_flush(struct bcm_op *op)
+{
+	int updated = 0;
+
+	if (op->nframes > 1) {
+		int i;
+
+		/* for MUX filter we start at index 1 */
+		for (i = 1; i < op->nframes; i++)
+			updated += bcm_rx_do_flush(op, i);
+
+	} else {
+		/* for RX_FILTER_ID and simple filter */
+		updated += bcm_rx_do_flush(op, 0);
+	}
+
+	return updated;
+}
+
+/*
+ * bcm_rx_thr_handler - the time for blocked content updates is over now:
+ *                      Check for throttled data and send it to the userspace
+ */
+static void bcm_rx_thr_handler(unsigned long data)
+{
+	struct bcm_op *op = (struct bcm_op *)data;
+
+	if (bcm_rx_thr_flush(op))
+		mod_timer(&op->thrtimer, jiffies + op->j_ival2);
+	else {
+		/* mark disabled / consumed timer */
+		op->thrtimer.expires = 0;
+	}
+}
+
+/*
+ * bcm_rx_handler - handle a CAN frame receiption
+ */
+static void bcm_rx_handler(struct sk_buff *skb, void *data)
+{
+	struct bcm_op *op = (struct bcm_op *)data;
+	const struct can_frame *rxframe = (struct can_frame *)skb->data;
+	int i;
+
+	/* disable timeout */
+	del_timer(&op->timer);
+
+	if (op->can_id != rxframe->can_id)
+		return;
+
+	/* save rx timestamp */
+	op->rx_stamp = skb->tstamp;
+	/* save originator for recvfrom() */
+	op->rx_ifindex = skb->dev->ifindex;
+	/* update statistics */
+	op->frames_abs++;
+
+	if (op->flags & RX_RTR_FRAME) {
+		/* send reply for RTR-request (placed in op->frames[0]) */
+		bcm_can_tx(op);
+		return;
+	}
+
+	if (op->flags & RX_FILTER_ID) {
+		/* the easiest case */
+		bcm_rx_update_and_send(op, &op->last_frames[0], rxframe);
+		goto rx_starttimer;
+	}
+
+	if (op->nframes == 1) {
+		/* simple compare with index 0 */
+		bcm_rx_cmp_to_index(op, 0, rxframe);
+		goto rx_starttimer;
+	}
+
+	if (op->nframes > 1) {
+		/*
+		 * multiplex compare
+		 *
+		 * find the first multiplex mask that fits.
+		 * Remark: The MUX-mask is stored in index 0
+		 */
+
+		for (i = 1; i < op->nframes; i++) {
+			if ((GET_U64(&op->frames[0]) & GET_U64(rxframe)) ==
+			    (GET_U64(&op->frames[0]) &
+			     GET_U64(&op->frames[i]))) {
+				bcm_rx_cmp_to_index(op, i, rxframe);
+				break;
+			}
+		}
+	}
+
+rx_starttimer:
+	bcm_rx_starttimer(op);
+}
+
+/*
+ * helpers for bcm_op handling: find & delete bcm [rx|tx] op elements
+ */
+static struct bcm_op *bcm_find_op(struct list_head *ops, canid_t can_id,
+				  int ifindex)
+{
+	struct bcm_op *op;
+
+	list_for_each_entry(op, ops, list) {
+		if ((op->can_id == can_id) && (op->ifindex == ifindex))
+			return op;
+	}
+
+	return NULL;
+}
+
+static void bcm_remove_op(struct bcm_op *op)
+{
+	del_timer(&op->timer);
+	del_timer(&op->thrtimer);
+
+	if ((op->frames) && (op->frames != &op->sframe))
+		kfree(op->frames);
+
+	if ((op->last_frames) && (op->last_frames != &op->last_sframe))
+		kfree(op->last_frames);
+
+	kfree(op);
+
+	return;
+}
+
+static void bcm_rx_unreg(struct net_device *dev, struct bcm_op *op)
+{
+	if (op->rx_reg_dev == dev) {
+		can_rx_unregister(dev, op->can_id, REGMASK(op->can_id),
+				  bcm_rx_handler, op);
+
+		/* mark as removed subscription */
+		op->rx_reg_dev = NULL;
+	} else
+		printk(KERN_ERR "can-bcm: bcm_rx_unreg: registered device "
+		       "mismatch %p %p\n", op->rx_reg_dev, dev);
+}
+
+/*
+ * bcm_delete_rx_op - find and remove a rx op (returns number of removed ops)
+ */
+static int bcm_delete_rx_op(struct list_head *ops, canid_t can_id, int ifindex)
+{
+	struct bcm_op *op, *n;
+
+	list_for_each_entry_safe(op, n, ops, list) {
+		if ((op->can_id == can_id) && (op->ifindex == ifindex)) {
+
+			/*
+			 * Don't care if we're bound or not (due to netdev
+			 * problems) can_rx_unregister() is always a save
+			 * thing to do here.
+			 */
+			if (op->ifindex) {
+				/*
+				 * Only remove subscriptions that had not
+				 * been removed due to NETDEV_UNREGISTER
+				 * in bcm_notifier()
+				 */
+				if (op->rx_reg_dev) {
+					struct net_device *dev;
+
+					dev = dev_get_by_index(&init_net,
+							       op->ifindex);
+					if (dev) {
+						bcm_rx_unreg(dev, op);
+						dev_put(dev);
+					}
+				}
+			} else
+				can_rx_unregister(NULL, op->can_id,
+						  REGMASK(op->can_id),
+						  bcm_rx_handler, op);
+
+			list_del(&op->list);
+			bcm_remove_op(op);
+			return 1; /* done */
+		}
+	}
+
+	return 0; /* not found */
+}
+
+/*
+ * bcm_delete_tx_op - find and remove a tx op (returns number of removed ops)
+ */
+static int bcm_delete_tx_op(struct list_head *ops, canid_t can_id, int ifindex)
+{
+	struct bcm_op *op, *n;
+
+	list_for_each_entry_safe(op, n, ops, list) {
+		if ((op->can_id == can_id) && (op->ifindex == ifindex)) {
+			list_del(&op->list);
+			bcm_remove_op(op);
+			return 1; /* done */
+		}
+	}
+
+	return 0; /* not found */
+}
+
+/*
+ * bcm_read_op - read out a bcm_op and send it to the user (for bcm_sendmsg)
+ */
+static int bcm_read_op(struct list_head *ops, struct bcm_msg_head *msg_head,
+		       int ifindex)
+{
+	struct bcm_op *op = bcm_find_op(ops, msg_head->can_id, ifindex);
+
+	if (!op)
+		return -EINVAL;
+
+	/* put current values into msg_head */
+	msg_head->flags   = op->flags;
+	msg_head->count   = op->count;
+	msg_head->ival1   = op->ival1;
+	msg_head->ival2   = op->ival2;
+	msg_head->nframes = op->nframes;
+
+	bcm_send_to_user(op, msg_head, op->frames, 0);
+
+	return MHSIZ;
+}
+
+/*
+ * bcm_tx_setup - create or update a bcm tx op (for bcm_sendmsg)
+ */
+static int bcm_tx_setup(struct bcm_msg_head *msg_head, struct msghdr *msg,
+			int ifindex, struct sock *sk)
+{
+	struct bcm_sock *bo = bcm_sk(sk);
+	struct bcm_op *op;
+	int i, err;
+
+	/* we need a real device to send frames */
+	if (!ifindex)
+		return -ENODEV;
+
+	/* we need at least one can_frame */
+	if (msg_head->nframes < 1)
+		return -EINVAL;
+
+	/* check the given can_id */
+	op = bcm_find_op(&bo->tx_ops, msg_head->can_id, ifindex);
+
+	if (op) {
+		/* update existing BCM operation */
+
+		/*
+		 * Do we need more space for the can_frames than currently
+		 * allocated? -> This is a _really_ unusual use-case and
+		 * therefore (complexity / locking) it is not supported.
+		 */
+		if (msg_head->nframes > op->nframes)
+			return -E2BIG;
+
+		/* update can_frames content */
+		for (i = 0; i < msg_head->nframes; i++) {
+			err = memcpy_fromiovec((u8 *)&op->frames[i],
+					       msg->msg_iov, CFSIZ);
+
+			if (op->frames[i].can_dlc > 8)
+				err = -EINVAL;
+
+			if (err < 0)
+				return err;
+
+			if (msg_head->flags & TX_CP_CAN_ID) {
+				/* copy can_id into frame */
+				op->frames[i].can_id = msg_head->can_id;
+			}
+		}
+
+	} else {
+		/* insert new BCM operation for the given can_id */
+
+		op = kzalloc(OPSIZ, GFP_KERNEL);
+		if (!op)
+			return -ENOMEM;
+
+		op->can_id    = msg_head->can_id;
+
+		/* create array for can_frames and copy the data */
+		if (msg_head->nframes > 1) {
+			op->frames = kmalloc(msg_head->nframes * CFSIZ,
+					     GFP_KERNEL);
+			if (!op->frames) {
+				kfree(op);
+				return -ENOMEM;
+			}
+		} else
+			op->frames = &op->sframe;
+
+		for (i = 0; i < msg_head->nframes; i++) {
+			err = memcpy_fromiovec((u8 *)&op->frames[i],
+					       msg->msg_iov, CFSIZ);
+
+			if (op->frames[i].can_dlc > 8)
+				err = -EINVAL;
+
+			if (err < 0) {
+				if (op->frames != &op->sframe)
+					kfree(op->frames);
+				kfree(op);
+				return err;
+			}
+
+			if (msg_head->flags & TX_CP_CAN_ID) {
+				/* copy can_id into frame */
+				op->frames[i].can_id = msg_head->can_id;
+			}
+		}
+
+		/* tx_ops never compare with previous received messages */
+		op->last_frames = NULL;
+
+		/* bcm_can_tx / bcm_tx_timeout_handler needs this */
+		op->sk = sk;
+		op->ifindex = ifindex;
+
+		/* initialize uninitialized (kzalloc) structure */
+		setup_timer(&op->timer, bcm_tx_timeout_handler,
+			    (unsigned long)op);
+
+		/* currently unused in tx_ops */
+		init_timer(&op->thrtimer);
+
+		/* add this bcm_op to the list of the tx_ops */
+		list_add(&op->list, &bo->tx_ops);
+
+	} /* if ((op = bcm_find_op(&bo->tx_ops, msg_head->can_id, ifindex))) */
+
+	if (op->nframes != msg_head->nframes) {
+		op->nframes   = msg_head->nframes;
+		/* start multiple frame transmission with index 0 */
+		op->currframe = 0;
+	}
+
+	/* check flags */
+
+	op->flags = msg_head->flags;
+
+	if (op->flags & TX_RESET_MULTI_IDX) {
+		/* start multiple frame transmission with index 0 */
+		op->currframe = 0;
+	}
+
+	if (op->flags & SETTIMER) {
+		/* set timer values */
+		op->count = msg_head->count;
+		op->ival1 = msg_head->ival1;
+		op->ival2 = msg_head->ival2;
+		op->j_ival1 = rounded_tv2jif(&msg_head->ival1);
+		op->j_ival2 = rounded_tv2jif(&msg_head->ival2);
+
+		/* disable an active timer due to zero values? */
+		if (!op->j_ival1 && !op->j_ival2)
+			del_timer(&op->timer);
+	}
+
+	if ((op->flags & STARTTIMER) &&
+	    ((op->j_ival1 && op->count) || op->j_ival2)) {
+
+		/* spec: send can_frame when starting timer */
+		op->flags |= TX_ANNOUNCE;
+
+		if (op->j_ival1 && (op->count > 0)) {
+			/* op->count-- is done in bcm_tx_timeout_handler */
+			mod_timer(&op->timer, jiffies + op->j_ival1);
+		} else
+			mod_timer(&op->timer, jiffies + op->j_ival2);
+	}
+
+	if (op->flags & TX_ANNOUNCE)
+		bcm_can_tx(op);
+
+	return msg_head->nframes * CFSIZ + MHSIZ;
+}
+
+/*
+ * bcm_rx_setup - create or update a bcm rx op (for bcm_sendmsg)
+ */
+static int bcm_rx_setup(struct bcm_msg_head *msg_head, struct msghdr *msg,
+			int ifindex, struct sock *sk)
+{
+	struct bcm_sock *bo = bcm_sk(sk);
+	struct bcm_op *op;
+	int do_rx_register;
+	int err = 0;
+
+	if ((msg_head->flags & RX_FILTER_ID) || (!(msg_head->nframes))) {
+		/* be robust against wrong usage ... */
+		msg_head->flags |= RX_FILTER_ID;
+		/* ignore trailing garbage */
+		msg_head->nframes = 0;
+	}
+
+	if ((msg_head->flags & RX_RTR_FRAME) &&
+	    ((msg_head->nframes != 1) ||
+	     (!(msg_head->can_id & CAN_RTR_FLAG))))
+		return -EINVAL;
+
+	/* check the given can_id */
+	op = bcm_find_op(&bo->rx_ops, msg_head->can_id, ifindex);
+	if (op) {
+		/* update existing BCM operation */
+
+		/*
+		 * Do we need more space for the can_frames than currently
+		 * allocated? -> This is a _really_ unusual use-case and
+		 * therefore (complexity / locking) it is not supported.
+		 */
+		if (msg_head->nframes > op->nframes)
+			return -E2BIG;
+
+		if (msg_head->nframes) {
+			/* update can_frames content */
+			err = memcpy_fromiovec((u8 *)op->frames,
+					       msg->msg_iov,
+					       msg_head->nframes * CFSIZ);
+			if (err < 0)
+				return err;
+
+			/* clear last_frames to indicate 'nothing received' */
+			memset(op->last_frames, 0, msg_head->nframes * CFSIZ);
+		}
+
+		op->nframes = msg_head->nframes;
+
+		/* Only an update -> do not call can_rx_register() */
+		do_rx_register = 0;
+
+	} else {
+		/* insert new BCM operation for the given can_id */
+		op = kzalloc(OPSIZ, GFP_KERNEL);
+		if (!op)
+			return -ENOMEM;
+
+		op->can_id    = msg_head->can_id;
+		op->nframes   = msg_head->nframes;
+
+		if (msg_head->nframes > 1) {
+			/* create array for can_frames and copy the data */
+			op->frames = kmalloc(msg_head->nframes * CFSIZ,
+					     GFP_KERNEL);
+			if (!op->frames) {
+				kfree(op);
+				return -ENOMEM;
+			}
+
+			/* create and init array for received can_frames */
+			op->last_frames = kzalloc(msg_head->nframes * CFSIZ,
+						  GFP_KERNEL);
+			if (!op->last_frames) {
+				kfree(op->frames);
+				kfree(op);
+				return -ENOMEM;
+			}
+
+		} else {
+			op->frames = &op->sframe;
+			op->last_frames = &op->last_sframe;
+		}
+
+		if (msg_head->nframes) {
+			err = memcpy_fromiovec((u8 *)op->frames, msg->msg_iov,
+					       msg_head->nframes * CFSIZ);
+			if (err < 0) {
+				if (op->frames != &op->sframe)
+					kfree(op->frames);
+				if (op->last_frames != &op->last_sframe)
+					kfree(op->last_frames);
+				kfree(op);
+				return err;
+			}
+		}
+
+		/* bcm_can_tx / bcm_tx_timeout_handler needs this */
+		op->sk = sk;
+		op->ifindex = ifindex;
+
+		/* initialize uninitialized (kzalloc) structure */
+		setup_timer(&op->timer, bcm_rx_timeout_handler,
+			    (unsigned long)op);
+
+		/* init throttle timer for RX_CHANGED */
+		setup_timer(&op->thrtimer, bcm_rx_thr_handler,
+			    (unsigned long)op);
+
+		/* mark disabled timer */
+		op->thrtimer.expires = 0;
+
+		/* add this bcm_op to the list of the rx_ops */
+		list_add(&op->list, &bo->rx_ops);
+
+		/* call can_rx_register() */
+		do_rx_register = 1;
+
+	} /* if ((op = bcm_find_op(&bo->rx_ops, msg_head->can_id, ifindex))) */
+
+	/* check flags */
+	op->flags = msg_head->flags;
+
+	if (op->flags & RX_RTR_FRAME) {
+
+		/* no timers in RTR-mode */
+		del_timer(&op->thrtimer);
+		del_timer(&op->timer);
+
+		/*
+		 * funny feature in RX(!)_SETUP only for RTR-mode:
+		 * copy can_id into frame BUT without RTR-flag to
+		 * prevent a full-load-loopback-test ... ;-]
+		 */
+		if ((op->flags & TX_CP_CAN_ID) ||
+		    (op->frames[0].can_id == op->can_id))
+			op->frames[0].can_id = op->can_id & ~CAN_RTR_FLAG;
+
+	} else {
+		if (op->flags & SETTIMER) {
+
+			/* set timer value */
+			op->ival1 = msg_head->ival1;
+			op->ival2 = msg_head->ival2;
+			op->j_ival1 = rounded_tv2jif(&msg_head->ival1);
+			op->j_ival2 = rounded_tv2jif(&msg_head->ival2);
+
+			/* disable an active timer due to zero value? */
+			if (!op->j_ival1)
+				del_timer(&op->timer);
+
+			/*
+			 * In any case cancel the throttle timer, flush
+			 * potentially blocked msgs and reset throttle handling
+			 */
+			del_timer(&op->thrtimer);
+			bcm_rx_thr_flush(op);
+			op->thrtimer.expires = 0;
+		}
+
+		if ((op->flags & STARTTIMER) && op->j_ival1)
+			mod_timer(&op->timer, jiffies + op->j_ival1);
+	}
+
+	/* now we can register for can_ids, if we added a new bcm_op */
+	if (do_rx_register) {
+		if (ifindex) {
+			struct net_device *dev;
+
+			dev = dev_get_by_index(&init_net, ifindex);
+			if (dev) {
+				err = can_rx_register(dev, op->can_id,
+						      REGMASK(op->can_id),
+						      bcm_rx_handler, op,
+						      "bcm");
+
+				op->rx_reg_dev = dev;
+				dev_put(dev);
+			}
+
+		} else
+			err = can_rx_register(NULL, op->can_id,
+					      REGMASK(op->can_id),
+					      bcm_rx_handler, op, "bcm");
+		if (err) {
+			/* this bcm rx op is broken -> remove it */
+			list_del(&op->list);
+			bcm_remove_op(op);
+			return err;
+		}
+	}
+
+	return msg_head->nframes * CFSIZ + MHSIZ;
+}
+
+/*
+ * bcm_tx_send - send a single CAN frame to the CAN interface (for bcm_sendmsg)
+ */
+static int bcm_tx_send(struct msghdr *msg, int ifindex, struct sock *sk)
+{
+	struct sk_buff *skb;
+	struct net_device *dev;
+	int err;
+
+	/* we need a real device to send frames */
+	if (!ifindex)
+		return -ENODEV;
+
+	skb = alloc_skb(CFSIZ, GFP_KERNEL);
+
+	if (!skb)
+		return -ENOMEM;
+
+	err = memcpy_fromiovec(skb_put(skb, CFSIZ), msg->msg_iov, CFSIZ);
+	if (err < 0) {
+		kfree_skb(skb);
+		return err;
+	}
+
+	dev = dev_get_by_index(&init_net, ifindex);
+	if (!dev) {
+		kfree_skb(skb);
+		return -ENODEV;
+	}
+
+	skb->dev = dev;
+	skb->sk  = sk;
+	err = can_send(skb, 1); /* send with loopback */
+	dev_put(dev);
+
+	if (err)
+		return err;
+
+	return CFSIZ + MHSIZ;
+}
+
+/*
+ * bcm_sendmsg - process BCM commands (opcodes) from the userspace
+ */
+static int bcm_sendmsg(struct kiocb *iocb, struct socket *sock,
+		       struct msghdr *msg, size_t size)
+{
+	struct sock *sk = sock->sk;
+	struct bcm_sock *bo = bcm_sk(sk);
+	int ifindex = bo->ifindex; /* default ifindex for this bcm_op */
+	struct bcm_msg_head msg_head;
+	int ret; /* read bytes or error codes as return value */
+
+	if (!bo->bound)
+		return -ENOTCONN;
+
+	/* check for valid message length from userspace */
+	if (size < MHSIZ || (size - MHSIZ) % CFSIZ)
+		return -EINVAL;
+
+	/* check for alternative ifindex for this bcm_op */
+
+	if (!ifindex && msg->msg_name) {
+		/* no bound device as default => check msg_name */
+		struct sockaddr_can *addr =
+			(struct sockaddr_can *)msg->msg_name;
+
+		if (addr->can_family != AF_CAN)
+			return -EINVAL;
+
+		/* ifindex from sendto() */
+		ifindex = addr->can_ifindex;
+
+		if (ifindex) {
+			struct net_device *dev;
+
+			dev = dev_get_by_index(&init_net, ifindex);
+			if (!dev)
+				return -ENODEV;
+
+			if (dev->type != ARPHRD_CAN) {
+				dev_put(dev);
+				return -ENODEV;
+			}
+
+			dev_put(dev);
+		}
+	}
+
+	/* read message head information */
+
+	ret = memcpy_fromiovec((u8 *)&msg_head, msg->msg_iov, MHSIZ);
+	if (ret < 0)
+		return ret;
+
+	lock_sock(sk);
+
+	switch (msg_head.opcode) {
+
+	case TX_SETUP:
+		ret = bcm_tx_setup(&msg_head, msg, ifindex, sk);
+		break;
+
+	case RX_SETUP:
+		ret = bcm_rx_setup(&msg_head, msg, ifindex, sk);
+		break;
+
+	case TX_DELETE:
+		if (bcm_delete_tx_op(&bo->tx_ops, msg_head.can_id, ifindex))
+			ret = MHSIZ;
+		else
+			ret = -EINVAL;
+		break;
+
+	case RX_DELETE:
+		if (bcm_delete_rx_op(&bo->rx_ops, msg_head.can_id, ifindex))
+			ret = MHSIZ;
+		else
+			ret = -EINVAL;
+		break;
+
+	case TX_READ:
+		/* reuse msg_head for the reply to TX_READ */
+		msg_head.opcode  = TX_STATUS;
+		ret = bcm_read_op(&bo->tx_ops, &msg_head, ifindex);
+		break;
+
+	case RX_READ:
+		/* reuse msg_head for the reply to RX_READ */
+		msg_head.opcode  = RX_STATUS;
+		ret = bcm_read_op(&bo->rx_ops, &msg_head, ifindex);
+		break;
+
+	case TX_SEND:
+		/* we need exactly one can_frame behind the msg head */
+		if ((msg_head.nframes != 1) || (size != CFSIZ + MHSIZ))
+			ret = -EINVAL;
+		else
+			ret = bcm_tx_send(msg, ifindex, sk);
+		break;
+
+	default:
+		ret = -EINVAL;
+		break;
+	}
+
+	release_sock(sk);
+
+	return ret;
+}
+
+/*
+ * notification handler for netdevice status changes
+ */
+static int bcm_notifier(struct notifier_block *nb, unsigned long msg,
+			void *data)
+{
+	struct net_device *dev = (struct net_device *)data;
+	struct bcm_sock *bo = container_of(nb, struct bcm_sock, notifier);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,12)
+	struct sock *sk = &bo->sk;
+#else
+	struct sock *sk = bo->sk;
+#endif
+	struct bcm_op *op;
+	int notify_enodev = 0;
+
+	if (dev->type != ARPHRD_CAN)
+		return NOTIFY_DONE;
+
+	switch (msg) {
+
+	case NETDEV_UNREGISTER:
+		lock_sock(sk);
+
+		/* remove device specific receive entries */
+		list_for_each_entry(op, &bo->rx_ops, list)
+			if (op->rx_reg_dev == dev)
+				bcm_rx_unreg(dev, op);
+
+		/* remove device reference, if this is our bound device */
+		if (bo->bound && bo->ifindex == dev->ifindex) {
+			bo->bound   = 0;
+			bo->ifindex = 0;
+			notify_enodev = 1;
+		}
+
+		release_sock(sk);
+
+		if (notify_enodev) {
+			sk->sk_err = ENODEV;
+			if (!sock_flag(sk, SOCK_DEAD))
+				sk->sk_error_report(sk);
+		}
+		break;
+
+	case NETDEV_DOWN:
+		if (bo->bound && bo->ifindex == dev->ifindex) {
+			sk->sk_err = ENETDOWN;
+			if (!sock_flag(sk, SOCK_DEAD))
+				sk->sk_error_report(sk);
+		}
+	}
+
+	return NOTIFY_DONE;
+}
+
+/*
+ * initial settings for all BCM sockets to be set at socket creation time
+ */
+static int bcm_init(struct sock *sk)
+{
+	struct bcm_sock *bo = bcm_sk(sk);
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,12)
+	bo->sk               = sk;
+#endif
+	bo->bound            = 0;
+	bo->ifindex          = 0;
+	bo->dropped_usr_msgs = 0;
+	bo->bcm_proc_read    = NULL;
+
+	INIT_LIST_HEAD(&bo->tx_ops);
+	INIT_LIST_HEAD(&bo->rx_ops);
+
+	/* set notifier */
+	bo->notifier.notifier_call = bcm_notifier;
+
+	register_netdevice_notifier(&bo->notifier);
+
+	return 0;
+}
+
+/*
+ * standard socket functions
+ */
+static int bcm_release(struct socket *sock)
+{
+	struct sock *sk = sock->sk;
+	struct bcm_sock *bo = bcm_sk(sk);
+	struct bcm_op *op, *next;
+
+	/* remove bcm_ops, timer, rx_unregister(), etc. */
+
+	unregister_netdevice_notifier(&bo->notifier);
+
+	lock_sock(sk);
+
+	list_for_each_entry_safe(op, next, &bo->tx_ops, list)
+		bcm_remove_op(op);
+
+	list_for_each_entry_safe(op, next, &bo->rx_ops, list) {
+		/*
+		 * Don't care if we're bound or not (due to netdev problems)
+		 * can_rx_unregister() is always a save thing to do here.
+		 */
+		if (op->ifindex) {
+			/*
+			 * Only remove subscriptions that had not
+			 * been removed due to NETDEV_UNREGISTER
+			 * in bcm_notifier()
+			 */
+			if (op->rx_reg_dev) {
+				struct net_device *dev;
+
+				dev = dev_get_by_index(&init_net, op->ifindex);
+				if (dev) {
+					bcm_rx_unreg(dev, op);
+					dev_put(dev);
+				}
+			}
+		} else
+			can_rx_unregister(NULL, op->can_id,
+					  REGMASK(op->can_id),
+					  bcm_rx_handler, op);
+
+		bcm_remove_op(op);
+	}
+
+	/* remove procfs entry */
+	if (proc_dir && bo->bcm_proc_read)
+		remove_proc_entry(bo->procname, proc_dir);
+
+	/* remove device reference */
+	if (bo->bound) {
+		bo->bound   = 0;
+		bo->ifindex = 0;
+	}
+
+	sock_orphan(sk);
+	sock->sk = NULL;
+
+	release_sock(sk);
+	sock_put(sk);
+
+	return 0;
+}
+
+static int bcm_connect(struct socket *sock, struct sockaddr *uaddr, int len,
+		       int flags)
+{
+	struct sockaddr_can *addr = (struct sockaddr_can *)uaddr;
+	struct sock *sk = sock->sk;
+	struct bcm_sock *bo = bcm_sk(sk);
+
+	if (bo->bound)
+		return -EISCONN;
+
+	/* bind a device to this socket */
+	if (addr->can_ifindex) {
+		struct net_device *dev;
+
+		dev = dev_get_by_index(&init_net, addr->can_ifindex);
+		if (!dev)
+			return -ENODEV;
+
+		if (dev->type != ARPHRD_CAN) {
+			dev_put(dev);
+			return -ENODEV;
+		}
+
+		bo->ifindex = dev->ifindex;
+		dev_put(dev);
+
+	} else {
+		/* no interface reference for ifindex = 0 ('any' CAN device) */
+		bo->ifindex = 0;
+	}
+
+	bo->bound = 1;
+
+	if (proc_dir) {
+		/* unique socket address as filename */
+		sprintf(bo->procname, "%p", sock);
+		bo->bcm_proc_read = create_proc_read_entry(bo->procname, 0644,
+							   proc_dir,
+							   bcm_read_proc, sk);
+	}
+
+	return 0;
+}
+
+static int bcm_recvmsg(struct kiocb *iocb, struct socket *sock,
+		       struct msghdr *msg, size_t size, int flags)
+{
+	struct sock *sk = sock->sk;
+	struct sk_buff *skb;
+	int error = 0;
+	int noblock;
+	int err;
+
+	noblock =  flags & MSG_DONTWAIT;
+	flags   &= ~MSG_DONTWAIT;
+	skb = skb_recv_datagram(sk, flags, noblock, &error);
+	if (!skb)
+		return error;
+
+	if (skb->len < size)
+		size = skb->len;
+
+	err = memcpy_toiovec(msg->msg_iov, skb->data, size);
+	if (err < 0) {
+		skb_free_datagram(sk, skb);
+		return err;
+	}
+
+	sock_recv_timestamp(msg, sk, skb);
+
+	if (msg->msg_name) {
+		msg->msg_namelen = sizeof(struct sockaddr_can);
+		memcpy(msg->msg_name, skb->cb, msg->msg_namelen);
+	}
+
+	skb_free_datagram(sk, skb);
+
+	return size;
+}
+
+static const struct proto_ops bcm_ops = {
+	.family        = PF_CAN,
+	.release       = bcm_release,
+	.bind          = sock_no_bind,
+	.connect       = bcm_connect,
+	.socketpair    = sock_no_socketpair,
+	.accept        = sock_no_accept,
+	.getname       = sock_no_getname,
+	.poll          = datagram_poll,
+	.ioctl         = can_ioctl,	/* use can_ioctl() from af_can.c */
+	.listen        = sock_no_listen,
+	.shutdown      = sock_no_shutdown,
+	.setsockopt    = sock_no_setsockopt,
+	.getsockopt    = sock_no_getsockopt,
+	.sendmsg       = bcm_sendmsg,
+	.recvmsg       = bcm_recvmsg,
+	.mmap          = sock_no_mmap,
+	.sendpage      = sock_no_sendpage,
+};
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,12)
+static struct proto bcm_proto __read_mostly = {
+	.name       = "CAN_BCM",
+	.owner      = THIS_MODULE,
+	.obj_size   = sizeof(struct bcm_sock),
+	.init       = bcm_init,
+};
+
+static const struct can_proto bcm_can_proto = {
+	.type       = SOCK_DGRAM,
+	.protocol   = CAN_BCM,
+	.capability = -1,
+	.ops        = &bcm_ops,
+	.prot       = &bcm_proto,
+};
+#else
+static const struct can_proto bcm_can_proto = {
+	.type       = SOCK_DGRAM,
+	.protocol   = CAN_BCM,
+	.capability = -1,
+	.ops        = &bcm_ops,
+	.owner      = THIS_MODULE,
+	.obj_size   = sizeof(struct bcm_sock),
+	.init       = bcm_init,
+};
+#endif
+
+static int __init bcm_module_init(void)
+{
+	int err;
+
+	printk(banner);
+
+	err = can_proto_register(&bcm_can_proto);
+	if (err < 0) {
+		printk(KERN_ERR "can: registration of bcm protocol failed\n");
+		return err;
+	}
+
+	/* create /proc/net/can-bcm directory */
+	proc_dir = proc_mkdir("can-bcm", proc_net);
+
+	if (proc_dir)
+		proc_dir->owner = THIS_MODULE;
+
+	return 0;
+}
+
+static void __exit bcm_module_exit(void)
+{
+	can_proto_unregister(&bcm_can_proto);
+
+	if (proc_dir)
+		proc_net_remove("can-bcm");
+}
+
+module_init(bcm_module_init);
+module_exit(bcm_module_exit);
diff --exclude CVS --exclude .git -uNr linux-2.6.27.8/net/can/bcm.c linux-2.6.27.8.modified/net/can/bcm.c
--- linux-2.6.27.8/net/can/bcm.c	2008-12-05 15:03:02.000000000 -0500
+++ linux-2.6.27.8.modified/net/can/bcm.c	2013-05-30 03:44:16.000000000 -0400
@@ -42,21 +42,40 @@
  */
 
 #include <linux/module.h>
+#include <linux/version.h>
 #include <linux/init.h>
 #include <linux/hrtimer.h>
 #include <linux/list.h>
 #include <linux/proc_fs.h>
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,26)
+#include <linux/seq_file.h>
+#endif
 #include <linux/uio.h>
 #include <linux/net.h>
 #include <linux/netdevice.h>
 #include <linux/socket.h>
 #include <linux/if_arp.h>
 #include <linux/skbuff.h>
-#include <linux/can.h>
-#include <linux/can/core.h>
-#include <linux/can/bcm.h>
+#include <socketcan/can.h>
+#include <socketcan/can/core.h>
+#include <socketcan/can/bcm.h>
 #include <net/sock.h>
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,24)
 #include <net/net_namespace.h>
+#endif
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,25)
+#include "compat.h"
+#endif
+
+#include <socketcan/can/version.h> /* for RCSID. Removed by mkpatch script */
+RCSID("$Id: bcm.c 1259 2011-06-02 18:58:43Z hartkopp $");
+
+/*
+ * To send multiple CAN frame content within TX_SETUP or to filter
+ * CAN messages with multiplex index within RX_SETUP, the number of
+ * different filters is limited to 256 due to the one byte index value. 
+ */
+#define MAX_NFRAMES 256
 
 /* use of last_frames[index].can_dlc */
 #define RX_RECV    0x40 /* received data for this element */
@@ -64,16 +83,23 @@
 #define BCM_CAN_DLC_MASK 0x0F /* clean private flags in can_dlc by masking */
 
 /* get best masking value for can_rx_register() for a given single can_id */
-#define REGMASK(id) ((id & CAN_RTR_FLAG) | ((id & CAN_EFF_FLAG) ? \
-			(CAN_EFF_MASK | CAN_EFF_FLAG) : CAN_SFF_MASK))
+#define REGMASK(id) ((id & CAN_EFF_FLAG) ? \
+		     (CAN_EFF_MASK | CAN_EFF_FLAG | CAN_RTR_FLAG) : \
+		     (CAN_SFF_MASK | CAN_EFF_FLAG | CAN_RTR_FLAG))
 
-#define CAN_BCM_VERSION "20080415"
+#define CAN_BCM_VERSION CAN_VERSION
 static __initdata const char banner[] = KERN_INFO
-	"can: broadcast manager protocol (rev " CAN_BCM_VERSION ")\n";
+	"can: broadcast manager protocol (rev " CAN_BCM_VERSION " t)\n";
 
 MODULE_DESCRIPTION("PF_CAN broadcast manager protocol");
 MODULE_LICENSE("Dual BSD/GPL");
 MODULE_AUTHOR("Oliver Hartkopp <oliver.hartkopp@volkswagen.de>");
+MODULE_ALIAS("can-proto-2");
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,22)
+#error This code only supports Kernel versions 2.6.22+
+#error For older 2.6 Kernels please use bcm-prior-2-6-22.c instead of bcm.c
+#endif
 
 /* easy access to can_frame payload */
 static inline u64 GET_U64(const struct can_frame *cp)
@@ -85,15 +111,16 @@
 	struct list_head list;
 	int ifindex;
 	canid_t can_id;
-	int flags;
+	u32 flags;
 	unsigned long frames_abs, frames_filtered;
 	struct timeval ival1, ival2;
 	struct hrtimer timer, thrtimer;
+	struct tasklet_struct tsklet, thrtsklet;
 	ktime_t rx_stamp, kt_ival1, kt_ival2, kt_lastmsg;
 	int rx_ifindex;
-	int count;
-	int nframes;
-	int currframe;
+	u32 count;
+	u32 nframes;
+	u32 currframe;
 	struct can_frame *frames;
 	struct can_frame *last_frames;
 	struct can_frame sframe;
@@ -113,7 +140,7 @@
 	struct list_head tx_ops;
 	unsigned long dropped_usr_msgs;
 	struct proc_dir_entry *bcm_proc_read;
-	char procname [9]; /* pointer printed in ASCII with \0 */
+	char procname [32]; /* inode number in decimal with \0 */
 };
 
 static inline struct bcm_sock *bcm_sk(const struct sock *sk)
@@ -128,24 +155,114 @@
 /*
  * procfs functions
  */
-static char *bcm_proc_getifname(int ifindex)
+static char *bcm_proc_getifname(char *result, int ifindex)
 {
 	struct net_device *dev;
 
 	if (!ifindex)
 		return "any";
 
-	/* no usage counting */
+	read_lock(&dev_base_lock);
 	dev = __dev_get_by_index(&init_net, ifindex);
 	if (dev)
-		return dev->name;
+		strcpy(result, dev->name);
+	else
+		strcpy(result, "???");
+	read_unlock(&dev_base_lock);
+
+	return result;
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,26)
+static int bcm_proc_show(struct seq_file *m, void *v)
+{
+	char ifname[IFNAMSIZ];
+	struct sock *sk = (struct sock *)m->private;
+	struct bcm_sock *bo = bcm_sk(sk);
+	struct bcm_op *op;
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,0,0)
+	seq_printf(m, ">>> socket %p", sk->sk_socket);
+	seq_printf(m, " / sk %p", sk);
+	seq_printf(m, " / bo %p", bo);
+#else
+	seq_printf(m, ">>> socket %pK", sk->sk_socket);
+	seq_printf(m, " / sk %pK", sk);
+	seq_printf(m, " / bo %pK", bo);
+#endif
+	seq_printf(m, " / dropped %lu", bo->dropped_usr_msgs);
+	seq_printf(m, " / bound %s", bcm_proc_getifname(ifname, bo->ifindex));
+	seq_printf(m, " <<<\n");
+
+	list_for_each_entry(op, &bo->rx_ops, list) {
+
+		unsigned long reduction;
+
+		/* print only active entries & prevent division by zero */
+		if (!op->frames_abs)
+			continue;
+
+		seq_printf(m, "rx_op: %03X %-5s ",
+				op->can_id, bcm_proc_getifname(ifname, op->ifindex));
+		seq_printf(m, "[%u]%c ", op->nframes,
+				(op->flags & RX_CHECK_DLC)?'d':' ');
+		if (op->kt_ival1.tv64)
+			seq_printf(m, "timeo=%lld ",
+					(long long)
+					ktime_to_us(op->kt_ival1));
+
+		if (op->kt_ival2.tv64)
+			seq_printf(m, "thr=%lld ",
+					(long long)
+					ktime_to_us(op->kt_ival2));
+
+		seq_printf(m, "# recv %ld (%ld) => reduction: ",
+				op->frames_filtered, op->frames_abs);
+
+		reduction = 100 - (op->frames_filtered * 100) / op->frames_abs;
+
+		seq_printf(m, "%s%ld%%\n",
+				(reduction == 100)?"near ":"", reduction);
+	}
+
+	list_for_each_entry(op, &bo->tx_ops, list) {
+
+		seq_printf(m, "tx_op: %03X %s [%u] ",
+				op->can_id,
+				bcm_proc_getifname(ifname, op->ifindex),
+				op->nframes);
+
+		if (op->kt_ival1.tv64)
+			seq_printf(m, "t1=%lld ",
+					(long long) ktime_to_us(op->kt_ival1));
 
-	return "???";
+		if (op->kt_ival2.tv64)
+			seq_printf(m, "t2=%lld ",
+					(long long) ktime_to_us(op->kt_ival2));
+
+		seq_printf(m, "# sent %ld\n", op->frames_abs);
+	}
+	seq_putc(m, '\n');
+	return 0;
+}
+
+static int bcm_proc_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, bcm_proc_show, PDE(inode)->data);
 }
 
+static const struct file_operations bcm_proc_fops = {
+	.owner		= THIS_MODULE,
+	.open		= bcm_proc_open,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+};
+#else
 static int bcm_read_proc(char *page, char **start, off_t off,
 			 int count, int *eof, void *data)
 {
+	char ifname[IFNAMSIZ];
 	int len = 0;
 	struct sock *sk = (struct sock *)data;
 	struct bcm_sock *bo = bcm_sk(sk);
@@ -158,7 +275,7 @@
 	len += snprintf(page + len, PAGE_SIZE - len, " / dropped %lu",
 			bo->dropped_usr_msgs);
 	len += snprintf(page + len, PAGE_SIZE - len, " / bound %s",
-			bcm_proc_getifname(bo->ifindex));
+			bcm_proc_getifname(ifname, bo->ifindex));
 	len += snprintf(page + len, PAGE_SIZE - len, " <<<\n");
 
 	list_for_each_entry(op, &bo->rx_ops, list) {
@@ -171,7 +288,7 @@
 
 		len += snprintf(page + len, PAGE_SIZE - len,
 				"rx_op: %03X %-5s ",
-				op->can_id, bcm_proc_getifname(op->ifindex));
+				op->can_id, bcm_proc_getifname(ifname, op->ifindex));
 		len += snprintf(page + len, PAGE_SIZE - len, "[%d]%c ",
 				op->nframes,
 				(op->flags & RX_CHECK_DLC)?'d':' ');
@@ -207,7 +324,8 @@
 
 		len += snprintf(page + len, PAGE_SIZE - len,
 				"tx_op: %03X %s [%d] ",
-				op->can_id, bcm_proc_getifname(op->ifindex),
+				op->can_id,
+				bcm_proc_getifname(ifname, op->ifindex),
 				op->nframes);
 
 		if (op->kt_ival1.tv64)
@@ -233,6 +351,7 @@
 	*eof = 1;
 	return len;
 }
+#endif
 
 /*
  * bcm_can_tx - send the (next) CAN frame to the appropriate CAN interface
@@ -287,7 +406,7 @@
 	struct can_frame *firstframe;
 	struct sockaddr_can *addr;
 	struct sock *sk = op->sk;
-	int datalen = head->nframes * CFSIZ;
+	unsigned int datalen = head->nframes * CFSIZ;
 	int err;
 
 	skb = alloc_skb(sizeof(*head) + datalen, gfp_any());
@@ -340,19 +459,15 @@
 	}
 }
 
-/*
- * bcm_tx_timeout_handler - performes cyclic CAN frame transmissions
- */
-static enum hrtimer_restart bcm_tx_timeout_handler(struct hrtimer *hrtimer)
+static void bcm_tx_timeout_tsklet(unsigned long data)
 {
-	struct bcm_op *op = container_of(hrtimer, struct bcm_op, timer);
-	enum hrtimer_restart ret = HRTIMER_NORESTART;
+	struct bcm_op *op = (struct bcm_op *)data;
+	struct bcm_msg_head msg_head;
 
 	if (op->kt_ival1.tv64 && (op->count > 0)) {
 
 		op->count--;
 		if (!op->count && (op->flags & TX_COUNTEVT)) {
-			struct bcm_msg_head msg_head;
 
 			/* create notification to user */
 			msg_head.opcode  = TX_EXPIRED;
@@ -371,20 +486,32 @@
 
 		/* send (next) frame */
 		bcm_can_tx(op);
-		hrtimer_forward(hrtimer, ktime_get(), op->kt_ival1);
-		ret = HRTIMER_RESTART;
+		hrtimer_start(&op->timer,
+			      ktime_add(ktime_get(), op->kt_ival1),
+			      HRTIMER_MODE_ABS);
 
 	} else {
 		if (op->kt_ival2.tv64) {
 
 			/* send (next) frame */
 			bcm_can_tx(op);
-			hrtimer_forward(hrtimer, ktime_get(), op->kt_ival2);
-			ret = HRTIMER_RESTART;
+			hrtimer_start(&op->timer,
+				      ktime_add(ktime_get(), op->kt_ival2),
+				      HRTIMER_MODE_ABS);
 		}
 	}
+}
 
-	return ret;
+/*
+ * bcm_tx_timeout_handler - performs cyclic CAN frame transmissions
+ */
+static enum hrtimer_restart bcm_tx_timeout_handler(struct hrtimer *hrtimer)
+{
+	struct bcm_op *op = container_of(hrtimer, struct bcm_op, timer);
+
+	tasklet_schedule(&op->tsklet);
+
+	return HRTIMER_NORESTART;
 }
 
 /*
@@ -401,6 +528,9 @@
 	if (op->frames_filtered > ULONG_MAX/100)
 		op->frames_filtered = op->frames_abs = 0;
 
+	/* this element is not throttled anymore */
+	data->can_dlc &= (BCM_CAN_DLC_MASK|RX_RECV);
+
 	head.opcode  = RX_CHANGED;
 	head.flags   = op->flags;
 	head.count   = op->count;
@@ -412,6 +542,19 @@
 	bcm_send_to_user(op, &head, data, 1);
 }
 
+#if LINUX_VERSION_CODE == KERNEL_VERSION(2,6,25)
+/* is part of linux/hrtimer.h since 2.6.26 */
+static inline int hrtimer_callback_running(struct hrtimer *timer)
+{
+	return timer->state & HRTIMER_STATE_CALLBACK;
+}
+#endif
+#if LINUX_VERSION_CODE == KERNEL_VERSION(2,6,22)
+static inline s64 ktime_us_delta(const ktime_t later, const ktime_t earlier)
+{
+	return ktime_to_us(ktime_sub(later, earlier));
+}
+#endif
 /*
  * bcm_rx_update_and_send - process a detected relevant receive content change
  *                          1. update the last received data
@@ -419,37 +562,32 @@
  */
 static void bcm_rx_update_and_send(struct bcm_op *op,
 				   struct can_frame *lastdata,
-				   struct can_frame *rxdata)
+				   const struct can_frame *rxdata)
 {
 	memcpy(lastdata, rxdata, CFSIZ);
 
-	/* mark as used */
-	lastdata->can_dlc |= RX_RECV;
+	/* mark as used and throttled by default */
+	lastdata->can_dlc |= (RX_RECV|RX_THR);
 
-	/* throtteling mode inactive OR data update already on the run ? */
-	if (!op->kt_ival2.tv64 || hrtimer_callback_running(&op->thrtimer)) {
+	/* throtteling mode inactive ? */
+	if (!op->kt_ival2.tv64) {
 		/* send RX_CHANGED to the user immediately */
-		bcm_rx_changed(op, rxdata);
+		bcm_rx_changed(op, lastdata);
 		return;
 	}
 
-	if (hrtimer_active(&op->thrtimer)) {
-		/* mark as 'throttled' */
-		lastdata->can_dlc |= RX_THR;
+	/* with active throttling timer we are just done here */
+	if (hrtimer_active(&op->thrtimer))
 		return;
-	}
 
-	if (!op->kt_lastmsg.tv64) {
-		/* send first RX_CHANGED to the user immediately */
-		bcm_rx_changed(op, rxdata);
-		op->kt_lastmsg = ktime_get();
-		return;
-	}
+	/* first receiption with enabled throttling mode */
+	if (!op->kt_lastmsg.tv64)
+		goto rx_changed_settime;
 
+	/* got a second frame inside a potential throttle period? */
 	if (ktime_us_delta(ktime_get(), op->kt_lastmsg) <
 	    ktime_to_us(op->kt_ival2)) {
-		/* mark as 'throttled' and start timer */
-		lastdata->can_dlc |= RX_THR;
+		/* do not send the saved data - only start throttle timer */
 		hrtimer_start(&op->thrtimer,
 			      ktime_add(op->kt_lastmsg, op->kt_ival2),
 			      HRTIMER_MODE_ABS);
@@ -457,7 +595,8 @@
 	}
 
 	/* the gap was that big, that throttling was not needed here */
-	bcm_rx_changed(op, rxdata);
+rx_changed_settime:
+	bcm_rx_changed(op, lastdata);
 	op->kt_lastmsg = ktime_get();
 }
 
@@ -465,8 +604,8 @@
  * bcm_rx_cmp_to_index - (bit)compares the currently received data to formerly
  *                       received data stored in op->last_frames[]
  */
-static void bcm_rx_cmp_to_index(struct bcm_op *op, int index,
-				struct can_frame *rxdata)
+static void bcm_rx_cmp_to_index(struct bcm_op *op, unsigned int index,
+				const struct can_frame *rxdata)
 {
 	/*
 	 * no one uses the MSBs of can_dlc for comparation,
@@ -510,14 +649,12 @@
 		hrtimer_start(&op->timer, op->kt_ival1, HRTIMER_MODE_REL);
 }
 
-/*
- * bcm_rx_timeout_handler - when the (cyclic) CAN frame receiption timed out
- */
-static enum hrtimer_restart bcm_rx_timeout_handler(struct hrtimer *hrtimer)
+static void bcm_rx_timeout_tsklet(unsigned long data)
 {
-	struct bcm_op *op = container_of(hrtimer, struct bcm_op, timer);
+	struct bcm_op *op = (struct bcm_op *)data;
 	struct bcm_msg_head msg_head;
 
+	/* create notification to user */
 	msg_head.opcode  = RX_TIMEOUT;
 	msg_head.flags   = op->flags;
 	msg_head.count   = op->count;
@@ -527,6 +664,17 @@
 	msg_head.nframes = 0;
 
 	bcm_send_to_user(op, &msg_head, NULL, 0);
+}
+
+/*
+ * bcm_rx_timeout_handler - when the (cyclic) CAN frame receiption timed out
+ */
+static enum hrtimer_restart bcm_rx_timeout_handler(struct hrtimer *hrtimer)
+{
+	struct bcm_op *op = container_of(hrtimer, struct bcm_op, timer);
+
+	/* schedule before NET_RX_SOFTIRQ */
+	tasklet_hi_schedule(&op->tsklet);
 
 	/* no restart of the timer is done here! */
 
@@ -540,37 +688,52 @@
 }
 
 /*
+ * bcm_rx_do_flush - helper for bcm_rx_thr_flush
+ */
+static inline int bcm_rx_do_flush(struct bcm_op *op, int update,
+				  unsigned int index)
+{
+	if ((op->last_frames) && (op->last_frames[index].can_dlc & RX_THR)) {
+		if (update)
+			bcm_rx_changed(op, &op->last_frames[index]);
+		return 1;
+	}
+	return 0;
+}
+
+/*
  * bcm_rx_thr_flush - Check for throttled data and send it to the userspace
+ *
+ * update == 0 : just check if throttled data is available  (any irq context)
+ * update == 1 : check and send throttled data to userspace (soft_irq context)
  */
-static int bcm_rx_thr_flush(struct bcm_op *op)
+static int bcm_rx_thr_flush(struct bcm_op *op, int update)
 {
 	int updated = 0;
 
 	if (op->nframes > 1) {
-		int i;
+		unsigned int i;
 
 		/* for MUX filter we start at index 1 */
-		for (i = 1; i < op->nframes; i++) {
-			if ((op->last_frames) &&
-			    (op->last_frames[i].can_dlc & RX_THR)) {
-				op->last_frames[i].can_dlc &= ~RX_THR;
-				bcm_rx_changed(op, &op->last_frames[i]);
-				updated++;
-			}
-		}
+		for (i = 1; i < op->nframes; i++)
+			updated += bcm_rx_do_flush(op, update, i);
 
 	} else {
 		/* for RX_FILTER_ID and simple filter */
-		if (op->last_frames && (op->last_frames[0].can_dlc & RX_THR)) {
-			op->last_frames[0].can_dlc &= ~RX_THR;
-			bcm_rx_changed(op, &op->last_frames[0]);
-			updated++;
-		}
+		updated += bcm_rx_do_flush(op, update, 0);
 	}
 
 	return updated;
 }
 
+static void bcm_rx_thr_tsklet(unsigned long data)
+{
+	struct bcm_op *op = (struct bcm_op *)data;
+
+	/* push the changed data to the userspace */
+	bcm_rx_thr_flush(op, 1);
+}
+
 /*
  * bcm_rx_thr_handler - the time for blocked content updates is over now:
  *                      Check for throttled data and send it to the userspace
@@ -579,7 +742,9 @@
 {
 	struct bcm_op *op = container_of(hrtimer, struct bcm_op, thrtimer);
 
-	if (bcm_rx_thr_flush(op)) {
+	tasklet_schedule(&op->thrtsklet);
+
+	if (bcm_rx_thr_flush(op, 0)) {
 		hrtimer_forward(hrtimer, ktime_get(), op->kt_ival2);
 		return HRTIMER_RESTART;
 	} else {
@@ -595,29 +760,21 @@
 static void bcm_rx_handler(struct sk_buff *skb, void *data)
 {
 	struct bcm_op *op = (struct bcm_op *)data;
-	struct can_frame rxframe;
-	int i;
+	const struct can_frame *rxframe = (struct can_frame *)skb->data;
+	unsigned int i;
 
 	/* disable timeout */
 	hrtimer_cancel(&op->timer);
 
-	if (skb->len == sizeof(rxframe)) {
-		memcpy(&rxframe, skb->data, sizeof(rxframe));
-		/* save rx timestamp */
-		op->rx_stamp = skb->tstamp;
-		/* save originator for recvfrom() */
-		op->rx_ifindex = skb->dev->ifindex;
-		/* update statistics */
-		op->frames_abs++;
-		kfree_skb(skb);
-
-	} else {
-		kfree_skb(skb);
+	if (op->can_id != rxframe->can_id)
 		return;
-	}
 
-	if (op->can_id != rxframe.can_id)
-		return;
+	/* save rx timestamp */
+	op->rx_stamp = skb->tstamp;
+	/* save originator for recvfrom() */
+	op->rx_ifindex = skb->dev->ifindex;
+	/* update statistics */
+	op->frames_abs++;
 
 	if (op->flags & RX_RTR_FRAME) {
 		/* send reply for RTR-request (placed in op->frames[0]) */
@@ -627,16 +784,14 @@
 
 	if (op->flags & RX_FILTER_ID) {
 		/* the easiest case */
-		bcm_rx_update_and_send(op, &op->last_frames[0], &rxframe);
-		bcm_rx_starttimer(op);
-		return;
+		bcm_rx_update_and_send(op, &op->last_frames[0], rxframe);
+		goto rx_starttimer;
 	}
 
 	if (op->nframes == 1) {
 		/* simple compare with index 0 */
-		bcm_rx_cmp_to_index(op, 0, &rxframe);
-		bcm_rx_starttimer(op);
-		return;
+		bcm_rx_cmp_to_index(op, 0, rxframe);
+		goto rx_starttimer;
 	}
 
 	if (op->nframes > 1) {
@@ -648,15 +803,17 @@
 		 */
 
 		for (i = 1; i < op->nframes; i++) {
-			if ((GET_U64(&op->frames[0]) & GET_U64(&rxframe)) ==
+			if ((GET_U64(&op->frames[0]) & GET_U64(rxframe)) ==
 			    (GET_U64(&op->frames[0]) &
 			     GET_U64(&op->frames[i]))) {
-				bcm_rx_cmp_to_index(op, i, &rxframe);
+				bcm_rx_cmp_to_index(op, i, rxframe);
 				break;
 			}
 		}
-		bcm_rx_starttimer(op);
 	}
+
+rx_starttimer:
+	bcm_rx_starttimer(op);
 }
 
 /*
@@ -680,6 +837,12 @@
 	hrtimer_cancel(&op->timer);
 	hrtimer_cancel(&op->thrtimer);
 
+	if (op->tsklet.func)
+		tasklet_kill(&op->tsklet);
+
+	if (op->thrtsklet.func)
+		tasklet_kill(&op->thrtsklet);
+
 	if ((op->frames) && (op->frames != &op->sframe))
 		kfree(op->frames);
 
@@ -798,14 +961,15 @@
 {
 	struct bcm_sock *bo = bcm_sk(sk);
 	struct bcm_op *op;
-	int i, err;
+	unsigned int i;
+	int err;
 
 	/* we need a real device to send frames */
 	if (!ifindex)
 		return -ENODEV;
 
-	/* we need at least one can_frame */
-	if (msg_head->nframes < 1)
+	/* check nframes boundaries - we need at least one can_frame */
+	if (msg_head->nframes < 1 || msg_head->nframes > MAX_NFRAMES)
 		return -EINVAL;
 
 	/* check the given can_id */
@@ -890,6 +1054,10 @@
 		hrtimer_init(&op->timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
 		op->timer.function = bcm_tx_timeout_handler;
 
+		/* initialize tasklet for tx countevent notification */
+		tasklet_init(&op->tsklet, bcm_tx_timeout_tsklet,
+			     (unsigned long) op);
+
 		/* currently unused in tx_ops */
 		hrtimer_init(&op->thrtimer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
 
@@ -965,6 +1133,10 @@
 		msg_head->nframes = 0;
 	}
 
+	/* the first element contains the mux-mask => MAX_NFRAMES + 1  */
+	if (msg_head->nframes > MAX_NFRAMES + 1)
+		return -EINVAL;
+
 	if ((msg_head->flags & RX_RTR_FRAME) &&
 	    ((msg_head->nframes != 1) ||
 	     (!(msg_head->can_id & CAN_RTR_FLAG))))
@@ -1053,9 +1225,17 @@
 		hrtimer_init(&op->timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
 		op->timer.function = bcm_rx_timeout_handler;
 
+		/* initialize tasklet for rx timeout notification */
+		tasklet_init(&op->tsklet, bcm_rx_timeout_tsklet,
+			     (unsigned long) op);
+
 		hrtimer_init(&op->thrtimer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
 		op->thrtimer.function = bcm_rx_thr_handler;
 
+		/* initialize tasklet for rx throttle handling */
+		tasklet_init(&op->thrtsklet, bcm_rx_thr_tsklet,
+			     (unsigned long) op);
+
 		/* add this bcm_op to the list of the rx_ops */
 		list_add(&op->list, &bo->rx_ops);
 
@@ -1101,7 +1281,7 @@
 			 */
 			op->kt_lastmsg = ktime_set(0, 0);
 			hrtimer_cancel(&op->thrtimer);
-			bcm_rx_thr_flush(op);
+			bcm_rx_thr_flush(op, 1);
 		}
 
 		if ((op->flags & STARTTIMER) && op->kt_ival1.tv64)
@@ -1207,6 +1387,9 @@
 		struct sockaddr_can *addr =
 			(struct sockaddr_can *)msg->msg_name;
 
+		if (msg->msg_namelen < required_size(can_ifindex, *addr))
+			return -EINVAL;
+
 		if (addr->can_family != AF_CAN)
 			return -EINVAL;
 
@@ -1303,8 +1486,13 @@
 	struct bcm_op *op;
 	int notify_enodev = 0;
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,26)
 	if (!net_eq(dev_net(dev), &init_net))
 		return NOTIFY_DONE;
+#elif LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,24)
+	if (dev->nd_net != &init_net)
+		return NOTIFY_DONE;
+#endif
 
 	if (dev->type != ARPHRD_CAN)
 		return NOTIFY_DONE;
@@ -1375,9 +1563,14 @@
 static int bcm_release(struct socket *sock)
 {
 	struct sock *sk = sock->sk;
-	struct bcm_sock *bo = bcm_sk(sk);
+	struct bcm_sock *bo;
 	struct bcm_op *op, *next;
 
+	if (sk == NULL)
+		return 0;
+
+	bo = bcm_sk(sk);
+
 	/* remove bcm_ops, timer, rx_unregister(), etc. */
 
 	unregister_netdevice_notifier(&bo->notifier);
@@ -1425,6 +1618,9 @@
 		bo->ifindex = 0;
 	}
 
+	sock_orphan(sk);
+	sock->sk = NULL;
+
 	release_sock(sk);
 	sock_put(sk);
 
@@ -1438,6 +1634,9 @@
 	struct sock *sk = sock->sk;
 	struct bcm_sock *bo = bcm_sk(sk);
 
+	if (len < required_size(can_ifindex, *addr))
+ 		return -EINVAL;
+
 	if (bo->bound)
 		return -EISCONN;
 
@@ -1466,10 +1665,16 @@
 
 	if (proc_dir) {
 		/* unique socket address as filename */
-		sprintf(bo->procname, "%p", sock);
+		sprintf(bo->procname, "%lu", sock_i_ino(sk));
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,26)
+		bo->bcm_proc_read = proc_create_data(bo->procname, 0644,
+						     proc_dir,
+						     &bcm_proc_fops, sk);
+#else
 		bo->bcm_proc_read = create_proc_read_entry(bo->procname, 0644,
 							   proc_dir,
 							   bcm_read_proc, sk);
+#endif
 	}
 
 	return 0;
@@ -1511,7 +1716,7 @@
 	return size;
 }
 
-static struct proto_ops bcm_ops __read_mostly = {
+static const struct proto_ops bcm_ops = {
 	.family        = PF_CAN,
 	.release       = bcm_release,
 	.bind          = sock_no_bind,
@@ -1520,7 +1725,7 @@
 	.accept        = sock_no_accept,
 	.getname       = sock_no_getname,
 	.poll          = datagram_poll,
-	.ioctl         = NULL,		/* use can_ioctl() from af_can.c */
+	.ioctl         = can_ioctl,	/* use can_ioctl() from af_can.c */
 	.listen        = sock_no_listen,
 	.shutdown      = sock_no_shutdown,
 	.setsockopt    = sock_no_setsockopt,
@@ -1538,10 +1743,12 @@
 	.init       = bcm_init,
 };
 
-static struct can_proto bcm_can_proto __read_mostly = {
+static const struct can_proto bcm_can_proto = {
 	.type       = SOCK_DGRAM,
 	.protocol   = CAN_BCM,
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,33)
 	.capability = -1,
+#endif
 	.ops        = &bcm_ops,
 	.prot       = &bcm_proto,
 };
@@ -1559,10 +1766,16 @@
 	}
 
 	/* create /proc/net/can-bcm directory */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,24)
 	proc_dir = proc_mkdir("can-bcm", init_net.proc_net);
+#else
+	proc_dir = proc_mkdir("can-bcm", proc_net);
+#endif
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,30)
 	if (proc_dir)
 		proc_dir->owner = THIS_MODULE;
+#endif
 
 	return 0;
 }
@@ -1572,7 +1785,11 @@
 	can_proto_unregister(&bcm_can_proto);
 
 	if (proc_dir)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,24)
 		proc_net_remove(&init_net, "can-bcm");
+#else
+		proc_net_remove("can-bcm");
+#endif
 }
 
 module_init(bcm_module_init);
diff --exclude CVS --exclude .git -uNr linux-2.6.27.8/net/can/compat.h linux-2.6.27.8.modified/net/can/compat.h
--- linux-2.6.27.8/net/can/compat.h	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.27.8.modified/net/can/compat.h	2013-05-30 03:44:16.000000000 -0400
@@ -0,0 +1,67 @@
+/*
+ * $Id: compat.h 1038 2009-08-21 10:00:21Z hartkopp $
+ */
+
+#ifndef CAN_COMPAT_H
+#define CAN_COMPAT_H
+
+#ifndef PF_CAN
+#define PF_CAN 29
+#endif
+
+#ifndef AF_CAN
+#define AF_CAN PF_CAN
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,14)
+static inline void *kzalloc(size_t size, unsigned int __nocast flags)
+{
+	void *ret = kmalloc(size, flags);
+	if (ret)
+		memset(ret, 0, size);
+	return ret;
+}
+
+static inline void skb_get_timestamp(const struct sk_buff *skb,
+				     struct timeval *stamp)
+{
+	stamp->tv_sec  = skb->stamp.tv_sec;
+	stamp->tv_usec = skb->stamp.tv_usec;
+}
+
+static inline void skb_set_timestamp(struct sk_buff *skb,
+				     const struct timeval *stamp)
+{
+	skb->stamp.tv_sec  = stamp->tv_sec;
+	skb->stamp.tv_usec = stamp->tv_usec;
+}
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,15)
+static inline void setup_timer(struct timer_list * timer,
+				void (*function)(unsigned long),
+				unsigned long data)
+{
+	timer->function = function;
+	timer->data = data;
+	init_timer(timer);
+}
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,20)
+#define round_jiffies(j) (j)
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,24)
+#define   dev_get_by_index(ns, ifindex)   dev_get_by_index(ifindex)
+#define __dev_get_by_index(ns, ifindex) __dev_get_by_index(ifindex)
+#endif
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,22)
+#include <linux/hrtimer.h>
+static inline int hrtimer_callback_running(struct hrtimer *timer)
+{
+        return timer->state & HRTIMER_STATE_CALLBACK;
+}
+#endif
+#endif
diff --exclude CVS --exclude .git -uNr linux-2.6.27.8/net/can/gw.c linux-2.6.27.8.modified/net/can/gw.c
--- linux-2.6.27.8/net/can/gw.c	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.27.8.modified/net/can/gw.c	2013-05-30 03:44:16.000000000 -0400
@@ -0,0 +1,966 @@
+/*
+ * gw.c - CAN frame Gateway/Router/Bridge with netlink interface
+ *
+ * Copyright (c) 2002-2010 Volkswagen Group Electronic Research
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of Volkswagen nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * Alternatively, provided that this notice is retained in full, this
+ * software may be distributed under the terms of the GNU General
+ * Public License ("GPL") version 2, in which case the provisions of the
+ * GPL apply INSTEAD OF those given above.
+ *
+ * The provided data structures and external interfaces from this code
+ * are not restricted to be used by modules with a GPL compatible license.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * Send feedback to <socketcan-users@lists.berlios.de>
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/version.h>
+#include <linux/init.h>
+#include <linux/types.h>
+#include <linux/list.h>
+#include <linux/spinlock.h>
+#include <linux/rcupdate.h>
+#include <linux/rculist.h>
+#include <linux/net.h>
+#include <linux/netdevice.h>
+#include <linux/if_arp.h>
+#include <linux/skbuff.h>
+#include <socketcan/can.h>
+#include <socketcan/can/core.h>
+#include <socketcan/can/gw.h>
+#include <net/rtnetlink.h>
+#include <net/net_namespace.h>
+#include <net/sock.h>
+
+#include <socketcan/can/version.h> /* for RCSID. Removed by mkpatch script */
+RCSID("$Id: gw.c 1225 2010-12-09 18:58:59Z hartkopp $");
+
+#define CAN_GW_VERSION "20101209"
+static __initdata const char banner[] =
+	KERN_INFO "can: netlink gateway (rev " CAN_GW_VERSION ")\n";
+
+MODULE_DESCRIPTION("PF_CAN netlink gateway");
+MODULE_LICENSE("Dual BSD/GPL");
+MODULE_AUTHOR("Oliver Hartkopp <oliver.hartkopp@volkswagen.de>");
+MODULE_ALIAS("can-gw");
+
+HLIST_HEAD(cgw_list);
+static struct notifier_block notifier;
+
+static struct kmem_cache *cgw_cache __read_mostly;
+
+/* structure that contains the (on-the-fly) CAN frame modifications */
+struct cf_mod {
+	struct {
+		struct can_frame and;
+		struct can_frame or;
+		struct can_frame xor;
+		struct can_frame set;
+	} modframe;
+	struct {
+		u8 and;
+		u8 or;
+		u8 xor;
+		u8 set;
+	} modtype;
+	void (*modfunc[MAX_MODFUNCTIONS])(struct can_frame *cf,
+					  struct cf_mod *mod);
+
+	/* CAN frame checksum calculation after CAN frame modifications */
+	struct {
+		struct cgw_csum_xor xor;
+		struct cgw_csum_crc8 crc8;
+	} csum;
+	struct {
+		void (*xor)(struct can_frame *cf, struct cgw_csum_xor *xor);
+		void (*crc8)(struct can_frame *cf, struct cgw_csum_crc8 *crc8);
+	} csumfunc;
+};
+
+
+/*
+ * So far we just support CAN -> CAN routing and frame modifications.
+ *
+ * The internal can_can_gw structure contains data and attributes for
+ * a CAN -> CAN gateway job.
+ */
+struct can_can_gw {
+	struct can_filter filter;
+	int src_idx;
+	int dst_idx;
+};
+
+/* list entry for CAN gateways jobs */
+struct cgw_job {
+	struct hlist_node list;
+	struct rcu_head rcu;
+	u32 handled_frames;
+	u32 dropped_frames;
+	struct cf_mod mod;
+	union {
+		/* CAN frame data source */
+		struct net_device *dev;
+	} src;
+	union {
+		/* CAN frame data destination */
+		struct net_device *dev;
+	} dst;
+	union {
+		struct can_can_gw ccgw;
+		/* tbc */
+	};
+	u8 gwtype;
+	u16 flags;
+};
+
+/* modification functions that are invoked in the hot path in can_can_gw_rcv */
+
+#define MODFUNC(func, op) static void func (struct can_frame *cf, \
+					    struct cf_mod *mod) { op ; }
+
+MODFUNC(mod_and_id, cf->can_id &= mod->modframe.and.can_id)
+MODFUNC(mod_and_dlc, cf->can_dlc &= mod->modframe.and.can_dlc)
+MODFUNC(mod_and_data, *(u64 *)cf->data &= *(u64 *)mod->modframe.and.data)
+MODFUNC(mod_or_id, cf->can_id |= mod->modframe.or.can_id)
+MODFUNC(mod_or_dlc, cf->can_dlc |= mod->modframe.or.can_dlc)
+MODFUNC(mod_or_data, *(u64 *)cf->data |= *(u64 *)mod->modframe.or.data)
+MODFUNC(mod_xor_id, cf->can_id ^= mod->modframe.xor.can_id)
+MODFUNC(mod_xor_dlc, cf->can_dlc ^= mod->modframe.xor.can_dlc)
+MODFUNC(mod_xor_data, *(u64 *)cf->data ^= *(u64 *)mod->modframe.xor.data)
+MODFUNC(mod_set_id, cf->can_id = mod->modframe.set.can_id)
+MODFUNC(mod_set_dlc, cf->can_dlc = mod->modframe.set.can_dlc)
+MODFUNC(mod_set_data, *(u64 *)cf->data = *(u64 *)mod->modframe.set.data)
+
+static inline void canframecpy(struct can_frame *dst, struct can_frame *src)
+{
+	/*
+	 * Copy the struct members separately to ensure that no uninitialized
+	 * data are copied in the 3 bytes hole of the struct. This is needed
+	 * to make easy compares of the data in the struct cf_mod.
+	 */
+
+	dst->can_id = src->can_id;
+	dst->can_dlc = src->can_dlc;
+	*(u64 *)dst->data = *(u64 *)src->data;
+}
+
+static int cgw_chk_csum_parms(s8 fr, s8 to, s8 re)
+{
+	/* 
+	 * absolute dlc values 0 .. 7 => 0 .. 7, e.g. data [0]
+	 * relative to received dlc -1 .. -8 :
+	 * e.g. for received dlc = 8 
+	 * -1 => index = 7 (data[7])
+	 * -3 => index = 5 (data[5])
+	 * -8 => index = 0 (data[0])
+	 */
+
+	if (fr > -9 && fr < 8 &&
+	    to > -9 && to < 8 &&
+	    re > -9 && re < 8)
+		return 0;
+	else
+		return -EINVAL;
+} 
+
+static inline int calc_idx(int idx, int rx_dlc)
+{
+	if (idx < 0)
+		return rx_dlc + idx;
+	else
+		return idx;
+}
+
+static void cgw_csum_xor_rel(struct can_frame *cf, struct cgw_csum_xor *xor)
+{
+	int from = calc_idx(xor->from_idx, cf->can_dlc);
+	int to = calc_idx(xor->to_idx, cf->can_dlc);
+	int res = calc_idx(xor->result_idx, cf->can_dlc);
+	u8 val = xor->init_xor_val;
+	int i;
+
+	if (from < 0 || to < 0 || res < 0)
+		return;
+
+	if (from <= to) {
+		for (i = from; i <= to; i++)
+			val ^= cf->data[i]; 
+	} else {
+		for (i = from; i >= to; i--)
+			val ^= cf->data[i]; 
+	}
+
+	cf->data[res] = val;
+}
+
+static void cgw_csum_xor_pos(struct can_frame *cf, struct cgw_csum_xor *xor)
+{
+	u8 val = xor->init_xor_val;
+	int i;
+
+	for (i = xor->from_idx; i <= xor->to_idx; i++)
+		val ^= cf->data[i];
+
+	cf->data[xor->result_idx] = val;
+}
+
+static void cgw_csum_xor_neg(struct can_frame *cf, struct cgw_csum_xor *xor)
+{
+	u8 val = xor->init_xor_val;
+	int i;
+
+	for (i = xor->from_idx; i >= xor->to_idx; i--)
+		val ^= cf->data[i];
+
+	cf->data[xor->result_idx] = val;
+}
+
+static void cgw_csum_crc8_rel(struct can_frame *cf, struct cgw_csum_crc8 *crc8)
+{
+	int from = calc_idx(crc8->from_idx, cf->can_dlc);
+	int to = calc_idx(crc8->to_idx, cf->can_dlc);
+	int res = calc_idx(crc8->result_idx, cf->can_dlc);
+	u8 crc = crc8->init_crc_val;
+	int i;
+
+	if (from < 0 || to < 0 || res < 0)
+		return;
+
+	if (from <= to) {
+		for (i = crc8->from_idx; i <= crc8->to_idx; i++)
+			crc = crc8->crctab[crc^cf->data[i]];
+	} else {
+		for (i = crc8->from_idx; i >= crc8->to_idx; i--)
+			crc = crc8->crctab[crc^cf->data[i]];
+	}
+
+	switch (crc8->profile) {
+
+	case CGW_CRC8PRF_1U8:
+		crc = crc8->crctab[crc^crc8->profile_data[0]];
+		break;
+
+	case  CGW_CRC8PRF_16U8:
+		crc = crc8->crctab[crc^crc8->profile_data[cf->data[1] & 0xF]];
+		break;
+
+	case CGW_CRC8PRF_SFFID_XOR:
+		crc = crc8->crctab[crc^(cf->can_id & 0xFF)^
+				   (cf->can_id >> 8 & 0xFF)];
+		break;
+
+	}
+
+	cf->data[crc8->result_idx] = crc^crc8->final_xor_val;
+}
+
+static void cgw_csum_crc8_pos(struct can_frame *cf, struct cgw_csum_crc8 *crc8)
+{
+	u8 crc = crc8->init_crc_val;
+	int i;
+
+	for (i = crc8->from_idx; i <= crc8->to_idx; i++)
+		crc = crc8->crctab[crc^cf->data[i]];
+
+	switch (crc8->profile) {
+
+	case CGW_CRC8PRF_1U8:
+		crc = crc8->crctab[crc^crc8->profile_data[0]];
+		break;
+
+	case  CGW_CRC8PRF_16U8:
+		crc = crc8->crctab[crc^crc8->profile_data[cf->data[1] & 0xF]];
+		break;
+
+	case CGW_CRC8PRF_SFFID_XOR:
+		crc = crc8->crctab[crc^(cf->can_id & 0xFF)^
+				   (cf->can_id >> 8 & 0xFF)];
+		break;
+	}
+
+	cf->data[crc8->result_idx] = crc^crc8->final_xor_val;
+}
+
+static void cgw_csum_crc8_neg(struct can_frame *cf, struct cgw_csum_crc8 *crc8)
+{
+	u8 crc = crc8->init_crc_val;
+	int i;
+
+	for (i = crc8->from_idx; i >= crc8->to_idx; i--)
+		crc = crc8->crctab[crc^cf->data[i]];
+
+	switch (crc8->profile) {
+
+	case CGW_CRC8PRF_1U8:
+		crc = crc8->crctab[crc^crc8->profile_data[0]];
+		break;
+
+	case  CGW_CRC8PRF_16U8:
+		crc = crc8->crctab[crc^crc8->profile_data[cf->data[1] & 0xF]];
+		break;
+
+	case CGW_CRC8PRF_SFFID_XOR:
+		crc = crc8->crctab[crc^(cf->can_id & 0xFF)^
+				   (cf->can_id >> 8 & 0xFF)];
+		break;
+	}
+
+	cf->data[crc8->result_idx] = crc^crc8->final_xor_val;
+}
+
+/* the receive & process & send function */
+static void can_can_gw_rcv(struct sk_buff *skb, void *data)
+{
+	struct cgw_job *gwj = (struct cgw_job *)data;
+	struct can_frame *cf;
+	struct sk_buff *nskb;
+	int modidx = 0;
+
+	/* do not handle already routed frames - see comment below */
+	if (skb_mac_header_was_set(skb))
+		return;
+
+	if (!(gwj->dst.dev->flags & IFF_UP)) {
+		gwj->dropped_frames++;
+		return;
+	}
+
+	/*
+	 * clone the given skb, which has not been done in can_rcv()
+	 *
+	 * When there is at least one modification function activated,
+	 * we need to copy the skb as we want to modify skb->data.
+	 */
+	if (gwj->mod.modfunc[0])
+		nskb = skb_copy(skb, GFP_ATOMIC);
+	else
+		nskb = skb_clone(skb, GFP_ATOMIC);
+
+	if (!nskb) {
+		gwj->dropped_frames++;
+		return;
+	}
+
+	/*
+	 * Mark routed frames by setting some mac header length which is
+	 * not relevant for the CAN frames located in the skb->data section.
+	 *
+	 * As dev->header_ops is not set in CAN netdevices no one is ever
+	 * accessing the various header offsets in the CAN skbuffs anyway.
+	 * E.g. using the packet socket to read CAN frames is still working.
+	 */
+	skb_set_mac_header(nskb, 8);
+	nskb->dev = gwj->dst.dev;
+
+	/* pointer to modifiable CAN frame */
+	cf = (struct can_frame *)nskb->data;
+
+	/* perform preprocessed modification functions if there are any */
+	while (modidx < MAX_MODFUNCTIONS && gwj->mod.modfunc[modidx])
+		(*gwj->mod.modfunc[modidx++])(cf, &gwj->mod);
+
+	/* check for checksum updates when the CAN frame has been modified */
+	if (modidx) {
+		if (gwj->mod.csumfunc.crc8)
+			(*gwj->mod.csumfunc.crc8)(cf, &gwj->mod.csum.crc8);
+
+		if (gwj->mod.csumfunc.xor)
+			(*gwj->mod.csumfunc.xor)(cf, &gwj->mod.csum.xor);
+	}
+
+	/* clear the skb timestamp if not configured the other way */
+	if (!(gwj->flags & CGW_FLAGS_CAN_SRC_TSTAMP))
+		nskb->tstamp.tv64 = 0;
+
+	/* send to netdevice */
+	if (can_send(nskb, gwj->flags & CGW_FLAGS_CAN_ECHO))
+		gwj->dropped_frames++;
+	else
+		gwj->handled_frames++;
+}
+
+static inline int cgw_register_filter(struct cgw_job *gwj)
+{
+	return can_rx_register(gwj->src.dev, gwj->ccgw.filter.can_id,
+			       gwj->ccgw.filter.can_mask, can_can_gw_rcv,
+			       gwj, "gw");
+}
+
+static inline void cgw_unregister_filter(struct cgw_job *gwj)
+{
+	can_rx_unregister(gwj->src.dev, gwj->ccgw.filter.can_id,
+			  gwj->ccgw.filter.can_mask, can_can_gw_rcv, gwj);
+}
+
+static int cgw_notifier(struct notifier_block *nb,
+			unsigned long msg, void *data)
+{
+	struct net_device *dev = (struct net_device *)data;
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,26)
+	if (!net_eq(dev_net(dev), &init_net))
+		return NOTIFY_DONE;
+#elif LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,24)
+	if (dev->nd_net != &init_net)
+		return NOTIFY_DONE;
+#endif
+	if (dev->type != ARPHRD_CAN)
+		return NOTIFY_DONE;
+
+	if (msg == NETDEV_UNREGISTER) {
+
+		struct cgw_job *gwj = NULL;
+		struct hlist_node *n, *nx;
+
+		ASSERT_RTNL();
+
+		hlist_for_each_entry_safe(gwj, n, nx, &cgw_list, list) {
+
+			if (gwj->src.dev == dev || gwj->dst.dev == dev) { 
+				hlist_del(&gwj->list);
+				cgw_unregister_filter(gwj);
+				kfree(gwj);
+			}
+		}
+	}
+
+	return NOTIFY_DONE;
+}
+
+static int cgw_put_job(struct sk_buff *skb, struct cgw_job *gwj)
+{
+	struct cgw_frame_mod mb;
+	struct rtcanmsg *rtcan;
+	struct nlmsghdr *nlh = nlmsg_put(skb, 0, 0, 0, sizeof(*rtcan), 0);
+	if (!nlh)
+		return -EMSGSIZE;
+
+	rtcan = nlmsg_data(nlh);
+	rtcan->can_family = AF_CAN;
+	rtcan->gwtype = gwj->gwtype;
+	rtcan->flags = gwj->flags;
+
+	/* add statistics if available */
+
+	if (gwj->handled_frames) {
+		if (nla_put_u32(skb, CGW_HANDLED, gwj->handled_frames) < 0)
+			goto cancel;
+		else
+			nlh->nlmsg_len += NLA_HDRLEN + NLA_ALIGN(sizeof(u32));
+	}
+
+	if (gwj->dropped_frames) {
+		if (nla_put_u32(skb, CGW_DROPPED, gwj->dropped_frames) < 0)
+			goto cancel;
+		else
+			nlh->nlmsg_len += NLA_HDRLEN + NLA_ALIGN(sizeof(u32));
+	}
+
+	/* check non default settings of attributes */
+
+	if (gwj->mod.modtype.and) {
+		memcpy(&mb.cf, &gwj->mod.modframe.and, sizeof(mb.cf));
+		mb.modtype = gwj->mod.modtype.and;
+		if (nla_put(skb, CGW_MOD_AND, sizeof(mb), &mb) < 0)
+			goto cancel;
+		else
+			nlh->nlmsg_len += NLA_HDRLEN + NLA_ALIGN(sizeof(mb));
+	}
+
+	if (gwj->mod.modtype.or) {
+		memcpy(&mb.cf, &gwj->mod.modframe.or, sizeof(mb.cf));
+		mb.modtype = gwj->mod.modtype.or;
+		if (nla_put(skb, CGW_MOD_OR, sizeof(mb), &mb) < 0)
+			goto cancel;
+		else
+			nlh->nlmsg_len += NLA_HDRLEN + NLA_ALIGN(sizeof(mb));
+	}
+
+	if (gwj->mod.modtype.xor) {
+		memcpy(&mb.cf, &gwj->mod.modframe.xor, sizeof(mb.cf));
+		mb.modtype = gwj->mod.modtype.xor;
+		if (nla_put(skb, CGW_MOD_XOR, sizeof(mb), &mb) < 0)
+			goto cancel;
+		else
+			nlh->nlmsg_len += NLA_HDRLEN + NLA_ALIGN(sizeof(mb));
+	}
+
+	if (gwj->mod.modtype.set) {
+		memcpy(&mb.cf, &gwj->mod.modframe.set, sizeof(mb.cf));
+		mb.modtype = gwj->mod.modtype.set;
+		if (nla_put(skb, CGW_MOD_SET, sizeof(mb), &mb) < 0)
+			goto cancel;
+		else
+			nlh->nlmsg_len += NLA_HDRLEN + NLA_ALIGN(sizeof(mb));
+	}
+
+	if (gwj->mod.csumfunc.crc8) {
+		if (nla_put(skb, CGW_CS_CRC8, CGW_CS_CRC8_LEN,
+			    &gwj->mod.csum.crc8) < 0)
+			goto cancel;
+		else
+			nlh->nlmsg_len += NLA_HDRLEN + \
+				NLA_ALIGN(CGW_CS_CRC8_LEN);
+	}
+
+	if (gwj->mod.csumfunc.xor) {
+		if (nla_put(skb, CGW_CS_XOR, CGW_CS_XOR_LEN,
+			    &gwj->mod.csum.xor) < 0)
+			goto cancel;
+		else
+			nlh->nlmsg_len += NLA_HDRLEN + \
+				NLA_ALIGN(CGW_CS_XOR_LEN);
+	}
+
+	if (gwj->gwtype == CGW_TYPE_CAN_CAN) {
+
+		if (gwj->ccgw.filter.can_id || gwj->ccgw.filter.can_mask) {
+			if (nla_put(skb, CGW_FILTER, sizeof(struct can_filter),
+				    &gwj->ccgw.filter) < 0)
+				goto cancel;
+			else
+				nlh->nlmsg_len += NLA_HDRLEN +
+					NLA_ALIGN(sizeof(struct can_filter));
+		}
+
+		if (nla_put_u32(skb, CGW_SRC_IF, gwj->ccgw.src_idx) < 0)
+			goto cancel;
+		else
+			nlh->nlmsg_len += NLA_HDRLEN + NLA_ALIGN(sizeof(u32));
+
+		if (nla_put_u32(skb, CGW_DST_IF, gwj->ccgw.dst_idx) < 0)
+			goto cancel;
+		else
+			nlh->nlmsg_len += NLA_HDRLEN + NLA_ALIGN(sizeof(u32));
+	}
+
+	return skb->len;
+
+cancel:
+	nlmsg_cancel(skb, nlh);
+	return -EMSGSIZE;
+}
+
+/* Dump information about all CAN gateway jobs, in response to RTM_GETROUTE */
+static int cgw_dump_jobs(struct sk_buff *skb, struct netlink_callback *cb)
+{
+	struct cgw_job *gwj = NULL;
+	struct hlist_node *n;
+	int idx = 0;
+	int s_idx = cb->args[0];
+
+	rcu_read_lock();
+	hlist_for_each_entry_rcu(gwj, n, &cgw_list, list) {
+		if (idx < s_idx)
+			goto cont;
+
+		if (cgw_put_job(skb, gwj) < 0)
+			break;
+cont:
+		idx++;
+	}
+	rcu_read_unlock();
+
+	cb->args[0] = idx;
+
+	return skb->len;
+}
+
+/* check for common and gwtype specific attributes */
+static int cgw_parse_attr(struct nlmsghdr *nlh, struct cf_mod *mod, 
+			  u8 gwtype, void *gwtypeattr)
+{
+	struct nlattr *tb[CGW_MAX+1];
+	struct cgw_frame_mod mb;
+	int modidx = 0;
+	int err = 0;
+
+	/* initialize modification & checksum data space */
+	memset(mod, 0, sizeof(*mod)); 
+
+	err = nlmsg_parse(nlh, sizeof(struct rtcanmsg), tb, CGW_MAX, NULL);
+	if (err < 0)
+		return err;
+
+	/* check for AND/OR/XOR/SET modifications */
+
+	if (tb[CGW_MOD_AND] &&
+	    nla_len(tb[CGW_MOD_AND]) == CGW_MODATTR_LEN) {
+		nla_memcpy(&mb, tb[CGW_MOD_AND], CGW_MODATTR_LEN);
+
+		canframecpy(&mod->modframe.and, &mb.cf);
+		mod->modtype.and = mb.modtype;
+
+		if (mb.modtype & CGW_MOD_ID)
+			mod->modfunc[modidx++] = mod_and_id;
+
+		if (mb.modtype & CGW_MOD_DLC)
+			mod->modfunc[modidx++] = mod_and_dlc;
+
+		if (mb.modtype & CGW_MOD_DATA)
+			mod->modfunc[modidx++] = mod_and_data;
+	}
+
+	if (tb[CGW_MOD_OR] &&
+	    nla_len(tb[CGW_MOD_OR]) == CGW_MODATTR_LEN) {
+		nla_memcpy(&mb, tb[CGW_MOD_OR], CGW_MODATTR_LEN);
+
+		canframecpy(&mod->modframe.or, &mb.cf);
+		mod->modtype.or = mb.modtype;
+
+		if (mb.modtype & CGW_MOD_ID)
+			mod->modfunc[modidx++] = mod_or_id;
+
+		if (mb.modtype & CGW_MOD_DLC)
+			mod->modfunc[modidx++] = mod_or_dlc;
+
+		if (mb.modtype & CGW_MOD_DATA)
+			mod->modfunc[modidx++] = mod_or_data;
+	}
+
+	if (tb[CGW_MOD_XOR] &&
+	    nla_len(tb[CGW_MOD_XOR]) == CGW_MODATTR_LEN) {
+		nla_memcpy(&mb, tb[CGW_MOD_XOR], CGW_MODATTR_LEN);
+
+		canframecpy(&mod->modframe.xor, &mb.cf);
+		mod->modtype.xor = mb.modtype;
+
+		if (mb.modtype & CGW_MOD_ID)
+			mod->modfunc[modidx++] = mod_xor_id;
+
+		if (mb.modtype & CGW_MOD_DLC)
+			mod->modfunc[modidx++] = mod_xor_dlc;
+
+		if (mb.modtype & CGW_MOD_DATA)
+			mod->modfunc[modidx++] = mod_xor_data;
+	}
+
+	if (tb[CGW_MOD_SET] &&
+	    nla_len(tb[CGW_MOD_SET]) == CGW_MODATTR_LEN) {
+		nla_memcpy(&mb, tb[CGW_MOD_SET], CGW_MODATTR_LEN);
+
+		canframecpy(&mod->modframe.set, &mb.cf);
+		mod->modtype.set = mb.modtype;
+
+		if (mb.modtype & CGW_MOD_ID)
+			mod->modfunc[modidx++] = mod_set_id;
+
+		if (mb.modtype & CGW_MOD_DLC)
+			mod->modfunc[modidx++] = mod_set_dlc;
+
+		if (mb.modtype & CGW_MOD_DATA)
+			mod->modfunc[modidx++] = mod_set_data;
+	}
+
+	/* check for checksum operations after CAN frame modifications */
+	if (modidx) {
+
+		if (tb[CGW_CS_CRC8] &&
+		    nla_len(tb[CGW_CS_CRC8]) == CGW_CS_CRC8_LEN) {
+
+			struct cgw_csum_crc8 *c = (struct cgw_csum_crc8 *)\
+				nla_data(tb[CGW_CS_CRC8]);
+
+			err = cgw_chk_csum_parms(c->from_idx, c->to_idx,
+						 c->result_idx);
+			if (err)
+				return err;
+
+			nla_memcpy(&mod->csum.crc8, tb[CGW_CS_CRC8],
+				   CGW_CS_CRC8_LEN);
+
+			/*
+			 * select dedicated processing function to reduce
+			 * runtime operations in receive hot path.
+			 */
+			if (c->from_idx < 0 || c->to_idx < 0 ||
+			    c->result_idx < 0)
+				mod->csumfunc.crc8 = cgw_csum_crc8_rel;
+			else if (c->from_idx <= c->to_idx)
+				mod->csumfunc.crc8 = cgw_csum_crc8_pos;
+			else
+				mod->csumfunc.crc8 = cgw_csum_crc8_neg;
+		}
+
+		if (tb[CGW_CS_XOR] &&
+		    nla_len(tb[CGW_CS_XOR]) == CGW_CS_XOR_LEN) {
+
+			struct cgw_csum_xor *c = (struct cgw_csum_xor *)\
+				nla_data(tb[CGW_CS_XOR]);
+
+			err = cgw_chk_csum_parms(c->from_idx, c->to_idx,
+						 c->result_idx);
+			if (err)
+				return err;
+
+			nla_memcpy(&mod->csum.xor, tb[CGW_CS_XOR],
+				   CGW_CS_XOR_LEN);
+
+			/*
+			 * select dedicated processing function to reduce
+			 * runtime operations in receive hot path.
+			 */
+			if (c->from_idx < 0 || c->to_idx < 0 ||
+			    c->result_idx < 0)
+				mod->csumfunc.xor = cgw_csum_xor_rel;
+			else if (c->from_idx <= c->to_idx)
+				mod->csumfunc.xor = cgw_csum_xor_pos;
+			else
+				mod->csumfunc.xor = cgw_csum_xor_neg;
+		}
+	}
+
+	if (gwtype == CGW_TYPE_CAN_CAN) {
+
+		/* check CGW_TYPE_CAN_CAN specific attributes */
+
+		struct can_can_gw *ccgw = (struct can_can_gw *)gwtypeattr;
+		memset(ccgw, 0, sizeof(*ccgw)); 
+
+		/* check for can_filter in attributes */
+		if (tb[CGW_FILTER] &&
+		    nla_len(tb[CGW_FILTER]) == sizeof(struct can_filter))
+			nla_memcpy(&ccgw->filter, tb[CGW_FILTER],
+				   sizeof(struct can_filter));
+
+		err = -ENODEV;
+
+		/* specifying two interfaces is mandatory */
+		if (!tb[CGW_SRC_IF] || !tb[CGW_DST_IF])
+			return err;
+
+		if (nla_len(tb[CGW_SRC_IF]) == sizeof(u32))
+			nla_memcpy(&ccgw->src_idx, tb[CGW_SRC_IF],
+				   sizeof(u32));
+
+		if (nla_len(tb[CGW_DST_IF]) == sizeof(u32))
+			nla_memcpy(&ccgw->dst_idx, tb[CGW_DST_IF],
+				   sizeof(u32));
+
+		/* both indices set to 0 for flushing all routing entries */
+		if (!ccgw->src_idx && !ccgw->dst_idx)
+			return 0;
+
+		/* only one index set to 0 is an error */
+		if (!ccgw->src_idx || !ccgw->dst_idx)
+			return err;
+	}
+
+	/* add the checks for other gwtypes here */
+
+	return 0;
+}
+
+static int cgw_create_job(struct sk_buff *skb,  struct nlmsghdr *nlh,
+			  void *arg)
+{
+	struct rtcanmsg *r;
+	struct cgw_job *gwj;
+	int err = 0;
+
+	if (nlmsg_len(nlh) < sizeof(*r))
+		return -EINVAL;
+
+	r = nlmsg_data(nlh);
+	if (r->can_family != AF_CAN)
+		return -EPFNOSUPPORT;
+
+	/* so far we only support CAN -> CAN routings */
+	if (r->gwtype != CGW_TYPE_CAN_CAN)
+		return -EINVAL;
+
+	gwj = kmem_cache_alloc(cgw_cache, GFP_KERNEL);
+	if (!gwj)
+		return -ENOMEM;
+
+	gwj->handled_frames = 0;
+	gwj->dropped_frames = 0;
+	gwj->flags = r->flags;
+	gwj->gwtype = r->gwtype;
+
+	err = cgw_parse_attr(nlh, &gwj->mod, CGW_TYPE_CAN_CAN, &gwj->ccgw);
+	if (err < 0)
+		goto out;
+
+	err = -ENODEV;
+
+	/* ifindex == 0 is not allowed for job creation */
+	if (!gwj->ccgw.src_idx || !gwj->ccgw.dst_idx)
+		goto out;
+
+	gwj->src.dev = dev_get_by_index(&init_net, gwj->ccgw.src_idx);
+
+	if (!gwj->src.dev)
+		goto out;
+
+	if (gwj->src.dev->type != ARPHRD_CAN)
+		goto put_src_out;
+
+	gwj->dst.dev = dev_get_by_index(&init_net, gwj->ccgw.dst_idx);
+
+	if (!gwj->dst.dev)
+		goto put_src_out;
+
+	if (gwj->dst.dev->type != ARPHRD_CAN)
+		goto put_src_dst_out;
+		
+	ASSERT_RTNL();
+
+	err = cgw_register_filter(gwj);
+	if (!err)
+		hlist_add_head_rcu(&gwj->list, &cgw_list);
+
+put_src_dst_out:
+	dev_put(gwj->dst.dev);
+put_src_out:
+	dev_put(gwj->src.dev);
+out:
+	if (err)
+		kmem_cache_free(cgw_cache, gwj);
+
+	return err;
+}
+
+static void cgw_remove_all_jobs(void)
+{
+	struct cgw_job *gwj = NULL;
+	struct hlist_node *n, *nx;
+
+	ASSERT_RTNL();
+
+	hlist_for_each_entry_safe(gwj, n, nx, &cgw_list, list) {
+		hlist_del(&gwj->list);
+		cgw_unregister_filter(gwj);
+		kfree(gwj);
+	}
+}
+
+static int cgw_remove_job(struct sk_buff *skb,  struct nlmsghdr *nlh, void *arg)
+{
+	struct cgw_job *gwj = NULL;
+	struct hlist_node *n, *nx;
+	struct rtcanmsg *r;
+	struct cf_mod mod;
+	struct can_can_gw ccgw;
+	int err = 0;
+
+	if (nlmsg_len(nlh) < sizeof(*r))
+		return -EINVAL;
+
+	r = nlmsg_data(nlh);
+	if (r->can_family != AF_CAN)
+		return -EPFNOSUPPORT;
+
+	/* so far we only support CAN -> CAN routings */
+	if (r->gwtype != CGW_TYPE_CAN_CAN)
+		return -EINVAL;
+
+	err = cgw_parse_attr(nlh, &mod, CGW_TYPE_CAN_CAN, &ccgw);
+	if (err < 0)
+		return err;
+
+	/* two interface indices both set to 0 => remove all entries */
+	if (!ccgw.src_idx && !ccgw.dst_idx) {
+		cgw_remove_all_jobs();
+		return 0;
+	}
+
+	err = -EINVAL;
+
+	ASSERT_RTNL();
+
+	/* remove only the first matching entry */
+	hlist_for_each_entry_safe(gwj, n, nx, &cgw_list, list) {
+
+		if (gwj->flags != r->flags)
+			continue;
+
+		if (memcmp(&gwj->mod, &mod, sizeof(mod)))
+			continue;
+
+		/* if (r->gwtype == CGW_TYPE_CAN_CAN) - is made sure here */
+		if (memcmp(&gwj->ccgw, &ccgw, sizeof(ccgw)))
+			continue;
+
+		hlist_del(&gwj->list);
+		cgw_unregister_filter(gwj);
+		kfree(gwj);
+		err = 0;
+		break;
+	}
+
+	return err;
+}
+
+static __init int cgw_module_init(void)
+{
+	printk(banner);
+
+	cgw_cache = kmem_cache_create("can_gw", sizeof(struct cgw_job),
+				      0, 0, NULL);
+
+	if (!cgw_cache)
+		return -ENOMEM;
+
+	/* set notifier */
+	notifier.notifier_call = cgw_notifier;
+	register_netdevice_notifier(&notifier);
+
+	if (__rtnl_register(PF_CAN, RTM_GETROUTE, NULL, cgw_dump_jobs)) {
+		unregister_netdevice_notifier(&notifier);
+		kmem_cache_destroy(cgw_cache);
+		return -ENOBUFS;
+	}
+
+	/* Only the first call to __rtnl_register can fail */
+	__rtnl_register(PF_CAN, RTM_NEWROUTE, cgw_create_job, NULL);
+	__rtnl_register(PF_CAN, RTM_DELROUTE, cgw_remove_job, NULL);
+
+	return 0;
+}
+
+static __exit void cgw_module_exit(void)
+{
+	rtnl_unregister_all(PF_CAN);
+
+	unregister_netdevice_notifier(&notifier);
+
+	rtnl_lock();
+	cgw_remove_all_jobs();
+	rtnl_unlock();
+
+	rcu_barrier(); /* Wait for completion of call_rcu()'s */
+
+	kmem_cache_destroy(cgw_cache);
+}
+
+module_init(cgw_module_init);
+module_exit(cgw_module_exit);
diff --exclude CVS --exclude .git -uNr linux-2.6.27.8/net/can/isotp.c linux-2.6.27.8.modified/net/can/isotp.c
--- linux-2.6.27.8/net/can/isotp.c	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.27.8.modified/net/can/isotp.c	2013-05-30 03:44:13.000000000 -0400
@@ -0,0 +1,1190 @@
+/*
+ * isotp.c - ISO 15765-2 CAN transport protocol for protocol family CAN
+ *
+ * WARNING: This is ALPHA code for discussions and first tests that should
+ *          not be used in production environments.
+ *
+ * In the discussion the Socket-API to the userspace or the ISO-TP socket
+ * options or the return values we may change! Current behaviour:
+ *
+ * - no ISO-TP specific return values are provided to the userspace
+ * - when a transfer (tx) is on the run the next write() blocks until it's done
+ * - no support for sending wait frames to the data source in the rx path
+ *
+ * Copyright (c) 2008 Volkswagen Group Electronic Research
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of Volkswagen nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * Alternatively, provided that this notice is retained in full, this
+ * software may be distributed under the terms of the GNU General
+ * Public License ("GPL") version 2, in which case the provisions of the
+ * GPL apply INSTEAD OF those given above.
+ *
+ * The provided data structures and external interfaces from this code
+ * are not restricted to be used by modules with a GPL compatible license.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * Send feedback to <socketcan-users@lists.berlios.de>
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/version.h>
+#include <linux/init.h>
+#include <linux/wait.h>
+#include <linux/uio.h>
+#include <linux/net.h>
+#include <linux/netdevice.h>
+#include <linux/socket.h>
+#include <linux/if_arp.h>
+#include <linux/skbuff.h>
+#include <socketcan/can.h>
+#include <socketcan/can/core.h>
+#include <socketcan/can/isotp.h>
+#include <net/sock.h>
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,24)
+#include <net/net_namespace.h>
+#endif
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,25)
+#include "compat.h"
+#endif
+
+#include <socketcan/can/version.h> /* for RCSID. Removed by mkpatch script */
+RCSID("$Id: isotp.c 1252 2011-05-05 14:42:58Z hartkopp $");
+
+#define CAN_ISOTP_VERSION CAN_VERSION
+static __initdata const char banner[] =
+	KERN_INFO "can: isotp protocol (rev " CAN_ISOTP_VERSION " alpha)\n";
+
+MODULE_DESCRIPTION("PF_CAN isotp 15765-2 protocol");
+MODULE_LICENSE("Dual BSD/GPL");
+MODULE_AUTHOR("Oliver Hartkopp <oliver.hartkopp@volkswagen.de>");
+MODULE_ALIAS("can-proto-6");
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,22)
+#error This modules needs hrtimers (available since Kernel 2.6.22)
+#endif
+
+#define DBG(fmt, args...) (printk( KERN_DEBUG "can-isotp: %s: " fmt, \
+				   __func__, ##args))
+#undef DBG
+#define DBG(fmt, args...) 
+
+#define SINGLE_MASK(id) ((id & CAN_EFF_FLAG) ? \
+			 (CAN_EFF_MASK | CAN_EFF_FLAG | CAN_RTR_FLAG) : \
+			 (CAN_SFF_MASK | CAN_EFF_FLAG | CAN_RTR_FLAG))
+
+/* N_PCI type values in bits 7-4 of N_PCI bytes */
+#define N_PCI_SF 0x00	/* single frame */
+#define N_PCI_FF 0x10	/* first frame */
+#define N_PCI_CF 0x20	/* consecutive frame */
+#define N_PCI_FC 0x30	/* flow control */
+
+/* Flow Status given in FC frame */
+#define ISOTP_FC_CTS	0	/* clear to send */
+#define ISOTP_FC_WT	1	/* wait */
+#define ISOTP_FC_OVFLW	2	/* overflow */
+
+enum {
+	ISOTP_IDLE = 0,
+	ISOTP_WAIT_FIRST_FC,
+	ISOTP_WAIT_FC,
+	ISOTP_WAIT_DATA,
+	ISOTP_SENDING
+};
+
+struct tpcon {
+	int idx;
+	int len;
+	u8  state;
+	u8  bs;
+	u8  sn;
+	u8  buf[4096];
+};
+ 
+struct isotp_sock {
+	struct sock sk;
+	int bound;
+	int ifindex;
+	canid_t txid;
+	canid_t rxid;
+	ktime_t tx_gap;
+	ktime_t lastrxcf_tstamp;
+	struct hrtimer rxtimer, txtimer;
+	struct tasklet_struct txtsklet;
+	struct can_isotp_options opt;
+	struct can_isotp_fc_options rxfc, txfc;
+	__u32 force_tx_stmin;
+	__u32 force_rx_stmin;
+	struct tpcon rx, tx;
+	struct notifier_block notifier;
+	wait_queue_head_t wait;
+};
+
+static inline struct isotp_sock *isotp_sk(const struct sock *sk)
+{
+	return (struct isotp_sock *)sk;
+}
+
+static enum hrtimer_restart isotp_rx_timer_handler(struct hrtimer *hrtimer)
+{
+	struct isotp_sock *so = container_of(hrtimer, struct isotp_sock,
+					     rxtimer);
+	if (so->rx.state == ISOTP_WAIT_DATA) {
+#if 0
+		struct sock *sk = &so->sk;
+
+		/* report 'timeout' */
+		sk->sk_err = E?????;
+		if (!sock_flag(sk, SOCK_DEAD))
+			sk->sk_error_report(sk);
+#endif
+		DBG("we did not get new data frames in time.\n");
+
+		/* reset tx state */
+		so->rx.state = ISOTP_IDLE;
+	}
+
+	return HRTIMER_NORESTART;
+}
+
+static int isotp_send_fc(struct sock *sk, int ae)
+{
+	struct net_device *dev;
+	struct sk_buff *nskb;
+	struct can_frame *ncf;
+	struct isotp_sock *so = isotp_sk(sk);
+
+	nskb = alloc_skb(sizeof(struct can_frame), gfp_any());
+	if (!nskb)
+		return 1;
+
+	dev = dev_get_by_index(&init_net, so->ifindex);
+	if (!dev) {
+		kfree_skb(nskb);
+		return 1;
+	}
+	nskb->dev = dev;
+	nskb->sk = sk;
+	ncf = (struct can_frame *) nskb->data;
+	skb_put(nskb, sizeof(struct can_frame));
+
+	/* create & send flow control reply */
+	ncf->can_id = so->txid;
+
+	if (so->opt.flags & CAN_ISOTP_RX_PADDING) {
+		memset(ncf->data, so->opt.rxpad_content, 8);
+		ncf->can_dlc = 8;
+	} else
+		ncf->can_dlc = ae+3;
+
+	ncf->data[ae] = N_PCI_FC | ISOTP_FC_CTS;
+	ncf->data[ae+1] = so->rxfc.bs;
+	ncf->data[ae+2] = so->rxfc.stmin;
+
+	if (ae)
+		ncf->data[0] = so->opt.ext_address;
+
+	can_send(nskb, 1);
+	dev_put(dev);
+
+	/* reset blocksize counter */
+	so->rx.bs = 0;
+
+	/* reset last CF frame rx timestamp for rx stmin enforcement */
+	so->lastrxcf_tstamp = ktime_set(0,0);
+
+	/* start rx timeout watchdog */
+	hrtimer_start(&so->rxtimer, ktime_set(1,0), HRTIMER_MODE_REL);
+	return 0;
+}
+
+static void isotp_rcv_skb(struct sk_buff *skb, struct sock *sk)
+{
+	struct sockaddr_can *addr = (struct sockaddr_can *)skb->cb;
+
+	BUILD_BUG_ON(sizeof(skb->cb) < sizeof(struct sockaddr_can));
+
+	skb->sk = sk;
+
+	memset(addr, 0, sizeof(*addr));
+	addr->can_family  = AF_CAN;
+	addr->can_ifindex = skb->dev->ifindex;
+
+	if (sock_queue_rcv_skb(sk, skb) < 0)
+		kfree_skb(skb);
+}
+
+static int check_pad(struct isotp_sock *so, struct can_frame *cf,
+		     int start_index, __u8 content)
+{
+	int i;
+
+	/* check datalength code */
+	if ((so->opt.flags & CAN_ISOTP_CHK_PAD_LEN) && cf->can_dlc != 8)
+			return 1;
+
+	/* check padding content */
+	if (so->opt.flags & CAN_ISOTP_CHK_PAD_DATA) {
+		for (i = start_index; i < 8; i++)
+			if (cf->data[i] != content)
+				return 1;
+	}
+	return 0;
+}
+
+static int isotp_rcv_fc(struct isotp_sock *so, struct can_frame *cf, int ae)
+{
+	if (so->tx.state != ISOTP_WAIT_FC &&
+	    so->tx.state != ISOTP_WAIT_FIRST_FC)
+		return 0;
+
+	hrtimer_cancel(&so->txtimer);
+
+	if ((so->opt.flags & CAN_ISOTP_TX_PADDING) &&
+	    check_pad(so, cf, ae+3, so->opt.txpad_content)) {
+		so->tx.state = ISOTP_IDLE;
+		wake_up_interruptible(&so->wait);
+		return 1;
+	}
+
+	/* get communication parameters only from the first FC frame */
+	if (so->tx.state == ISOTP_WAIT_FIRST_FC) {
+
+		so->txfc.bs = cf->data[ae+1];
+		so->txfc.stmin = cf->data[ae+2];
+
+		/* fix wrong STmin values according spec */
+		if ((so->txfc.stmin > 0x7F) && 
+		    ((so->txfc.stmin < 0xF1) || (so->txfc.stmin > 0xF9)))
+			so->txfc.stmin = 0x7F;
+
+		so->tx_gap = ktime_set(0,0);
+		/* add transmission time for CAN frame N_As */
+		so->tx_gap = ktime_add_ns(so->tx_gap, so->opt.frame_txtime);
+		/* add waiting time for consecutive frames N_Cs */
+		if (so->opt.flags & CAN_ISOTP_FORCE_TXSTMIN) 
+			so->tx_gap = ktime_add_ns(so->tx_gap,
+						  so->force_tx_stmin);
+		else if (so->txfc.stmin < 0x80)
+			so->tx_gap = ktime_add_ns(so->tx_gap,
+						  so->txfc.stmin * 1000000);
+		else
+			so->tx_gap = ktime_add_ns(so->tx_gap,
+						  (so->txfc.stmin - 0xF0)
+						  * 100000);
+		so->tx.state = ISOTP_WAIT_FC;
+	}
+
+	DBG("FC frame: FS %d, BS %d, STmin 0x%02X, tx_gap %lld\n",
+	    cf->data[ae] & 0x0F & 0x0F, so->txfc.bs, so->txfc.stmin,
+	    (long long)so->tx_gap.tv64);
+
+	switch (cf->data[ae] & 0x0F) {
+
+	case ISOTP_FC_CTS:
+		so->tx.bs = 0;
+		so->tx.state = ISOTP_SENDING;
+		DBG("starting txtimer for sending\n");
+		/* start cyclic timer for sending CF frame */
+		hrtimer_start(&so->txtimer, so->tx_gap,
+			      HRTIMER_MODE_REL);
+		break;
+
+	case ISOTP_FC_WT:
+		DBG("starting waiting for next FC\n");
+		/* start timer to wait for next FC frame */
+		hrtimer_start(&so->txtimer, ktime_set(1,0),
+			      HRTIMER_MODE_REL);
+		break;
+
+	case ISOTP_FC_OVFLW:
+		DBG("overflow in receiver side\n");
+
+	default:
+		/* stop this tx job. TODO: error reporting? */
+		so->tx.state = ISOTP_IDLE;
+		wake_up_interruptible(&so->wait);
+	}
+	return 0;
+}
+
+static int isotp_rcv_sf(struct sock *sk, struct can_frame *cf, int ae,
+			struct sk_buff *skb)
+{
+	struct isotp_sock *so = isotp_sk(sk);
+	int len = cf->data[ae] & 0x0F;
+	struct sk_buff *nskb;
+
+	hrtimer_cancel(&so->rxtimer);
+	so->rx.state = ISOTP_IDLE;
+
+	if (!len || len > 7 || (ae && len > 6))
+		return 1;
+
+	if ((so->opt.flags & CAN_ISOTP_RX_PADDING) &&
+	    check_pad(so, cf, 1+ae+len, so->opt.rxpad_content))
+		return 1;
+
+	nskb = alloc_skb(len, gfp_any());
+	if (!nskb)
+		return 1;
+
+	memcpy(skb_put(nskb, len), &cf->data[1+ae], len);
+
+	nskb->tstamp = skb->tstamp;
+	nskb->dev = skb->dev;
+	isotp_rcv_skb(nskb, sk);
+	return 0;
+}
+
+static int isotp_rcv_ff(struct sock *sk, struct can_frame *cf, int ae)
+{
+	struct isotp_sock *so = isotp_sk(sk);
+	int i;
+
+	hrtimer_cancel(&so->rxtimer);
+	so->rx.state = ISOTP_IDLE;
+
+	if (cf->can_dlc != 8)
+		return 1;
+
+	so->rx.len = (cf->data[ae] & 0x0F) << 8;
+	so->rx.len += cf->data[ae+1];
+
+	if (so->rx.len + ae < 8)
+		return 1;
+
+	/* copy the first received data bytes */
+	so->rx.idx = 0;
+	for (i = ae+2; i < 8; i++)
+		so->rx.buf[so->rx.idx++] = cf->data[i];
+
+	/* initial setup for this pdu receiption */
+	so->rx.sn = 1;
+	so->rx.state = ISOTP_WAIT_DATA;
+
+	/* no creation of flow control frames */
+	if (so->opt.flags & CAN_ISOTP_LISTEN_MODE)
+		return 0;
+
+	/* send our first FC frame */
+	isotp_send_fc(sk, ae);
+	return 0;
+}
+
+static int isotp_rcv_cf(struct sock *sk, struct can_frame *cf, int ae,
+			struct sk_buff *skb)
+{
+	struct isotp_sock *so = isotp_sk(sk);
+	struct sk_buff *nskb;
+	int i;
+
+	if (so->rx.state != ISOTP_WAIT_DATA)
+		return 0;
+
+	/* drop if timestamp gap is less than force_rx_stmin nano secs */
+	if (so->opt.flags & CAN_ISOTP_FORCE_RXSTMIN) {
+
+		if (ktime_to_ns(ktime_sub(skb->tstamp, so->lastrxcf_tstamp)) <
+		    so->force_rx_stmin)
+			return 0;
+
+		so->lastrxcf_tstamp = skb->tstamp; 
+	}
+
+	hrtimer_cancel(&so->rxtimer);
+
+	if ((cf->data[ae] & 0x0F) != so->rx.sn) {
+		DBG("wrong sn %d. expected %d.\n",
+		    cf->data[ae] & 0x0F, so->rx.sn);
+		/* some error reporting? */
+		so->rx.state = ISOTP_IDLE;
+		return 1;
+	}
+	so->rx.sn++;
+	so->rx.sn %= 16;
+
+	for (i = ae+1; i < 8; i++) {
+		so->rx.buf[so->rx.idx++] = cf->data[i];
+		if (so->rx.idx >= so->rx.len)
+			break;
+	}
+
+	if (so->rx.idx >= so->rx.len) {
+
+		/* we are done */
+		so->rx.state = ISOTP_IDLE;
+
+		if ((so->opt.flags & CAN_ISOTP_RX_PADDING) &&
+		    check_pad(so, cf, i+1, so->opt.rxpad_content))
+			return 1;
+
+		nskb = alloc_skb(so->rx.len, gfp_any());
+		if (!nskb)
+			return 1;
+
+		memcpy(skb_put(nskb, so->rx.len), so->rx.buf,
+		       so->rx.len);
+
+		nskb->tstamp = skb->tstamp;
+		nskb->dev = skb->dev;
+		isotp_rcv_skb(nskb, sk);
+		return 0;
+	}
+
+	/* no creation of flow control frames */
+	if (so->opt.flags & CAN_ISOTP_LISTEN_MODE)
+		return 0;
+
+	/* perform blocksize handling, if enabled */
+	if (!so->rxfc.bs || ++so->rx.bs < so->rxfc.bs) {
+
+		/* start rx timeout watchdog */
+		hrtimer_start(&so->rxtimer, ktime_set(1,0),
+			      HRTIMER_MODE_REL);
+		return 0;
+	}
+
+	/* we reached the specified blocksize so->rxfc.bs */
+	isotp_send_fc(sk, ae);
+	return 0;
+}
+
+static void isotp_rcv(struct sk_buff *skb, void *data)
+{
+	struct sock *sk = (struct sock *)data;
+	struct isotp_sock *so = isotp_sk(sk);
+	struct can_frame *cf;
+	int ae = (so->opt.flags & CAN_ISOTP_EXTEND_ADDR)? 1:0;
+	u8 n_pci_type;
+
+	/* read CAN frame and free skbuff */
+	BUG_ON(skb->len != sizeof(struct can_frame));
+	cf = (struct can_frame *) skb->data;
+
+	/* if enabled: check receiption of my configured extended address */
+	if (ae && cf->data[0] != so->opt.ext_address)
+		return;
+
+	n_pci_type = cf->data[ae] & 0xF0;
+
+	if (so->opt.flags & CAN_ISOTP_HALF_DUPLEX) {
+		/* check rx/tx path half duplex expectations */
+		if ((so->tx.state != ISOTP_IDLE && n_pci_type != N_PCI_FC) ||
+		    (so->rx.state != ISOTP_IDLE && n_pci_type == N_PCI_FC))
+			return;
+	}
+
+	switch (n_pci_type) {
+	case N_PCI_FC:
+		/* tx path: flow control frame containing the FC parameters */
+		isotp_rcv_fc(so, cf, ae);
+		break;
+
+	case N_PCI_SF:
+		/* rx path: single frame */
+		isotp_rcv_sf(sk, cf, ae, skb);
+		break;
+
+	case N_PCI_FF:
+		/* rx path: first frame */
+		isotp_rcv_ff(sk, cf, ae);
+		break;
+
+	case N_PCI_CF:
+		/* rx path: consecutive frame */
+		isotp_rcv_cf(sk, cf, ae, skb);
+		break;
+	}
+}
+
+static void isotp_fill_dataframe(struct can_frame *cf, struct isotp_sock *so,
+				 int ae)
+{
+	unsigned char space = 7 - ae;
+	int num = min_t(int, so->tx.len - so->tx.idx, space);
+	int i;
+
+	cf->can_id = so->txid;
+
+	if (so->opt.flags & CAN_ISOTP_TX_PADDING) {
+		if (num < space)
+			memset(cf->data, so->opt.txpad_content, 8);
+
+		cf->can_dlc = 8;
+	} else
+		cf->can_dlc = num + 1 + ae;
+
+
+	for (i = 0; i < num; i++)
+		cf->data[i+ae+1] = so->tx.buf[so->tx.idx++];
+
+	if (ae)
+		cf->data[0] = so->opt.ext_address;
+}
+
+static void isotp_create_fframe(struct can_frame *cf, struct isotp_sock *so,
+				int ae)
+{
+	int i;
+
+	cf->can_id = so->txid;
+	cf->can_dlc = 8;
+	if (ae)
+		cf->data[0] = so->opt.ext_address;
+
+	/* N_PCI bytes with FF_DL data length */
+	cf->data[ae] = (u8) (so->tx.len>>8) | N_PCI_FF;
+	cf->data[ae+1] = (u8) so->tx.len & 0xFFU;
+
+	/* add first 5 or 6 data bytes depending on ae */
+	for (i = ae+2; i < 8; i++)
+		cf->data[i] = so->tx.buf[so->tx.idx++];
+
+	so->tx.sn = 1;
+	so->tx.state = ISOTP_WAIT_FIRST_FC;
+}
+
+static void isotp_tx_timer_tsklet(unsigned long data)
+{
+	struct isotp_sock *so = (struct isotp_sock *)data;
+	struct sock *sk = &so->sk;
+	struct sk_buff *skb;
+	struct net_device *dev;
+	struct can_frame *cf;
+	int ae = (so->opt.flags & CAN_ISOTP_EXTEND_ADDR)? 1:0;
+
+	switch (so->tx.state) {
+
+	case ISOTP_WAIT_FC:
+	case ISOTP_WAIT_FIRST_FC:
+
+		/* we did not get any flow control frame in time */
+
+		DBG("we did not get FC frame in time.\n");
+
+#if 0
+		/* report 'communication error on send' */
+		sk->sk_err = ECOMM;
+		if (!sock_flag(sk, SOCK_DEAD))
+			sk->sk_error_report(sk);
+#endif
+		/* reset tx state */
+		so->tx.state = ISOTP_IDLE;
+		wake_up_interruptible(&so->wait);
+		break;
+
+	case ISOTP_SENDING:
+
+		/* push out the next segmented pdu */
+
+		DBG("next pdu to send.\n");
+
+		dev = dev_get_by_index(&init_net, so->ifindex);
+		if (!dev)
+			break;
+
+isotp_tx_burst:
+		skb = alloc_skb(sizeof(*cf), gfp_any());
+		if (!skb) {
+			dev_put(dev);
+			break;
+		}
+
+		cf = (struct can_frame *)skb->data;
+		skb_put(skb, sizeof(*cf));
+
+		/* create consecutive frame */
+		isotp_fill_dataframe(cf, so, ae);
+
+		/* place consecutive frame N_PCI in appropriate index */
+		cf->data[ae] = N_PCI_CF | so->tx.sn++;
+		so->tx.sn %= 16;
+		so->tx.bs++;
+
+		skb->dev = dev;
+		skb->sk  = sk;
+		can_send(skb, 1);
+
+		if (so->tx.idx >= so->tx.len) {
+			/* we are done */
+			DBG("we are done\n");
+			so->tx.state = ISOTP_IDLE;
+			dev_put(dev);
+			wake_up_interruptible(&so->wait);
+			break;
+		}
+
+		if (so->txfc.bs && so->tx.bs >= so->txfc.bs) {
+			/* stop and wait for FC */
+			DBG("BS stop and wait for FC\n");
+			so->tx.state = ISOTP_WAIT_FC;
+			dev_put(dev);
+			hrtimer_start(&so->txtimer,
+				      ktime_add(ktime_get(), ktime_set(1,0)),
+				      HRTIMER_MODE_ABS);
+			break;
+		} 
+
+		/* no gap between data frames needed => use burst mode */
+		if (!so->tx_gap.tv64)
+			goto isotp_tx_burst;
+
+		/* start timer to send next data frame with correct delay */
+		dev_put(dev);
+		hrtimer_start(&so->txtimer,
+			      ktime_add(ktime_get(), so->tx_gap),
+			      HRTIMER_MODE_ABS);
+		break;
+
+	default:
+		BUG_ON(1);
+	}
+}
+
+static enum hrtimer_restart isotp_tx_timer_handler(struct hrtimer *hrtimer)
+{
+	struct isotp_sock *so = container_of(hrtimer, struct isotp_sock,
+					     txtimer);
+	tasklet_schedule(&so->txtsklet);
+
+	return HRTIMER_NORESTART;
+}
+
+static int isotp_sendmsg(struct kiocb *iocb, struct socket *sock,
+		       struct msghdr *msg, size_t size)
+{
+	struct sock *sk = sock->sk;
+	struct isotp_sock *so = isotp_sk(sk);
+	struct sk_buff *skb;
+	struct net_device *dev;
+	struct can_frame *cf;
+	int ae = (so->opt.flags & CAN_ISOTP_EXTEND_ADDR)? 1:0;
+	int err;
+
+	if (!so->bound)
+		return -EADDRNOTAVAIL;
+
+	/* we do not support multiple buffers - for now */
+	if (so->tx.state != ISOTP_IDLE) {
+		if (msg->msg_flags & MSG_DONTWAIT)
+			return -EAGAIN;
+
+		/* wait for complete transmission of current pdu */
+		wait_event_interruptible(so->wait, so->tx.state == ISOTP_IDLE);
+	}
+
+	if (!size || size > 4095)
+		return -EINVAL;
+
+	err = memcpy_fromiovec(so->tx.buf, msg->msg_iov, size);
+	if (err < 0)
+		return err;
+
+	dev = dev_get_by_index(&init_net, so->ifindex);
+	if (!dev)
+		return -ENXIO;
+
+	skb = sock_alloc_send_skb(sk, sizeof(*cf),
+				  msg->msg_flags & MSG_DONTWAIT, &err);
+	if (!skb) {
+		dev_put(dev);
+		return err;
+	}
+
+	so->tx.state = ISOTP_SENDING;
+	so->tx.len = size;
+	so->tx.idx = 0;
+
+	cf = (struct can_frame *)skb->data;
+	skb_put(skb, sizeof(*cf));
+
+	/* check for single frame transmission */
+	if (size <= 7 - ae) {
+
+		isotp_fill_dataframe(cf, so, ae);
+
+		/* place single frame N_PCI in appropriate index */
+		cf->data[ae] = size | N_PCI_SF;
+
+		so->tx.state = ISOTP_IDLE;
+		wake_up_interruptible(&so->wait);
+	} else {
+		/* send first frame and wait for FC */
+
+		isotp_create_fframe(cf, so, ae);
+
+		DBG("starting txtimer for fc\n");
+		/* start timeout for FC */
+		hrtimer_start(&so->txtimer, ktime_set(1,0), HRTIMER_MODE_REL);
+	}
+
+	/* send the first or only CAN frame */
+	skb->dev = dev;
+	skb->sk  = sk;
+	err = can_send(skb, 1);
+	dev_put(dev);
+	if (err)
+		return err;
+
+	return size;
+}
+
+static int isotp_recvmsg(struct kiocb *iocb, struct socket *sock,
+			 struct msghdr *msg, size_t size, int flags)
+{
+	struct sock *sk = sock->sk;
+	struct sk_buff *skb;
+	int err = 0;
+	int noblock;
+
+	noblock =  flags & MSG_DONTWAIT;
+	flags   &= ~MSG_DONTWAIT;
+
+	skb = skb_recv_datagram(sk, flags, noblock, &err);
+	if (!skb)
+		return err;
+
+	if (size < skb->len)
+		msg->msg_flags |= MSG_TRUNC;
+	else
+		size = skb->len;
+
+	err = memcpy_toiovec(msg->msg_iov, skb->data, size);
+	if (err < 0) {
+		skb_free_datagram(sk, skb);
+		return err;
+	}
+
+	sock_recv_timestamp(msg, sk, skb);
+
+	if (msg->msg_name) {
+		msg->msg_namelen = sizeof(struct sockaddr_can);
+		memcpy(msg->msg_name, skb->cb, msg->msg_namelen);
+	}
+
+	skb_free_datagram(sk, skb);
+
+	return size;
+}
+
+static int isotp_release(struct socket *sock)
+{
+	struct sock *sk = sock->sk;
+	struct isotp_sock *so;
+
+	if (!sk)
+		return 0;
+
+	so = isotp_sk(sk);
+
+	/* wait for complete transmission of current pdu */
+	wait_event_interruptible(so->wait, so->tx.state == ISOTP_IDLE);
+
+	unregister_netdevice_notifier(&so->notifier);
+
+	lock_sock(sk);
+
+	hrtimer_cancel(&so->txtimer);
+	hrtimer_cancel(&so->rxtimer);
+	tasklet_kill(&so->txtsklet);
+
+	/* remove current filters & unregister */
+	if (so->bound) {
+		if (so->ifindex) {
+			struct net_device *dev;
+
+			dev = dev_get_by_index(&init_net, so->ifindex);
+			if (dev) {
+				can_rx_unregister(dev, so->rxid,
+						  SINGLE_MASK(so->rxid),
+						  isotp_rcv, sk);
+				dev_put(dev);
+			}
+		}
+	}
+
+	so->ifindex = 0;
+	so->bound   = 0;
+
+	sock_orphan(sk);
+	sock->sk = NULL;
+
+	release_sock(sk);
+	sock_put(sk);
+
+	return 0;
+}
+
+static int isotp_bind(struct socket *sock, struct sockaddr *uaddr, int len)
+{
+	struct sockaddr_can *addr = (struct sockaddr_can *)uaddr;
+	struct sock *sk = sock->sk;
+	struct isotp_sock *so = isotp_sk(sk);
+	int ifindex;
+	struct net_device *dev;
+	int err = 0;
+	int notify_enetdown = 0;
+
+	if (len < sizeof(*addr))
+		return -EINVAL;
+
+	if (addr->can_addr.tp.rx_id == addr->can_addr.tp.tx_id)
+		return -EADDRNOTAVAIL;
+
+	if ((addr->can_addr.tp.rx_id | addr->can_addr.tp.tx_id) &
+	    (CAN_ERR_FLAG | CAN_RTR_FLAG))
+		return -EADDRNOTAVAIL;
+
+	if (!addr->can_ifindex)
+		return -ENODEV;
+
+	lock_sock(sk);
+
+	if (so->bound && addr->can_ifindex == so->ifindex &&
+	    addr->can_addr.tp.rx_id == so->rxid &&
+	    addr->can_addr.tp.tx_id == so->txid)
+		goto out;
+
+	dev = dev_get_by_index(&init_net, addr->can_ifindex);
+	if (!dev) {
+		err = -ENODEV;
+		goto out;
+	}
+	if (dev->type != ARPHRD_CAN) {
+		dev_put(dev);
+		err = -ENODEV;
+		goto out;
+	}
+	if (!(dev->flags & IFF_UP))
+		notify_enetdown = 1;
+
+	ifindex = dev->ifindex;
+
+	can_rx_register(dev, addr->can_addr.tp.rx_id,
+			SINGLE_MASK(addr->can_addr.tp.rx_id),
+			isotp_rcv, sk, "isotp");
+	dev_put(dev);
+
+	if (so->bound) {
+		/* unregister old filter */
+		if (so->ifindex) {
+			dev = dev_get_by_index(&init_net, so->ifindex);
+			if (dev) {
+				can_rx_unregister(dev, so->rxid,
+						  SINGLE_MASK(so->rxid),
+						  isotp_rcv, sk);
+				dev_put(dev);
+			}
+		}
+	}
+
+	/* switch to new settings */
+	so->ifindex = ifindex;
+	so->rxid = addr->can_addr.tp.rx_id;
+	so->txid = addr->can_addr.tp.tx_id;
+	so->bound = 1;
+
+ out:
+	release_sock(sk);
+
+	if (notify_enetdown) {
+		sk->sk_err = ENETDOWN;
+		if (!sock_flag(sk, SOCK_DEAD))
+			sk->sk_error_report(sk);
+	}
+
+	return err;
+}
+
+static int isotp_getname(struct socket *sock, struct sockaddr *uaddr,
+		       int *len, int peer)
+{
+	struct sockaddr_can *addr = (struct sockaddr_can *)uaddr;
+	struct sock *sk = sock->sk;
+	struct isotp_sock *so = isotp_sk(sk);
+
+	if (peer)
+		return -EOPNOTSUPP;
+
+	addr->can_family  = AF_CAN;
+	addr->can_ifindex = so->ifindex;
+
+	*len = sizeof(*addr);
+
+	return 0;
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,32)
+static int isotp_setsockopt(struct socket *sock, int level, int optname,
+			    char __user *optval, unsigned int optlen)
+#else
+static int isotp_setsockopt(struct socket *sock, int level, int optname,
+			    char __user *optval, int optlen)
+#endif
+{
+	struct sock *sk = sock->sk;
+	struct isotp_sock *so = isotp_sk(sk);
+	int ret = 0;
+
+	if (level != SOL_CAN_ISOTP)
+		return -EINVAL;
+	if (optlen < 0)
+		return -EINVAL;
+
+	switch (optname) {
+
+	case CAN_ISOTP_OPTS:
+		if (optlen != sizeof(struct can_isotp_options))
+			return -EINVAL;
+
+		if (copy_from_user(&so->opt, optval, optlen))
+			return -EFAULT;
+		break;
+
+	case CAN_ISOTP_RECV_FC:
+		if (optlen != sizeof(struct can_isotp_fc_options))
+			return -EINVAL;
+
+		if (copy_from_user(&so->rxfc, optval, optlen))
+			return -EFAULT;
+		break;
+
+	case CAN_ISOTP_TX_STMIN:
+		if (optlen != sizeof(__u32))
+			return -EINVAL;
+
+		if (copy_from_user(&so->force_tx_stmin, optval, optlen))
+			return -EFAULT;
+		break;
+
+	case CAN_ISOTP_RX_STMIN:
+		if (optlen != sizeof(__u32))
+			return -EINVAL;
+
+		if (copy_from_user(&so->force_rx_stmin, optval, optlen))
+			return -EFAULT;
+		break;
+
+	default:
+		ret = -ENOPROTOOPT;
+	}
+
+	return ret;
+}
+
+static int isotp_getsockopt(struct socket *sock, int level, int optname,
+			  char __user *optval, int __user *optlen)
+{
+	struct sock *sk = sock->sk;
+	struct isotp_sock *so = isotp_sk(sk);
+	int len;
+	void *val;
+
+	if (level != SOL_CAN_ISOTP)
+		return -EINVAL;
+	if (get_user(len, optlen))
+		return -EFAULT;
+	if (len < 0)
+		return -EINVAL;
+
+	switch (optname) {
+
+	case CAN_ISOTP_OPTS:
+		len = min_t(int, len, sizeof(struct can_isotp_options));
+		val = &so->opt;
+		break;
+
+	case CAN_ISOTP_RECV_FC:
+		len = min_t(int, len, sizeof(struct can_isotp_fc_options));
+		val = &so->rxfc;
+		break;
+
+	case CAN_ISOTP_TX_STMIN:
+		len = min_t(int, len, sizeof(__u32));
+		val = &so->force_tx_stmin;
+		break;
+
+	case CAN_ISOTP_RX_STMIN:
+		len = min_t(int, len, sizeof(__u32));
+		val = &so->force_rx_stmin;
+		break;
+
+	default:
+		return -ENOPROTOOPT;
+	}
+
+	if (put_user(len, optlen))
+		return -EFAULT;
+	if (copy_to_user(optval, val, len))
+		return -EFAULT;
+	return 0;
+}
+
+
+static int isotp_notifier(struct notifier_block *nb,
+			unsigned long msg, void *data)
+{
+	struct net_device *dev = (struct net_device *)data;
+	struct isotp_sock *so = container_of(nb, struct isotp_sock, notifier);
+	struct sock *sk = &so->sk;
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,26)
+	if (dev_net(dev) != &init_net)
+		return NOTIFY_DONE;
+#elif LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,24)
+	if (dev->nd_net != &init_net)
+		return NOTIFY_DONE;
+#endif
+
+	if (dev->type != ARPHRD_CAN)
+		return NOTIFY_DONE;
+
+	if (so->ifindex != dev->ifindex)
+		return NOTIFY_DONE;
+
+	switch (msg) {
+
+	case NETDEV_UNREGISTER:
+		lock_sock(sk);
+		/* remove current filters & unregister */
+		if (so->bound)
+			can_rx_unregister(dev, so->rxid, SINGLE_MASK(so->rxid),
+					  isotp_rcv, sk);
+
+		so->ifindex = 0;
+		so->bound   = 0;
+		release_sock(sk);
+
+		sk->sk_err = ENODEV;
+		if (!sock_flag(sk, SOCK_DEAD))
+			sk->sk_error_report(sk);
+		break;
+
+	case NETDEV_DOWN:
+		sk->sk_err = ENETDOWN;
+		if (!sock_flag(sk, SOCK_DEAD))
+			sk->sk_error_report(sk);
+		break;
+	}
+
+	return NOTIFY_DONE;
+}
+
+
+static int isotp_init(struct sock *sk)
+{
+	struct isotp_sock *so = isotp_sk(sk);
+
+	so->ifindex = 0;
+	so->bound   = 0;
+
+	so->opt.flags		= CAN_ISOTP_DEFAULT_FLAGS;
+	so->opt.ext_address	= CAN_ISOTP_DEFAULT_EXT_ADDRESS;
+	so->opt.rxpad_content	= CAN_ISOTP_DEFAULT_RXPAD_CONTENT;
+	so->opt.txpad_content	= CAN_ISOTP_DEFAULT_TXPAD_CONTENT;
+	so->opt.frame_txtime	= CAN_ISOTP_DEFAULT_FRAME_TXTIME;
+	so->rxfc.bs		= CAN_ISOTP_DEFAULT_RECV_BS;
+	so->rxfc.stmin		= CAN_ISOTP_DEFAULT_RECV_STMIN;
+	so->rxfc.wftmax		= CAN_ISOTP_DEFAULT_RECV_WFTMAX;
+
+	so->rx.state = ISOTP_IDLE;
+	so->tx.state = ISOTP_IDLE;
+
+	hrtimer_init(&so->rxtimer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
+	so->rxtimer.function = isotp_rx_timer_handler;
+	hrtimer_init(&so->txtimer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
+	so->txtimer.function = isotp_tx_timer_handler;
+
+	tasklet_init(&so->txtsklet, isotp_tx_timer_tsklet, (unsigned long)so);
+
+	init_waitqueue_head(&so->wait);
+
+	so->notifier.notifier_call = isotp_notifier;
+	register_netdevice_notifier(&so->notifier);
+
+	return 0;
+}
+
+
+static const struct proto_ops isotp_ops = {
+	.family        = PF_CAN,
+	.release       = isotp_release,
+	.bind          = isotp_bind,
+	.connect       = sock_no_connect,
+	.socketpair    = sock_no_socketpair,
+	.accept        = sock_no_accept,
+	.getname       = isotp_getname,
+	.poll          = datagram_poll,
+	.ioctl         = can_ioctl,	/* use can_ioctl() from af_can.c */
+	.listen        = sock_no_listen,
+	.shutdown      = sock_no_shutdown,
+	.setsockopt    = isotp_setsockopt,
+	.getsockopt    = isotp_getsockopt,
+	.sendmsg       = isotp_sendmsg,
+	.recvmsg       = isotp_recvmsg,
+	.mmap          = sock_no_mmap,
+	.sendpage      = sock_no_sendpage,
+};
+
+static struct proto isotp_proto __read_mostly = {
+	.name       = "CAN_ISOTP",
+	.owner      = THIS_MODULE,
+	.obj_size   = sizeof(struct isotp_sock),
+	.init       = isotp_init,
+};
+
+static const struct can_proto isotp_can_proto = {
+	.type       = SOCK_DGRAM,
+	.protocol   = CAN_ISOTP,
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,33)
+	.capability = -1,
+#endif
+	.ops        = &isotp_ops,
+	.prot       = &isotp_proto,
+};
+
+static __init int isotp_module_init(void)
+{
+	int err;
+
+	printk(banner);
+
+	err = can_proto_register(&isotp_can_proto);
+	if (err < 0)
+		printk(KERN_ERR "can: registration of isotp protocol failed\n");
+
+	return err;
+}
+
+static __exit void isotp_module_exit(void)
+{
+	can_proto_unregister(&isotp_can_proto);
+}
+
+module_init(isotp_module_init);
+module_exit(isotp_module_exit);
diff --exclude CVS --exclude .git -uNr linux-2.6.27.8/net/can/j1939/Kconfig linux-2.6.27.8.modified/net/can/j1939/Kconfig
--- linux-2.6.27.8/net/can/j1939/Kconfig	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.27.8.modified/net/can/j1939/Kconfig	2013-05-30 03:44:13.000000000 -0400
@@ -0,0 +1,22 @@
+#
+# SAE J1939 network layer core configuration
+#
+
+config CAN_J1939
+	tristate "SAE J1939"
+	depends on CAN
+	---help---
+	  SAE J1939
+	  Say Y to have in-kernel support for j1939 socket type. This
+	  allows communication according to SAE j1939.
+	  The relevant parts in kernel are
+	  SAE j1939-21 (datalink & transport protocol)
+	  & SAE j1939-81 (network management).
+
+config CAN_J1939_DEBUG
+	bool "debug SAE J1939"
+	depends on CAN_J1939
+	default n
+	---help---
+	  Say Y to add extra debug code (via printk) in the j1939 stack
+
diff --exclude CVS --exclude .git -uNr linux-2.6.27.8/net/can/j1939/Makefile linux-2.6.27.8.modified/net/can/j1939/Makefile
--- linux-2.6.27.8/net/can/j1939/Makefile	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.27.8.modified/net/can/j1939/Makefile	2013-05-30 03:44:13.000000000 -0400
@@ -0,0 +1,40 @@
+
+
+#
+#  $Id: Makefile 1127 2010-02-18 18:37:20Z hartkopp $
+#
+
+ifeq ($(KERNELRELEASE),)
+
+KERNELDIR := /lib/modules/$(shell uname -r)/build
+PWD       := $(shell pwd)
+TOPDIR    := $(PWD)/../..
+
+modules modules_install clean:
+	$(MAKE) -C $(KERNELDIR) M=$(PWD) $@ TOPDIR=$(TOPDIR)
+
+export CONFIG_CAN=m
+export CONFIG_CAN_RAW=m
+export CONFIG_CAN_BCM=m
+export CONFIG_CAN_ISOTP=m
+export CONFIG_CAN_GW=m
+export CONFIG_CAN_J1939=m
+
+else
+
+-include $(TOPDIR)/Makefile.common
+
+obj-$(CONFIG_CAN_J1939)	+= can-j1939.o
+
+can-j1939-objs := main.o \
+	proc.o bus.o \
+	rtnl.o \
+	socket.o \
+	address-claim.o transport.o \
+	promisc.o filter.o
+
+ifeq ($(CONFIG_CAN_J1939_DEBUG),y)
+	EXTRA_CFLAGS += -DDEBUG
+endif
+
+endif
\ No newline at end of file
diff --exclude CVS --exclude .git -uNr linux-2.6.27.8/net/can/j1939/address-claim.c linux-2.6.27.8.modified/net/can/j1939/address-claim.c
--- linux-2.6.27.8/net/can/j1939/address-claim.c	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.27.8.modified/net/can/j1939/address-claim.c	2013-05-30 03:44:13.000000000 -0400
@@ -0,0 +1,227 @@
+/*
+ * Copyright (c) 2010-2011 EIA Electronics
+ *
+ * Authors:
+ * Pieter Beyens <pieter.beyens@eia.be>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the version 2 of the GNU General Public License
+ * as published by the Free Software Foundation
+ */
+
+/*
+ * J1939 Address Claiming.
+ * Address Claiming in the kernel
+ * - keeps track of the AC states of ECU's,
+ * - resolves NAME<=>SA taking into account the AC states of ECU's.
+ *
+ * All Address Claim msgs (including host-originated msg) are processed
+ * at the receive path (a sent msg is always received again via CAN echo).
+ * As such, the processing of AC msgs is done in the order on which msgs
+ * are sent on the bus.
+ *
+ * This module doesn't send msgs itself (e.g. replies on Address Claims),
+ * this is the responsibility of a user space application or daemon.
+ */
+
+#include <linux/skbuff.h>
+#include <linux/byteorder/generic.h>
+
+#include "j1939-priv.h"
+
+#define CANDATA2NAME(data) le64_to_cpup((uint64_t *)data)
+
+static inline int ac_msg_is_request_for_ac(struct sk_buff *skb)
+{
+	struct j1939_sk_buff_cb *sk_addr = (void *)skb->cb;
+	int req_pgn;
+
+	if ((skb->len < 3) || (sk_addr->pgn != PGN_REQUEST))
+		return 0;
+	req_pgn = skb->data[0] | (skb->data[1] << 8) | (skb->data[2] << 16);
+	return req_pgn = PGN_ADDRESS_CLAIMED;
+}
+
+static int j1939_verify_outgoing_address_claim(struct sk_buff *skb)
+{
+	struct j1939_sk_buff_cb *sk_addr = (void *)skb->cb;
+
+	if (skb->len != 8) {
+		j1939_notice("tx address claim with dlc %i\n", skb->len);
+		return -EPROTO;
+	}
+
+	if (sk_addr->src.name != CANDATA2NAME(skb->data)) {
+		j1939_notice("tx address claim with different name\n");
+		return -EPROTO;
+	}
+
+	if (sk_addr->src.addr == J1939_NO_ADDR) {
+		j1939_notice("tx address claim with broadcast sa\n");
+		return -EPROTO;
+	}
+
+	/* ac must always be a broadcast */
+	if (sk_addr->dst.name || (sk_addr->dst.addr != J1939_NO_ADDR)) {
+		j1939_notice("tx address claim with dest, not broadcast\n");
+		return -EPROTO;
+	}
+	return 0;
+}
+
+int j1939_send_address_claim(struct sk_buff *skb)
+{
+	int ret, sa;
+	struct j1939_sk_buff_cb *sk_addr = (void *)skb->cb;
+
+	/* network mgmt: address claiming msgs */
+	if (sk_addr->pgn == PGN_ADDRESS_CLAIMED) {
+		struct j1939_ecu *ecu;
+
+		ret = j1939_verify_outgoing_address_claim(skb);
+		/* return both when failure & when successfull */
+		if (ret < 0)
+			return ret;
+		ecu = j1939_ecu_find_by_name(sk_addr->src.name,
+				sk_addr->ifindex);
+		if (!ecu)
+			return -ENODEV;
+		if (!(ecu->flags & ECUFLAG_LOCAL)) {
+			put_j1939_ecu(ecu);
+			return -EREMOTE;
+		}
+
+		if (ecu->sa != sk_addr->src.addr)
+			/* hold further traffic for ecu, remove from parent */
+			j1939_ecu_remove_sa(ecu);
+		put_j1939_ecu(ecu);
+	} else if (sk_addr->src.name) {
+		/* assign source address */
+		sa = j1939_name_to_sa(sk_addr->src.name, sk_addr->ifindex);
+		if (!j1939_address_is_unicast(sa) &&
+				!ac_msg_is_request_for_ac(skb)) {
+			j1939_notice("tx drop: invalid sa for name "
+					"0x%016llx\n", sk_addr->src.name);
+			return -EADDRNOTAVAIL;
+		}
+		sk_addr->src.addr = sa;
+	}
+
+	/* assign destination address */
+	if (sk_addr->dst.name) {
+		sa = j1939_name_to_sa(sk_addr->dst.name, sk_addr->ifindex);
+		if (!j1939_address_is_unicast(sa)) {
+			j1939_notice("tx drop: invalid da for name "
+					"0x%016llx\n", sk_addr->dst.name);
+			return -EADDRNOTAVAIL;
+		}
+		sk_addr->dst.addr = sa;
+	}
+	return 0;
+}
+
+static struct j1939_ecu *j1939_process_address_claim(struct sk_buff *skb)
+{
+	struct j1939_sk_buff_cb *sk_addr = (void *)skb->cb;
+	struct j1939_ecu *ecu, *dut, **pref;
+	name_t name;
+
+	if (skb->len < 8) {
+		j1939_notice("rx address claim with wrong dlc %i\n", skb->len);
+		return ERR_PTR(-EPROTO);
+	}
+
+	name = CANDATA2NAME(skb->data);
+	if (!name) {
+		j1939_notice("rx address claim without name\n");
+		return ERR_PTR(-EPROTO);
+	}
+
+	if (!j1939_address_is_valid(sk_addr->src.addr)) {
+		j1939_notice("rx address claim with broadcast sa\n");
+		return ERR_PTR(-EPROTO);
+	}
+
+	ecu = j1939_ecu_get_register(name, sk_addr->ifindex, ECUFLAG_REMOTE, 1);
+	if (IS_ERR(ecu))
+		return ecu;
+	if ((ecu->flags & ECUFLAG_LOCAL) && !skb->sk)
+		j1939_warning("duplicate name on the bus %016llx!\n",
+				(long long)name);
+
+	if (sk_addr->src.addr >= J1939_IDLE_ADDR) {
+		j1939_ecu_remove_sa(ecu);
+		if (ecu->flags & ECUFLAG_REMOTE)
+			/* extra put => schedule removal */
+			j1939_ecu_unregister(ecu);
+		return ecu;
+	}
+
+	write_lock_bh(&ecu->parent->lock);
+	/* save new SA */
+	if (sk_addr->src.addr != ecu->sa)
+		j1939_ecu_remove_sa_locked(ecu);
+	ecu->sa = sk_addr->src.addr;
+	/* iterate this segment */
+	list_for_each_entry(dut, &ecu->parent->ecus, list) {
+		/* cancel pending claims for this SA */
+		/* this includes myself ! */
+		if (ecu->sa == dut->sa)
+			/*
+			 * cancel pending claims for our new SA
+			 * this includes 'ecu', since we will
+			 * schedule a timer soon now
+			 */
+			hrtimer_try_to_cancel(&dut->ac_timer);
+		if ((ecu->sa == dut->sa) && (dut->name > ecu->name))
+			dut->sa = J1939_IDLE_ADDR;
+	}
+
+	pref = &ecu->parent->ents[sk_addr->src.addr].ecu;
+	if (*pref && ((*pref)->name > ecu->name))
+		*pref = NULL;
+
+	/* schedule timer in 250 msec to commit address change */
+	hrtimer_start(&ecu->ac_timer, ktime_set(0, 250000000),
+			HRTIMER_MODE_REL);
+	write_unlock_bh(&ecu->parent->lock);
+
+	return ecu;
+}
+
+int j1939_recv_address_claim(struct sk_buff *skb)
+{
+	struct j1939_sk_buff_cb *sk_addr = (void *)skb->cb;
+	struct j1939_ecu *ecu;
+
+	/*
+	 * network mgmt
+	 */
+	if (sk_addr->pgn == PGN_ADDRESS_CLAIMED) {
+		ecu = j1939_process_address_claim(skb);
+		if (IS_ERR(ecu))
+			return PTR_ERR(ecu);
+	} else if (j1939_address_is_unicast(sk_addr->src.addr)) {
+		ecu = j1939_ecu_find_by_addr(sk_addr->src.addr,
+				sk_addr->ifindex);
+	} else {
+		ecu = NULL;
+	}
+
+	/* assign source stuff */
+	if (ecu) {
+		ecu->rxtime = ktime_get();
+		sk_addr->src.flags = ecu->flags;
+		sk_addr->src.name = ecu->name;
+		put_j1939_ecu(ecu);
+	}
+	/* assign destination stuff */
+	ecu = j1939_ecu_find_by_addr(sk_addr->dst.addr, sk_addr->ifindex);
+	if (ecu) {
+		sk_addr->dst.flags = ecu->flags;
+		sk_addr->dst.name = ecu->name;
+		put_j1939_ecu(ecu);
+	}
+	return 0;
+}
+
diff --exclude CVS --exclude .git -uNr linux-2.6.27.8/net/can/j1939/bus.c linux-2.6.27.8.modified/net/can/j1939/bus.c
--- linux-2.6.27.8/net/can/j1939/bus.c	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.27.8.modified/net/can/j1939/bus.c	2013-05-30 03:44:13.000000000 -0400
@@ -0,0 +1,597 @@
+/*
+ * Copyright (c) 2010-2011 EIA Electronics
+ *
+ * Authors:
+ * Kurt Van Dijck <kurt.van.dijck@eia.be>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the version 2 of the GNU General Public License
+ * as published by the Free Software Foundation
+ */
+
+/*
+ * j1939-bus.c - bus for j1939 remote devices
+ * Since rtnetlink, no real bus is used.
+ */
+
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/err.h>
+#include <linux/workqueue.h>
+
+#include "j1939-priv.h"
+
+#define jseg_dbg(jseg, fmt, ...) \
+	pr_debug("j1939-%i: " fmt, (jseg)->ifindex, ##__VA_ARGS__)
+
+#define ecu_dbg(ecu, fmt, ...) \
+	pr_debug("j1939-%i,%016llx,%02x: " fmt, (ecu)->parent->ifindex, \
+		(ecu)->name, (ecu)->sa, ##__VA_ARGS__)
+#define ecu_alert(ecu, fmt, ...) \
+	pr_alert("j1939-%i,%016llx,%02x: " fmt, (ecu)->parent->ifindex, \
+		(ecu)->name, (ecu)->sa, ##__VA_ARGS__)
+
+static struct {
+	struct list_head list;
+	spinlock_t lock;
+} segments;
+
+struct j1939_segment *j1939_segment_find(int ifindex)
+{
+	struct j1939_segment *jseg;
+
+	spin_lock_bh(&segments.lock);
+	list_for_each_entry(jseg, &segments.list, flist) {
+		if (jseg->ifindex == ifindex) {
+			get_j1939_segment(jseg);
+			goto found;
+		}
+	}
+	jseg = NULL;
+found:
+	spin_unlock_bh(&segments.lock);
+	return jseg;
+}
+
+/*
+ * iterate over ECU's,
+ * and register flagged ecu's on their claimed SA
+ */
+static void j1939_segment_ac_task(unsigned long val)
+{
+	struct j1939_segment *jseg = (void *)val;
+	struct j1939_ecu *ecu;
+
+	write_lock_bh(&jseg->lock);
+	list_for_each_entry(ecu, &jseg->ecus, list) {
+		/* next 2 (read & set) could be merged into xxx? */
+		if (!atomic_read(&ecu->ac_delay_expired))
+			continue;
+		atomic_set(&ecu->ac_delay_expired, 0);
+		if (j1939_address_is_unicast(ecu->sa))
+			ecu->parent->ents[ecu->sa].ecu = ecu;
+	}
+	write_unlock_bh(&jseg->lock);
+}
+/*
+ * segment device interface
+ */
+static void cb_put_j1939_segment(struct kref *kref)
+{
+	struct j1939_segment *jseg =
+		container_of(kref, struct j1939_segment, kref);
+
+	tasklet_disable_nosync(&jseg->ac_task);
+	kfree(jseg);
+}
+
+void put_j1939_segment(struct j1939_segment *segment)
+{
+	kref_put(&segment->kref, cb_put_j1939_segment);
+}
+
+int j1939_segment_register(struct net_device *netdev)
+{
+	int ret;
+	struct j1939_segment *jseg;
+
+	jseg = j1939_segment_find(netdev->ifindex);
+	if (jseg) {
+		put_j1939_segment(jseg);
+		ret = -EALREADY;
+		goto fail_exist;
+	}
+	jseg = kzalloc(sizeof(*jseg), GFP_KERNEL);
+	if (!jseg) {
+		ret = -ENOMEM;
+		goto fail_malloc;
+	}
+	tasklet_init(&jseg->ac_task, j1939_segment_ac_task,
+			(unsigned long)jseg);
+	rwlock_init(&jseg->lock);
+	INIT_LIST_HEAD(&jseg->ecus);
+	INIT_LIST_HEAD(&jseg->flist);
+	jseg->ifindex = netdev->ifindex;
+
+	kref_init(&jseg->kref);
+
+	spin_lock_bh(&segments.lock);
+	list_add_tail(&jseg->flist, &segments.list);
+	spin_unlock_bh(&segments.lock);
+
+	jseg_dbg(jseg, "register\n");
+	return 0;
+
+fail_malloc:
+fail_exist:
+	return ret;
+}
+
+void j1939_segment_unregister(struct j1939_segment *jseg)
+{
+	struct j1939_ecu *ecu;
+
+	if (!jseg)
+		return;
+
+	spin_lock_bh(&segments.lock);
+	list_del_init(&jseg->flist);
+	spin_unlock_bh(&segments.lock);
+
+	write_lock_bh(&jseg->lock);
+	while (!list_empty(&jseg->ecus)) {
+		ecu = list_first_entry(&jseg->ecus, struct j1939_ecu, list);
+		write_unlock_bh(&jseg->lock);
+		j1939_ecu_unregister(ecu);
+		write_lock_bh(&jseg->lock);
+	}
+	write_unlock_bh(&jseg->lock);
+	jseg_dbg(jseg, "unregister\n");
+	put_j1939_segment(jseg);
+}
+
+/*
+ * ECU device interface
+ */
+static enum hrtimer_restart j1939_ecu_timer_handler(struct hrtimer *hrtimer)
+{
+	struct j1939_ecu *ecu =
+		container_of(hrtimer, struct j1939_ecu, ac_timer);
+
+	atomic_set(&ecu->ac_delay_expired, 1);
+	tasklet_schedule(&ecu->parent->ac_task);
+	return HRTIMER_NORESTART;
+}
+
+static void cb_put_j1939_ecu(struct kref *kref)
+{
+	struct j1939_ecu *ecu =container_of(kref, struct j1939_ecu, kref);
+
+	kfree(ecu);
+}
+void put_j1939_ecu(struct j1939_ecu *ecu)
+{
+	kref_put(&ecu->kref, cb_put_j1939_ecu);
+}
+
+struct j1939_ecu *j1939_ecu_get_register(name_t name, int ifindex, int flags,
+		int return_existing)
+{
+	struct j1939_segment *parent;
+	struct j1939_ecu *ecu, *dut;
+
+	if (!ifindex || !name) {
+		pr_alert("%s(%i, %016llx) invalid\n",
+				__func__, ifindex, (long long)name);
+		return ERR_PTR(-EINVAL);
+	}
+
+	parent = j1939_segment_find(ifindex);
+	if (!parent) {
+		pr_alert("%s %i: segment not found\n", __func__, ifindex);
+		return ERR_PTR(-EINVAL);
+	}
+	if (return_existing) {
+		read_lock_bh(&parent->lock);
+		/* test for existing name */
+		list_for_each_entry(dut, &parent->ecus, list) {
+			if (dut->name == name) {
+				get_j1939_ecu(dut);
+				read_unlock_bh(&parent->lock);
+				return dut;
+			}
+		}
+		read_unlock_bh(&parent->lock);
+	}
+	/* alloc */
+	ecu = kzalloc(sizeof(*ecu), gfp_any());
+	if (!ecu)
+		/* should we look for an existing ecu */
+		return ERR_PTR(-ENOMEM);
+	kref_init(&ecu->kref);
+	ecu->sa = J1939_IDLE_ADDR;
+	ecu->name = name;
+	ecu->flags = flags;
+
+	hrtimer_init(&ecu->ac_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
+	ecu->ac_timer.function = j1939_ecu_timer_handler;
+	INIT_LIST_HEAD(&ecu->list);
+
+	/* first add to internal list */
+	write_lock_bh(&parent->lock);
+	/* test for duplicate name */
+	list_for_each_entry(dut, &parent->ecus, list) {
+		if (dut->name == ecu->name)
+			goto duplicate;
+	}
+	get_j1939_ecu(ecu);
+	/* a ref to parent is held */
+	ecu->parent = parent;
+	list_add_tail(&ecu->list, &parent->ecus);
+	write_unlock_bh(&parent->lock);
+	ecu_dbg(ecu, "register\n");
+	return ecu;
+
+duplicate:
+	get_j1939_ecu(dut);
+	write_unlock_bh(&parent->lock);
+	put_j1939_segment(parent);
+	if (return_existing)
+		return dut;
+	ecu_alert(ecu, "duplicate name\n");
+	put_j1939_ecu(ecu);
+	return ERR_PTR(-EEXIST);
+}
+
+void j1939_ecu_unregister(struct j1939_ecu *ecu)
+{
+	BUG_ON(!ecu);
+	ecu_dbg(ecu, "unregister\n");
+	hrtimer_try_to_cancel(&ecu->ac_timer);
+
+	write_lock_bh(&ecu->parent->lock);
+	j1939_ecu_remove_sa_locked(ecu);
+	list_del_init(&ecu->list);
+	write_unlock_bh(&ecu->parent->lock);
+	/* put segment, reverting the effect done by ..._register() */
+	put_j1939_segment(ecu->parent);
+	put_j1939_ecu(ecu);
+}
+
+struct j1939_ecu *j1939_ecu_find_by_addr(int sa, int ifindex)
+{
+	struct j1939_ecu *ecu;
+	struct j1939_segment *parent;
+
+	if (!j1939_address_is_unicast(sa))
+		return NULL;
+	parent = j1939_segment_find(ifindex);
+	if (!parent)
+		return NULL;
+	read_lock_bh(&parent->lock);
+	ecu = parent->ents[sa].ecu;
+	if (ecu)
+		get_j1939_ecu(ecu);
+	read_unlock_bh(&parent->lock);
+	put_j1939_segment(parent);
+	return ecu;
+}
+
+int j1939_name_to_sa(uint64_t name, int ifindex)
+{
+	struct j1939_ecu *ecu;
+	struct j1939_segment *parent;
+	int sa;
+
+	if (!name)
+		return J1939_IDLE_ADDR;
+	parent = j1939_segment_find(ifindex);
+	if (!parent)
+		return J1939_IDLE_ADDR;
+
+	sa = J1939_IDLE_ADDR;
+	read_lock_bh(&parent->lock);
+	list_for_each_entry(ecu, &parent->ecus, list) {
+		if (ecu->name == name) {
+			if ((sa == J1939_IDLE_ADDR) &&
+			    (parent->ents[ecu->sa].ecu == ecu))
+				/* ecu's SA is registered */
+				sa = ecu->sa;
+			break;
+		}
+	}
+	read_unlock_bh(&parent->lock);
+	put_j1939_segment(parent);
+	return sa;
+}
+
+struct j1939_ecu *j1939_ecu_find_segment_default_tx(int ifindex,
+		name_t *name, uint8_t *addr)
+{
+	struct j1939_ecu *ecu;
+	struct j1939_segment *parent;
+	struct addr_ent *paddr;
+	int j;
+
+	if (ifindex <= 0)
+		return ERR_PTR(-EINVAL);
+	parent = j1939_segment_find(ifindex);
+	if (!parent)
+		return ERR_PTR(-ENETUNREACH);
+	read_lock_bh(&parent->lock);
+	list_for_each_entry(ecu, &parent->ecus, list) {
+		if (ecu->flags & ECUFLAG_LOCAL) {
+			get_j1939_ecu(ecu);
+			if (name)
+				*name = ecu->name;
+			if (addr)
+				*addr = ecu->sa;
+			goto found;
+		}
+	}
+	ecu = NULL;
+	for (j = 0, paddr = parent->ents; j < J1939_IDLE_ADDR; ++j, ++paddr) {
+		if (paddr->ecu)
+			continue;
+		if (paddr->flags & ECUFLAG_LOCAL) {
+			if (name)
+				*name = 0;
+			if (addr)
+				*addr = j;
+			goto found;
+		}
+	}
+	ecu = ERR_PTR(-EHOSTDOWN);
+found:
+	read_unlock_bh(&parent->lock);
+	put_j1939_segment(parent);
+	return ecu;
+}
+
+/* ecu lookup helper */
+static struct j1939_ecu *_j1939_ecu_find_by_name(name_t name,
+		struct j1939_segment *jseg)
+{
+	struct j1939_ecu *ecu;
+
+	read_lock_bh(&jseg->lock);
+	list_for_each_entry(ecu, &jseg->ecus, list) {
+		if (ecu->name == name) {
+			get_j1939_ecu(ecu);
+			goto found_on_intf;
+		}
+	}
+	ecu = NULL;
+found_on_intf:
+	read_unlock_bh(&jseg->lock);
+	return ecu;
+}
+
+/* ecu lookup by name */
+struct j1939_ecu *j1939_ecu_find_by_name(name_t name, int ifindex)
+{
+	struct j1939_ecu *ecu;
+	struct j1939_segment *jseg;
+
+	if (!name)
+		return NULL;
+	if (ifindex) {
+		jseg = j1939_segment_find(ifindex);
+		if (!jseg)
+			return NULL;
+		ecu = _j1939_ecu_find_by_name(name, jseg);
+		put_j1939_segment(jseg);
+		return ecu;
+	}
+	/* iterate segments */
+	spin_lock_bh(&segments.lock);
+	list_for_each_entry(jseg, &segments.list, flist) {
+		get_j1939_segment(jseg);
+		ecu = _j1939_ecu_find_by_name(name, jseg);
+		put_j1939_segment(jseg);
+		if (ecu)
+			goto found;
+	}
+	ecu = NULL;
+found:
+	spin_unlock_bh(&segments.lock);
+	return ecu;
+}
+
+/* PROC */
+static int j1939_proc_addr(struct seq_file *sqf, void *v)
+{
+	struct j1939_segment *jseg;
+	struct net_device *netdev;
+	struct addr_ent *paddr;
+	int j, flags;
+	ktime_t now;
+	struct timeval tv;
+
+	now = ktime_get();
+	seq_printf(sqf, "iface\tSA\tflags\trxtime\n");
+	spin_lock_bh(&segments.lock);
+	list_for_each_entry(jseg, &segments.list, flist) {
+		get_j1939_segment(jseg);
+		netdev = dev_get_by_index(&init_net, jseg->ifindex);
+		if (!netdev) {
+			pr_alert("j1939 proc: ifindex %i not found\n",
+				jseg->ifindex);
+			put_j1939_segment(jseg);
+			continue;
+		}
+		read_lock_bh(&jseg->lock);
+		for (j = 0, paddr = jseg->ents; j < J1939_IDLE_ADDR;
+				++j, ++paddr) {
+			flags = paddr->flags;
+			if (paddr->ecu)
+				flags |= paddr->ecu->flags;
+			tv = ktime_to_timeval(ktime_sub(now, paddr->rxtime));
+			if (!paddr->flags && !paddr->ecu)
+				continue;
+			seq_printf(sqf, "%s\t%02x\t%c%c%c%c\t-%lu.%06lu\n",
+				netdev->name, j,
+				(flags & ECUFLAG_LOCAL) ? 'L' : '-',
+				(flags & ECUFLAG_REMOTE) ? 'R' : '-',
+				(paddr->flags) ? 'S' : '-',
+				paddr->ecu ? 'E' : '-',
+				tv.tv_sec, tv.tv_usec);
+		}
+		read_unlock_bh(&jseg->lock);
+		dev_put(netdev);
+		put_j1939_segment(jseg);
+	}
+	spin_unlock_bh(&segments.lock);
+	return 0;
+}
+
+static int j1939_proc_ecu(struct seq_file *sqf, void *v)
+{
+	struct j1939_segment *jseg;
+	struct j1939_ecu *ecu;
+	struct net_device *netdev;
+	ktime_t now;
+	struct timeval tv;
+	char sa[4];
+
+	now = ktime_get();
+	seq_printf(sqf, "iface\taddr\tname\tflags\trxtime\n");
+	spin_lock_bh(&segments.lock);
+	list_for_each_entry(jseg, &segments.list, flist) {
+		get_j1939_segment(jseg);
+		netdev = dev_get_by_index(&init_net, jseg->ifindex);
+		if (!netdev) {
+			pr_alert("j1939 proc: ifindex %i not found\n",
+				jseg->ifindex);
+			put_j1939_segment(jseg);
+			continue;
+		}
+		read_lock_bh(&jseg->lock);
+		list_for_each_entry(ecu, &jseg->ecus, list) {
+			tv = ktime_to_timeval(ktime_sub(now, ecu->rxtime));
+			if (j1939_address_is_unicast(ecu->sa) &&
+				(ecu->parent->ents[ecu->sa].ecu == ecu))
+				snprintf(sa, sizeof(sa), "%02x", ecu->sa);
+			else
+				strcpy(sa, "-");
+			seq_printf(sqf, "%s\t%s\t%016llx\t%c\t-%lu.%06lu\n",
+				netdev->name, sa,
+				(unsigned long long)ecu->name,
+				(ecu->flags & ECUFLAG_LOCAL) ? 'L' : 'R',
+				tv.tv_sec, tv.tv_usec);
+		}
+		read_unlock_bh(&jseg->lock);
+		dev_put(netdev);
+		put_j1939_segment(jseg);
+	}
+	spin_unlock_bh(&segments.lock);
+	return 0;
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,36)
+static int j1939_proc_net(struct seq_file *sqf, void *v)
+{
+	struct j1939_segment *jseg;
+	struct net_device *netdev;
+
+	seq_printf(sqf, "ifindex\tiface\tid\n");
+	spin_lock_bh(&segments.lock);
+	list_for_each_entry(jseg, &segments.list, flist) {
+		get_j1939_segment(jseg);
+		netdev = dev_get_by_index(&init_net, jseg->ifindex);
+		if (!netdev) {
+			pr_alert("j1939 proc: ifindex %i not found\n",
+				jseg->ifindex);
+			put_j1939_segment(jseg);
+			continue;
+		}
+		seq_printf(sqf, "%i\t%s\n", jseg->ifindex,
+				netdev ? netdev->name : "!");
+		if (netdev)
+			dev_put(netdev);
+		put_j1939_segment(jseg);
+	}
+	spin_unlock_bh(&segments.lock);
+	return 0;
+}
+
+static int j1939_proc_wr_net(struct file *file, const char __user *buffer,
+		unsigned long count, void *data)
+{
+	int ret;
+	char *arg;
+	int opt;
+	struct net_device *netdev = NULL;
+	char buf[IFNAMSIZ+4];
+
+	if (!capable(CAP_NET_ADMIN))
+		return -EPERM;
+	if (count >= sizeof(buf))
+		return -EINVAL;
+	if (copy_from_user(buf, buffer, count))
+		return -EFAULT;
+	buf[count] = 0;
+	arg = strstrip(buf);
+
+	opt = '+';
+	if (strchr("+-~!", arg[0])) {
+		opt = arg[0];
+		++arg;
+	}
+	netdev = dev_get_by_name(&init_net, arg);
+	if (!netdev)
+		return -ENOENT;
+	if (strchr("+", opt))
+		ret = j1939_segment_attach(netdev);
+	else
+		ret = j1939_segment_detach(netdev);
+	if (ret < 0)
+		goto failed;
+	ret = count;
+
+failed:
+	if (netdev)
+		dev_put(netdev);
+	return ret;
+}
+#endif
+
+/* exported init */
+int __init j1939bus_module_init(void)
+{
+	INIT_LIST_HEAD(&segments.list);
+	spin_lock_init(&segments.lock);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,36)
+	j1939_proc_add("net", j1939_proc_net, j1939_proc_wr_net);
+#endif
+	j1939_proc_add("addr", j1939_proc_addr, NULL);
+	j1939_proc_add("ecu", j1939_proc_ecu, NULL);
+	return 0;
+}
+
+void j1939bus_module_exit(void)
+{
+	struct j1939_segment *jseg;
+	struct net_device *netdev;
+
+	spin_lock_bh(&segments.lock);
+	while (!list_empty(&segments.list)) {
+		jseg = list_first_entry(&segments.list,
+				struct j1939_segment, flist);
+		netdev = dev_get_by_index(&init_net, jseg->ifindex);
+		spin_unlock_bh(&segments.lock);
+		j1939_segment_detach(netdev);
+		dev_put(netdev);
+		spin_lock_bh(&segments.lock);
+	}
+	spin_unlock_bh(&segments.lock);
+
+	j1939_proc_remove("ecu");
+	j1939_proc_remove("addr");
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,36)
+	j1939_proc_remove("net");
+#endif
+}
+
+
diff --exclude CVS --exclude .git -uNr linux-2.6.27.8/net/can/j1939/filter.c linux-2.6.27.8.modified/net/can/j1939/filter.c
--- linux-2.6.27.8/net/can/j1939/filter.c	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.27.8.modified/net/can/j1939/filter.c	2013-05-30 03:44:13.000000000 -0400
@@ -0,0 +1,76 @@
+/*
+ * Copyright (c) 2010-2011 EIA Electronics
+ *
+ * Authors:
+ * Pieter Beyens <pieter.beyens@eia.be>
+ * Kurt Van Dijck <kurt.van.dijck@eia.be>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the version 2 of the GNU General Public License
+ * as published by the Free Software Foundation
+ */
+
+#include <linux/list.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/skbuff.h>
+#include <linux/spinlock.h>
+
+#include "j1939-priv.h"
+
+static LIST_HEAD(filters);
+DEFINE_RWLOCK(j1939_receiver_rwlock); /* protects the filter list */
+
+struct filter {
+	struct list_head list;
+	void *vp;
+	void (*fn)(struct sk_buff *, void *);
+};
+
+int j1939_recv_distribute(struct sk_buff *skb)
+{
+	struct filter *filter;
+
+	read_lock_bh(&j1939_receiver_rwlock);
+	list_for_each_entry(filter, &filters, list)
+		filter->fn(skb, filter->vp);
+	read_unlock_bh(&j1939_receiver_rwlock);
+
+	return 0;
+}
+
+int j1939_recv_add(void *vp, void (*fn)(struct sk_buff *, void *))
+{
+	struct filter *f;
+
+	f = kzalloc(sizeof(*f), GFP_KERNEL);
+	if (!f)
+		return -ENOMEM;
+
+	f->vp = vp;
+	f->fn = fn;
+
+	j1939_recv_suspend();
+	list_add(&f->list, &filters);
+	j1939_recv_resume();
+	return 0;
+}
+
+int j1939_recv_remove(void *vp, void (*fn)(struct sk_buff *, void *))
+{
+	struct filter *filter;
+	int found = 0;
+
+	j1939_recv_suspend();
+	list_for_each_entry(filter, &filters, list) {
+		if ((filter->vp == vp) && (filter->fn == fn)) {
+			list_del_init(&filter->list);
+			kfree(filter);
+			found = 1;
+			break;
+		}
+	}
+	j1939_recv_resume();
+	return found ? 0 : -ENOENT;
+}
+
diff --exclude CVS --exclude .git -uNr linux-2.6.27.8/net/can/j1939/j1939-priv.h linux-2.6.27.8.modified/net/can/j1939/j1939-priv.h
--- linux-2.6.27.8/net/can/j1939/j1939-priv.h	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.27.8.modified/net/can/j1939/j1939-priv.h	2013-05-30 03:44:13.000000000 -0400
@@ -0,0 +1,320 @@
+/*
+ * j1939-priv.h
+ *
+ * Copyright (c) 2010-2011 EIA Electronics
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef _J1939_PRIV_H_
+#define _J1939_PRIV_H_
+
+#include <linux/kref.h>
+#include <linux/list.h>
+#include <net/sock.h>
+
+#include <linux/seq_file.h>
+#include <linux/proc_fs.h>
+#include <linux/module.h>
+#include <socketcan/can/j1939.h>
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37)
+#include <linux/atomic.h>
+#else
+#include <asm/atomic.h>
+#endif
+
+/* TODO: return ENETRESET on busoff. */
+
+#define ECUFLAG_LOCAL	0x01
+#define ECUFLAG_REMOTE	0x02
+
+#define PGN_REQUEST		0x0ea00
+#define PGN_ADDRESS_CLAIMED	0x0ee00
+#define PGN_MAX			0x3ffff
+
+#define SA_MAX_UNICAST	0xfd
+/*
+ * j1939 devices
+ */
+struct j1939_ecu {
+	struct list_head list;
+	ktime_t rxtime;
+	name_t name;
+	int flags;
+	uint8_t sa;
+	/*
+	 * atomic flag, set by ac_timer
+	 * cleared/processed by segment's tasklet
+	 * indicates that this ecu successfully claimed @sa as its address
+	 * By communicating this from the ac_timer event to segments tasklet,
+	 * a context locking problem is solved. All other 'ecu readers'
+	 * must only lock with _bh, not with _irq.
+	 */
+	atomic_t ac_delay_expired;
+	struct hrtimer ac_timer;
+	struct kref kref;
+	struct j1939_segment *parent;
+};
+#define to_j1939_ecu(x) container_of((x), struct j1939_ecu, dev)
+
+struct j1939_segment {
+	struct list_head ecus; /*
+	 * local list entry in parent
+	 * These allow irq (& softirq) context lookups on j1939 devices
+	 * This approach (seperate lists) is done as the other 2 alternatives
+	 * are not easier or even wrong
+	 * 1) using the pure kobject methods involves mutexes, which are not
+	 *    allowed in irq context.
+	 * 2) duplicating data structures would require a lot of synchronization
+	 *    code
+	 * usage:
+	 */
+	rwlock_t lock; /*
+	 * segments need a lock to protect the above list
+	 */
+	struct list_head flist; /*
+	 * list entry for use by interrupt lookup routines
+	 */
+	int ifindex;
+	struct addr_ent {
+		ktime_t rxtime;
+		struct j1939_ecu *ecu;
+		int flags;
+	} ents[256];
+
+	/*
+	 * tasklet to process ecu address claimed events.
+	 * These events raise in hardirq context. Signalling the event
+	 * and scheduling this tasklet successfully moves the
+	 * event to softirq context
+	 */
+	struct tasklet_struct ac_task;
+	/*
+	 * list of 256 ecu ptrs, that cache the claimed addresses.
+	 * also protected by the above lock
+	 * don't use directly, use j1939_ecu_set_address() instead
+	 */
+	struct kref kref;
+};
+#define to_j1939_segment(x) container_of((x), struct j1939_segment, dev)
+
+extern void put_j1939_ecu(struct j1939_ecu *ecu);
+extern void put_j1939_segment(struct j1939_segment *segment);
+static inline struct j1939_ecu *get_j1939_ecu(struct j1939_ecu *dut)
+{
+	kref_get(&dut->kref);
+	return dut;
+}
+static inline struct j1939_segment *get_j1939_segment(struct j1939_segment *dut)
+{
+	kref_get(&dut->kref);
+	return dut;
+}
+
+/*
+ * conversion function between (struct sock | struct sk_buff)->sk_priority
+ * from linux and j1939 priority field
+ */
+static inline int j1939_prio(int sk_priority)
+{
+	if (sk_priority < 0)
+		return 6; /* default */
+	else if (sk_priority > 7)
+		return 0;
+	else
+		return 7 - sk_priority;
+}
+static inline int j1939_to_sk_priority(int j1939_prio)
+{
+	return 7 - j1939_prio;
+}
+
+static inline int j1939_address_is_valid(uint8_t sa)
+{
+	return sa != J1939_NO_ADDR;
+}
+
+static inline int j1939_address_is_unicast(uint8_t sa)
+{
+	return sa <= SA_MAX_UNICAST;
+}
+
+static inline int pgn_is_pdu1(pgn_t pgn)
+{
+	/* ignore dp & res bits for this */
+	return (pgn & 0xff00) < 0xf000;
+}
+
+static inline int pgn_is_valid(pgn_t pgn)
+{
+	return pgn <= PGN_MAX;
+}
+
+/* utility to correctly unregister a SA */
+static inline void j1939_ecu_remove_sa_locked(struct j1939_ecu *ecu)
+{
+	if (!j1939_address_is_unicast(ecu->sa))
+		return;
+	if (ecu->parent->ents[ecu->sa].ecu == ecu)
+		ecu->parent->ents[ecu->sa].ecu = NULL;
+}
+
+static inline void j1939_ecu_remove_sa(struct j1939_ecu *ecu)
+{
+	if (!j1939_address_is_unicast(ecu->sa))
+		return;
+	write_lock_bh(&ecu->parent->lock);
+	j1939_ecu_remove_sa_locked(ecu);
+	write_unlock_bh(&ecu->parent->lock);
+}
+
+extern int j1939_name_to_sa(uint64_t name, int ifindex);
+extern struct j1939_ecu *j1939_ecu_find_by_addr(int sa, int ifindex);
+extern struct j1939_ecu *j1939_ecu_find_by_name(name_t name, int ifindex);
+/* find_by_name, with kref & read_lock taken */
+extern struct j1939_ecu *j1939_ecu_find_segment_default_tx(
+		int ifindex, name_t *pname, uint8_t *paddr);
+
+extern void j1939_put_promisc_receiver(int ifindex);
+extern void j1939_get_promisc_receiver(int ifindex);
+
+extern int j1939_proc_add(const char *file,
+		int (*seq_show)(struct seq_file *sqf, void *v),
+		write_proc_t write);
+extern void j1939_proc_remove(const char *file);
+
+extern const char j1939_procname[];
+/* j1939 printk */
+#define j1939_printk(level, ...) printk(level "J1939 " __VA_ARGS__)
+
+#define j1939_err(...)		j1939_printk(KERN_ERR , __VA_ARGS__)
+#define j1939_warning(...)	j1939_printk(KERN_WARNING , __VA_ARGS__)
+#define j1939_notice(...)	j1939_printk(KERN_NOTICE , __VA_ARGS__)
+#define j1939_info(...)		j1939_printk(KERN_INFO , __VA_ARGS__)
+#ifdef DEBUG
+#define j1939_debug(...)	j1939_printk(KERN_DEBUG , __VA_ARGS__)
+#else
+#define j1939_debug(...)
+#endif
+
+struct sk_buff;
+
+/* control buffer of the sk_buff */
+struct j1939_sk_buff_cb {
+	int ifindex;
+	priority_t priority;
+	struct {
+		name_t name;
+		uint8_t addr;
+		int flags;
+	} src, dst;
+	pgn_t pgn;
+	int msg_flags;
+	/* for tx, MSG_SYN will be used to sync on sockets */
+};
+#define J1939_MSG_RESERVED	MSG_SYN
+#define J1939_MSG_SYNC		MSG_SYN
+
+static inline int j1939cb_is_broadcast(const struct j1939_sk_buff_cb *cb)
+{
+	return (!cb->dst.name && (cb->dst.addr >= 0xff));
+}
+
+/* J1939 stack */
+enum {
+	j1939_level_can,
+	j1939_level_transport,
+	j1939_level_sky,
+};
+
+#define RESULT_STOP	1
+/*
+ * return RESULT_STOP when stack processing may stop.
+ * it is up to the stack entry itself to kfree_skb() the sk_buff
+ */
+
+extern int j1939_send(struct sk_buff *, int level);
+extern int j1939_recv(struct sk_buff *, int level);
+
+/* stack entries */
+extern int j1939_recv_promisc(struct sk_buff *);
+extern int j1939_send_transport(struct sk_buff *);
+extern int j1939_recv_transport(struct sk_buff *);
+extern int j1939_send_address_claim(struct sk_buff *);
+extern int j1939_recv_address_claim(struct sk_buff *);
+
+extern int j1939_recv_distribute(struct sk_buff *);
+
+/* network management */
+/*
+ * j1939_ecu_get_register
+ * 'create' & 'register' & 'get' new ecu
+ * when a matching ecu already exists, the behaviour depends
+ * on @return_existing.
+ * when @return_existing is 0, -EEXISTS is returned
+ * when @return_exsiting is 1, that ecu is 'get' & returned.
+ * @flags is only used when creating new ecu.
+ */
+extern struct j1939_ecu *j1939_ecu_get_register(name_t name, int ifindex,
+		int flags, int return_existing);
+extern void j1939_ecu_unregister(struct j1939_ecu *);
+
+extern int j1939_segment_attach(struct net_device *);
+extern int j1939_segment_detach(struct net_device *);
+
+extern int j1939_segment_register(struct net_device *);
+extern void j1939_segment_unregister(struct j1939_segment *);
+extern struct j1939_segment *j1939_segment_find(int ifindex);
+
+extern void j1939sk_netdev_event(int ifindex, int error_code);
+
+/* add/remove receiver */
+extern int j1939_recv_add(void *vp, void (*fn)(struct sk_buff *, void *));
+extern int j1939_recv_remove(void *vp, void (*fn)(struct sk_buff *, void *));
+
+/*
+ * provide public access to this lock
+ * so sparse can verify the context balance
+ */
+extern rwlock_t j1939_receiver_rwlock;
+static inline void j1939_recv_suspend(void)
+{
+	write_lock_bh(&j1939_receiver_rwlock);
+}
+
+static inline void j1939_recv_resume(void)
+{
+	write_unlock_bh(&j1939_receiver_rwlock);
+}
+
+/* locks the recv module */
+extern void j1939_recv_suspend(void);
+extern void j1939_recv_resume(void);
+
+/*
+ * decrement pending skb for a j1939 socket
+ */
+extern void j1939_sock_pending_del(struct sock *sk);
+
+/* seperate module-init/modules-exit's */
+extern __init int j1939_proc_module_init(void);
+extern __init int j1939bus_module_init(void);
+extern __init int j1939sk_module_init(void);
+extern __init int j1939tp_module_init(void);
+
+extern void j1939_proc_module_exit(void);
+extern void j1939bus_module_exit(void);
+extern void j1939sk_module_exit(void);
+extern void j1939tp_module_exit(void);
+
+/* rtnetlink */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,36)
+extern const struct rtnl_af_ops j1939_rtnl_af_ops;
+#endif
+extern int j1939rtnl_new_addr(struct sk_buff *, struct nlmsghdr *, void *arg);
+extern int j1939rtnl_del_addr(struct sk_buff *, struct nlmsghdr *, void *arg);
+extern int j1939rtnl_dump_addr(struct sk_buff *, struct netlink_callback *);
+
+#endif /* _J1939_PRIV_H_ */
diff --exclude CVS --exclude .git -uNr linux-2.6.27.8/net/can/j1939/main.c linux-2.6.27.8.modified/net/can/j1939/main.c
--- linux-2.6.27.8/net/can/j1939/main.c	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.27.8.modified/net/can/j1939/main.c	2013-05-30 03:44:13.000000000 -0400
@@ -0,0 +1,463 @@
+/*
+ * Copyright (c) 2010-2011 EIA Electronics
+ *
+ * Authors:
+ * Kurt Van Dijck <kurt.van.dijck@eia.be>
+ * Pieter Beyens <pieter.beyens@eia.be>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the version 2 of the GNU General Public License
+ * as published by the Free Software Foundation
+ */
+
+/*
+ * Core of can-j1939 that links j1939 to CAN.
+ */
+
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/socket.h>
+#include <linux/list.h>
+#include <linux/if_arp.h>
+#include <net/tcp_states.h>
+
+#include <socketcan/can.h>
+#include <socketcan/can/core.h>
+#include "j1939-priv.h"
+
+MODULE_DESCRIPTION("PF_CAN SAE J1939");
+MODULE_LICENSE("GPL v2");
+MODULE_AUTHOR("EIA Electronics (Kurt Van Dijck & Pieter Beyens)");
+
+static struct {
+	struct notifier_block notifier;
+} s;
+
+/* LOWLEVEL CAN interface */
+
+/* CAN_HDR: #bytes before can_frame data part */
+#define CAN_HDR	(offsetof(struct can_frame, data))
+/* CAN_FTR: #bytes beyond data part */
+#define CAN_FTR	(sizeof(struct can_frame)-CAN_HDR-\
+		sizeof(((struct can_frame *)0)->data))
+
+static void j1939_recv_ecu_flags(struct sk_buff *skb, void *data)
+{
+	struct j1939_segment *jseg = data;
+	struct j1939_sk_buff_cb *cb = (void *)skb->cb;
+	struct addr_ent *paddr;
+
+	if (!jseg)
+		return;
+	write_lock_bh(&jseg->lock);
+	if (j1939_address_is_unicast(cb->src.addr)) {
+		paddr = &jseg->ents[cb->src.addr];
+		paddr->rxtime = ktime_get();
+		if (0x0ee00 == cb->pgn) {
+			/* do not touch many things for Address claims */
+		} else if (paddr->ecu) {
+			paddr->ecu->rxtime = paddr->rxtime;
+			cb->src.flags = paddr->ecu->flags;
+		} else {
+			if (!paddr->flags)
+				paddr->flags |= ECUFLAG_REMOTE;
+			cb->src.flags = paddr->flags;
+		}
+	}
+
+	if (j1939_address_is_unicast(cb->dst.addr)) {
+		paddr = &jseg->ents[cb->dst.addr];
+		if (paddr->ecu)
+			cb->dst.flags = paddr->ecu->flags;
+		else
+			cb->dst.flags = paddr->flags ?: ECUFLAG_REMOTE;
+	}
+	write_unlock_bh(&jseg->lock);
+}
+
+/* lowest layer */
+static void j1939_can_recv(struct sk_buff *skb, void *data)
+{
+	int orig_len;
+	struct j1939_sk_buff_cb *sk_addr;
+	struct can_frame *msg;
+	uint8_t saved_cb[sizeof(skb->cb)];
+
+	BUILD_BUG_ON(sizeof(*sk_addr) > sizeof(skb->cb));
+	/*
+	 * get a pointer to the header of the skb
+	 * the skb payload (pointer) is moved, so that the next skb_data
+	 * returns the actual payload
+	 */
+	msg = (void *)skb->data;
+	orig_len = skb->len;
+	skb_pull(skb, CAN_HDR);
+	/* fix length, set to dlc, with 8 maximum */
+	skb_trim(skb, min_t(uint8_t, msg->can_dlc, 8));
+
+	/* set addr */
+	sk_addr = (struct j1939_sk_buff_cb *)skb->cb;
+	memcpy(saved_cb, sk_addr, sizeof(saved_cb));
+	memset(sk_addr, 0, sizeof(*sk_addr));
+	if (skb->dev)
+		sk_addr->ifindex = skb->dev->ifindex;
+	sk_addr->priority = (msg->can_id & 0x1c000000) >> 26;
+	sk_addr->src.addr = msg->can_id & 0xff;
+	sk_addr->pgn = (msg->can_id & 0x3ffff00) >> 8;
+	if (pgn_is_pdu1(sk_addr->pgn)) {
+		/* Type 1: with destination address */
+		sk_addr->dst.addr = sk_addr->pgn & 0xff;
+		/* normalize pgn: strip dst address */
+		sk_addr->pgn &= 0x3ff00;
+	} else {
+		/* set broadcast address */
+		sk_addr->dst.addr = J1939_NO_ADDR;
+	}
+	j1939_recv_ecu_flags(skb, data);
+	j1939_recv(skb, j1939_level_can);
+
+	/* restore the original skb, should always work */
+	skb_push(skb, CAN_HDR);
+	/* no safety check, it just restores the skbuf's contents */
+	__skb_trim(skb, orig_len);
+	memcpy(sk_addr, saved_cb, sizeof(saved_cb));
+}
+
+static int j1939_send_can(struct sk_buff *skb)
+{
+	int ret, dlc;
+	canid_t canid;
+	struct j1939_sk_buff_cb *sk_addr;
+	struct net_device *netdev = NULL;
+	struct can_frame *msg;
+
+	dlc = skb->len;
+	if (dlc > 8)
+		return -EMSGSIZE;
+	ret = pskb_expand_head(skb, SKB_DATA_ALIGN(CAN_HDR),
+			CAN_FTR + (8-dlc), GFP_ATOMIC);
+	if (ret < 0)
+		return ret;
+
+	msg = (void *)skb_push(skb, CAN_HDR);
+	BUG_ON(!msg);
+	/* make it a full can frame */
+	skb_put(skb, CAN_FTR + (8 - dlc));
+
+	sk_addr = (struct j1939_sk_buff_cb *)skb->cb;
+	canid = CAN_EFF_FLAG |
+		(sk_addr->src.addr & 0xff) |
+		((sk_addr->priority & 0x7) << 26);
+	if (pgn_is_pdu1(sk_addr->pgn))
+		canid |= ((sk_addr->pgn & 0x3ff00) << 8) |
+			((sk_addr->dst.addr & 0xff) << 8);
+	else
+		canid |= ((sk_addr->pgn & 0x3ffff) << 8);
+
+	msg->can_id = canid;
+	msg->can_dlc = dlc;
+
+	/* set net_device */
+	ret = -ENODEV;
+	if (!skb->dev) {
+		if (!sk_addr->ifindex)
+			goto failed;
+		netdev = dev_get_by_index(&init_net, sk_addr->ifindex);
+		if (!netdev)
+			goto failed;
+		skb->dev = netdev;
+	}
+
+	/* fix the 'always free' policy of can_send */
+	skb = skb_get(skb);
+	ret = can_send(skb, 1);
+	if (!ret) {
+		/* free when can_send succeeded */
+		kfree_skb(skb);
+		/* is this necessary ? */
+		ret = RESULT_STOP;
+	}
+failed:
+	if (netdev)
+		dev_put(netdev);
+	return ret;
+}
+
+static int j1939_send_normalize(struct sk_buff *skb)
+{
+	struct j1939_sk_buff_cb *cb = (void *)skb->cb;
+	struct j1939_segment *jseg;
+	struct addr_ent *paddr;
+	struct j1939_ecu *ecu;
+	int ret = 0;
+
+	/* apply sanity checks */
+	cb->pgn &= (pgn_is_pdu1(cb->pgn)) ? 0x3ff00 : 0x3ffff;
+	if (cb->priority > 7)
+		cb->priority = 6;
+
+	/* verify source */
+	if (!cb->ifindex)
+		return -ENETUNREACH;
+	jseg = j1939_segment_find(cb->ifindex);
+	if (!jseg)
+		return -ENETUNREACH;
+	read_lock_bh(&jseg->lock);
+	/* verify source */
+	if (cb->src.name) {
+		ecu = j1939_ecu_find_by_name(cb->src.name, cb->ifindex);
+		cb->src.flags = ecu ? ecu->flags : 0;
+		if (ecu)
+			put_j1939_ecu(ecu);
+	} else if (j1939_address_is_unicast(cb->src.addr)) {
+		paddr = &jseg->ents[cb->src.addr];
+		cb->src.flags = paddr->flags;
+	} else if (cb->src.addr == J1939_IDLE_ADDR) {
+		/* allow always */
+		cb->src.flags = ECUFLAG_LOCAL;
+	} else {
+		/* J1939_NO_ADDR */
+		cb->src.flags = 0;
+	}
+	if (cb->src.flags & ECUFLAG_REMOTE) {
+		ret = -EREMOTE;
+		goto failed;
+	} else if (!(cb->src.flags & ECUFLAG_LOCAL)) {
+		ret = -EADDRNOTAVAIL;
+		goto failed;
+	}
+
+	/* verify destination */
+	if (cb->dst.name) {
+		ecu = j1939_ecu_find_by_name(cb->dst.name, cb->ifindex);
+		if (!ecu) {
+			ret = -EADDRNOTAVAIL;
+			goto failed;
+		}
+		cb->dst.flags = ecu->flags;
+		put_j1939_ecu(ecu);
+	} else if (cb->dst.addr == J1939_IDLE_ADDR) {
+		/* not a valid destination */
+		ret = -EADDRNOTAVAIL;
+		goto failed;
+	} else if (j1939_address_is_unicast(cb->dst.addr)) {
+		paddr = &jseg->ents[cb->dst.addr];
+		cb->dst.flags = paddr->flags;
+	} else {
+		cb->dst.flags = 0;
+	}
+
+	ret = 0;
+failed:
+	read_unlock_bh(&jseg->lock);
+	put_j1939_segment(jseg);
+	return ret;
+}
+
+/* TOPLEVEL interface */
+int j1939_recv(struct sk_buff *skb, int level)
+{
+	int ret;
+
+	/* this stack operates with fallthrough switch statement */
+	switch (level) {
+	default:
+		WARN_ONCE(1, "%s: unsupported level %i\n", __func__, level);
+		return 0;
+	case j1939_level_can:
+		ret = j1939_recv_address_claim(skb);
+		if (unlikely(ret))
+			break;
+		ret = j1939_recv_promisc(skb);
+		if (unlikely(ret))
+			break;
+		ret = j1939_recv_transport(skb);
+		if (unlikely(ret))
+			break;
+	case j1939_level_transport:
+	case j1939_level_sky:
+		ret = j1939_recv_distribute(skb);
+		break;
+	}
+	if (ret == RESULT_STOP)
+		return 0;
+	return ret;
+
+}
+EXPORT_SYMBOL_GPL(j1939_recv);
+
+int j1939_send(struct sk_buff *skb, int level)
+{
+	int ret;
+	struct sock *sk = NULL;
+
+	/* this stack operates with fallthrough switch statement */
+	switch (level) {
+	default:
+		WARN_ONCE(1, "%s: unsupported level %i\n", __func__, level);
+	case j1939_level_sky:
+		sk = skb->sk;
+		if (sk)
+			sock_hold(sk);
+		ret = j1939_send_normalize(skb);
+		if (unlikely(ret))
+			break;
+		ret = j1939_send_transport(skb);
+		if (unlikely(ret))
+			break;
+	case j1939_level_transport:
+		ret = j1939_send_address_claim(skb);
+		if (unlikely(ret))
+			break;
+	case j1939_level_can:
+		ret = j1939_send_can(skb);
+		if (RESULT_STOP == ret)
+			/* don't mark as stopped, it can't be better */
+			ret = 0;
+		break;
+	}
+	if (ret == RESULT_STOP)
+		ret = 0;
+	else if (!ret && sk)
+		j1939_sock_pending_del(sk);
+	if (sk)
+		sock_put(sk);
+	return ret;
+
+}
+EXPORT_SYMBOL_GPL(j1939_send);
+
+/* NETDEV MANAGEMENT */
+
+#define J1939_CAN_ID	CAN_EFF_FLAG
+#define J1939_CAN_MASK	(CAN_EFF_FLAG | CAN_RTR_FLAG)
+int j1939_segment_attach(struct net_device *netdev)
+{
+	int ret;
+	struct j1939_segment *jseg;
+
+	if (!netdev)
+		return -ENODEV;
+	if (netdev->type != ARPHRD_CAN)
+		return -EAFNOSUPPORT;
+
+	ret = j1939_segment_register(netdev);
+	if (ret < 0)
+		goto fail_register;
+	jseg = j1939_segment_find(netdev->ifindex);
+	ret = can_rx_register(netdev, J1939_CAN_ID, J1939_CAN_MASK,
+			j1939_can_recv, jseg, "j1939");
+	if (ret < 0)
+		goto fail_can_rx;
+	return 0;
+
+fail_can_rx:
+	j1939_segment_unregister(jseg);
+	put_j1939_segment(jseg);
+fail_register:
+	return ret;
+}
+
+int j1939_segment_detach(struct net_device *netdev)
+{
+	struct j1939_segment *jseg;
+
+	BUG_ON(!netdev);
+	jseg = j1939_segment_find(netdev->ifindex);
+	if (!jseg)
+		return -EHOSTDOWN;
+	can_rx_unregister(netdev, J1939_CAN_ID, J1939_CAN_MASK,
+			j1939_can_recv, jseg);
+	j1939_segment_unregister(jseg);
+	put_j1939_segment(jseg);
+	j1939sk_netdev_event(netdev->ifindex, EHOSTDOWN);
+	return 0;
+}
+
+static int j1939_notifier(struct notifier_block *nb,
+			unsigned long msg, void *data)
+{
+	struct net_device *netdev = (struct net_device *)data;
+	struct j1939_segment *jseg;
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,26)
+	if (!net_eq(dev_net(netdev), &init_net))
+		return NOTIFY_DONE;
+#elif LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,24)
+	if (netdev->nd_net != &init_net)
+		return NOTIFY_DONE;
+#endif
+
+	if (netdev->type != ARPHRD_CAN)
+		return NOTIFY_DONE;
+
+	switch (msg) {
+	case NETDEV_UNREGISTER:
+		jseg = j1939_segment_find(netdev->ifindex);
+		if (!jseg)
+			break;
+		j1939_segment_unregister(jseg);
+		j1939sk_netdev_event(netdev->ifindex, ENODEV);
+		break;
+
+	case NETDEV_DOWN:
+		j1939sk_netdev_event(netdev->ifindex, ENETDOWN);
+		break;
+	}
+
+	return NOTIFY_DONE;
+}
+
+/* MODULE interface */
+
+static __init int j1939_module_init(void)
+{
+	int ret;
+
+	pr_info("can: SAE J1939\n");
+
+	ret = j1939_proc_module_init();
+	if (ret < 0)
+		goto fail_proc;
+
+	s.notifier.notifier_call = j1939_notifier;
+	register_netdevice_notifier(&s.notifier);
+
+	ret = j1939bus_module_init();
+	if (ret < 0)
+		goto fail_bus;
+	ret = j1939sk_module_init();
+	if (ret < 0)
+		goto fail_sk;
+	ret = j1939tp_module_init();
+	if (ret < 0)
+		goto fail_tp;
+	return 0;
+
+	j1939tp_module_exit();
+fail_tp:
+	j1939sk_module_exit();
+fail_sk:
+	j1939bus_module_exit();
+fail_bus:
+	unregister_netdevice_notifier(&s.notifier);
+
+	j1939_proc_module_exit();
+fail_proc:
+	return ret;
+}
+
+static __exit void j1939_module_exit(void)
+{
+	j1939tp_module_exit();
+	j1939sk_module_exit();
+	j1939bus_module_exit();
+
+	unregister_netdevice_notifier(&s.notifier);
+
+	j1939_proc_module_exit();
+}
+
+module_init(j1939_module_init);
+module_exit(j1939_module_exit);
diff --exclude CVS --exclude .git -uNr linux-2.6.27.8/net/can/j1939/proc.c linux-2.6.27.8.modified/net/can/j1939/proc.c
--- linux-2.6.27.8/net/can/j1939/proc.c	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.27.8.modified/net/can/j1939/proc.c	2013-05-30 03:44:13.000000000 -0400
@@ -0,0 +1,115 @@
+/*
+ * Copyright (c) 2010-2011 EIA Electronics
+ *
+ * Authors:
+ * Kurt Van Dijck <kurt.van.dijck@eia.be>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the version 2 of the GNU General Public License
+ * as published by the Free Software Foundation
+ */
+
+#include <linux/version.h>
+#include <linux/string.h>
+#include <linux/seq_file.h>
+#include <linux/proc_fs.h>
+#include <linux/uaccess.h>
+
+#include "j1939-priv.h"
+
+const char j1939_procname[] = "can-j1939";
+
+static struct proc_dir_entry *rootdir;
+
+static int j1939_proc_open(struct inode *inode, struct file *file)
+{
+	struct proc_dir_entry *pde = PDE(inode);
+	int (*fn)(struct seq_file *sqf, void *v) = pde->data;
+
+	return single_open(file, fn, pde);
+}
+
+/* copied from fs/proc/generic.c */
+static ssize_t
+proc_file_write(struct file *file, const char __user *buffer,
+		size_t count, loff_t *ppos)
+{
+	struct inode *inode = file->f_path.dentry->d_inode;
+	struct proc_dir_entry *dp;
+
+	dp = PDE(inode);
+
+	if (!dp->write_proc)
+		return -EIO;
+
+	/* FIXME: does this routine need ppos?  probably... */
+	return dp->write_proc(file, buffer, count, dp->data);
+}
+
+static const struct file_operations j1939_proc_ops = {
+	.owner		= THIS_MODULE,
+	.open		= j1939_proc_open,
+	.read		= seq_read,
+	.write		= proc_file_write,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+};
+
+int j1939_proc_add(const char *file,
+		int (*seq_show)(struct seq_file *sqf, void *v),
+		write_proc_t write)
+{
+	struct proc_dir_entry *pde;
+	int mode = 0;
+
+	if (seq_show)
+		mode |= 0444;
+	if (write)
+		mode |= 0200;
+
+	if (!rootdir)
+		return -ENODEV;
+	pde = proc_create(file, mode, rootdir, &j1939_proc_ops);
+	if (!pde)
+		goto fail_create;
+	pde->data = seq_show;
+	pde->write_proc = write;
+	return 0;
+
+fail_create:
+	return -ENOENT;
+}
+EXPORT_SYMBOL(j1939_proc_add);
+
+void j1939_proc_remove(const char *file)
+{
+	remove_proc_entry(file, rootdir);
+}
+EXPORT_SYMBOL(j1939_proc_remove);
+
+__init int j1939_proc_module_init(void)
+{
+	/* create /proc/net/can directory */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,24)
+	rootdir = proc_mkdir(j1939_procname, init_net.proc_net);
+#else
+	rootdir = proc_mkdir(j1939_procname, proc_net);
+#endif
+	if (!rootdir)
+		return -EINVAL;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,30)
+	rootdir->owner = THIS_MODULE;
+#endif
+	return 0;
+}
+
+void j1939_proc_module_exit(void)
+{
+	if (rootdir)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,24)
+		proc_net_remove(&init_net, j1939_procname);
+#else
+		proc_net_remove(j1939_procname);
+#endif
+}
+
diff --exclude CVS --exclude .git -uNr linux-2.6.27.8/net/can/j1939/promisc.c linux-2.6.27.8.modified/net/can/j1939/promisc.c
--- linux-2.6.27.8/net/can/j1939/promisc.c	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.27.8.modified/net/can/j1939/promisc.c	2013-05-30 03:44:13.000000000 -0400
@@ -0,0 +1,43 @@
+/*
+ * Copyright (c) 2010-2011 EIA Electronics
+ *
+ * Authors:
+ * Kurt Van Dijck <kurt.van.dijck@eia.be>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the version 2 of the GNU General Public License
+ * as published by the Free Software Foundation
+ */
+
+#include <linux/version.h>
+#include <linux/skbuff.h>
+#include <linux/sysctl.h>
+#include "j1939-priv.h"
+
+static atomic_t n_promisc = ATOMIC_INIT(0);
+
+void j1939_get_promisc_receiver(int ifindex)
+{
+	atomic_inc(&n_promisc);
+}
+EXPORT_SYMBOL_GPL(j1939_get_promisc_receiver);
+
+void j1939_put_promisc_receiver(int ifindex)
+{
+	atomic_dec(&n_promisc);
+}
+EXPORT_SYMBOL_GPL(j1939_put_promisc_receiver);
+
+int j1939_recv_promisc(struct sk_buff *skb)
+{
+	struct j1939_sk_buff_cb *cb = (void *)skb->cb;
+
+	if ((cb->src.flags & ECUFLAG_REMOTE) &&
+		(cb->dst.flags & ECUFLAG_REMOTE)) {
+		if (!atomic_read(&n_promisc))
+			/* stop receive path */
+			return RESULT_STOP;
+	}
+	return 0;
+}
+
diff --exclude CVS --exclude .git -uNr linux-2.6.27.8/net/can/j1939/rtnl.c linux-2.6.27.8.modified/net/can/j1939/rtnl.c
--- linux-2.6.27.8/net/can/j1939/rtnl.c	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.27.8.modified/net/can/j1939/rtnl.c	2013-05-30 03:44:13.000000000 -0400
@@ -0,0 +1,316 @@
+/*
+ * Copyright (c) 2011 EIA Electronics
+ *
+ * Authors:
+ * Kurt Van Dijck <kurt.van.dijck@eia.be>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the version 2 of the GNU General Public License
+ * as published by the Free Software Foundation
+ */
+
+/*
+ * j1939-rtnl.c - netlink addressing interface
+ */
+
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/err.h>
+#include <linux/if_arp.h>
+
+#include "j1939-priv.h"
+
+static const struct nla_policy j1939_ifa_policy[IFA_J1939_MAX] = {
+	[IFA_J1939_ADDR] = { .type = NLA_U8, },
+	[IFA_J1939_NAME] = { .type = NLA_U64, },
+};
+
+int j1939rtnl_del_addr(struct sk_buff *skb, struct nlmsghdr *nlh, void *arg)
+{
+	int ret;
+	struct ifaddrmsg *ifm;
+	struct j1939_segment *jseg;
+	uint8_t jaddr = J1939_NO_ADDR;
+	uint64_t jname = J1939_NO_NAME;
+
+	struct nlattr *nla, *tb[IFA_J1939_MAX];
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,26)
+	if (!net_eq(sock_net(skb->sk), &init_net))
+		return -EINVAL;
+#endif
+
+	nla = nlmsg_find_attr(nlh, sizeof(*ifm), IFA_LOCAL);
+	if (!nla)
+		return -EINVAL;
+
+	nla_parse_nested(tb, IFA_J1939_MAX-1, nla, j1939_ifa_policy);
+	if (tb[IFA_J1939_ADDR])
+		jaddr = nla_get_u8(tb[IFA_J1939_ADDR]);
+	if (tb[IFA_J1939_NAME])
+		jname = be64_to_cpu(nla_get_u64(tb[IFA_J1939_NAME]));
+
+	ifm = nlmsg_data(nlh);
+	jseg = j1939_segment_find(ifm->ifa_index);
+	if (!jseg)
+		return -EHOSTDOWN;
+
+	ret = 0;
+	if (j1939_address_is_unicast(jaddr)) {
+		struct addr_ent *ent;
+
+		ent = &jseg->ents[jaddr];
+		write_lock_bh(&jseg->lock);
+		if (!ent->flags)
+			ret = -EADDRNOTAVAIL;
+		else if (!(ent->flags & ECUFLAG_LOCAL))
+			ret = -EREMOTE;
+		else
+			ent->flags = 0;
+		write_unlock_bh(&jseg->lock);
+	} else if (jname) {
+		struct j1939_ecu *ecu;
+
+		ecu = j1939_ecu_find_by_name(jname, ifm->ifa_index);
+		if (ecu) {
+			if (ecu->flags & ECUFLAG_LOCAL) {
+				j1939_ecu_unregister(ecu);
+				put_j1939_ecu(ecu);
+			} else {
+				ret = -EREMOTE;
+			}
+		} else {
+			ret = -ENODEV;
+		}
+	}
+	put_j1939_segment(jseg);
+	return ret;
+}
+
+int j1939rtnl_new_addr(struct sk_buff *skb, struct nlmsghdr *nlh, void *arg)
+{
+	struct ifaddrmsg *ifm;
+	struct j1939_segment *jseg;
+	uint8_t jaddr = J1939_NO_ADDR;
+	uint64_t jname = J1939_NO_NAME;
+	struct addr_ent *ent;
+	int ret;
+	struct nlattr *nla, *tb[IFA_J1939_MAX];
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,26)
+	if (!net_eq(sock_net(skb->sk), &init_net))
+		return -EINVAL;
+#endif
+
+	nla = nlmsg_find_attr(nlh, sizeof(*ifm), IFA_LOCAL);
+	if (!nla)
+		return -EINVAL;
+
+	ifm = nlmsg_data(nlh);
+	jseg = j1939_segment_find(ifm->ifa_index);
+	if (!jseg)
+		return -EHOSTDOWN;
+
+	nla_parse_nested(tb, IFA_J1939_MAX-1, nla, j1939_ifa_policy);
+	if (tb[IFA_J1939_ADDR])
+		jaddr = nla_get_u8(tb[IFA_J1939_ADDR]);
+	if (tb[IFA_J1939_NAME])
+		jname = be64_to_cpu(nla_get_u64(tb[IFA_J1939_NAME]));
+
+
+	ret = 0;
+	if (j1939_address_is_unicast(jaddr)) {
+		ent = &jseg->ents[jaddr];
+		write_lock_bh(&jseg->lock);
+		if ((ent->ecu && (ent->ecu->flags & ECUFLAG_REMOTE)) ||
+				(ent->flags & ECUFLAG_REMOTE))
+			ret = -EREMOTE;
+		else
+			ent->flags |= ECUFLAG_LOCAL;
+		write_unlock_bh(&jseg->lock);
+	} else if (jname) {
+		struct j1939_ecu *ecu;
+
+		ecu = j1939_ecu_get_register(jname, ifm->ifa_index,
+				ECUFLAG_LOCAL, 0);
+		if (IS_ERR(ecu))
+			ret = PTR_ERR(ecu);
+		else
+			put_j1939_ecu(ecu);
+	}
+	put_j1939_segment(jseg);
+	return ret;
+}
+
+static int j1939rtnl_fill_ifaddr(struct sk_buff *skb, int ifindex,
+		uint8_t addr, uint64_t name, int j1939_flags,
+		u32 pid, u32 seq, int event, unsigned int flags)
+{
+	struct ifaddrmsg *ifm;
+	struct nlmsghdr *nlh;
+	struct nlattr *nla;
+
+	nlh = nlmsg_put(skb, pid, seq, event, sizeof(*ifm), flags);
+	if (nlh == NULL)
+		return -EMSGSIZE;
+
+	ifm = nlmsg_data(nlh);
+	ifm->ifa_family = AF_CAN;
+	ifm->ifa_prefixlen = CAN_J1939;
+	ifm->ifa_flags = name ? 0 : IFA_F_PERMANENT;
+	ifm->ifa_scope = RT_SCOPE_LINK;
+	ifm->ifa_index = ifindex;
+
+	nla = nla_nest_start(skb, IFA_LOCAL);
+	if (j1939_address_is_unicast(addr))
+		NLA_PUT_U8(skb, IFA_J1939_ADDR, addr);
+	if (name)
+		NLA_PUT_U64(skb, IFA_J1939_NAME, cpu_to_be64(name));
+	nla_nest_end(skb, nla);
+
+	return nlmsg_end(skb, nlh);
+
+nla_put_failure:
+	nlmsg_cancel(skb, nlh);
+	return -EMSGSIZE;
+}
+
+int j1939rtnl_dump_addr(struct sk_buff *skb, struct netlink_callback *cb)
+{
+	int ndev, addr, ret, sa;
+	struct net_device *netdev;
+	struct j1939_segment *jseg;
+	struct j1939_ecu *ecu;
+	struct addr_ent *ent;
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,26)
+	if (!net_eq(sock_net(skb->sk), &init_net))
+		return 0;
+#endif
+
+	ndev = 0;
+	for_each_netdev(&init_net, netdev) {
+		++ndev;
+		if (ndev < cb->args[1])
+			continue;
+		if (netdev->type != ARPHRD_CAN)
+			continue;
+
+		jseg = j1939_segment_find(netdev->ifindex);
+		if (!jseg)
+			continue;
+
+		read_lock_bh(&jseg->lock);
+		for (addr = cb->args[2]; addr < J1939_IDLE_ADDR; ++addr) {
+			ent = &jseg->ents[addr];
+			if (!(ent->flags & ECUFLAG_LOCAL))
+				continue;
+			ret = j1939rtnl_fill_ifaddr(skb, netdev->ifindex, addr,
+					0, ent->flags, NETLINK_CB(cb->skb).pid,
+					cb->nlh->nlmsg_seq, RTM_NEWADDR,
+					NLM_F_MULTI);
+			if (ret < 0) {
+				read_unlock_bh(&jseg->lock);
+				goto done;
+			}
+			cb->args[2] = addr + 1;
+		}
+
+		if (addr > J1939_IDLE_ADDR)
+			addr = J1939_IDLE_ADDR;
+		list_for_each_entry(ecu, &jseg->ecus, list) {
+			if (addr++ < cb->args[2])
+				continue;
+			if (!(ecu->flags & ECUFLAG_LOCAL))
+				continue;
+			sa = ecu->sa;
+			if (ecu->parent->ents[sa].ecu != ecu)
+				sa = J1939_IDLE_ADDR;
+			ret = j1939rtnl_fill_ifaddr(skb, netdev->ifindex,
+					sa, ecu->name, ecu->flags,
+					NETLINK_CB(cb->skb).pid,
+					cb->nlh->nlmsg_seq, RTM_NEWADDR,
+					NLM_F_MULTI);
+			if (ret < 0) {
+				read_unlock_bh(&jseg->lock);
+				goto done;
+			}
+			cb->args[2] = addr;
+		}
+		read_unlock_bh(&jseg->lock);
+		/* reset first address for device */
+		cb->args[2] = 0;
+	}
+	++ndev;
+done:
+	cb->args[1] = ndev;
+
+	return skb->len;
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,36)
+/*
+ * rtnl_link_ops
+ */
+
+static const struct nla_policy j1939_ifla_policy[IFLA_J1939_MAX] = {
+	[IFLA_J1939_ENABLE] = { .type = NLA_U8, },
+};
+
+static size_t j1939_get_link_af_size(const struct net_device *dev)
+{
+	return nla_policy_len(j1939_ifla_policy, IFLA_J1939_MAX-1);
+}
+
+static int j1939_validate_link_af(const struct net_device *dev,
+				 const struct nlattr *nla)
+{
+	return nla_validate_nested(nla, IFLA_J1939_MAX-1, j1939_ifla_policy);
+}
+
+static int j1939_fill_link_af(struct sk_buff *skb, const struct net_device *dev)
+{
+	struct j1939_segment *jseg;
+
+	if (!dev)
+		return -ENODEV;
+	jseg = j1939_segment_find(dev->ifindex);
+	if (jseg)
+		put_j1939_segment(jseg);
+	NLA_PUT_U8(skb, IFLA_J1939_ENABLE, jseg ? 1 : 0);
+	return 0;
+
+nla_put_failure:
+	return -EMSGSIZE;
+}
+
+static int j1939_set_link_af(struct net_device *dev, const struct nlattr *nla)
+{
+	int ret;
+	struct nlattr *tb[IFLA_J1939_MAX];
+
+	ret = nla_parse_nested(tb, IFLA_J1939_MAX-1, nla, j1939_ifla_policy);
+	if (ret < 0)
+		return ret;
+
+	if (tb[IFLA_J1939_ENABLE]) {
+		if (nla_get_u8(tb[IFLA_J1939_ENABLE]))
+			ret = j1939_segment_attach(dev);
+		else
+			ret = j1939_segment_detach(dev);
+		if (ret < 0)
+			return ret;
+	}
+	return 0;
+}
+
+const struct rtnl_af_ops j1939_rtnl_af_ops = {
+	.family		  = AF_CAN,
+	.fill_link_af	  = j1939_fill_link_af,
+	.get_link_af_size = j1939_get_link_af_size,
+	.validate_link_af = j1939_validate_link_af,
+	.set_link_af	  = j1939_set_link_af,
+};
+#endif
+
diff --exclude CVS --exclude .git -uNr linux-2.6.27.8/net/can/j1939/socket.c linux-2.6.27.8.modified/net/can/j1939/socket.c
--- linux-2.6.27.8/net/can/j1939/socket.c	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.27.8.modified/net/can/j1939/socket.c	2013-05-30 03:44:13.000000000 -0400
@@ -0,0 +1,981 @@
+/*
+ * Copyright (c) 2010-2011 EIA Electronics
+ *
+ * Authors:
+ * Kurt Van Dijck <kurt.van.dijck@eia.be>
+ * Pieter Beyens <pieter.beyens@eia.be>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the version 2 of the GNU General Public License
+ * as published by the Free Software Foundation
+ */
+
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/socket.h>
+#include <linux/list.h>
+#include <linux/if_arp.h>
+#include <net/tcp_states.h>
+
+#include <socketcan/can/core.h>
+#include <socketcan/can/j1939.h>
+#include "j1939-priv.h"
+
+struct j1939_sock {
+	struct sock sk; /* must be first to skip with memset */
+	struct list_head list;
+
+	int state;
+	#define JSK_BOUND	BIT(0)
+	#define JSK_CONNECTED	BIT(1)
+	#define PROMISC		BIT(2)
+	#define RECV_OWN	BIT(3)
+
+	struct {
+		name_t src, dst;
+		pgn_t pgn;
+
+		uint8_t sa, da;
+	} addr;
+
+	struct j1939_filter *filters;
+	int nfilters;
+
+	int skb_pending;
+	spinlock_t lock;
+	wait_queue_head_t waitq;
+};
+
+static inline struct j1939_sock *j1939_sk(const struct sock *sk)
+{
+	return container_of(sk, struct j1939_sock, sk);
+}
+
+/* skb_pending issues */
+static inline int j1939_sock_pending_add_first(struct sock *sk)
+{
+	int saved;
+	struct j1939_sock *jsk = j1939_sk(sk);
+
+	spin_lock_bh(&jsk->lock);
+	if (!jsk->skb_pending) {
+		++jsk->skb_pending;
+		saved = 1;
+	} else
+		saved = 0;
+	spin_unlock_bh(&jsk->lock);
+	return saved;
+}
+
+static inline void j1939_sock_pending_add(struct sock *sk)
+{
+	struct j1939_sock *jsk = j1939_sk(sk);
+
+	spin_lock_bh(&jsk->lock);
+	++jsk->skb_pending;
+	spin_unlock_bh(&jsk->lock);
+}
+
+void j1939_sock_pending_del(struct sock *sk)
+{
+	struct j1939_sock *jsk = j1939_sk(sk);
+	int saved;
+
+	spin_lock_bh(&jsk->lock);
+	--jsk->skb_pending;
+	saved = jsk->skb_pending;
+	spin_unlock_bh(&jsk->lock);
+	if (!saved)
+		wake_up(&jsk->waitq);
+}
+
+
+static inline int j1939_no_address(const struct sock *sk)
+{
+	const struct j1939_sock *jsk = j1939_sk(sk);
+	return (jsk->addr.sa == J1939_NO_ADDR) && !jsk->addr.src;
+}
+
+/*
+ * list of sockets
+ */
+static struct {
+	struct mutex lock;
+	struct list_head socks;
+} s;
+
+/* matches skb control buffer (addr) with a j1939 filter */
+static inline int packet_match(const struct j1939_sk_buff_cb *cb,
+		const struct j1939_filter *f, int nfilter)
+{
+	if (!nfilter)
+		/* receive all when no filters are assigned */
+		return 1;
+	/*
+	 * Filters relying on the addr for static addressing _should_ get
+	 * packets from dynamic addressed ECU's too if they match their SA.
+	 * Sockets using dynamic addressing in their filters should not set it.
+	 */
+	for (; nfilter; ++f, --nfilter) {
+		if ((cb->pgn & f->pgn_mask) != (f->pgn & f->pgn_mask))
+			continue;
+		if ((cb->src.addr & f->addr_mask) != (f->addr & f->addr_mask))
+			continue;
+		if ((cb->src.name & f->name_mask) != (f->name & f->name_mask))
+			continue;
+		return 1;
+	}
+	return 0;
+}
+
+/*
+ * callback per socket, called from filter infrastructure
+ */
+static void j1939sk_recv_skb(struct sk_buff *oskb, void *data)
+{
+	struct sk_buff *skb;
+	struct j1939_sock *jsk = (struct j1939_sock *)data;
+	struct j1939_sk_buff_cb *cb = (void *)oskb->cb;
+
+	if (jsk->sk.sk_bound_dev_if && (jsk->sk.sk_bound_dev_if != cb->ifindex))
+		/* this socket does not take packets from this iface */
+		return;
+	if (!(jsk->state & PROMISC)) {
+		if (cb->dst.flags & ECUFLAG_REMOTE)
+			/*
+			 * this msg was destined for an ECU associated
+			 * with this socket
+			 */
+			return;
+		if (jsk->addr.src) {
+			if (cb->dst.name &&
+				(cb->dst.name != jsk->addr.src))
+				/*
+				 * the msg is not destined for the name
+				 * that the socket is bound to
+				 */
+				return;
+		} else if (j1939_address_is_unicast(jsk->addr.sa)) {
+			if (j1939_address_is_unicast(cb->dst.addr) &&
+				(cb->dst.addr != jsk->addr.sa))
+				/*
+				 * the msg is not destined for the name
+				 * that the socket is bound to
+				 */
+				return;
+		}
+	}
+
+	if ((oskb->sk == &jsk->sk) && !(jsk->state & RECV_OWN))
+		/* own message */
+		return;
+
+	if (!packet_match(cb, jsk->filters, jsk->nfilters))
+		return;
+
+	skb = skb_clone(oskb, GFP_ATOMIC);
+	if (!skb) {
+		j1939_warning("skb clone failed\n");
+		return;
+	}
+	cb = (void *)skb->cb;
+	cb->msg_flags &= ~(MSG_DONTROUTE | MSG_CONFIRM);
+	if (oskb->sk)
+		cb->msg_flags |= MSG_DONTROUTE;
+	if (oskb->sk == &jsk->sk)
+		cb->msg_flags |= MSG_CONFIRM;
+
+	skb->sk = &jsk->sk;
+	if (sock_queue_rcv_skb(&jsk->sk, skb) < 0)
+		kfree_skb(skb);
+}
+
+static int j1939sk_init(struct sock *sk)
+{
+	struct j1939_sock *jsk = j1939_sk(sk);
+
+	INIT_LIST_HEAD(&jsk->list);
+	spin_lock_init(&jsk->lock);
+	init_waitqueue_head(&jsk->waitq);
+	jsk->sk.sk_priority = j1939_to_sk_priority(6);
+	jsk->sk.sk_reuse = 1; /* per default */
+	jsk->addr.sa = J1939_NO_ADDR;
+	jsk->addr.da = J1939_NO_ADDR;
+	return 0;
+}
+
+/*
+ * helper: return <0 for error, >0 for error to notify
+ */
+static int j1939sk_bind_netdev_helper(struct socket *sock)
+{
+	struct j1939_sock *jsk = j1939_sk(sock->sk);
+	int ret;
+	struct net_device *netdev;
+	struct j1939_segment *jseg;
+
+	if (!jsk->sk.sk_bound_dev_if)
+		return 0;
+	ret = 0;
+
+	netdev = dev_get_by_index(&init_net, jsk->sk.sk_bound_dev_if);
+	if (!netdev) {
+		ret = -ENODEV;
+		goto fail_netdev;
+	}
+
+	/* no need to test for CAN device,
+	 * implicitely done by j1939_segment
+	 */
+	jseg = j1939_segment_find(netdev->ifindex);
+	if (!jseg) {
+		ret = -EHOSTDOWN;
+		goto fail_segment;
+	}
+
+	if (!(netdev->flags & IFF_UP)) {
+		sock->sk->sk_err = ENETDOWN;
+		sock->sk->sk_error_report(sock->sk);
+	}
+	put_j1939_segment(jseg);
+fail_segment:
+	dev_put(netdev);
+fail_netdev:
+	return ret;
+}
+
+static int j1939sk_bind(struct socket *sock, struct sockaddr *uaddr, int len)
+{
+	struct sockaddr_can *addr = (struct sockaddr_can *)uaddr;
+	struct j1939_sock *jsk = j1939_sk(sock->sk);
+	struct j1939_ecu *ecu = NULL;
+	int ret, old_state;
+
+	if (len < required_size(can_addr.j1939, *addr))
+		return -EINVAL;
+	if (addr->can_family != AF_CAN)
+		return -EINVAL;
+
+	/* lock s.lock first, to avoid circular lock dependancy */
+	mutex_lock(&s.lock);
+	lock_sock(sock->sk);
+	if (jsk->state & JSK_BOUND) {
+		ret = -EBUSY;
+		if (addr->can_ifindex &&
+				(addr->can_ifindex != jsk->sk.sk_bound_dev_if))
+			goto fail_locked;
+		/*
+		 * do not allow to change addres after first bind(),
+		 * (it would require updating the j1939_ecu list)
+		 * but allow the change SA when using dynaddr,
+		 * and allow to change PGN
+		 */
+		if (!jsk->addr.src ||
+			(jsk->addr.src != addr->can_addr.j1939.name) ||
+			(jsk->addr.pgn != addr->can_addr.j1939.pgn))
+			goto fail_locked;
+		/* set to be able to send address claims */
+		jsk->addr.sa = addr->can_addr.j1939.addr;
+		/* since this socket is bound already, we can skip a lot */
+		release_sock(sock->sk);
+		mutex_unlock(&s.lock);
+		return 0;
+	}
+
+	/* do netdev */
+	if (jsk->sk.sk_bound_dev_if && addr->can_ifindex &&
+			(jsk->sk.sk_bound_dev_if != addr->can_ifindex)) {
+		ret = -EBADR;
+		goto fail_locked;
+	}
+	if (!jsk->sk.sk_bound_dev_if)
+		jsk->sk.sk_bound_dev_if = addr->can_ifindex;
+
+	ret = j1939sk_bind_netdev_helper(sock);
+	if (ret < 0)
+		goto fail_locked;
+
+	/* bind name/addr */
+	if (addr->can_addr.j1939.name) {
+		ecu = j1939_ecu_find_by_name(addr->can_addr.j1939.name,
+				jsk->sk.sk_bound_dev_if);
+		if (!ecu) {
+			ret = -EADDRNOTAVAIL;
+			goto fail_locked;
+		} else if (ecu->flags & ECUFLAG_REMOTE) {
+			ret = -EREMOTE;
+			goto fail_with_ecu;
+		} else if (jsk->sk.sk_bound_dev_if != ecu->parent->ifindex) {
+			ret = -EHOSTUNREACH;
+			goto fail_with_ecu;
+		}
+		jsk->addr.src = ecu->name;
+		jsk->addr.sa = addr->can_addr.j1939.addr;
+	} else if (j1939_address_is_unicast(addr->can_addr.j1939.addr)) {
+		struct j1939_segment *jseg;
+		struct addr_ent *paddr;
+		int flags;
+
+		/* static addressing, netdev is required */
+		if (!jsk->sk.sk_bound_dev_if) {
+			ret = -EINVAL;
+			goto fail_locked;
+		}
+		jseg = j1939_segment_find(jsk->sk.sk_bound_dev_if);
+		if (!jseg) {
+			ret = -ENETUNREACH;
+			goto fail_locked;
+		}
+		paddr = &jseg->ents[addr->can_addr.j1939.addr];
+		ret = 0;
+		read_lock_bh(&jseg->lock);
+		flags = paddr->flags;
+		read_unlock_bh(&jseg->lock);
+		put_j1939_segment(jseg);
+		if (!(flags & ECUFLAG_LOCAL)) {
+			ret = -EADDRNOTAVAIL;
+			goto fail_locked;
+		}
+		jsk->addr.sa = addr->can_addr.j1939.addr;
+	} else if (addr->can_addr.j1939.addr == J1939_IDLE_ADDR) {
+		/* static addressing, netdev is required */
+		if (!jsk->sk.sk_bound_dev_if) {
+			ret = -EINVAL;
+			goto fail_locked;
+		}
+		jsk->addr.sa = addr->can_addr.j1939.addr;
+	} else {
+		/* no name, no addr */
+	}
+
+	/* set default transmit pgn/priority */
+	jsk->addr.pgn = addr->can_addr.j1939.pgn;
+
+	old_state = jsk->state;
+	jsk->state |= JSK_BOUND;
+
+	if (!(old_state & (JSK_BOUND | JSK_CONNECTED))) {
+		list_add_tail(&jsk->list, &s.socks);
+		j1939_recv_add(jsk, j1939sk_recv_skb);
+	}
+
+	ret = 0;
+
+fail_with_ecu:
+	if (ecu && !IS_ERR(ecu))
+		put_j1939_ecu(ecu);
+fail_locked:
+	release_sock(sock->sk);
+	mutex_unlock(&s.lock);
+	return ret;
+}
+
+static int j1939sk_connect(struct socket *sock, struct sockaddr *uaddr,
+		int len, int flags)
+{
+	int ret, old_state;
+	struct sockaddr_can *addr = (struct sockaddr_can *)uaddr;
+	struct j1939_sock *jsk = j1939_sk(sock->sk);
+	struct j1939_ecu *ecu;
+	int ifindex;
+
+	if (!uaddr)
+		return -EDESTADDRREQ;
+
+	if (len < required_size(can_addr.j1939, *addr))
+		return -EINVAL;
+	if (addr->can_family != AF_CAN)
+		return -EINVAL;
+
+	mutex_lock(&s.lock);
+	lock_sock(sock->sk);
+	if (jsk->state & JSK_CONNECTED) {
+		ret = -EISCONN;
+		goto fail_locked;
+	}
+
+	ifindex = jsk->sk.sk_bound_dev_if;
+	if (ifindex && addr->can_ifindex && (ifindex != addr->can_ifindex)) {
+		ret = -ECONNREFUSED;
+		goto fail_locked;
+	}
+	if (!ifindex)
+		ifindex = addr->can_ifindex;
+
+	/* lookup destination */
+	if (addr->can_addr.j1939.name) {
+		ecu = j1939_ecu_find_by_name(addr->can_addr.j1939.name,
+				ifindex);
+		if (!ecu) {
+			ret = -EADDRNOTAVAIL;
+			goto fail_locked;
+		}
+		if (ifindex && (ifindex != ecu->parent->ifindex)) {
+			ret = -EHOSTUNREACH;
+			goto fail_locked;
+		}
+		ifindex = ecu->parent->ifindex;
+		jsk->addr.dst = ecu->name;
+		jsk->addr.da = ecu->sa;
+		put_j1939_ecu(ecu);
+	} else {
+		/* broadcast */
+		jsk->addr.dst = 0;
+		jsk->addr.da = addr->can_addr.j1939.addr;
+	}
+	/*
+	 * take a default source when not present, so connected sockets
+	 * will stick to the same source ECU
+	 */
+	if (!jsk->addr.src && !j1939_address_is_valid(jsk->addr.sa)) {
+		ecu = j1939_ecu_find_segment_default_tx(ifindex,
+				&jsk->addr.src, &jsk->addr.sa);
+		if (IS_ERR(ecu)) {
+			ret = PTR_ERR(ecu);
+			goto fail_locked;
+		}
+		put_j1939_ecu(ecu);
+	}
+
+	/* start assigning, no problem can occur at this point anymore */
+	jsk->sk.sk_bound_dev_if = ifindex;
+
+	if (!(jsk->state & JSK_BOUND) || !pgn_is_valid(jsk->addr.pgn)) {
+		/*
+		 * bind() takes precedence over connect() for the
+		 * pgn to use ourselve
+		 */
+		jsk->addr.pgn = addr->can_addr.j1939.pgn;
+	}
+
+	old_state = jsk->state;
+	jsk->state |= JSK_CONNECTED;
+
+	if (!(old_state & (JSK_BOUND | JSK_CONNECTED))) {
+		list_add_tail(&jsk->list, &s.socks);
+		j1939_recv_add(jsk, j1939sk_recv_skb);
+	}
+	release_sock(sock->sk);
+	mutex_unlock(&s.lock);
+	return 0;
+
+fail_locked:
+	release_sock(sock->sk);
+	mutex_unlock(&s.lock);
+	return ret;
+}
+
+static void j1939sk_sock2sockaddr_can(struct sockaddr_can *addr,
+		const struct j1939_sock *jsk, int peer)
+{
+	addr->can_family = AF_CAN;
+	addr->can_ifindex = jsk->sk.sk_bound_dev_if;
+	addr->can_addr.j1939.name = peer ? jsk->addr.dst : jsk->addr.src;
+	addr->can_addr.j1939.pgn = jsk->addr.pgn;
+	addr->can_addr.j1939.addr = peer ? jsk->addr.da : jsk->addr.sa;
+}
+
+static int j1939sk_getname(struct socket *sock, struct sockaddr *uaddr,
+		int *len, int peer)
+{
+	struct sockaddr_can *addr = (struct sockaddr_can *)uaddr;
+	struct sock *sk = sock->sk;
+	struct j1939_sock *jsk = j1939_sk(sk);
+	int ret = 0;
+
+	lock_sock(sk);
+
+	if (peer && !(jsk->state & JSK_CONNECTED)) {
+		ret = -EADDRNOTAVAIL;
+		goto failure;
+	}
+
+	j1939sk_sock2sockaddr_can(addr, jsk, peer);
+	*len = sizeof(*addr);
+
+failure:
+	release_sock(sk);
+
+	return ret;
+}
+
+static int j1939sk_release(struct socket *sock)
+{
+	struct sock *sk = sock->sk;
+	struct j1939_sock *jsk;
+
+	if (!sk)
+		return 0;
+	jsk = j1939_sk(sk);
+	j1939_recv_remove(jsk, j1939sk_recv_skb);
+	mutex_lock(&s.lock);
+	list_del_init(&jsk->list);
+	mutex_unlock(&s.lock);
+
+	lock_sock(sk);
+	if (jsk->state & PROMISC)
+		j1939_put_promisc_receiver(jsk->sk.sk_bound_dev_if);
+
+	sock_orphan(sk);
+	sock->sk = NULL;
+
+	release_sock(sk);
+	sock_put(sk);
+
+	return 0;
+}
+
+static int j1939sk_setsockopt_flag(struct j1939_sock *jsk,
+		char __user *optval, unsigned int optlen, int flag)
+{
+	int tmp;
+
+	if (optlen != sizeof(tmp))
+		return -EINVAL;
+	if (copy_from_user(&tmp, optval, optlen))
+		return -EFAULT;
+	lock_sock(&jsk->sk);
+	if (tmp)
+		jsk->state |= flag;
+	else
+		jsk->state &= ~flag;
+	release_sock(&jsk->sk);
+	return tmp;
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,32)
+static int j1939sk_setsockopt(struct socket *sock, int level, int optname,
+		char __user *optval, unsigned int optlen)
+#else
+static int j1939sk_setsockopt(struct socket *sock, int level, int optname,
+		char __user *optval, int optlen)
+#endif
+{
+	struct sock *sk = sock->sk;
+	struct j1939_sock *jsk = j1939_sk(sk);
+	int ret = 0, tmp, count;
+	struct j1939_filter *filters, *ofilters;
+
+	if (level != SOL_CAN_J1939)
+		return -EINVAL;
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,32)
+	if (optlen < 0)
+		return -EINVAL;
+#endif
+
+	switch (optname) {
+	case SO_J1939_FILTER:
+		if (optval) {
+			if (optlen % sizeof(*filters) != 0)
+				return -EINVAL;
+			count = optlen / sizeof(*filters);
+			filters = kmalloc(optlen, GFP_KERNEL);
+			if (!filters)
+				return -ENOMEM;
+			if (copy_from_user(filters, optval, optlen)) {
+				kfree(filters);
+				return -EFAULT;
+			}
+		} else {
+			filters = NULL;
+			count = 0;
+		}
+
+		j1939_recv_suspend();
+		ofilters = jsk->filters;
+		jsk->filters = filters;
+		jsk->nfilters = count;
+		j1939_recv_resume();
+		if (ofilters)
+			kfree(ofilters);
+		break;
+	case SO_J1939_PROMISC:
+		tmp = jsk->state & PROMISC;
+		ret = j1939sk_setsockopt_flag(jsk, optval, optlen, PROMISC);
+		if (ret && !tmp)
+			j1939_get_promisc_receiver(jsk->sk.sk_bound_dev_if);
+		else if (!ret && tmp)
+			j1939_put_promisc_receiver(jsk->sk.sk_bound_dev_if);
+		ret = 0;
+		break;
+	case SO_J1939_RECV_OWN:
+		j1939sk_setsockopt_flag(jsk, optval, optlen, RECV_OWN);
+		break;
+	case SO_J1939_SEND_PRIO:
+		if (optlen != sizeof(tmp))
+			return -EINVAL;
+		if (copy_from_user(&tmp, optval, optlen))
+			return -EFAULT;
+		if ((tmp < 0) || (tmp > 7))
+			return -EDOM;
+		if ((tmp < 2) && !capable(CAP_NET_ADMIN))
+			return -EPERM;
+		lock_sock(&jsk->sk);
+		jsk->sk.sk_priority = j1939_to_sk_priority(tmp);
+		release_sock(&jsk->sk);
+		break;
+	default:
+		return -ENOPROTOOPT;
+	}
+
+	return ret;
+}
+
+static int j1939sk_getsockopt(struct socket *sock, int level, int optname,
+		char __user *optval, int __user *optlen)
+{
+	struct sock *sk = sock->sk;
+	struct j1939_sock *jsk = j1939_sk(sk);
+	int ret, ulen;
+	/* set defaults for using 'int' properties */
+	int tmp = 0;
+	int len = sizeof(tmp);
+	void *val = &tmp;
+
+	if (level != SOL_CAN_J1939)
+		return -EINVAL;
+	if (get_user(ulen, optlen))
+		return -EFAULT;
+	if (ulen < 0)
+		return -EINVAL;
+
+	lock_sock(&jsk->sk);
+	switch (optname) {
+	case SO_J1939_PROMISC:
+		tmp = (jsk->state & PROMISC) ? 1 : 0;
+		break;
+	case SO_J1939_RECV_OWN:
+		tmp = (jsk->state & RECV_OWN) ? 1 : 0;
+		break;
+	case SO_J1939_SEND_PRIO:
+		tmp = j1939_prio(jsk->sk.sk_priority);
+		break;
+	default:
+		ret = -ENOPROTOOPT;
+		goto no_copy;
+	}
+
+	/*
+	 * copy to user, based on 'len' & 'val'
+	 * but most sockopt's are 'int' properties, and have 'len' & 'val'
+	 * left unchanged, but instead modified 'tmp'
+	 */
+	if (len > ulen)
+		ret = -EFAULT;
+	else if (put_user(len, optlen))
+		ret = -EFAULT;
+	else if (copy_to_user(optval, val, len))
+		ret = -EFAULT;
+	else
+		ret = 0;
+no_copy:
+	release_sock(&jsk->sk);
+	return ret;
+}
+
+static int j1939sk_recvmsg(struct kiocb *iocb, struct socket *sock,
+			 struct msghdr *msg, size_t size, int flags)
+{
+	struct sock *sk = sock->sk;
+	struct sk_buff *skb;
+	struct j1939_sk_buff_cb *sk_addr;
+	int ret = 0;
+
+	skb = skb_recv_datagram(sk, flags, 0, &ret);
+	if (!skb)
+		return ret;
+
+	if (size < skb->len)
+		msg->msg_flags |= MSG_TRUNC;
+	else
+		size = skb->len;
+
+	ret = memcpy_toiovec(msg->msg_iov, skb->data, size);
+	if (ret < 0)
+		goto failed_with_skb;
+
+	sock_recv_timestamp(msg, sk, skb);
+	sk_addr = (void *)skb->cb;
+
+	if (j1939_address_is_valid(sk_addr->dst.addr))
+		put_cmsg(msg, SOL_CAN_J1939, SCM_J1939_DEST_ADDR,
+				sizeof(sk_addr->dst.addr), &sk_addr->dst.addr);
+
+	if (sk_addr->dst.name)
+		put_cmsg(msg, SOL_CAN_J1939, SCM_J1939_DEST_NAME,
+				sizeof(sk_addr->dst.name), &sk_addr->dst.name);
+
+	put_cmsg(msg, SOL_CAN_J1939, SCM_J1939_PRIO,
+			sizeof(sk_addr->priority), &sk_addr->priority);
+
+	if (msg->msg_name) {
+		struct sockaddr_can *paddr = msg->msg_name;
+
+		msg->msg_namelen = required_size(can_addr.j1939, *paddr);
+		memset(msg->msg_name, 0, msg->msg_namelen);
+		paddr->can_family = AF_CAN;
+		paddr->can_ifindex = sk_addr->ifindex;
+		paddr->can_addr.j1939.name = sk_addr->src.name;
+		paddr->can_addr.j1939.addr = sk_addr->src.addr;
+		paddr->can_addr.j1939.pgn = sk_addr->pgn;
+	}
+
+	skb_free_datagram(sk, skb);
+
+	return size;
+
+failed_with_skb:
+	skb_kill_datagram(sk, skb, flags);
+	return ret;
+}
+
+static int j1939sk_sendmsg(struct kiocb *iocb, struct socket *sock,
+		       struct msghdr *msg, size_t size)
+{
+	struct sock *sk = sock->sk;
+	struct j1939_sock *jsk = j1939_sk(sk);
+	struct j1939_sk_buff_cb *skb_cb;
+	struct sk_buff *skb;
+	struct net_device *dev;
+	struct j1939_ecu *ecu;
+	int ifindex;
+	int ret;
+
+	if (!(jsk->state | JSK_BOUND))
+		return -ENOTCONN;
+
+	if (msg->msg_name && (msg->msg_namelen <
+			required_size(can_addr.j1939, struct sockaddr_can)))
+		return -EINVAL;
+
+	ifindex = jsk->sk.sk_bound_dev_if;
+	if (msg->msg_name) {
+		struct sockaddr_can *addr = msg->msg_name;
+		if (msg->msg_namelen < required_size(can_addr.j1939, *addr))
+			return -EFAULT;
+		if (addr->can_family != AF_CAN)
+			return -EINVAL;
+		if (ifindex && addr->can_ifindex &&
+			(ifindex != addr->can_ifindex))
+			return -ENONET;
+		if (!ifindex)
+			/* take destination intf when intf not yet set */
+			ifindex = addr->can_ifindex;
+	}
+
+	if (!ifindex)
+		return -EDESTADDRREQ;
+	if (j1939_no_address(&jsk->sk)) {
+		lock_sock(&jsk->sk);
+		ecu = j1939_ecu_find_segment_default_tx(
+				jsk->sk.sk_bound_dev_if,
+				&jsk->addr.src, &jsk->addr.sa);
+		release_sock(&jsk->sk);
+		if (IS_ERR(ecu))
+			return PTR_ERR(ecu);
+	}
+
+	dev = dev_get_by_index(&init_net, ifindex);
+	if (!dev)
+		return -ENXIO;
+
+	skb = sock_alloc_send_skb(sk, size,
+			msg->msg_flags & MSG_DONTWAIT, &ret);
+	if (!skb)
+		goto put_dev;
+
+	ret = memcpy_fromiovec(skb_put(skb, size), msg->msg_iov, size);
+	if (ret < 0)
+		goto free_skb;
+	skb->dev = dev;
+	skb->sk  = sk;
+
+	BUILD_BUG_ON(sizeof(skb->cb) < sizeof(*skb_cb));
+
+	skb_cb = (void *) skb->cb;
+	memset(skb_cb, 0, sizeof(*skb_cb));
+	skb_cb->msg_flags = msg->msg_flags;
+	skb_cb->ifindex = ifindex;
+	skb_cb->src.name = jsk->addr.src;
+	skb_cb->dst.name = jsk->addr.dst;
+	skb_cb->pgn = jsk->addr.pgn;
+	skb_cb->priority = j1939_prio(jsk->sk.sk_priority);
+	skb_cb->src.addr = jsk->addr.sa;
+	skb_cb->dst.addr = jsk->addr.da;
+
+	if (msg->msg_name) {
+		struct sockaddr_can *addr = msg->msg_name;
+		if (addr->can_addr.j1939.name) {
+			ecu = j1939_ecu_find_by_name(addr->can_addr.j1939.name,
+					ifindex);
+			if (!ecu)
+				return -EADDRNOTAVAIL;
+			skb_cb->dst.name = ecu->name;
+			skb_cb->dst.addr = ecu->sa;
+			put_j1939_ecu(ecu);
+		} else {
+			skb_cb->dst.name = 0;
+			skb_cb->dst.addr = addr->can_addr.j1939.addr;
+		}
+		if (pgn_is_valid(addr->can_addr.j1939.pgn))
+			skb_cb->pgn = addr->can_addr.j1939.pgn;
+	}
+
+	if (skb_cb->msg_flags & J1939_MSG_SYNC) {
+		if (skb_cb->msg_flags & MSG_DONTWAIT) {
+			ret = j1939_sock_pending_add_first(&jsk->sk);
+			if (ret > 0)
+				ret = -EAGAIN;
+		} else {
+			ret = wait_event_interruptible(jsk->waitq,
+					j1939_sock_pending_add_first(&jsk->sk));
+		}
+		if (ret < 0)
+			goto free_skb;
+	} else {
+		j1939_sock_pending_add(&jsk->sk);
+	}
+
+	ret = j1939_send(skb, j1939_level_sky);
+	if (ret < 0)
+		goto decrement_pending;
+
+	dev_put(dev);
+	return size;
+
+decrement_pending:
+	j1939_sock_pending_del(&jsk->sk);
+free_skb:
+	kfree_skb(skb);
+put_dev:
+	dev_put(dev);
+	return ret;
+}
+
+/* PROC */
+static int j1939sk_proc_show(struct seq_file *sqf, void *v)
+{
+	struct j1939_sock *jsk;
+	struct net_device *netdev;
+
+	seq_printf(sqf, "iface\tflags\tlocal\tremote\tpgn\tprio\tpending\n");
+	mutex_lock(&s.lock);
+	list_for_each_entry(jsk, &s.socks, list) {
+		lock_sock(&jsk->sk);
+		netdev = NULL;
+		if (jsk->sk.sk_bound_dev_if)
+			netdev = dev_get_by_index(&init_net,
+				jsk->sk.sk_bound_dev_if);
+		seq_printf(sqf, "%s\t", netdev ? netdev->name : "-");
+		if (netdev)
+			dev_put(netdev);
+		seq_printf(sqf, "%c%c%c%c\t",
+			(jsk->state & JSK_BOUND) ? 'b' : '-',
+			(jsk->state & JSK_CONNECTED) ? 'c' : '-',
+			(jsk->state & PROMISC) ? 'P' : '-',
+			(jsk->state & RECV_OWN) ? 'o' : '-');
+		if (jsk->addr.src)
+			seq_printf(sqf, "%016llx", (long long)jsk->addr.src);
+		else if (j1939_address_is_unicast(jsk->addr.sa))
+			seq_printf(sqf, "%02x", jsk->addr.sa);
+		else
+			seq_printf(sqf, "-");
+		seq_printf(sqf, "\t");
+		if (jsk->addr.dst)
+			seq_printf(sqf, "%016llx", (long long)jsk->addr.dst);
+		else if (j1939_address_is_unicast(jsk->addr.da))
+			seq_printf(sqf, "%02x", jsk->addr.da);
+		else
+			seq_printf(sqf, "-");
+		seq_printf(sqf, "\t%05x", jsk->addr.pgn);
+		seq_printf(sqf, "\t%u", j1939_prio(jsk->sk.sk_priority));
+		seq_printf(sqf, "\t%u", jsk->skb_pending);
+		release_sock(&jsk->sk);
+		seq_printf(sqf, "\n");
+	}
+	mutex_unlock(&s.lock);
+	return 0;
+}
+
+void j1939sk_netdev_event(int ifindex, int error_code)
+{
+	struct j1939_sock *jsk;
+
+	mutex_lock(&s.lock);
+	list_for_each_entry(jsk, &s.socks, list) {
+		if (jsk->sk.sk_bound_dev_if != ifindex)
+			continue;
+		jsk->sk.sk_err = error_code;
+		if (!sock_flag(&jsk->sk, SOCK_DEAD))
+			jsk->sk.sk_error_report(&jsk->sk);
+		/* do not remove filters here */
+	}
+	mutex_unlock(&s.lock);
+}
+
+static const struct proto_ops j1939_ops = {
+	.family = PF_CAN,
+	.release = j1939sk_release,
+	.bind = j1939sk_bind,
+	.connect = j1939sk_connect,
+	.socketpair = sock_no_socketpair,
+	.accept = sock_no_accept,
+	.getname = j1939sk_getname,
+	.poll = datagram_poll,
+	.ioctl = can_ioctl,
+	.listen = sock_no_listen,
+	.shutdown = sock_no_shutdown,
+	.setsockopt = j1939sk_setsockopt,
+	.getsockopt = j1939sk_getsockopt,
+	.sendmsg = j1939sk_sendmsg,
+	.recvmsg = j1939sk_recvmsg,
+	.mmap = sock_no_mmap,
+	.sendpage = sock_no_sendpage,
+};
+
+static struct proto j1939_proto __read_mostly = {
+	.name = "CAN_J1939",
+	.owner = THIS_MODULE,
+	.obj_size = sizeof(struct j1939_sock),
+	.init = j1939sk_init,
+};
+
+static const struct can_proto j1939_can_proto = {
+	.type = SOCK_DGRAM,
+	.protocol = CAN_J1939,
+	.ops = &j1939_ops,
+	.prot = &j1939_proto,
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,36)
+	.rtnl_link_ops = &j1939_rtnl_af_ops,
+#endif
+	.rtnl_new_addr = j1939rtnl_new_addr,
+	.rtnl_del_addr = j1939rtnl_del_addr,
+	.rtnl_dump_addr = j1939rtnl_dump_addr,
+};
+
+__init int j1939sk_module_init(void)
+{
+	int ret;
+
+	INIT_LIST_HEAD(&s.socks);
+	mutex_init(&s.lock);
+
+	ret = can_proto_register(&j1939_can_proto);
+	if (ret < 0)
+		pr_err("can: registration of j1939 protocol failed\n");
+	else
+		j1939_proc_add("sock", j1939sk_proc_show, NULL);
+	return ret;
+}
+
+void j1939sk_module_exit(void)
+{
+	j1939_proc_remove("sock");
+	can_proto_unregister(&j1939_can_proto);
+}
+
+MODULE_ALIAS("can-proto-" __stringify(CAN_J1939));
+
diff --exclude CVS --exclude .git -uNr linux-2.6.27.8/net/can/j1939/transport.c linux-2.6.27.8.modified/net/can/j1939/transport.c
--- linux-2.6.27.8/net/can/j1939/transport.c	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.27.8.modified/net/can/j1939/transport.c	2013-05-30 03:44:13.000000000 -0400
@@ -0,0 +1,1454 @@
+/*
+ * Copyright (c) 2010-2011 EIA Electronics
+ *
+ * Authors:
+ * Kurt Van Dijck <kurt.van.dijck@eia.be>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the version 2 of the GNU General Public License
+ * as published by the Free Software Foundation
+ */
+
+#include <linux/skbuff.h>
+#include <linux/hrtimer.h>
+#include <linux/version.h>
+#include <linux/if_arp.h>
+#include <linux/wait.h>
+#include "j1939-priv.h"
+
+#define REGULAR		0
+#define EXTENDED	1
+
+#define etp_pgn_ctl	0xc800
+#define etp_pgn_dat	0xc700
+#define tp_pgn_ctl	0xec00
+#define tp_pgn_dat	0xeb00
+
+#define  tp_cmd_bam	0x20
+#define  tp_cmd_rts	0x10
+#define  tp_cmd_cts	0x11
+#define  tp_cmd_eof	0x13
+#define  tp_cmd_abort	0xff
+
+#define etp_cmd_rts	0x14
+#define etp_cmd_cts	0x15
+#define etp_cmd_dpo	0x16
+#define etp_cmd_eof	0x17
+#define etp_cmd_abort	0xff
+
+#define ABORT_BUSY	1
+#define ABORT_RESOURCE	2
+#define ABORT_TIMEOUT	3
+#define ABORT_GENERIC	4
+#define ABORT_FAULT	5
+
+#define MAX_TP_PACKET_SIZE	(7*255)
+#define MAX_ETP_PACKET_SIZE	(7*0xffffff)
+
+static int block = 255;
+static int max_packet_size = 1024*100;
+static int retry_ms = 20;
+
+struct session {
+	struct list_head list;
+	atomic_t refs;
+	spinlock_t lock;
+
+	struct j1939_sk_buff_cb *cb; /*
+	 * ifindex, src, dst, pgn define the session block
+	 * the are _never_ modified after insertion in the list
+	 * this decreases locking problems a _lot_
+	 */
+	struct sk_buff *skb;
+
+	/*
+	 * all tx related stuff (last_txcmd, pkt.tx)
+	 * is protected (modified only) with the txtask tasklet
+	 * 'total' & 'block' are never changed,
+	 * last_cmd, last & block are protected by ->lock
+	 * this means that the tx may run after cts is received that should
+	 * have stopped tx, but this time discrepancy is never avoided anyhow
+	 */
+	uint8_t last_cmd, last_txcmd;
+	uint8_t transmission;
+	uint8_t extd;
+	struct {
+		/*
+		 * these do not require 16 bit, they should fit in uint8_t
+		 * but putting in int makes it easier to deal with
+		 */
+		unsigned int total, done, last, tx;
+		unsigned int block; /* for TP */
+		unsigned int dpo; /* for ETP */
+	} pkt;
+	struct hrtimer txtimer, rxtimer;
+	/* tasklets for execution of tx/rx timer hander in softirq */
+	struct tasklet_struct txtask, rxtask;
+};
+
+static struct j1939tp {
+	spinlock_t lock;
+	struct list_head sessionq;
+	struct list_head extsessionq;
+	struct {
+		struct list_head sessionq;
+		spinlock_t lock;
+		struct work_struct work;
+	} del;
+	wait_queue_head_t wait;
+	struct notifier_block notifier;
+} s;
+
+static struct session *j1939session_new(struct sk_buff *skb);
+static struct session *j1939session_fresh_new(int size,
+		struct j1939_sk_buff_cb *rel_cb, pgn_t pgn);
+
+static inline void fix_cb(struct j1939_sk_buff_cb *cb)
+{
+	cb->msg_flags &= ~J1939_MSG_RESERVED;
+}
+
+static inline struct list_head *sessionq(int extd)
+{
+	return extd ? &s.extsessionq : &s.sessionq;
+}
+
+static inline void j1939session_destroy(struct session *session)
+{
+	if (session->skb)
+		kfree_skb(session->skb);
+	hrtimer_cancel(&session->rxtimer);
+	hrtimer_cancel(&session->txtimer);
+	tasklet_disable(&session->rxtask);
+	tasklet_disable(&session->txtask);
+	kfree(session);
+}
+
+/* clean up work queue */
+static void j1939tp_del_work(struct work_struct *work)
+{
+	struct session *session;
+	int cnt = 0;
+
+	do {
+		session = NULL;
+		spin_lock_bh(&s.del.lock);
+		if (list_empty(&s.del.sessionq)) {
+			spin_unlock_bh(&s.del.lock);
+			break;
+		}
+		session = list_first_entry(&s.del.sessionq,
+				struct session, list);
+		list_del_init(&session->list);
+		spin_unlock_bh(&s.del.lock);
+		j1939session_destroy(session);
+		++cnt;
+	} while (1);
+}
+/* reference counter */
+static inline void get_session(struct session *session)
+{
+	atomic_inc(&session->refs);
+}
+
+static void put_session(struct session *session)
+{
+	BUG_ON(!session);
+	if (atomic_add_return(-1, &session->refs) >= 0)
+		/* not the last one */
+		return;
+	/* it should have been removed from any list long time ago */
+	BUG_ON(!list_empty(&session->list));
+
+	hrtimer_try_to_cancel(&session->rxtimer);
+	hrtimer_try_to_cancel(&session->txtimer);
+	tasklet_disable_nosync(&session->rxtask);
+	tasklet_disable_nosync(&session->txtask);
+
+	if (in_interrupt()) {
+		spin_lock_bh(&s.del.lock);
+		list_add_tail(&session->list, &s.del.sessionq);
+		spin_unlock_bh(&s.del.lock);
+		schedule_work(&s.del.work);
+	} else {
+		/* destroy session right here */
+		j1939session_destroy(session);
+	}
+}
+
+/* transport status locking */
+static inline void session_lock(struct session *session)
+{
+	get_session(session); /* safety measure */
+	spin_lock_bh(&session->lock);
+}
+
+static inline void session_unlock(struct session *session)
+{
+	spin_unlock_bh(&session->lock);
+	put_session(session);
+}
+
+static inline void sessionlist_lock(void)
+{
+	spin_lock_bh(&s.lock);
+}
+
+static inline void sessionlist_unlock(void)
+{
+	spin_unlock_bh(&s.lock);
+}
+
+/*
+ * see if we are receiver
+ * returns 0 for broadcasts, although we will receive them
+ */
+static inline int j1939tp_im_receiver(const struct j1939_sk_buff_cb *cb)
+{
+	return (cb->dst.flags & ECUFLAG_LOCAL) ? 1 : 0;
+}
+
+/* see if we are sender */
+static inline int j1939tp_im_transmitter(const struct j1939_sk_buff_cb *cb)
+{
+	return (cb->src.flags & ECUFLAG_LOCAL) ? 1 : 0;
+}
+
+/* see if we are involved as either receiver or transmitter */
+/* reverse = -1 means : any direction */
+static int j1939tp_im_involved(const struct j1939_sk_buff_cb *cb, int reverse)
+{
+	if (reverse < 0) {
+		return ((cb->src.flags | cb->dst.flags) & ECUFLAG_LOCAL)
+			? 1 : 0;
+	} else if (reverse) {
+		return j1939tp_im_receiver(cb);
+	} else {
+		return j1939tp_im_transmitter(cb);
+	}
+}
+
+/* extract pgn from flow-ctl message */
+static inline pgn_t j1939xtp_ctl_to_pgn(const uint8_t *dat)
+{
+	pgn_t pgn;
+
+	pgn = (dat[7] << 16) | (dat[6] << 8) | (dat[5] << 0);
+	if (pgn_is_pdu1(pgn))
+		pgn &= 0xffff00;
+	return pgn;
+}
+
+static inline unsigned int j1939tp_ctl_to_size(const uint8_t *dat)
+{
+	return (dat[2] << 8) + (dat[1] << 0);
+}
+static inline unsigned int j1939etp_ctl_to_packet(const uint8_t *dat)
+{
+	return (dat[4] << 16) | (dat[3] << 8) | (dat[2] << 0);
+}
+static inline unsigned int j1939etp_ctl_to_size(const uint8_t *dat)
+{
+	return (dat[4] << 24) | (dat[3] << 16) |
+		(dat[2] << 8) | (dat[1] << 0);
+}
+
+/*
+ * find existing session:
+ * reverse: swap cb's src & dst
+ * there is no problem with matching broadcasts, since
+ * broadcasts (no dst, no da) would never call this
+ * with reverse==1
+ */
+static int j1939tp_match(const struct j1939_sk_buff_cb *a,
+		const struct j1939_sk_buff_cb *b, int reverse)
+{
+	if (a->ifindex != b->ifindex)
+		return 0;
+	if (!reverse) {
+		if (a->src.name) {
+			if (a->src.name != b->src.name)
+				return 0;
+		} else if (a->src.addr != b->src.addr)
+			return 0;
+		if (a->dst.name) {
+			if (a->dst.name != b->dst.name)
+				return 0;
+		} else if (a->dst.addr != b->dst.addr)
+			return 0;
+	} else {
+		if (a->src.name) {
+			if (a->src.name != b->dst.name)
+				return 0;
+		} else if (a->src.addr != b->dst.addr)
+			return 0;
+		if (a->dst.name) {
+			if (a->dst.name != b->src.name)
+				return 0;
+		} else if (a->dst.addr != b->src.addr)
+			return 0;
+	}
+	return 1;
+}
+
+static struct session *_j1939tp_find(struct list_head *root,
+		const struct j1939_sk_buff_cb *cb, int reverse)
+{
+	struct session *session;
+
+	list_for_each_entry(session, root, list) {
+		get_session(session);
+		if (j1939tp_match(session->cb, cb, reverse))
+			return session;
+		put_session(session);
+	}
+	return NULL;
+}
+
+static struct session *j1939tp_find(struct list_head *root,
+		const struct j1939_sk_buff_cb *cb, int reverse)
+{
+	struct session *session;
+	sessionlist_lock();
+	session = _j1939tp_find(root, cb, reverse);
+	sessionlist_unlock();
+	return session;
+}
+
+static void j1939_skbcb_swap(struct j1939_sk_buff_cb *cb)
+{
+	name_t name;
+	uint8_t addr;
+	int flags;
+
+	name = cb->dst.name;
+	cb->dst.name = cb->src.name;
+	cb->src.name = name;
+
+	addr = cb->dst.addr;
+	cb->dst.addr = cb->src.addr;
+	cb->src.addr = addr;
+
+	flags = cb->dst.flags;
+	cb->dst.flags = cb->src.flags;
+	cb->src.flags = flags;
+}
+/* TP transmit packet functions */
+static int j1939tp_tx_dat(struct session *related,
+		const uint8_t *dat, int len)
+{
+	int ret;
+	struct sk_buff *skb;
+	struct j1939_sk_buff_cb *skb_cb;
+	uint8_t *skdat;
+
+	skb = dev_alloc_skb(8);
+	if (unlikely(!skb)) {
+		pr_alert("%s: out of memory?\n", __func__);
+		return -ENOMEM;
+	}
+	skb->protocol = related->skb->protocol;
+	skb->pkt_type = related->skb->pkt_type;
+	skb->ip_summed = related->skb->ip_summed;
+	skb->sk	= related->skb->sk;
+
+	skb_cb = (void *)skb->cb;
+	*skb_cb = *(related->cb);
+	fix_cb(skb_cb);
+	/* fix pgn */
+	skb_cb->pgn = related->extd ? etp_pgn_dat : tp_pgn_dat;
+
+	skdat = skb_put(skb, len);
+	memcpy(skdat, dat, len);
+	ret = j1939_send(skb, j1939_level_transport);
+	if (ret < 0)
+		kfree_skb(skb);
+	return ret;
+}
+
+static int j1939xtp_do_tx_ctl(struct sk_buff *related, int extd,
+		int swap_src_dst, pgn_t pgn, const uint8_t dat[5])
+{
+	int ret;
+	struct sk_buff *skb;
+	struct j1939_sk_buff_cb *skb_cb, *rel_cb;
+	uint8_t *skdat;
+
+	rel_cb = (void *)related->cb;
+	if (!j1939tp_im_involved(rel_cb, swap_src_dst))
+		return 0;
+
+	skb = dev_alloc_skb(8);
+	if (unlikely(!skb)) {
+		pr_alert("%s: out of memory?\n", __func__);
+		return -ENOMEM;
+	}
+	skb->protocol = related->protocol;
+	skb->pkt_type = related->pkt_type;
+	skb->ip_summed = related->ip_summed;
+	skb->sk	= related->sk;
+
+	skb_cb = (void *)skb->cb;
+	*skb_cb = *rel_cb;
+	fix_cb(skb_cb);
+	if (swap_src_dst)
+		j1939_skbcb_swap(skb_cb);
+	skb_cb->pgn = extd ? etp_pgn_ctl : tp_pgn_ctl;
+
+	skdat = skb_put(skb, 8);
+	memcpy(skdat, dat, 5);
+	skdat[7] = (pgn >> 16) & 0xff;
+	skdat[6] = (pgn >>  8) & 0xff;
+	skdat[5] = (pgn >>  0) & 0xff;
+
+	ret = j1939_send(skb, j1939_level_transport);
+	if (ret)
+		kfree_skb(skb);
+	return ret;
+}
+
+static inline int j1939tp_tx_ctl(struct session *session,
+		int swap_src_dst, const uint8_t dat[8])
+{
+	return j1939xtp_do_tx_ctl(session->skb, session->extd, swap_src_dst,
+			session->cb->pgn, dat);
+}
+
+static int j1939xtp_tx_abort(struct sk_buff *related, int extd,
+		int swap_src_dst, int err, pgn_t pgn)
+{
+	struct j1939_sk_buff_cb *cb = (void *)related->cb;
+	uint8_t dat[5];
+
+	if (!j1939tp_im_involved(cb, swap_src_dst))
+		return 0;
+
+	memset(dat, 0xff, sizeof(dat));
+	dat[0] = tp_cmd_abort;
+	if (!extd)
+		dat[1] = err ?: ABORT_GENERIC;
+	return j1939xtp_do_tx_ctl(related, extd, swap_src_dst, pgn, dat);
+}
+
+/* timer & scheduler functions */
+static inline void j1939session_schedule_txnow(struct session *session)
+{
+	tasklet_schedule(&session->txtask);
+}
+static enum hrtimer_restart j1939tp_txtimer(struct hrtimer *hrtimer)
+{
+	struct session *session =
+		container_of(hrtimer, struct session, txtimer);
+	j1939session_schedule_txnow(session);
+	return HRTIMER_NORESTART;
+}
+static inline void j1939tp_schedule_txtimer(struct session *session, int msec)
+{
+	hrtimer_start(&session->txtimer,
+			ktime_set(msec / 1000, (msec % 1000)*1000000UL),
+			HRTIMER_MODE_REL);
+}
+static inline void j1939tp_set_rxtimeout(struct session *session, int msec)
+{
+	hrtimer_start(&session->rxtimer,
+			ktime_set(msec / 1000, (msec % 1000)*1000000UL),
+			HRTIMER_MODE_REL);
+}
+
+/*
+ * session completion functions
+ */
+/*
+ * j1939session_drop
+ * removes a session from open session list
+ */
+static inline void j1939session_drop(struct session *session)
+{
+	sessionlist_lock();
+	list_del_init(&session->list);
+	sessionlist_unlock();
+
+	if (session->transmission) {
+		if (session->skb && session->skb->sk)
+			j1939_sock_pending_del(session->skb->sk);
+		wake_up_all(&s.wait);
+	}
+	put_session(session);
+}
+
+static inline void j1939session_completed(struct session *session)
+{
+	j1939_recv(session->skb, j1939_level_transport);
+	j1939session_drop(session);
+}
+
+static void j1939session_cancel(struct session *session, int err)
+{
+	if ((err >= 0) && j1939tp_im_involved(session->cb, -1)) {
+		if (!j1939cb_is_broadcast(session->cb)) {
+			/* do not send aborts on incoming broadcasts */
+			j1939xtp_tx_abort(session->skb, session->extd,
+				!j1939tp_im_transmitter(session->cb),
+				err, session->cb->pgn);
+		}
+	}
+	j1939session_drop(session);
+}
+
+static enum hrtimer_restart j1939tp_rxtimer(struct hrtimer *hrtimer)
+{
+	struct session *session =
+		container_of(hrtimer, struct session, rxtimer);
+	tasklet_schedule(&session->rxtask);
+	return HRTIMER_NORESTART;
+}
+
+static void j1939tp_rxtask(unsigned long val)
+{
+	struct session *session = (void *)val;
+
+	get_session(session);
+	pr_alert("%s: timeout on %i\n", __func__, session->cb->ifindex);
+	j1939session_cancel(session, ABORT_TIMEOUT);
+	put_session(session);
+}
+
+/*
+ * receive packet functions
+ */
+static void _j1939xtp_rx_bad_message(struct sk_buff *skb, int extd)
+{
+	struct j1939_sk_buff_cb *cb = (void *)skb->cb;
+	struct session *session;
+	pgn_t pgn;
+
+	pgn = j1939xtp_ctl_to_pgn(skb->data);
+	session = j1939tp_find(sessionq(extd), cb, 0);
+	if (session /*&& (session->cb->pgn == pgn)*/) {
+		/* do not allow TP control messages on 2 pgn's */
+		j1939session_cancel(session, ABORT_FAULT);
+		put_session(session); /* ~j1939tp_find */
+		return;
+	}
+	j1939xtp_tx_abort(skb, extd, 0, ABORT_FAULT, pgn);
+	if (!session)
+		return;
+	put_session(session); /* ~j1939tp_find */
+}
+
+/* abort packets may come in 2 directions */
+static void j1939xtp_rx_bad_message(struct sk_buff *skb, int extd)
+{
+	struct j1939_sk_buff_cb *cb = (void *)skb->cb;
+
+	pr_info("%s, pgn %05x\n", __func__, j1939xtp_ctl_to_pgn(skb->data));
+	_j1939xtp_rx_bad_message(skb, extd);
+	j1939_skbcb_swap(cb);
+	_j1939xtp_rx_bad_message(skb, extd);
+	/* restore skb */
+	j1939_skbcb_swap(cb);
+	return;
+}
+
+static void _j1939xtp_rx_abort(struct sk_buff *skb, int extd)
+{
+	struct j1939_sk_buff_cb *cb = (void *)skb->cb;
+	struct session *session;
+	pgn_t pgn;
+
+	pgn = j1939xtp_ctl_to_pgn(skb->data);
+	session = j1939tp_find(sessionq(extd), cb, 0);
+	if (!session)
+		return;
+	if (session->transmission && !session->last_txcmd) {
+		/*
+		 * empty block:
+		 * do not drop session when a transmit session did not
+		 * start yet
+		 */
+	} else if (session->cb->pgn == pgn)
+		j1939session_drop(session);
+	/* another PGN had a bad message */
+	/*
+	 * TODO: maybe cancel current connection
+	 * as another pgn was communicated
+	 */
+	put_session(session); /* ~j1939tp_find */
+}
+/* abort packets may come in 2 directions */
+static inline void j1939xtp_rx_abort(struct sk_buff *skb, int extd)
+{
+	struct j1939_sk_buff_cb *cb = (void *)skb->cb;
+
+	pr_info("%s %i, %05x\n", __func__, cb->ifindex,
+			j1939xtp_ctl_to_pgn(skb->data));
+	_j1939xtp_rx_abort(skb, extd);
+	j1939_skbcb_swap(cb);
+	_j1939xtp_rx_abort(skb, extd);
+	/* restore skb */
+	j1939_skbcb_swap(cb);
+	return;
+}
+
+static void j1939xtp_rx_eof(struct sk_buff *skb, int extd)
+{
+	struct j1939_sk_buff_cb *cb = (void *)skb->cb;
+	struct session *session;
+	pgn_t pgn;
+
+	/* end of tx cycle */
+	pgn = j1939xtp_ctl_to_pgn(skb->data);
+	session = j1939tp_find(sessionq(extd), cb, 1);
+	if (!session)
+		/*
+		 * strange, we had EOF on closed connection
+		 * do nothing, as EOF closes the connection anyway
+		 */
+		return;
+
+	if (session->cb->pgn != pgn) {
+		j1939xtp_tx_abort(skb, extd, 1, ABORT_BUSY, pgn);
+		j1939session_cancel(session, ABORT_BUSY);
+	} else {
+		/* transmitted without problems */
+		j1939session_completed(session);
+	}
+	put_session(session); /* ~j1939tp_find */
+}
+
+static void j1939xtp_rx_cts(struct sk_buff *skb, int extd)
+{
+	struct j1939_sk_buff_cb *cb = (void *)skb->cb;
+	struct session *session;
+	pgn_t pgn;
+	unsigned int pkt;
+	const uint8_t *dat;
+
+	dat = skb->data;
+	pgn = j1939xtp_ctl_to_pgn(skb->data);
+	session = j1939tp_find(sessionq(extd), cb, 1);
+	if (!session) {
+		/* 'CTS shall be ignored' */
+		return;
+	}
+	if (session->cb->pgn != pgn) {
+		/* what to do? */
+		j1939xtp_tx_abort(skb, extd, 1, ABORT_BUSY, pgn);
+		j1939session_cancel(session, ABORT_BUSY);
+		put_session(session); /* ~j1939tp_find */
+		return;
+	}
+	session_lock(session);
+	pkt = extd ? j1939etp_ctl_to_packet(dat) : dat[2];
+	if (!dat[0])
+		hrtimer_cancel(&session->txtimer);
+	else if (!pkt)
+		goto bad_fmt;
+	else if (dat[1] > session->pkt.block /* 0xff for etp */)
+		goto bad_fmt;
+	else {
+		/* set packet counters only when not CTS(0) */
+		session->pkt.done = pkt - 1;
+		session->pkt.last = session->pkt.done + dat[1];
+		if (session->pkt.last > session->pkt.total)
+			/* safety measure */
+			session->pkt.last = session->pkt.total;
+		/* TODO: do not set tx here, do it in txtask */
+		session->pkt.tx = session->pkt.done;
+	}
+	session->last_cmd = dat[0];
+	session_unlock(session);
+	if (dat[1]) {
+		j1939tp_set_rxtimeout(session, 1250);
+		if (j1939tp_im_transmitter(session->cb))
+			j1939session_schedule_txnow(session);
+	} else {
+		/* CTS(0) */
+		j1939tp_set_rxtimeout(session, 550);
+	}
+	put_session(session); /* ~j1939tp_find */
+	return;
+bad_fmt:
+	session_unlock(session);
+	j1939session_cancel(session, ABORT_FAULT);
+	put_session(session); /* ~j1939tp_find */
+}
+
+static void j1939xtp_rx_rts(struct sk_buff *skb, int extd)
+{
+	struct j1939_sk_buff_cb *cb = (void *)skb->cb;
+	struct session *session;
+	int len;
+	const uint8_t *dat;
+	pgn_t pgn;
+
+	dat = skb->data;
+	pgn = j1939xtp_ctl_to_pgn(dat);
+
+	if ((tp_cmd_rts == dat[0]) && j1939cb_is_broadcast(cb)) {
+		pr_alert("%s: rts without destination (%i %02x)\n", __func__,
+			cb->ifindex, cb->src.addr);
+		return;
+	}
+	/*
+	 * TODO: abort RTS when a similar
+	 * TP is pending in the other direction
+	 */
+	session = j1939tp_find(sessionq(extd), cb, 0);
+	if (session && !j1939tp_im_transmitter(cb)) {
+		/* RTS on pending connection */
+		j1939session_cancel(session, ABORT_BUSY);
+		if ((pgn != session->cb->pgn) && (tp_cmd_bam != dat[0]))
+			j1939xtp_tx_abort(skb, extd, 1, ABORT_BUSY, pgn);
+		put_session(session); /* ~j1939tp_find */
+		return;
+	} else if (!session && j1939tp_im_transmitter(cb)) {
+		pr_alert("%s: I should tx (%i %02x %02x)\n", __func__,
+			cb->ifindex, cb->src.addr, cb->dst.addr);
+		return;
+	}
+	if (session && (0 != session->last_cmd)) {
+		/* we received a second rts on the same connection */
+		pr_alert("%s: connection exists (%i %02x %02x)\n", __func__,
+				cb->ifindex, cb->src.addr, cb->dst.addr);
+		j1939session_cancel(session, ABORT_BUSY);
+		put_session(session); /* ~j1939tp_find */
+		return;
+	}
+	if (session) {
+		/*
+		 * make sure 'sa' & 'da' are correct !
+		 * They may be 'not filled in yet' for sending
+		 * skb's, since they did not pass the Address Claim ever.
+		 */
+		session->cb->src.addr = cb->src.addr;
+		session->cb->dst.addr = cb->dst.addr;
+	} else {
+		int abort = 0;
+		if (extd) {
+			len = j1939etp_ctl_to_size(dat);
+			if (len > (max_packet_size ?: MAX_ETP_PACKET_SIZE))
+				abort = ABORT_RESOURCE;
+			else if (len <= MAX_TP_PACKET_SIZE)
+				abort = ABORT_FAULT;
+		} else {
+			len = j1939tp_ctl_to_size(dat);
+			if (len > MAX_TP_PACKET_SIZE)
+				abort = ABORT_FAULT;
+			else if (max_packet_size && (len > max_packet_size))
+				abort = ABORT_RESOURCE;
+		}
+		if (abort) {
+			j1939xtp_tx_abort(skb, extd, 1, abort, pgn);
+			return;
+		}
+		session = j1939session_fresh_new(len, cb, pgn);
+		if (!session) {
+			j1939xtp_tx_abort(skb, extd, 1, ABORT_RESOURCE, pgn);
+			return;
+		}
+		session->extd = extd;
+		/* initialize the control buffer: plain copy */
+		session->pkt.total = (len+6)/7;
+		session->pkt.block = 0xff;
+		if (!extd) {
+			if (dat[3] != session->pkt.total)
+				pr_alert("%s: strange total,"
+						" %u != %u\n", __func__,
+						session->pkt.total, dat[3]);
+			session->pkt.total = dat[3];
+			session->pkt.block = dat[4];
+		}
+		session->pkt.done = session->pkt.tx = 0;
+		get_session(session); /* equivalent to j1939tp_find() */
+		sessionlist_lock();
+		list_add_tail(&session->list, sessionq(extd));
+		sessionlist_unlock();
+	}
+	session->last_cmd = dat[0];
+
+	j1939tp_set_rxtimeout(session, 1250);
+
+	if (j1939tp_im_receiver(session->cb)) {
+		if (extd || (tp_cmd_bam != dat[0]))
+			j1939session_schedule_txnow(session);
+	}
+	/*
+	 * as soon as it's inserted, things can go fast
+	 * protect against a long delay
+	 * between spin_unlock & next statement
+	 * so, only release here, at the end
+	 */
+	put_session(session); /* ~j1939tp_find */
+	return;
+}
+
+static void j1939xtp_rx_dpo(struct sk_buff *skb, int extd)
+{
+	struct j1939_sk_buff_cb *cb = (void *)skb->cb;
+	struct session *session;
+	pgn_t pgn;
+	const uint8_t *dat = skb->data;
+
+	pgn = j1939xtp_ctl_to_pgn(dat);
+	session = j1939tp_find(sessionq(extd), cb, 0);
+	if (!session) {
+		pr_info("%s: %s\n", __func__, "no connection found");
+		return;
+	}
+
+	if (session->cb->pgn != pgn) {
+		pr_info("%s: different pgn\n", __func__);
+		j1939xtp_tx_abort(skb, 1, 1, ABORT_BUSY, pgn);
+		j1939session_cancel(session, ABORT_BUSY);
+		put_session(session); /* ~j1939tp_find */
+		return;
+	}
+	/* transmitted without problems */
+	session->pkt.dpo = j1939etp_ctl_to_packet(skb->data);
+	session->last_cmd = dat[0];
+	j1939tp_set_rxtimeout(session, 750);
+	put_session(session); /* ~j1939tp_find */
+}
+
+static void j1939xtp_rx_dat(struct sk_buff *skb, int extd)
+{
+	struct j1939_sk_buff_cb *cb = (void *)skb->cb;
+	struct session *session;
+	const uint8_t *dat;
+	uint8_t *tpdat;
+	int offset;
+	int nbytes;
+	int final;
+	int do_cts_eof;
+	int packet;
+
+	session = j1939tp_find(sessionq(extd), cb, 0);
+	if (!session) {
+		pr_info("%s:%s\n", __func__, "no connection found");
+		return;
+	}
+	dat = skb->data;
+	if (skb->len <= 1)
+		/* makes no sense */
+		goto strange_packet_unlocked;
+
+	session_lock(session);
+
+	switch (session->last_cmd) {
+	case 0xff:
+		break;
+	case etp_cmd_dpo:
+		if (extd)
+			break;
+	case tp_cmd_bam:
+	case tp_cmd_cts:
+		if (!extd)
+			break;
+	default:
+		pr_info("%s: last %02x\n", __func__,
+				session->last_cmd);
+		goto strange_packet;
+	}
+
+	packet = (dat[0]-1+session->pkt.dpo);
+	offset = packet * 7;
+	if ((packet > session->pkt.total) ||
+			(session->pkt.done+1) > session->pkt.total) {
+		pr_info("%s: should have been completed\n", __func__);
+		goto strange_packet;
+	}
+	nbytes = session->skb->len - offset;
+	if (nbytes > 7)
+		nbytes = 7;
+	if ((nbytes <= 0) || ((nbytes + 1) > skb->len)) {
+		pr_info("%s: nbytes %i, len %i\n", __func__, nbytes,
+				skb->len);
+		goto strange_packet;
+	}
+	tpdat = session->skb->data;
+	memcpy(&tpdat[offset], &dat[1], nbytes);
+	if (packet == session->pkt.done)
+		++session->pkt.done;
+
+	if (!extd && j1939cb_is_broadcast(session->cb)) {
+		final = session->pkt.done >= session->pkt.total;
+		do_cts_eof = 0;
+	} else {
+		final = 0; /* never final, an EOF must follow */
+		do_cts_eof = (session->pkt.done >= session->pkt.last);
+	}
+	session_unlock(session);
+	if (final) {
+		j1939session_completed(session);
+	} else if (do_cts_eof) {
+		j1939tp_set_rxtimeout(session, 1250);
+		if (j1939tp_im_receiver(session->cb))
+			j1939session_schedule_txnow(session);
+	} else {
+		j1939tp_set_rxtimeout(session, 250);
+	}
+	session->last_cmd = 0xff;
+	put_session(session); /* ~j1939tp_find */
+	return;
+
+strange_packet:
+	/* unlock session (spinlock) before trying to send */
+	session_unlock(session);
+strange_packet_unlocked:
+	j1939session_cancel(session, ABORT_FAULT);
+	put_session(session); /* ~j1939tp_find */
+}
+
+/*
+ * transmit function
+ */
+static int j1939tp_txnext(struct session *session)
+{
+	uint8_t dat[8];
+	const uint8_t *tpdat;
+	int ret, offset, len, pkt_done, pkt_end;
+	unsigned int pkt;
+
+	memset(dat, 0xff, sizeof(dat));
+	get_session(session); /* do not loose it */
+
+	switch (session->last_cmd) {
+	case 0:
+		if (!j1939tp_im_transmitter(session->cb))
+			break;
+		dat[1] = (session->skb->len >> 0) & 0xff;
+		dat[2] = (session->skb->len >> 8) & 0xff;
+		dat[3] = session->pkt.total;
+		if (session->extd) {
+			dat[0] = etp_cmd_rts;
+			dat[1] = (session->skb->len >>  0) & 0xff;
+			dat[2] = (session->skb->len >>  8) & 0xff;
+			dat[3] = (session->skb->len >> 16) & 0xff;
+			dat[4] = (session->skb->len >> 24) & 0xff;
+		} else if (j1939cb_is_broadcast(session->cb)) {
+			dat[0] = tp_cmd_bam;
+			/* fake cts for broadcast */
+			session->pkt.tx = 0;
+		} else {
+			dat[0] = tp_cmd_rts;
+			dat[4] = dat[3];
+		}
+		if (dat[0] == session->last_txcmd)
+			/* done already */
+			break;
+		ret = j1939tp_tx_ctl(session, 0, dat);
+		if (ret < 0)
+			goto failed;
+		session->last_txcmd = dat[0];
+		/* must lock? */
+		if (tp_cmd_bam == dat[0])
+			j1939tp_schedule_txtimer(session, 50);
+		j1939tp_set_rxtimeout(session, 1250);
+		break;
+	case tp_cmd_rts:
+	case etp_cmd_rts:
+		if (!j1939tp_im_receiver(session->cb))
+			break;
+tx_cts:
+		ret = 0;
+		len = session->pkt.total - session->pkt.done;
+		if (len > 255)
+			len = 255;
+		if (len > session->pkt.block)
+			len = session->pkt.block;
+		if (block && (len > block))
+			len = block;
+
+		if (session->extd) {
+			pkt = session->pkt.done+1;
+			dat[0] = etp_cmd_cts;
+			dat[1] = len;
+			dat[2] = (pkt >>  0) & 0xff;
+			dat[3] = (pkt >>  8) & 0xff;
+			dat[4] = (pkt >> 16) & 0xff;
+		} else {
+			dat[0] = tp_cmd_cts;
+			dat[1] = len;
+			dat[2] = session->pkt.done+1;
+		}
+		if (dat[0] == session->last_txcmd)
+			/* done already */
+			break;
+		ret = j1939tp_tx_ctl(session, 1, dat);
+		if (ret < 0)
+			goto failed;
+		if (len)
+			/* only mark cts done when len is set */
+			session->last_txcmd = dat[0];
+		j1939tp_set_rxtimeout(session, 1250);
+		break;
+	case etp_cmd_cts:
+		if (j1939tp_im_transmitter(session->cb) && session->extd &&
+		    (etp_cmd_dpo != session->last_txcmd)) {
+			/* do dpo */
+			dat[0] = etp_cmd_dpo;
+			session->pkt.dpo = session->pkt.done;
+			pkt = session->pkt.dpo;
+			dat[1] = session->pkt.last - session->pkt.done;
+			dat[2] = (pkt >>  0) & 0xff;
+			dat[3] = (pkt >>  8) & 0xff;
+			dat[4] = (pkt >> 16) & 0xff;
+			ret = j1939tp_tx_ctl(session, 0, dat);
+			if (ret < 0)
+				goto failed;
+			session->last_txcmd = dat[0];
+			j1939tp_set_rxtimeout(session, 1250);
+			session->pkt.tx = session->pkt.done;
+		}
+	case tp_cmd_cts:
+	case 0xff: /* did some data */
+	case etp_cmd_dpo:
+		if ((session->extd || !j1939cb_is_broadcast(session->cb)) &&
+		     j1939tp_im_receiver(session->cb)) {
+			if (session->pkt.done >= session->pkt.total) {
+				if (session->extd) {
+					dat[0] = etp_cmd_eof;
+					dat[1] = session->skb->len >> 0;
+					dat[2] = session->skb->len >> 8;
+					dat[3] = session->skb->len >> 16;
+					dat[4] = session->skb->len >> 24;
+				} else {
+					dat[0] = tp_cmd_eof;
+					dat[1] = session->skb->len;
+					dat[2] = session->skb->len >> 8;
+					dat[3] = session->pkt.total;
+				}
+				if (dat[0] == session->last_txcmd)
+					/* done already */
+					break;
+				ret = j1939tp_tx_ctl(session, 1, dat);
+				if (ret < 0)
+					goto failed;
+				session->last_txcmd = dat[0];
+				j1939tp_set_rxtimeout(session, 1250);
+				/* wait for the EOF packet to come in */
+				break;
+			} else if (session->pkt.done >= session->pkt.last) {
+				session->last_txcmd = 0;
+				goto tx_cts;
+			}
+		}
+	case tp_cmd_bam:
+		if (!j1939tp_im_transmitter(session->cb))
+			break;
+		tpdat = session->skb->data;
+		ret = 0;
+		pkt_done = 0;
+		pkt_end = (!session->extd && j1939cb_is_broadcast(session->cb))
+			? session->pkt.total : session->pkt.last;
+
+		while (session->pkt.tx < pkt_end) {
+			dat[0] = session->pkt.tx - session->pkt.dpo+1;
+			offset = session->pkt.tx * 7;
+			len = session->skb->len - offset;
+			if (len > 7)
+				len = 7;
+			memcpy(&dat[1], &tpdat[offset], len);
+			ret = j1939tp_tx_dat(session, dat, len+1);
+			if (ret < 0)
+				break;
+			session->last_txcmd = 0xff;
+			++pkt_done;
+			++session->pkt.tx;
+			if (j1939cb_is_broadcast(session->cb)) {
+				if (session->pkt.tx < session->pkt.total)
+					j1939tp_schedule_txtimer(session, 50);
+				break;
+			}
+		}
+		if (pkt_done)
+			j1939tp_set_rxtimeout(session, 250);
+		if (ret)
+			goto failed;
+		break;
+	}
+	put_session(session);
+	return 0;
+failed:
+	put_session(session);
+	return ret;
+}
+
+static void j1939tp_txtask(unsigned long val)
+{
+	struct session *session = (void *)val;
+	int ret;
+
+	get_session(session);
+	ret = j1939tp_txnext(session);
+	if (ret < 0)
+		j1939tp_schedule_txtimer(session, retry_ms);
+	put_session(session);
+}
+
+static inline int j1939tp_tx_initial(struct session *session)
+{
+	int ret;
+
+	get_session(session);
+	ret = j1939tp_txnext(session);
+	/* set nonblocking for further packets */
+	session->cb->msg_flags |= MSG_DONTWAIT;
+	put_session(session);
+	return ret;
+}
+
+/* this call is to be used as probe within wait_event_xxx() */
+static int j1939session_insert(struct session *session)
+{
+	struct session *pending;
+
+	sessionlist_lock();
+	pending = _j1939tp_find(sessionq(session->extd), session->cb, 0);
+	if (pending)
+		/* revert the effect of find() */
+		put_session(pending);
+	else
+		list_add_tail(&session->list, sessionq(session->extd));
+	sessionlist_unlock();
+	return pending ? 0 : 1;
+}
+/*
+ * j1939 main intf
+ */
+int j1939_send_transport(struct sk_buff *skb)
+{
+	struct j1939_sk_buff_cb *cb = (void *)skb->cb;
+	struct session *session;
+	int ret;
+
+	if ((tp_pgn_dat == cb->pgn) || (tp_pgn_ctl == cb->pgn) ||
+	    (etp_pgn_dat == cb->pgn) || (etp_pgn_ctl == cb->pgn))
+		/* avoid conflict */
+		return -EDOM;
+	if (skb->len <= 8)
+		return 0;
+	else if (skb->len > (max_packet_size ?: MAX_ETP_PACKET_SIZE))
+		return -EMSGSIZE;
+
+	if (skb->len > MAX_TP_PACKET_SIZE) {
+		if (j1939cb_is_broadcast(cb))
+			return -EDESTADDRREQ;
+	}
+
+	/* prepare new session */
+	session = j1939session_new(skb);
+	if (!session)
+		return -ENOMEM;
+
+	session->extd = (skb->len > MAX_TP_PACKET_SIZE) ? EXTENDED : REGULAR;
+	session->transmission = 1;
+	session->pkt.total = (skb->len + 6)/7;
+	session->pkt.block = session->extd ? 255 :
+		(block ?: session->pkt.total);
+	if (j1939cb_is_broadcast(session->cb))
+		/* set the end-packet for broadcast */
+		session->pkt.last = session->pkt.total;
+
+	/* insert into queue, but avoid collision with pending session */
+	if (session->cb->msg_flags & MSG_DONTWAIT)
+		ret = j1939session_insert(session) ? 0 : -EAGAIN;
+	else
+		ret = wait_event_interruptible(s.wait,
+				j1939session_insert(session));
+	if (ret < 0)
+		goto failed;
+
+	ret = j1939tp_tx_initial(session);
+	if (!ret)
+		/* transmission started */
+		return RESULT_STOP;
+	sessionlist_lock();
+	list_del_init(&session->list);
+	sessionlist_unlock();
+failed:
+	/*
+	 * hide the skb from j1939session_drop, as it would
+	 * kfree_skb, but our caller will kfree_skb(skb) too.
+	 */
+	session->skb = NULL;
+	j1939session_drop(session);
+	return ret;
+}
+
+int j1939_recv_transport(struct sk_buff *skb)
+{
+	struct j1939_sk_buff_cb *cb = (void *)skb->cb;
+	const uint8_t *dat;
+
+	switch (cb->pgn) {
+	case etp_pgn_dat:
+		j1939xtp_rx_dat(skb, EXTENDED);
+		break;
+	case etp_pgn_ctl:
+		if (skb->len < 8) {
+			j1939xtp_rx_bad_message(skb, EXTENDED);
+			break;
+		}
+		dat = skb->data;
+		switch (*dat) {
+		case etp_cmd_rts:
+			j1939xtp_rx_rts(skb, EXTENDED);
+			break;
+		case etp_cmd_cts:
+			j1939xtp_rx_cts(skb, EXTENDED);
+			break;
+		case etp_cmd_dpo:
+			j1939xtp_rx_dpo(skb, EXTENDED);
+			break;
+		case etp_cmd_eof:
+			j1939xtp_rx_eof(skb, EXTENDED);
+			break;
+		case etp_cmd_abort:
+			j1939xtp_rx_abort(skb, EXTENDED);
+			break;
+		default:
+			j1939xtp_rx_bad_message(skb, EXTENDED);
+			break;
+		}
+		break;
+	case tp_pgn_dat:
+		j1939xtp_rx_dat(skb, REGULAR);
+		break;
+	case tp_pgn_ctl:
+		if (skb->len < 8) {
+			j1939xtp_rx_bad_message(skb, REGULAR);
+			break;
+		}
+		dat = skb->data;
+		switch (*dat) {
+		case tp_cmd_bam:
+		case tp_cmd_rts:
+			j1939xtp_rx_rts(skb, REGULAR);
+			break;
+		case tp_cmd_cts:
+			j1939xtp_rx_cts(skb, REGULAR);
+			break;
+		case tp_cmd_eof:
+			j1939xtp_rx_eof(skb, REGULAR);
+			break;
+		case tp_cmd_abort:
+			j1939xtp_rx_abort(skb, REGULAR);
+			break;
+		default:
+			j1939xtp_rx_bad_message(skb, REGULAR);
+			break;
+		}
+		break;
+	default:
+		return 0;
+	}
+	return RESULT_STOP;
+}
+
+static struct session *j1939session_fresh_new(int size,
+		struct j1939_sk_buff_cb *rel_cb, pgn_t pgn)
+{
+	struct sk_buff *skb;
+	struct j1939_sk_buff_cb *cb;
+	struct session *session;
+
+	skb = dev_alloc_skb(size);
+	if (!skb)
+		return NULL;
+	cb = (void *)skb->cb;
+	*cb = *rel_cb;
+	fix_cb(cb);
+	cb->pgn = pgn;
+
+	session = j1939session_new(skb);
+	if (!session) {
+		kfree(skb);
+		return NULL;
+	}
+	/* alloc data area */
+	skb_put(skb, size);
+	return session;
+}
+static struct session *j1939session_new(struct sk_buff *skb)
+{
+	struct session *session;
+
+	session = kzalloc(sizeof(*session), gfp_any());
+	if (!session)
+		return NULL;
+	INIT_LIST_HEAD(&session->list);
+	spin_lock_init(&session->lock);
+	session->skb = skb;
+
+	session->cb = (void *)session->skb->cb;
+	hrtimer_init(&session->txtimer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
+	session->txtimer.function = j1939tp_txtimer;
+	hrtimer_init(&session->rxtimer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
+	session->rxtimer.function = j1939tp_rxtimer;
+	tasklet_init(&session->txtask, j1939tp_txtask, (unsigned long)session);
+	tasklet_init(&session->rxtask, j1939tp_rxtask, (unsigned long)session);
+	return session;
+}
+
+static int j1939tp_notifier(struct notifier_block *nb,
+			unsigned long msg, void *data)
+{
+	struct net_device *netdev = (struct net_device *)data;
+	struct session *session, *saved;
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,26)
+	if (!net_eq(dev_net(netdev), &init_net))
+		return NOTIFY_DONE;
+#elif LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,24)
+	if (netdev->nd_net != &init_net)
+		return NOTIFY_DONE;
+#endif
+
+	if (netdev->type != ARPHRD_CAN)
+		return NOTIFY_DONE;
+
+	if (msg != NETDEV_UNREGISTER)
+		return NOTIFY_DONE;
+
+	sessionlist_lock();
+	list_for_each_entry_safe(session, saved, &s.sessionq, list) {
+		if (session->cb->ifindex != netdev->ifindex)
+			continue;
+		list_del_init(&session->list);
+		put_session(session);
+	}
+	list_for_each_entry_safe(session, saved, &s.extsessionq, list) {
+		if (session->cb->ifindex != netdev->ifindex)
+			continue;
+		list_del_init(&session->list);
+		put_session(session);
+	}
+	sessionlist_unlock();
+	return NOTIFY_DONE;
+}
+
+/* SYSCTL */
+static struct ctl_table_header *j1939tp_table_header;
+
+static int min_block = 1;
+static int max_block = 255;
+static int min_packet = 8;
+static int max_packet = ((2 << 24)-1)*7;
+
+static int min_retry = 5;
+static int max_retry = 5000;
+
+static ctl_table j1939tp_table[] = {
+	{
+		.procname	= "transport_cts_nr_of_frames",
+		.data		= &block,
+		.maxlen		= sizeof(block),
+		.mode		= 0644,
+		.proc_handler	= &proc_dointvec_minmax,
+		.extra1		= &min_block,
+		.extra2		= &max_block,
+	},
+	{
+		.procname	= "transport_max_payload_in_bytes",
+		.data		= &max_packet_size,
+		.maxlen		= sizeof(max_packet_size),
+		.mode		= 0644,
+		.proc_handler	= &proc_dointvec_minmax,
+		.extra1		= &min_packet,
+		.extra2		= &max_packet,
+	},
+	{
+		.procname	= "transport_tx_retry_ms",
+		.data		= &retry_ms,
+		.maxlen		= sizeof(retry_ms),
+		.mode		= 0644,
+		.proc_handler	= &proc_dointvec_minmax,
+		.extra1		= &min_retry,
+		.extra2		= &max_retry,
+	},
+	{ },
+};
+
+static struct ctl_path j1939tp_path[] = {
+	{ .procname = "net", },
+	{ .procname = j1939_procname, },
+	{ }
+};
+
+/* PROC */
+static int j1939tp_proc_show_session(struct seq_file *sqf,
+		struct session *session)
+{
+	seq_printf(sqf, "%i", session->cb->ifindex);
+	if (session->cb->src.name)
+		seq_printf(sqf, "\t%016llx", session->cb->src.name);
+	else
+		seq_printf(sqf, "\t%02x", session->cb->src.addr);
+	if (session->cb->dst.name)
+		seq_printf(sqf, "\t%016llx", session->cb->dst.name);
+	else if (j1939_address_is_unicast(session->cb->dst.addr))
+		seq_printf(sqf, "\t%02x", session->cb->dst.addr);
+	else
+		seq_printf(sqf, "\t-");
+	seq_printf(sqf, "\t%05x\t%u/%u\n", session->cb->pgn,
+			session->pkt.done*7, session->skb->len);
+	return 0;
+}
+
+static int j1939tp_proc_show(struct seq_file *sqf, void *v)
+{
+	struct session *session;
+
+	seq_printf(sqf, "iface\tsrc\tdst\tpgn\tdone/total\n");
+	sessionlist_lock();
+	list_for_each_entry(session, &s.sessionq, list)
+		j1939tp_proc_show_session(sqf, session);
+	list_for_each_entry(session, &s.extsessionq, list)
+		j1939tp_proc_show_session(sqf, session);
+	sessionlist_unlock();
+	return 0;
+}
+
+int __init j1939tp_module_init(void)
+{
+	spin_lock_init(&s.lock);
+	INIT_LIST_HEAD(&s.sessionq);
+	INIT_LIST_HEAD(&s.extsessionq);
+	spin_lock_init(&s.del.lock);
+	INIT_LIST_HEAD(&s.del.sessionq);
+	INIT_WORK(&s.del.work, j1939tp_del_work);
+
+	s.notifier.notifier_call = j1939tp_notifier;
+	register_netdevice_notifier(&s.notifier);
+
+	j1939_proc_add("transport", j1939tp_proc_show, NULL);
+	j1939tp_table_header =
+		register_sysctl_paths(j1939tp_path, j1939tp_table);
+	init_waitqueue_head(&s.wait);
+	return 0;
+}
+
+void j1939tp_module_exit(void)
+{
+	struct session *session, *saved;
+
+	wake_up_all(&s.wait);
+
+	unregister_sysctl_table(j1939tp_table_header);
+	unregister_netdevice_notifier(&s.notifier);
+	j1939_proc_remove("transport");
+	sessionlist_lock();
+	list_for_each_entry_safe(session, saved, &s.extsessionq, list) {
+		list_del_init(&session->list);
+		put_session(session);
+	}
+	list_for_each_entry_safe(session, saved, &s.sessionq, list) {
+		list_del_init(&session->list);
+		put_session(session);
+	}
+	sessionlist_unlock();
+	flush_scheduled_work();
+}
+
diff --exclude CVS --exclude .git -uNr linux-2.6.27.8/net/can/proc.c linux-2.6.27.8.modified/net/can/proc.c
--- linux-2.6.27.8/net/can/proc.c	2008-12-05 15:03:02.000000000 -0500
+++ linux-2.6.27.8.modified/net/can/proc.c	2013-05-30 03:44:16.000000000 -0400
@@ -42,12 +42,19 @@
  */
 
 #include <linux/module.h>
+#include <linux/version.h>
 #include <linux/proc_fs.h>
 #include <linux/list.h>
 #include <linux/rcupdate.h>
-#include <linux/can/core.h>
+#include <socketcan/can/core.h>
 
 #include "af_can.h"
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,25)
+#include "compat.h"
+#endif
+
+#include <socketcan/can/version.h> /* for RCSID. Removed by mkpatch script */
+RCSID("$Id: proc.c 1259 2011-06-02 18:58:43Z hartkopp $");
 
 /*
  * proc filenames for the PF_CAN core
@@ -196,13 +203,249 @@
  *
  */
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,26)
+static void can_print_rcvlist(struct seq_file *m, struct hlist_head *rx_list,
+			      struct net_device *dev)
+{
+	struct receiver *r;
+	struct hlist_node *n;
+
+	hlist_for_each_entry_rcu(r, n, rx_list, list) {
+		char *fmt = (r->can_id & CAN_EFF_FLAG)?
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,0,0)
+			"   %-5s  %08x  %08x  %p  %p  %8ld  %s\n" :
+			"   %-5s     %03x    %08x  %p  %p  %8ld  %s\n";
+#else
+			"   %-5s  %08x  %08x  %pK  %pK  %8ld  %s\n" :
+			"   %-5s     %03x    %08x  %pK  %pK  %8ld  %s\n";
+#endif
+
+		seq_printf(m, fmt, DNAME(dev), r->can_id, r->mask,
+				r->func, r->data, r->matches, r->ident);
+	}
+}
+
+static void can_print_recv_banner(struct seq_file *m)
+{
+	/*
+	 *                  can1.  00000000  00000000  00000000
+	 *                 .......          0  tp20
+	 */
+	seq_puts(m, "  device   can_id   can_mask  function"
+			"  userdata   matches  ident\n");
+}
+
+static int can_stats_proc_show(struct seq_file *m, void *v)
+{
+	seq_putc(m, '\n');
+	seq_printf(m, " %8ld transmitted frames (TXF)\n", can_stats.tx_frames);
+	seq_printf(m, " %8ld received frames (RXF)\n", can_stats.rx_frames);
+	seq_printf(m, " %8ld matched frames (RXMF)\n", can_stats.matches);
+
+	seq_putc(m, '\n');
+
+	if (can_stattimer.function == can_stat_update) {
+		seq_printf(m, " %8ld %% total match ratio (RXMR)\n",
+				can_stats.total_rx_match_ratio);
+
+		seq_printf(m, " %8ld frames/s total tx rate (TXR)\n",
+				can_stats.total_tx_rate);
+		seq_printf(m, " %8ld frames/s total rx rate (RXR)\n",
+				can_stats.total_rx_rate);
+
+		seq_putc(m, '\n');
+
+		seq_printf(m, " %8ld %% current match ratio (CRXMR)\n",
+				can_stats.current_rx_match_ratio);
+
+		seq_printf(m, " %8ld frames/s current tx rate (CTXR)\n",
+				can_stats.current_tx_rate);
+		seq_printf(m, " %8ld frames/s current rx rate (CRXR)\n",
+				can_stats.current_rx_rate);
+
+		seq_putc(m, '\n');
+
+		seq_printf(m, " %8ld %% max match ratio (MRXMR)\n",
+				can_stats.max_rx_match_ratio);
+
+		seq_printf(m, " %8ld frames/s max tx rate (MTXR)\n",
+				can_stats.max_tx_rate);
+		seq_printf(m, " %8ld frames/s max rx rate (MRXR)\n",
+				can_stats.max_rx_rate);
+
+		seq_putc(m, '\n');
+	}
+
+	seq_printf(m, " %8ld current receive list entries (CRCV)\n",
+			can_pstats.rcv_entries);
+	seq_printf(m, " %8ld maximum receive list entries (MRCV)\n",
+			can_pstats.rcv_entries_max);
+
+	if (can_pstats.stats_reset)
+		seq_printf(m, "\n %8ld statistic resets (STR)\n",
+				can_pstats.stats_reset);
+
+	if (can_pstats.user_reset)
+		seq_printf(m, " %8ld user statistic resets (USTR)\n",
+				can_pstats.user_reset);
+
+	seq_putc(m, '\n');
+	return 0;
+}
+
+static int can_stats_proc_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, can_stats_proc_show, NULL);
+}
+
+static const struct file_operations can_stats_proc_fops = {
+	.owner		= THIS_MODULE,
+	.open		= can_stats_proc_open,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+};
+
+static int can_reset_stats_proc_show(struct seq_file *m, void *v)
+{
+	user_reset = 1;
+
+	if (can_stattimer.function == can_stat_update) {
+		seq_printf(m, "Scheduled statistic reset #%ld.\n",
+				can_pstats.stats_reset + 1);
+
+	} else {
+		if (can_stats.jiffies_init != jiffies)
+			can_init_stats();
+
+		seq_printf(m, "Performed statistic reset #%ld.\n",
+				can_pstats.stats_reset);
+	}
+	return 0;
+}
+
+static int can_reset_stats_proc_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, can_reset_stats_proc_show, NULL);
+}
+
+static const struct file_operations can_reset_stats_proc_fops = {
+	.owner		= THIS_MODULE,
+	.open		= can_reset_stats_proc_open,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+};
+
+static int can_version_proc_show(struct seq_file *m, void *v)
+{
+	seq_printf(m, "%s\n", CAN_VERSION_STRING);
+	return 0;
+}
+
+static int can_version_proc_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, can_version_proc_show, NULL);
+}
+
+static const struct file_operations can_version_proc_fops = {
+	.owner		= THIS_MODULE,
+	.open		= can_version_proc_open,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+};
+
+static int can_rcvlist_proc_show(struct seq_file *m, void *v)
+{
+	/* double cast to prevent GCC warning */
+	int idx = (int)(long)m->private;
+	struct dev_rcv_lists *d;
+	struct hlist_node *n;
+
+	seq_printf(m, "\nreceive list '%s':\n", rx_list_name[idx]);
+
+	rcu_read_lock();
+	hlist_for_each_entry_rcu(d, n, &can_rx_dev_list, list) {
+
+		if (!hlist_empty(&d->rx[idx])) {
+			can_print_recv_banner(m);
+			can_print_rcvlist(m, &d->rx[idx], d->dev);
+		} else
+			seq_printf(m, "  (%s: no entry)\n", DNAME(d->dev));
+	}
+	rcu_read_unlock();
+
+	seq_putc(m, '\n');
+	return 0;
+}
+
+static int can_rcvlist_proc_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, can_rcvlist_proc_show, PDE(inode)->data);
+}
+
+static const struct file_operations can_rcvlist_proc_fops = {
+	.owner		= THIS_MODULE,
+	.open		= can_rcvlist_proc_open,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+};
+
+static int can_rcvlist_sff_proc_show(struct seq_file *m, void *v)
+{
+	struct dev_rcv_lists *d;
+	struct hlist_node *n;
+
+	/* RX_SFF */
+	seq_puts(m, "\nreceive list 'rx_sff':\n");
+
+	rcu_read_lock();
+	hlist_for_each_entry_rcu(d, n, &can_rx_dev_list, list) {
+		int i, all_empty = 1;
+		/* check wether at least one list is non-empty */
+		for (i = 0; i < 0x800; i++)
+			if (!hlist_empty(&d->rx_sff[i])) {
+				all_empty = 0;
+				break;
+			}
+
+		if (!all_empty) {
+			can_print_recv_banner(m);
+			for (i = 0; i < 0x800; i++) {
+				if (!hlist_empty(&d->rx_sff[i]))
+					can_print_rcvlist(m, &d->rx_sff[i],
+							  d->dev);
+			}
+		} else
+			seq_printf(m, "  (%s: no entry)\n", DNAME(d->dev));
+	}
+	rcu_read_unlock();
+
+	seq_putc(m, '\n');
+	return 0;
+}
+
+static int can_rcvlist_sff_proc_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, can_rcvlist_sff_proc_show, NULL);
+}
+
+static const struct file_operations can_rcvlist_sff_proc_fops = {
+	.owner		= THIS_MODULE,
+	.open		= can_rcvlist_sff_proc_open,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+};
+#else
 static int can_print_rcvlist(char *page, int len, struct hlist_head *rx_list,
 			     struct net_device *dev)
 {
 	struct receiver *r;
 	struct hlist_node *n;
 
-	rcu_read_lock();
 	hlist_for_each_entry_rcu(r, n, rx_list, list) {
 		char *fmt = (r->can_id & CAN_EFF_FLAG)?
 			"   %-5s  %08X  %08x  %08x  %08x  %8ld  %s\n" :
@@ -223,7 +466,6 @@
 			break;
 		}
 	}
-	rcu_read_unlock();
 
 	return len;
 }
@@ -436,11 +678,13 @@
 	*eof = 1;
 	return len;
 }
+#endif
 
 /*
  * proc utility functions
  */
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,26)
 static struct proc_dir_entry *can_create_proc_readentry(const char *name,
 							mode_t mode,
 							read_proc_t *read_proc,
@@ -452,6 +696,7 @@
 	else
 		return NULL;
 }
+#endif
 
 static void can_remove_proc_readentry(const char *name)
 {
@@ -465,7 +710,11 @@
 void can_init_proc(void)
 {
 	/* create /proc/net/can directory */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,24)
 	can_dir = proc_mkdir("can", init_net.proc_net);
+#else
+	can_dir = proc_mkdir("can", proc_net);
+#endif
 
 	if (!can_dir) {
 		printk(KERN_INFO "can: failed to create /proc/net/can . "
@@ -473,9 +722,31 @@
 		return;
 	}
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,30)
 	can_dir->owner = THIS_MODULE;
+#endif
 
 	/* own procfs entries from the AF_CAN core */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,26)
+	pde_version     = proc_create(CAN_PROC_VERSION, 0644, can_dir,
+				      &can_version_proc_fops);
+	pde_stats       = proc_create(CAN_PROC_STATS, 0644, can_dir,
+				      &can_stats_proc_fops);
+	pde_reset_stats = proc_create(CAN_PROC_RESET_STATS, 0644, can_dir,
+				      &can_reset_stats_proc_fops);
+	pde_rcvlist_err = proc_create_data(CAN_PROC_RCVLIST_ERR, 0644, can_dir,
+					   &can_rcvlist_proc_fops, (void *)RX_ERR);
+	pde_rcvlist_all = proc_create_data(CAN_PROC_RCVLIST_ALL, 0644, can_dir,
+					   &can_rcvlist_proc_fops, (void *)RX_ALL);
+	pde_rcvlist_fil = proc_create_data(CAN_PROC_RCVLIST_FIL, 0644, can_dir,
+					   &can_rcvlist_proc_fops, (void *)RX_FIL);
+	pde_rcvlist_inv = proc_create_data(CAN_PROC_RCVLIST_INV, 0644, can_dir,
+					   &can_rcvlist_proc_fops, (void *)RX_INV);
+	pde_rcvlist_eff = proc_create_data(CAN_PROC_RCVLIST_EFF, 0644, can_dir,
+					   &can_rcvlist_proc_fops, (void *)RX_EFF);
+	pde_rcvlist_sff = proc_create(CAN_PROC_RCVLIST_SFF, 0644, can_dir,
+				      &can_rcvlist_sff_proc_fops);
+#else
 	pde_version     = can_create_proc_readentry(CAN_PROC_VERSION, 0644,
 					can_proc_read_version, NULL);
 	pde_stats       = can_create_proc_readentry(CAN_PROC_STATS, 0644,
@@ -494,6 +765,7 @@
 					can_proc_read_rcvlist, (void *)RX_EFF);
 	pde_rcvlist_sff = can_create_proc_readentry(CAN_PROC_RCVLIST_SFF, 0644,
 					can_proc_read_rcvlist_sff, NULL);
+#endif
 }
 
 /*
@@ -529,5 +801,9 @@
 		can_remove_proc_readentry(CAN_PROC_RCVLIST_SFF);
 
 	if (can_dir)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,24)
 		proc_net_remove(&init_net, "can");
+#else
+		proc_net_remove("can");
+#endif
 }
diff --exclude CVS --exclude .git -uNr linux-2.6.27.8/net/can/raw.c linux-2.6.27.8.modified/net/can/raw.c
--- linux-2.6.27.8/net/can/raw.c	2008-12-05 15:03:02.000000000 -0500
+++ linux-2.6.27.8.modified/net/can/raw.c	2013-05-30 03:44:16.000000000 -0400
@@ -42,6 +42,7 @@
  */
 
 #include <linux/module.h>
+#include <linux/version.h>
 #include <linux/init.h>
 #include <linux/uio.h>
 #include <linux/net.h>
@@ -49,11 +50,19 @@
 #include <linux/socket.h>
 #include <linux/if_arp.h>
 #include <linux/skbuff.h>
-#include <linux/can.h>
-#include <linux/can/core.h>
-#include <linux/can/raw.h>
+#include <socketcan/can.h>
+#include <socketcan/can/core.h>
+#include <socketcan/can/raw.h>
 #include <net/sock.h>
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,24)
 #include <net/net_namespace.h>
+#endif
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,25)
+#include "compat.h"
+#endif
+
+#include <socketcan/can/version.h> /* for RCSID. Removed by mkpatch script */
+RCSID("$Id: raw.c 1258 2011-05-21 12:03:55Z hartkopp $");
 
 #define CAN_RAW_VERSION CAN_VERSION
 static __initdata const char banner[] =
@@ -62,6 +71,7 @@
 MODULE_DESCRIPTION("PF_CAN raw protocol");
 MODULE_LICENSE("Dual BSD/GPL");
 MODULE_AUTHOR("Urs Thuermann <urs.thuermann@volkswagen.de>");
+MODULE_ALIAS("can-proto-1");
 
 #define MASK_ALL 0
 
@@ -76,7 +86,11 @@
  */
 
 struct raw_sock {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,12)
 	struct sock sk;
+#else
+	struct sock *sk;
+#endif
 	int bound;
 	int ifindex;
 	struct notifier_block notifier;
@@ -88,24 +102,45 @@
 	can_err_mask_t err_mask;
 };
 
+/*
+ * Return pointer to store the extra msg flags for raw_recvmsg().
+ * We use the space of one unsigned int beyond the 'struct sockaddr_can'
+ * in skb->cb.
+ */
+static inline unsigned int *raw_flags(struct sk_buff *skb)
+{
+	BUILD_BUG_ON(sizeof(skb->cb) <= (sizeof(struct sockaddr_can) +
+					 sizeof(unsigned int)));
+
+	/* return pointer after struct sockaddr_can */
+	return (unsigned int *)(&((struct sockaddr_can *)skb->cb)[1]);
+}
+
 static inline struct raw_sock *raw_sk(const struct sock *sk)
 {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,12)
 	return (struct raw_sock *)sk;
+#else
+	return (struct raw_sock *)sk->sk_protinfo;
+#endif
 }
 
-static void raw_rcv(struct sk_buff *skb, void *data)
+static void raw_rcv(struct sk_buff *oskb, void *data)
 {
 	struct sock *sk = (struct sock *)data;
 	struct raw_sock *ro = raw_sk(sk);
 	struct sockaddr_can *addr;
+	struct sk_buff *skb;
+	unsigned int *pflags;
 
-	if (!ro->recv_own_msgs) {
-		/* check the received tx sock reference */
-		if (skb->sk == sk) {
-			kfree_skb(skb);
-			return;
-		}
-	}
+	/* check the received tx sock reference */
+	if (!ro->recv_own_msgs && oskb->sk == sk)
+		return;
+
+	/* clone the given skb to be able to enqueue it into the rcv queue */
+	skb = skb_clone(oskb, GFP_ATOMIC);
+	if (!skb)
+		return;
 
 	/*
 	 *  Put the datagram to the queue so that raw_recvmsg() can
@@ -120,6 +155,14 @@
 	addr->can_family  = AF_CAN;
 	addr->can_ifindex = skb->dev->ifindex;
 
+	/* add CAN specific message flags for raw_recvmsg() */
+	pflags = raw_flags(skb);
+	*pflags = 0;
+	if (oskb->sk)
+		*pflags |= MSG_DONTROUTE;
+	if (oskb->sk == sk)
+		*pflags |= MSG_CONFIRM;
+
 	if (sock_queue_rcv_skb(sk, skb) < 0)
 		kfree_skb(skb);
 }
@@ -208,10 +251,19 @@
 {
 	struct net_device *dev = (struct net_device *)data;
 	struct raw_sock *ro = container_of(nb, struct raw_sock, notifier);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,12)
 	struct sock *sk = &ro->sk;
+#else
+	struct sock *sk = ro->sk;
+#endif
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,26)
 	if (!net_eq(dev_net(dev), &init_net))
 		return NOTIFY_DONE;
+#elif LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,24)
+	if (dev->nd_net != &init_net)
+		return NOTIFY_DONE;
+#endif
 
 	if (dev->type != ARPHRD_CAN)
 		return NOTIFY_DONE;
@@ -254,6 +306,9 @@
 {
 	struct raw_sock *ro = raw_sk(sk);
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,12)
+	ro->sk               = sk;
+#endif
 	ro->bound            = 0;
 	ro->ifindex          = 0;
 
@@ -278,7 +333,12 @@
 static int raw_release(struct socket *sock)
 {
 	struct sock *sk = sock->sk;
-	struct raw_sock *ro = raw_sk(sk);
+	struct raw_sock *ro;
+
+	if (!sk)
+		return 0;
+
+	ro = raw_sk(sk);
 
 	unregister_netdevice_notifier(&ro->notifier);
 
@@ -305,6 +365,9 @@
 	ro->bound   = 0;
 	ro->count   = 0;
 
+	sock_orphan(sk);
+	sock->sk = NULL;
+
 	release_sock(sk);
 	sock_put(sk);
 
@@ -320,7 +383,7 @@
 	int err = 0;
 	int notify_enetdown = 0;
 
-	if (len < sizeof(*addr))
+	if (len < required_size(can_ifindex, *addr))
 		return -EINVAL;
 
 	lock_sock(sk);
@@ -404,8 +467,13 @@
 	return 0;
 }
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,32)
+static int raw_setsockopt(struct socket *sock, int level, int optname,
+			  char __user *optval, unsigned int optlen)
+#else
 static int raw_setsockopt(struct socket *sock, int level, int optname,
 			  char __user *optval, int optlen)
+#endif
 {
 	struct sock *sk = sock->sk;
 	struct raw_sock *ro = raw_sk(sk);
@@ -440,7 +508,7 @@
 				return -EFAULT;
 			}
 		} else if (count == 1) {
-			if (copy_from_user(&sfilter, optval, optlen))
+			if (copy_from_user(&sfilter, optval, sizeof(sfilter)))
 				return -EFAULT;
 		}
 
@@ -625,6 +693,9 @@
 		struct sockaddr_can *addr =
 			(struct sockaddr_can *)msg->msg_name;
 
+		if (msg->msg_namelen < required_size(can_ifindex, *addr))
+			return -EINVAL;
+
 		if (addr->can_family != AF_CAN)
 			return -EINVAL;
 
@@ -641,17 +712,12 @@
 
 	skb = sock_alloc_send_skb(sk, size, msg->msg_flags & MSG_DONTWAIT,
 				  &err);
-	if (!skb) {
-		dev_put(dev);
-		return err;
-	}
+	if (!skb)
+		goto put_dev;
 
 	err = memcpy_fromiovec(skb_put(skb, size), msg->msg_iov, size);
-	if (err < 0) {
-		kfree_skb(skb);
-		dev_put(dev);
-		return err;
-	}
+	if (err < 0)
+		goto free_skb;
 	skb->dev = dev;
 	skb->sk  = sk;
 
@@ -660,9 +726,16 @@
 	dev_put(dev);
 
 	if (err)
-		return err;
+		goto send_failed;
 
 	return size;
+
+free_skb:
+	kfree_skb(skb);
+put_dev:
+	dev_put(dev);
+send_failed:
+	return err;
 }
 
 static int raw_recvmsg(struct kiocb *iocb, struct socket *sock,
@@ -698,12 +771,15 @@
 		memcpy(msg->msg_name, skb->cb, msg->msg_namelen);
 	}
 
+	/* assign the flags that have been recorded in raw_rcv() */
+	msg->msg_flags |= *(raw_flags(skb));
+
 	skb_free_datagram(sk, skb);
 
 	return size;
 }
 
-static struct proto_ops raw_ops __read_mostly = {
+static const struct proto_ops raw_ops = {
 	.family        = PF_CAN,
 	.release       = raw_release,
 	.bind          = raw_bind,
@@ -712,7 +788,7 @@
 	.accept        = sock_no_accept,
 	.getname       = raw_getname,
 	.poll          = datagram_poll,
-	.ioctl         = NULL,		/* use can_ioctl() from af_can.c */
+	.ioctl         = can_ioctl,	/* use can_ioctl() from af_can.c */
 	.listen        = sock_no_listen,
 	.shutdown      = sock_no_shutdown,
 	.setsockopt    = raw_setsockopt,
@@ -723,6 +799,22 @@
 	.sendpage      = sock_no_sendpage,
 };
 
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,33)
+static struct proto raw_proto __read_mostly = {
+	.name       = "CAN_RAW",
+	.owner      = THIS_MODULE,
+	.obj_size   = sizeof(struct raw_sock),
+	.init       = raw_init,
+};
+
+static const struct can_proto raw_can_proto = {
+	.type       = SOCK_RAW,
+	.protocol   = CAN_RAW,
+	.ops        = &raw_ops,
+	.prot       = &raw_proto,
+};
+#elif LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,12)
 static struct proto raw_proto __read_mostly = {
 	.name       = "CAN_RAW",
 	.owner      = THIS_MODULE,
@@ -737,6 +829,17 @@
 	.ops        = &raw_ops,
 	.prot       = &raw_proto,
 };
+#else
+static struct can_proto raw_can_proto __read_mostly = {
+	.type       = SOCK_RAW,
+	.protocol   = CAN_RAW,
+	.capability = -1,
+	.ops        = &raw_ops,
+	.owner      = THIS_MODULE,
+	.obj_size   = sizeof(struct raw_sock),
+	.init       = raw_init,
+};
+#endif
 
 static __init int raw_module_init(void)
 {
